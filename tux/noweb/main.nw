\documentclass{article}
\usepackage[T1]{fontenc}                                                        
\usepackage[latin9]{inputenc}                                                   
\usepackage{mdwlist}           % less spaces between items
\usepackage{bm}                % bold math letters
\usepackage{noweb}
\usepackage{fancyvrb}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in}
\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\parskip}{1ex}

\newcommand{\Cclass}[1]{class \textit{#1}}
\newcommand{\Cmember}[1]{member \textit{#1}}
\newcommand{\Cmethod}[1]{method \textit{#1}}
\newcommand{\Cpackage}[1]{package \textit{#1}}
\newcommand{\program}[1]{\texttt{#1}}
\newcommand{\Cfile}[1]{\texttt{#1}}

\begin{document}
\raggedright

\title{Inferring transcript boundaries and expression levels using RNA-seq}
\author{Sang Chul Choi\\
Department of Biological Statistics and Computational Biology, \\
Cornell University,\\
Ithaca, NY 14850}

\maketitle

\tableofcontents


\newpage
\section{Introduction}

The lyx file is 
/Users/goshng/Dropbox/Documents/Projects/Peach/notes/researches/siepel-transcript.lyx

\subsection{YAML: Emitter}

Check /usr/local/include/yaml-cpp/emitter.h

We generate a data set under the model. A number of model parameters include:
\begin{enumerate*}
\item $J$ : 3
\item $L$ : 1,000 base pairs
\item $K$ : 5
\item $\bm{\lambda}$, $\bm{s}$ : a sample from Dirichlet(1)
\item $\bm{\delta}$, $\bm{\mu}$ : a sample from Dirichlet(1)
\item $\phi$ : a size as a function of $\mu$
\item $\bm{z}$ : a sample from uniform between 0.5 and 1.5
\item We repeat the above of simulation and inference 10 times. Note that we fix
the sampled values of $\bm{s}$, $\bm{\mu}$, and $\bm{z}$ throughout the 10 times
of simulation.
\end{enumerate*}
We use \Cclass{Likelihood}, \Cclass{ProbTxBoundaries}, and
\Cclass{ProbTxExpression} to create objects of \Cclass{Reads},
\Cclass{TxBoundaries}, and \Cclass{TxExpression}. Then, we save them in a YAML
file. The three objects are serialized to YAML output stream. 

We need testing procedures for classes we use, which requires a fair bit of
experience of CMake. 

Users comand \program{tux} via \Cclass{Mananger}.

We use \Cclass{Mcmc} to run a number of chains. A chain is a cold chain, and the
rest of chains are hot chains. The \Cclass{Mcmc} coordinates multiple
simultaneous runs of chains. We need to know what chains are running in which
machine. This can be done using MPI. Each chain needs to know what temperature
to use. The \Cclass{Mcmc} contains \Cmember{temperature} and \Cmember{chainid}
for accessing chains. 

The \Cclass {Manager} creates a list of temperature using \Cclass{c\_hlinear},
\Cclass{c\_hgeometric}. It sets \Cmember{chainid} as a sequence of non-negative
integers. It also sets values of \Cmember{temperature}. We need to set up a list
of chains before running them. The \Cclass{Mcmc} creates a list of chains and
executes each chain one at a time using \Cmethod{step}. We have two classes for
chains. One is for a chain that does the sampling job, and the other is for a
chain manager. The \Cclass{Mcmc}'s \Cmethod{step} commands all of the chains to
move a finite number of steps in their own process. The chain manager will be
run in a separate process. We may need Message Passing Interface (MPI), which
is an application interface that allows processes to communicate by sending and
receiving messages. In essence, it facilitates communication when multiple
computers/processors/cores are performing distributed calculations.

The \Cclass{Mcmc} sends a message of \Cmethod{step} to \Cclass{ChainManager},
which in turn sends a message of \Cmethod{step} to a list of \Cclass{Chain}.
A process owns one \Cclass{ChainManager}, which communicates with \Cclass{Mcmc}.
After finishing all of the messages of \Cmethod{step} in the list of
\Cclass{Chain}, the \Cclass{ChainManager} sends a message to \Cclass{Mcmc} to
check whether it can continue to move steps of the chains. The \Cclass{Mcmc}
would swap chains by receciving necessary values from \Cclass{ChainManager}. 

\subsection{Manager}

Members of \Cclass{Manager}:
\begin{enumerate*}
\item Data member
\item mNumberProcess; The program should know the number of CPUs to create
resources for jobs.
\item Method
\item void show();
\item void model();
\item void mcmc(int r = 0); a main MCMC loop. 
\item void summarize();
\item void save();
\item void load();
\item void help();
\end{enumerate*}

\subsection{Model}
I do not find a role of \Cclass{Model}, yet. The \Cclass{Fixed} has a similar
role.

\subsection{Mcmc}

Members of \Cclass{Mcmc}:
\begin{enumerate*}
\item vector<unsigned int> chainid; 
\item vector<unsigned int> mNumberChainPerProcess; e.g., c(3,3,2) 
\item vector<unsigned int> mAccumulateNumberChain; e.g., c(0,3,6,8)
\item vector<double> likelihoodPrior; the sum of likelihood and prior for each
chain. 
\item unsigned int lenChain; total length of a chain
\item unsigned int lenBurnin; length of a burn-in 
\item unsigned int lenThin; length of a sampling frequency
\item unsigned int lenSwap; length of a chain swapping frequency
\item unsigned int lenSwapTry; the number of attempts of swapping two chains.
This value can be smaller than ${n \choose 2}$ where $n$ is the number of
chains.
\item
\item The followings are nested structures:
\item struct c\_msg1 mMessage;
\item 
\item The following methods are public:
\item Mcmc ();
\item \~{}Mcmc ();
\item int numberChainPerProcess (); computes allocated numbers of chains for
each process
\item int createChainManager (unsigned int r);
\item int step (unsigned int n);
\item int swap (); swaps chains temperatures
\item int sample (); 
\item int save ();
\item int load ();
\item
\item The following methods are private:
\item int swapChains (); uses values from all of the chains to arrange chain
temperatures - called by \Cmethod{swap}
\item double swapWeight (unsigned int, unsigned int); computes an acceptance
ratio for swapping two chains - called by \Cmethod{swapChains}
\end{enumerate*}

\Cclass{c\_msg1} is used to send a message to the rank 0 process:
\begin{enumerate*}
\item unsigned int processid; the ordered ID of a process
\item unsigned int chainid; the designated chain ID
\item double likelihoodPrior; the sum of likelihood and prior of a chain
\end{enumerate*}

The \Cmethod{swap} for the rank 0 process waits for the rest of processes to
finish their \Cmethod{step}. Positively ranked processes send the rank 0 process
a message of likelihood and other values. The rank 0 process uses all of the
likelihood values to attempt swapping of chain temperature values. It finishes
the chain swapping by sending the rest of positively ranked processes a message
of the chosen temperature.
The \Cclass{ChainManager} sends the chain ID, and the sum of likelihood and
prior to the rank 0 process for each of the chains that it manages. The rank 0
process fills \Cmember{chainid} and \Cmember{likelihoodPrior} with those
received values. Note that the two vectors index chains managed by
\Cclass{ChainManager}. An element of \Cmember{chainid} is used to reference
a temperature value. Let us read the \Cmethod{swap} in detail.
Whatever the ranks are, \Cclass{ChainManager} calls \Cmethod{chainid} and
\Cmethod{likelihoodPrior} to get chain IDs, and sums of likelihood and prior for
the chains managed by the \Cclass{ChainManager} of the current rank process.
We start with the rank 0 process. We need sums of likelihood and prior from each
chain. We receive a message from each chain. Because \Cclass{ChainManager}
can contains multiple chains, we have two loops: one for the
\Cclass{ChainManager} and another for each chain in the \Cclass{ChainManager}.
A message is stored \Cmember{mMessage}. The \Cmember{processid} of 
\Cmember{mMessage} is the ordered index of a process that runs one chain. Do not
be confused by the name process. For example, if 
\Cmember{mNumberChainPerProcess} is c(3,3,2), the process indices run from 0 to
7. Processes are different in the assigned chain index, which is stored in
\Cmember{chainid} of \Cmember{mMessage}. We use \Cmember{processid} to index 
\Cmember{mChainid} and \Cmember{mLikelihoodPrior}. Now that we have chain
IDs, and sums of likelihood and prior. We call \Cmethod{swapChains}, and
rearrange \Cmember{mChainid}. 
We need to configure chains with the rearranged chain IDs. For the rank 0
process we find the chain IDs and save them in a vector of size being equal to
the number of chains in the rank 0 process. We send messages to the rest of
positively ranked processes. Let us turn to a postively ranked process. Note
that we have already stored chain IDs and sums of likelihood and prior. We send
those to the rank 0 process, and wait and receive messages from the rank 0
process. After getting all of the chain IDs we use \Cclass{ChainManager} to call
\Cmethod{setChainid}.

\subsection{ChainManager}

Members of \Cclass{ChainManager}:
\begin{enumerate*}
\item The followings are data members:
\item vector<Chain> chain; a list of chains
\item The followings are public:
\item ChainManager (); creates a single chain
\item ChainManager (unsigned int n); creates $n$ chains
\item void delete\_pointed\_to (T* p); function template to delete chains
\item void chainid (vector<unsigned int>\&); returns a vector of Chain IDs from
the list of chains
\item void setChainid (vector<unsigned int>\&); assigns chain IDs 
\item void createChain (unsigned int n); This must be called only once because
it creates a vector of \Cclass{Chain}, connects \Cclass{Fixed} and
\Cclass{Reads}, and calls \Cclass{createParameter} of \Cclass{Chain}. 
\end{enumerate*}

The \Cclass{ChainManager} owns objects from 
\Cmember{mTxFixed}, and \Cmember{mTxData}. This runs on a single process or a
single thread. It owns multiple chains. It is different from \Cclass{Mcmc} in
that it does call MPI command or threads. 

I think that \Cclass{Mcmc} should be renamed because it has something to do with
processes and threads. Chain swaps are done in \Cclass{Mcmc}. We might want to
keep its name. The \Cclass{Mcmc} might have two things in it: process management
and Markov chains management. 

\subsection{Chain}

Members of \Cclass{Chain}:
\begin{enumerate*}
\item Data Member:
\item unsigned int chainid; the ID of a chain
\item double likelihoodPrior; the sum of likelihood and prior
\item double mBeta; the temperature 
\item unsigned int mStep; the number of steps
\item Parameter* mTxBoundaries; a set of transcript boundaries
\item Parameter* mTxExpression; a set of transcript expression
\item Data* mTxData; a set of short reads alignment data
\item public:
\item TxFixed(); sets mTxFixed
\item TxReads(); sets mTxReads
\item createParameter(); creates boundaries and expression parameters
\end{enumerate*}

The \Cclass{Chain} owns objects from \Cclass{RandomVariable}:
\Cmember{mTxBoundaries}, \Cmember{mTxExpression}, and \Cmember{MoverManager}.
The \Cclass{Chain} has access to \Cmember{mTxFixed}, and \Cmember{mTxData}.
The \Cclass{ChainManager} owns objects from 
\Cmember{mTxFixed}, and \Cmember{mTxData}. 
The first two \Cclass{Parameter} objects change their contents through
\Cclass{Mover} objects that are managed by \Cclass{MoverManager}. Methods of
\Cclass{Chain} would create \Cclass{Parameter} objects. Additionally,
\Cclass{Mover} objects are created in methods of \Cclass{Chain}. Objects of
\Cclass{Mover}'s subclasses such as \Cclass{MoverTxBoundaries} are allowed to
access \Cclass{Parameter} members in \Cclass{Chain}. We do this by giving
\Cclass{MoverTxBoundaries} a pointer to the object of \Cclass{TxBoundaries}.
Let us check how we could propose a new state of \Cclass{TxBoundaries}, and
accept or reject it in \Cclass{MoverTxBoundaries}. Do this 
in \Cclass{MoverTxExpression} as well.

We use fstream to create a file and append the chain state to the file. We
considered \Cclass{Sample}, which did not make sense.


\subsection{RandomVariables}

TxBoundaries is created in a method of class Chain.
MoverTxBoundaries should be also created in a method of class Chain.
Then, Chain can connect its Parameters and Data to MoverTxBoundaries.
It passes the connected MoverTxBoundaries to MoverManager.

The chain uses \Cclass{Probability} and \Cclass{RandomVariable} to change the
value of \Cclass{Parameter}. The \Cclass{Data} is a \Cclass{RandomVariable} that
does not change its value. The \Cclass{Probability} is not a part of the chain. 
The chain must contain objects of \Cclass{RandomVariable}. The \Cclass{Mover} is
applied to \Cclass{ChainManager} or \Cclass{Mcmc}. The \Cclass{Chain} may have
access to \Cclass{Mover}. There are multiple possible movers of parameters. The
\Cclass{Chain} is manipulated to switch from one mover to another. Each step
multiple movers are chosen to be applied to \Cclass{Chain}. The \Cclass{Mover}
may have access to \Cclass{Probability}: it could use some \Cclass{Probability}
to replace a current state of \Cclass{Parameter} with another. The
\Cclass{Chain} has an object of \Cclass{MoverManager}, which manages several
\Cclass{Mover} objects. The \Cclass{MoverManager} is operational in that it
returns a \Cclass{Mover} among the set of \Cclass{Mover} objects with
multinomial probability.

\subsection{Parameter}

\subsection{TxBoundaries}

\begin{enumerate*}
\item public: 
\item   vector<unsigned int> mC; 1-based ending positions of segments
\item   unsigned int mLengthSampleSegment; length of interval for choosing
random segments
\item public:
\item   TxBoundaries ();
\item   ~TxBoundaries ();
\item   unsigned int size (); the number of segments
\item   unsigned int L (); the length of the chromosome 
\item   void seq (unsigned int from, unsigned int to, unsigned int by); 
\item   void sampleSegment (unsigned int\&, unsigned int\&);
\end{enumerate*}

\subsection{TxExpression}

\begin{enumerate*}
\item public:
\item   vector<double> mDelta; 
\item public:
\item   TxExpression ();
\item   ~TxExpression ();
\item   void seq (unsigned int); sets the equal-sized delta 
\item   friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, 
                                    const TxExpression \&tx);
\end{enumerate*}

\subsection{Data}

We do not have members yet. This is just a base of fixed parameters.

We would need to read and write \Cclass{RandomVariable} from and to a file using
YAML. We have a likelihood that is used to compute the likelihood and to sample
data given parameters.

\subsection{Reads}

Members of \Cclass{Reads}
\begin{enumerate*}
\item public: Data members
\item   vector<unsigned int> mCount; number of counts of reads at the position.
We only consider 5' end positions of short reads to count. 
\item   unsigned int mN; total number of counts derived from \Cmember{mCount}
\item   unsigned int mJ; j-th short reads
\item public: Methods
\item   Reads ();
\item   ~Reads ();
\item   unsigned int size (); the length of a chromosome 
\item   void sample (unsigned int l, unsigned int ul=10); sets counts for each
site to random values, the random values are between 0 and ul. The number of
sites becomes $l$
\item   friend YAML::Emitter operator (YAML::Emitter out, const Reads tx);
\end{enumerate*}

\subsection{Fixed}

Members of \Cclass{Fixed}
\begin{enumerate*}
\item public: Data members
\item   unsigned int mK; the number of segments
\item   unsigned int mM; the number of segments
\item   vector<double> mZ; the size factors
\item   double mA0; the coefficient $a_0$ of the function $\phi$
\item   double mA1; the coefficient $a_1$ of the function $\phi$
\item   double mAlpha; the proposal controller of expression levels
\item   double mAlphaQBoundaries; the proposal controller of boundaries
\item   unsigned int mLengthSampleSegment; the length of sampled segments
\item   double mAlphaPriorExpression; constant $\alpha_k$ value for the
Dirichlet prior, we would set 0.01 to $\alpha_k$. 
\item   unsigned int mMcmcLength; total length of a MCMC chain
\item   unsigned int mMcmcBurnin; length of burn-in of the total length
\item   unsigned int mMcmcThin; length of generation between sampling
\item   unsigned int mNumberProcess; the number of processes
\item   unsigned int mNumberChain; the number of chains
\item   unsigned int mNumberSwap; the number of swap 
\item   unsigned int mNumberSwapTry; the number of swap tries
\item   string mOutfile; the output file name
\item public: Methods
\item   Fixed ();
\item   \~{}Fixed ();
\item   unsigned int K(); returns the number of segments
\item   friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, const Fixed \&t);
\item   friend void operator$\gg$ (const YAML::Node\& node, Fixed\& t);
\item   friend ostream\& operator$\ll$ (ostream \&out, const Fixed \&t);
\end{enumerate*}


\subsection{Probability}

The \Cclass{Probability} is tightly linked with \Cclass{RandomVariable}. Two
sets of random variables are considered: one that is concerned, and the other
that is conditioned. We can sample random variates of the former set from
\Cclass{Probability}. We can compute the probability density for a specific
set of random variates. The set of random variables that are conditioned is
optional. We use \Cclass{Probability} for non-standard valued random variables.
We would use simpler functions or classes for sampling a random variate from a
uniform. 

Let us consider usages of \Cclass{Probability}. We want a negative binomial with
two parameters: mean and variance. The probability of a segment configuration is
distributed as a uniform with a probability of $\frac{1}{{L-1 \choose K-1}}$
where $L$ is the length of a genome where we have $K$ segments. A $k$-th segment
boundary is between $c_{k-1}+1$ and $c_k$ inclusively. The $c_0$ is 0, and $c_K$
is $L$. We impose a Dirichlet on expression level $\bm{\mu}$. An expression
level of $k$-th segment is $\mu_k$, which is $\delta_k M$ where $M$ is the total
expression level of a RNA-seq experiment. We should give a ``very''
uninformative prior on $\bm{\mu}$ using a set of values $\bm{\alpha}$. We use a
lagarithmic scale of $\bm{\mu}$. Given the prior we start with $\bm{s}^{(0)}$
and $\bm{\mu}^{(0)}$. These two values are sampled from each of their prior
distribution. The boundary value, $\bm{s}^{(0)}$, consists of
$\{c_{k}\}_{k=1\ldots K-1}$ where $c_k$ is the end position of $k$-th segment.
We need $K-1$ positive values. The expression value, $\bm{\mu}^{(0)}$, consists
of $K$ real values. We use $\bm{\delta}^{(0)}$ which is a set of fractions, and
only need $K-1$ values. We convert them in logarithmic scale. Let us go to
\Cclass{TxBoundaries} and \Cclass{TxExpression}, which are \Cclass{Parameter},
which in turn is \Cclass{RandomVariable}. A random variate is created from a
probability distribution. A class of \Cclass{Probability}, or a probability of a
set of transcript boundaries, would create an object of \Cclass{TxBoundaries}.
Let us create a probability of a set of transcript boundaries:
\Cclass{ProbTxBoundaries}. 

Members of \Cclass{Probability}
\begin{enumerate*}
\item Data members:
\item vector<RandomVariable*> mV; a list of random variables
\item vector<RandomVariable*> mC; a list of conditioning random variables
\item
\item virtual double d () = 0; a value of a probability
\item virtual RandomVariable* r () = 0; a random variate
\end{enumerate*}

\subsection{ProbTxBoundaries}

Members of \Cclass{ProbTxBoundaries}
\begin{enumerate*}
\item Data members:
\item  unsigned int mL; the length of a chromosome 
\item  unsigned int mK; the number of segments
\item Methods:
\item ProbTxBoundaries (unsigned int l, unsigned int k); sets the length of a
chromsome to l, and the number of segments to k. 
\item double d (); a value of a probability of a transcipt boundaries
\item RandomVariable* r (); a random variate of a transcript boundaries.
\end{enumerate*}

\Cmethod{ProbTxBoundaries::r} - 
Consider numerical stability in sampling a random variate of transcript
boundaries. A segment could be 0 in length. I let a segment be at least 1 in
length. How can I sample Dirichlet random variates that is at least $1/L$? How
can I sample from Dirichlet distribution? Let us see function 
gsl\_ran\_dirichlet. We use gsl\_ran\_choose to choose $k$ sites among $L$
sites. The value of $L$ can be large. Assuming bacterial genomes we use this
method. Otherwise, we have to use containt Dirichlet distribution.
We choose $K-1$ sites between 1 and $L-1$ inclusive.

\subsection{ProbTxExpression}

Members of \Cclass{ProbTxExpression}
\begin{enumerate*}
\item Data members:
\item vector<double> mAlpha; a concentration parameter
\item vector<double> mTheta; a random variate of Dirichlet
\item Methods:
\item  ProbTxExpression (const unsigned int k, const double a = 1.L); sets the
concentration parameter of Dirichlet distribution. The size is $k$, and
$\alpha_k$ is 1.
\item  ~ProbTxExpression ();
\item double d (); a value of a probability of transcipt expressions 
\item RandomVariable* r (); a random variate of transcript expressions
\end{enumerate*}

\subsection{Likelihood}

Members of \Cclass{Likelihood}
\begin{enumerate*}
\item Data members:
\item unsigned int mL; the length of a chromosome
\item unsigned int mK; the number of segments
\item double mM; the level of total expression 
\item vector<double> mSizeFactor; a set of size factors
\item vector<double> mDelta; a set of delta given by TxExpression
\item vector<unsigned int> mC; a set of segments given by TxBoundaries
\item vector<unsigned int> mCount; a set of numbers along a chromosome
\item Methods:
\item  Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te); creates a
likelihood object using the three random variables objects
\item Likelihood (unsigned int l, unsigned int k, double m); 
$l$ sites along a chromosome, $k$ segments, and $m$ total expression level.
\item RandomVariable* Likelihood::r (); creates a data set.
\end{enumerate*}

The \Cclass{Fixed} is created from a YAML file. Two probability classes create
\Cclass{TxBoundaries} and \Cclass{TxExpression}. The \Cclass{Likelihood} needs
the three \Cclass{RandomVariable} objects to create \Cclass{Data} object. It
does not own none of \Cclass{RandomVariable} objects.

\subsection{MoverManager}

Members of \Cclass{MoverManager}:
\begin{enumerate*}
\item Data Member:
\item vector<Mover*> mMover; a set of \Cclass{Mover} objects.
The \Cclass{MoverManager} owns the \Cclass{Mover} object elements in
\Cmember{mMover}. The \Cmethod{add} allocates the memory of a \Cclass{Mover}
object. The \Cclass{MoverManager}'s destructor must deallocate the memory.
\item vector<unsigned int> mId; why do we need this?
\item vector<double> mWeight; why do we need this?
\item gsl\_ran\_discrete\_t* mGslRanDiscrete; a lookup tabl for the discrete
random number generator
\item Method:
\item MoverManager (); 
\item ~MoverManager ();
\item void add (Mover*, const unsigned int, const double); adds a mover object
with an ID and weight.
\item Mover* choose ();
\end{enumerate*}

\subsection{Mover}

A \Cclass{Mover} may contain many different things. We would give an identifier
for a mover. A mover should be subclassed from the abstract \Cclass{Mover}.  

\subsection{MoverTxExpression}

\begin{enumerate*}
\item public: 
\item  TxBoundaries* mTxBoundaries; a pointer to TxBoundaries
\item  TxExpression* mTxExpression; a pointer to TxExpression
\item  Reads* mReads; a pointer to Reads
\item  double mAlpha; a concentration parameter of Dirichlet
\item public:
\item  MoverTxExpression ();
\item  int step (); 
\end{enumerate*}

1. Use MoverTxBoundaries::step to choose a subset of the K segments.
2. Find delta's for the subset.
3. Sample a new delta's using the current delta's.
Take the sum of the a, and multiply a by mAlpha/sum.
mAlpha is 1. If it is smaller, then the variance of a would be
larger. Because GSL Dirichlet function needs a memory for a return
value. a is the new delta of the old delta b.
4. Compute likelihood, prior, and MH ratio.
Find the start and end so that we can use parts of delta's in mDelta.
The random variable class's method can return a random stuff. For example,
TxBoundaries can return a random subset of boundaries. This seems sensible
because we use a member of TxBoundaries to get something of the member.
Let's make a method in TxBoundaries to sample a subset of boundaries.

Use the different theta to compute the likeilhood ratio.
Compute the prior ratio because we give a diffuse Dirichlet prior.
Compute the MH ratio based on our move.
We need to access the prior of gene expression.
We need a point to the prior probability of expression.

Now, lK contains lengths of the segments.

Nj, a0, a1 are fixed for one sample. These are also fixed parameter.
They should be a part of data. We need a class of data for storing these
fixed parameters. Let us assume that we be given those fixed parameters.
ck, mDelta, 
ck, and Nj are for each sample.
gsl\_ran\_negative\_binomial\_pdf (k, p, n);
k is from ck.
mu is (Nj * mDelta)
p is n/(n+mu)
n is 1/(a0+a1/mu).

\subsection{MoverTxBoundaries}

\begin{enumerate*}
\item any items
\end{enumerate*}

1. We choose a subset of the K segments.
1.1 We choose a site of the L sites.
1.2 We choose a length from a distribution or fixed value.
1.3 Group segments in the chosen region.
2. Find the lengths of the subset of the segments.
2.1 Sum the lengths.
2.2 Compute the fractions of the legnths with respect to the sum of the
length.
2.3 Multiply the factions by a pseudo-concentration parameter.
3. Use the multiplied factions as a set of concentration parameters to
sample a new set of random variates from the Dirichlet distribution.
3.1 Multiply the sum of the lengths of the subset to recover a new set of
segments. 
3.2 Adjust legnths of the segments so that legnths fit the remaining
segments.
4. Compute acceptance probability by using likelihood, priors, and
Metropolis-Hastings ratio.
4.1 The priors are p(mu|s)p(s)=p(mu)p(s). This value does not change
before and after the proposal.
4.2 Count reads on the subset and compute p(x|theta*)/p(x|theta).
Optimization of the likelihood ratio can be done by using forms of the
negative binomial probability functions.
4.3 Compute the Metropolis-Hastings ratio using the proposal.

\Cclass{MoverTxBoundaries} \Cmethod{step}
\begin{Verbatim}[frame=lines,framesep=5mm]
  // 1. We choose a subset of the K segments.
  // 1.1 We choose a site of the L sites.
  // 1.2 We choose a length from a distribution or fixed value.
  // 1.3 Group segments in the chosen region.
  // 2. Find the lengths of the subset of the segments.
  // 2.1 Sum the lengths.
  // 2.2 Compute the fractions of the legnths with respect to the sum of the
  // length.
  // 2.3 Multiply the factions by a pseudo-concentration parameter.
  // 3. Use the multiplied factions as a set of concentration parameters to
  // sample a new set of random variates from the Dirichlet distribution.
  // 3.1 Multiply the sum of the lengths of the subset to recover a new set of
  // segments. 
  // 3.2 Adjust legnths of the segments so that legnths fit the remaining
  // segments.
  // 4. Compute acceptance probability by using likelihood, priors, and
  // Metropolis-Hastings ratio.
  // 4.1 The priors are p(mu|s)p(s)=p(mu)p(s). This value does not change
  // before and after the proposal.
  // 4.2 Count reads on the subset and compute p(x|theta*)/p(x|theta).
  // Optimization of the likelihood ratio can be done by using forms of the
  // negative binomial probability functions.
  // 4.3 Compute the Metropolis-Hastings ratio using the proposal.
\end{Verbatim}

Members of \Cclass{RandomVariable}
\begin{enumerate*}
\item Data members:
\end{enumerate*}

Members of \Cclass{Parameter}
\begin{enumerate*}
\item Data members:
\end{enumerate*}

Members of \Cclass{TxBoundaries}
\begin{enumerate*}
\item Data members:
\item vector<unsigned int> mC; the end position of $c_k$ where $k$ runs from 0
to $K$. $c_0$ is 0, and $c_K$ is $L$. \Cmember{mC} runs from 0 to $K-1$. The
$0$-th element is $c_1$, and $K-1$-th element is $c_K$. Note that the first
element is not 1.
\item unsigned int mLengthSampleSegment; 
\item Methods:
\item unsigned int length (); returns the number of segments.
\item unsigned int L (); returns the length of a chromosome. 
\item operator out (YAML::Emitter \&out, const TxBoundaries \&tx); prints
\Cmember{mC} in YAML format.
\item TxBoundaries::sampleSegment (unsigned int\& left, unsigned int\& right); gets
the end positions of beginning and ending segments. Choose one segment and
another that are at least one segment apart. Now, we just add 
\Cmember{mLengthSampleSegment} to the chosen position. We may use a distribution
to have different values of \Cmember{mLengthSampleSegment} across sampling
procedure.
\end{enumerate*}
The \Cclass{TxBoundaries} object is created by \Cclass{ProbTxBoundaries}.

Members of \Cclass{ProbTxBoundaries}
\begin{enumerate*}
\item Data members:
\item unsigned int mL; the length of a genome
\item unsigned int mK; the number of segments
\item Method
\item double d (); logarithmic value of $1/{(L-1) \choose (K-1)}$
\item RandomVariable* r (); a random variate of \Cclass{TxBoundaries} object
\end{enumerate*}

\subsection{Sample}
Each chain produces an output file. The output file contains running setup
(\Cclass{Fixed}), data (\Cclass{Reads}), and samples (\Cclass{Sample}). 
There are other files such as mc3 file, GSL RNG files. One of the multiple
chains in MC3 would creates mc3 file as well as chain file. 

\subsection{Summarizer}
We reads in posterior sample files from multiple chains to create
\Cclass{Summary} object. 

\subsection{Summary}


\subsection{System}

\subsection{TUX GSL}

\begin{enumerate*}
\item double gsl\_ran\_negative\_binomial\_lnpdf (const unsigned int k, const
double p, const double n); This computes logarithm of 
gsl\_ran\_negative\_binomial\_pdf funtion.
\end{enumerate*}


Global variables
\begin{enumerate*}
\item const gsl\_rng *gGslRng; the main function calls MPI\_Init function to create
processes. Prior to that function call we should create as many seeds as
processes.
\end{enumerate*}

We borrow \Cfile{gtypes.h} from gnome's \Cfile{glib/gtypes.h}. 

Main function
\begin{enumerate*}
\item OPT\_MCMC: creates multiple random seeds using a single seed.
\end{enumerate*}

We have a number of boundaries. We can compute the average number of times a
boundary exists to the right of a site. We compute average expression level for
each site. We do this using the posterior samples of boundaries and expression
levels. Use \Cclass{Summary} and \Cclass{Summarizer}. Multiple files should be
handled by \Cclass{Summarizer} because MPI processors create their own output
files. 


The \Cclass{System} inspects the local computer system. What do we need to know?
We need to know the number of CPUs, the size of memory, the number of computes
nodes, the speed of CPUs, etc.

We create a data set in a YAML file. This is a test program.

\begin{Verbatim}[frame=lines,framesep=5mm]
tux-gsl: tests GSL.
tux-tx: tests TxBoundaries and TxExpression. 
tux-move: tests Movers.
tux-chain: tests Chains.
tux-sum: tests Summarizer.
tux-cmd: tests Readline library with tux.
\end{Verbatim}

\subsection{tux-fixed}
We creates a \Cclass{Fixed} object and write the object to a file. We also
change the property of the object by reading in another file. This needs YAML
library.  We create a yaml file.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./tux-fixed tux-fixed.out
$ cp tux-fixed.out fixed.yaml
$ Edit fixed.yaml
\end{Verbatim}

The fixed.yaml should look like this.
\begin{Verbatim}[frame=lines,framesep=5mm]
Fixed:
  mA0: 0.5
  mA1: 2.5
  mAlpha: 1.5
  mAlphaQBoundaries: 1.7
  mLengthSampleSegment: 300
  mAlphaPriorExpression: 0.04
  mMcmcLength: 3000
  mMcmcBurnin: 700
  mMcmcThin: 82
---
Reads:
  - [1, 32, 7, 9, 97, 3, 2, 5, 3, 7]
  - [2, 12, 7, 9, 98, 3, 1, 2, 3, 8]
  - [3, 13, 7, 8, 99, 3, 8, 4, 4, 9]
\end{Verbatim}

\subsection{tux-tx}
We use fixed.yaml to create tx.yaml.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./tux-tx tux-tx.out
$ cp tux-tx.out tx.yaml
\end{Verbatim}

The tx.yaml should look like the following verbatim section.
\begin{Verbatim}[frame=lines,framesep=5mm]
Fixed:
  mA0: 0.5
  mA1: 2.5
  mAlpha: 1.5
  mAlphaQBoundaries: 1.7
  mLengthSampleSegment: 300
  mAlphaPriorExpression: 0.04
  mMcmcLength: 3000
  mMcmcBurnin: 700
  mMcmcThin: 82
---
Reads:
  - [1, 32, 7, 9, 97, 3, 2, 5, 3, 7]
---
TxBoundaries:
  - [2, 4, 6, 8, 10]
---
TxExpression:
  - [0.2, 0.2, 0.2, 0.2, 0.2]
\end{Verbatim}

\subsection{tux-prob}
We use \Cclass{Probability} to create \Cclass{RandomVariable} objects.

\subsection{tux-move}
We would read in input files. We change parameters. We do not include chains
yet.

\subsection{tux-chain}
We would test a single chain using \Cclass{Chain}.

\subsection{tux-cm}
We would test multiple chains using \Cclass{ChainManager}.

\subsection{tux-mcmc}
We would test multiple chains in multiple processes.

\subsection{tux-sum}
We would summarize an output file.

\subsection{tux-cmd}
We would test tux commands using Readline library.

\section{Compilation}
Build a debug version using CMake.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ cd output/src
$ mkdir debug
$ cd debug
$ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ CC=openmpicc CXX=openmpic++ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ openmpirun -n 2 tux mcmc
$ make
$ make VERBOSE=1
$ cd ..;rm -rf b;mkdir b;cd b;cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ cd ../../..;./run 2;cd output/src;rm -rf b;mkdir b;cd b;cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug;make
\end{Verbatim}

Create a PDF document of this document. 
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./run 1
\end{Verbatim}

Tangle source codes of this document.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ mkdir -p output/src
$ ./run 2
$ pushd ../../..;./run 2;popd;make
\end{Verbatim}

To add a project create a source code, add it an executable in the CMakeLists
file, and tangle the source code by editting sh/noweb-tangle.sh script.

Debugging
\begin{Verbatim}[frame=lines,framesep=5mm]
print *(aAlpha._M_impl._M_start)@aAlpha.size()
\end{Verbatim}

\subsection{CMake}

See the following page for a tutorial of CTest.
\begin{Verbatim}
http://www.cmake.org/Wiki/CMake_Testing_With_CTest
\end{Verbatim}

\begin{Verbatim}
ENABLE_TESTING()
ADD_TEST(SimpleTest ${CMAKE_CURRENT_BINARY_DIR}/SimpleTest Hello)
\end{Verbatim}

When using Makefile generators, such as Unix Makefiles, Borland Makefiles, or
NMake Makefiles, the CTest can simply be run by running:
\begin{Verbatim}
make test
\end{Verbatim}

Use CMake, CTest, CDash, and CPack.

Find CMake modules at the following directory:
\begin{Verbatim}[frame=lines,framesep=5mm]
/Applications/CMake\ 2.8-8.app/Contents/share/cmake-2.8/Modules/
\end{Verbatim}

To add a custom CMake package
\begin{Verbatim}[frame=lines,framesep=5mm]
cp downloads/FindReadline.cmake output/src/cmake/Modules/
http://www.vtk.org/Wiki/CMake:How_To_Find_Libraries
\end{Verbatim}

Set the version number.
Check if this system provide the log and exp functions.
See if we should use our own math functions.
Configure a header file to pass some of the CMake settings
to the source code.
Add the binary tree to the search path for include files
so that we will find config.h
Add the MathFunctions library.
Add the executable.
Add the install targets.
Enable dashboard scripting
<<CMakeLists.txt>>=
cmake_minimum_required(VERSION 2.8)
project (tux)
# set (CMAKE_VERBOSE_MAKEFILE true)
set (CMAKE_BUILD_TYPE DEBUG)
SET (yamlEmitter_SRCS 
  "yamlEmitter.cpp"
)
set (tux-fixed_SRCS 
  "tux-fixed.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxData.cpp"
  "tuxFixed.cpp"
  "tuxReads.cpp"
)
set (tux-tx_SRCS 
  "tux-tx.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxData.cpp"
  "tuxFixed.cpp"
  "tuxReads.cpp"
)
set (tux-prob_SRCS 
  "tux-prob.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
)
set (tux-move_SRCS 
  "tux-move.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
)
set (tux-chain_SRCS 
  "tux-chain.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-cm_SRCS 
  "tux-cm.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-sum_SRCS 
  "tux-sum.cpp"
  "tuxSummarizer.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (CMAKE_C_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")
set (CMAKE_CXX_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")

set (CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}")
set (tux_VERSION_MAJOR 0)
set (tux_VERSION_MINOR 1)
include (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake)
include (${CMAKE_ROOT}/Modules/CheckIncludeFiles.cmake)
check_function_exists (log HAVE_LOG)
check_function_exists (exp HAVE_EXP)
check_include_files (malloc.h HAVE_MALLOC_H)
check_include_files (sys/file.h HAVE_SYS_FILE_H)
check_include_files (unistd.h HAVE_UNISTD_H)
check_include_files (string.h HAVE_STRING_H)
check_include_files (stdlib.h HAVE_STDLIB_H)
option(USE_MYMATH "Use my math implementation" OFF)
configure_file (
  "${PROJECT_SOURCE_DIR}/config.h.in"
  "${PROJECT_BINARY_DIR}/config.h"
  )
include_directories ("${PROJECT_BINARY_DIR}")
if (USE_MYMATH)
  include_directories ("${PROJECT_SOURCE_DIR}/MathFunctions")
  add_subdirectory (MathFunctions)
  set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
endif (USE_MYMATH)
  add_executable (tux tux-v1.cpp)
target_link_libraries (tux ${EXTRA_LIBS})

# GNU Scientific Library
find_package (GSL)
if (GSL_FOUND)
  include_directories (${GSL_INCLUDE_DIR})
#  add_executable (tux-gsl tux-gsl.cpp tuxGslRng.cpp)
#  target_link_libraries (tux-gsl ${GSL_LIBRARIES})
else (GSL_FOUND)
  message (FATAL_ERROR "No GNU GSL library found")
endif (GSL_FOUND)

# YAML-CPP static library
find_library(YAMLCPP yaml-cpp)
if(${YAMLCPP} MATCHES NOTFOUND)
  message(FATAL_ERROR "No yaml-cpp found")
else(${YAMLCPP} MATCHES NOTFOUND)
  add_library(yaml STATIC IMPORTED)
  set_property(TARGET yaml PROPERTY IMPORTED_LOCATION ${YAMLCPP})
  set (tux-tx_LIBS ${tux-tx_LIBS} yaml)
  set (tux-tx_LIBS ${tux-tx_LIBS} ${GSL_LIBRARIES})
#  add_executable (tux-tx ${tux-tx_SRCS})
#  target_link_libraries (tux-tx ${tux-tx_LIBS})

  set (tux-prob_LIBS ${tux-tx_LIBS})
#  add_executable (tux-prob ${tux-prob_SRCS})
#  target_link_libraries (tux-prob ${tux-prob_LIBS})

  set (tux-move_LIBS ${tux-tx_LIBS})
#  add_executable (tux-move ${tux-move_SRCS})
#  target_link_libraries (tux-move ${tux-move_LIBS})
  
  set (tux-chain_LIBS ${tux-tx_LIBS})
#  add_executable (tux-chain ${tux-chain_SRCS})
#  target_link_libraries (tux-chain ${tux-chain_LIBS})
  
  set (tux-cm_LIBS ${tux-tx_LIBS})
#  add_executable (tux-cm ${tux-cm_SRCS})
#  target_link_libraries (tux-cm ${tux-cm_LIBS})
  
  set (tux-sum_LIBS ${tux-tx_LIBS})
  add_executable (tux-sum ${tux-sum_SRCS})
  target_link_libraries (tux-sum ${tux-sum_LIBS})
  
  set (tux-fixed_LIBS ${tux-tx_LIBS})
#  add_executable (tux-fixed ${tux-fixed_SRCS})
#  target_link_libraries (tux-fixed ${tux-fixed_LIBS})

  set (yamlEmitter_LIBS ${tux-tx_LIBS})
#  add_executable (yamlEmitter ${yamlEmitter_SRCS})
#  target_link_libraries (yamlEmitter ${yamlEmitter_LIBS})

endif(${YAMLCPP} MATCHES NOTFOUND)

add_executable (stl-transform stl-transform.cpp)

# Install
install (TARGETS tux DESTINATION bin)

# Tests
enable_testing ()
add_test (tuxUsage tux)
set_tests_properties (tuxUsage
  PROPERTIES 
  PASS_REGULAR_EXPRESSION "Usage:.*number"
  )

add_test (tuxGslCreate tux-gsl ${CMAKE_CURRENT_BINARY_DIR}/tux-gsl.out)
add_test (tuxGslCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-gsl.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-gsl.out)
add_test (tuxTxCreate tux-tx ${CMAKE_CURRENT_BINARY_DIR}/tux-tx.out)
add_test (tuxTxCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-tx.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-tx.out)
add_test (tuxProbCreate tux-prob ${CMAKE_CURRENT_BINARY_DIR}/tux-prob.out)
add_test (tuxProbCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-prob.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-prob.out)
add_test (tuxMoveCreate tux-move ${CMAKE_CURRENT_BINARY_DIR}/tux-move.out)
add_test (tuxMoveCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-move.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-move.out)
add_test (tuxChainCreate tux-chain ${CMAKE_CURRENT_BINARY_DIR}/tux-chain.out)
add_test (tuxChainCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-chain.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-chain.out)
add_test (tuxCMCreate tux-cm ${CMAKE_CURRENT_BINARY_DIR}/tux-cm.out)
add_test (tuxCMCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-cm.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-cm.out)
add_test (tuxSumCreate tux-sum ${CMAKE_CURRENT_BINARY_DIR}/tux-sum.out)
add_test (tuxSumCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-sum.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-sum.out)
add_test (tuxFixedCreate tux-fixed ${CMAKE_CURRENT_BINARY_DIR}/tux-fixed.out)
add_test (tuxFixedCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-fixed.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-fixed.out)

include (${CMAKE_ROOT}/Modules/InstallRequiredSystemLibraries.cmake)
set (CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/gpl-3.0.txt")
set (CPACK_PACKAGE_VERSION_MAJOR "${tux_VERSION_MAJOR}")
set (CPACK_PACKAGE_VERSION_MINOR "${tux_VERSION_MINOR}")
set (CPACK_PACKAGE_CONTACT       "tuxg@googlegroups.com")
include (CPack)

include (CTest)
@

<<MathFunctions/CMakeLists.txt>>=
# first we add the executable that generates the table
add_executable(MakeTable MakeTable.cpp)

get_target_property(MakeTableLocation MakeTable LOCATION)

# add the command to generate the source code
add_custom_command (
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  DEPENDS MakeTable
  COMMAND ${MakeTableLocation}
  ARGS ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  )

set_source_files_properties (
  mysqrt.cpp PROPERTIES 
  OBJECT_DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  )

# add the binary tree directory to the search path for include files
include_directories( ${CMAKE_CURRENT_BINARY_DIR} )

# add the main library
add_library(MathFunctions mysqrt.cpp)

install (TARGETS MathFunctions DESTINATION bin)
install (FILES MathFunctions.h DESTINATION include)
@

<<CMakeListsV1.txt>>=
cmake_minimum_required(VERSION 2.8)
ENABLE_TESTING()

PROJECT (tux)
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/Modules/")
SET (tux_SRCS 
  "tux.cpp"
  "tuxHelp.cpp"
  "tuxManager.cpp"
  "tuxModel.cpp"
  "tuxMcmc.cpp"
  "tuxChainManager.cpp"
  "tuxChain.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxData.cpp"
  "tuxSystem.cpp"
  "tuxProbability.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxSummarizer.cpp"
  "tuxSummary.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxReads.cpp"
  "tuxXyz.cpp"
  "xmalloc.c"
  "xfree.c"
)
SET (monsters_SRCS 
  "monsters.cpp"
)
SET (gsl_SRCS 
  "gsl.cpp"
)
SET (yamlEmitter_SRCS 
  "yamlEmitter.cpp"
)
SET (fileman_SRCS 
  "fileman.cpp"
  "xmalloc.c"
  "xfree.c"
)
SET (ezlogger_SRCS 
  "ezlogger.cpp"
)

# SET (CMAKE_EXE_LINKER_FLAGS "-static")
ADD_DEFINITIONS(-DHAVE_CONFIG_H) 
# SET (CMAKE_C_FLAGS_DEBUG "-Wno-write-strings -g3 -ggdb -O0")
# SET (CMAKE_CXX_FLAGS_DEBUG "-Wno-write-strings -g3 -ggdb -O0")
SET (CMAKE_C_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")
SET (CMAKE_CXX_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")

# YAML
add_library(yaml STATIC IMPORTED)
set_property(TARGET yaml PROPERTY IMPORTED_LOCATION /usr/local/lib/libyaml-cpp.a)
ADD_EXECUTABLE (monsters ${monsters_SRCS})
target_link_libraries(monsters yaml)
ADD_EXECUTABLE (yamlEmitter ${yamlEmitter_SRCS})
target_link_libraries(yamlEmitter yaml)

# GSL
ADD_EXECUTABLE (gsl ${gsl_SRCS})
find_package (GSL)
if (GSL_FOUND)
  include_directories(${GSL_INCLUDE_DIR})
  target_link_libraries (gsl ${GSL_LIBRARIES})
endif (GSL_FOUND)

# EzLogger
ADD_EXECUTABLE (ezlogger ${ezlogger_SRCS})

# Readline
# find_package (Readline)
add_library(readline STATIC IMPORTED)
set_property(TARGET readline PROPERTY IMPORTED_LOCATION /usr/local/lib/libreadline.a)
include_directories(${CMAKE_CURRENT_BINARY_DIR})
ADD_EXECUTABLE (fileman ${fileman_SRCS})
target_link_libraries(fileman readline)
target_link_libraries(fileman -ltermcap)

# TUX
SET(CMAKE_C_COMPILER openmpicc)
SET(CMAKE_CXX_COMPILER openmpicxx)
ADD_EXECUTABLE (tux ${tux_SRCS})
target_link_libraries(tux mpi readline -ltermcap)

INCLUDE (CheckIncludeFiles)
CHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)
CHECK_INCLUDE_FILES (sys/file.h HAVE_SYS_FILE_H)
CHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)
CHECK_INCLUDE_FILES (string.h HAVE_STRING_H)
CHECK_INCLUDE_FILES (stdlib.h HAVE_STDLIB_H)
CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/config.h.in ${CMAKE_CURRENT_BINARY_DIR}/config.h)

@



\section{Code}

\subsection{Tux classes}

\begin{Verbatim}[frame=lines,framesep=5mm]
Manager - Dispatches user commands
  show - shows states of data, model, mcmc, and others
  model - sets model parameters
  mcmc - executes MCMC to sample from the posterior
  summarize - summarizes a posterior sample 
  save - saves the current state of data, model, mcmc, and others to a file
  load - loads a state of data, model, mcmc, and others from a file
  help - shows commands and their usages

Mcmc - Command MCMC
  show - shows a state of MCMC
  step - samples a next set of parameter values
  save - saves a current state of MCMC
  load - loads a state of mcmc from MCMC parts of a file
  burn - explores a posterior distribution without saving states of MCMC
  sample - continues to sample parameter values till a next save of a MCMC state
  swap - swaps chains of different temparatures

ChainManager - A controler of Markov chains
  step - proceeds to a next step of the chain
  save - saves a current state of the chain
  load - laods a state of a chain 
  temperature - temperature of the chain
  
Chain - A Markov chain of parameters
  step - proceeds to a next step of the chain
  save - saves a current state of the chain
  load - laods a state of a chain 
  temperature - temperature of the chain
  
Model - Command Model
  show - shows a state of model
  save - saves a current state of model
  load - loads a state of model

System - Computer system configuration
  show - shows info of CPUs, GPUs, memory, compute nodes

Help - Command help
  show - shows help messages by reading messages

Memory - Customized memory management

Probability - Probability distribution
  rv - add a set of random variables
  conditionalRv - add a set of conditional random variables
  d - computes density of the distribution
  r - generates random deviates of the distribution
  logD - computes log of density of the distribution

Likelihood - A probability of data given parameters
Posterior - A probability of parameters given data
Prior - A probability of paramters
Proposal - A probability of a set of parameters given another

ProbabilityRatio - A ratio of probabilities

RandomVariable - Random variables; e.g., data, parameters

Mover - Proposal of a new set of parameters

MoverTxBoundaries - Proposal of transcript boundaries
MoverTxExpression - Proposal of transcript expression

Data - A random variable that does not change

Reads - A data of short reads mapped on a genome

Parameter - A random variable that can vary

Temperature - A parameter of chain IDs 
TxBoundaries - A parameter of transcript boundaries
TxExpression - A parameter of transcript expression levels

Summarizer - Command summarize of chains of posterior samples
  show - shows a state of summarization
  do - computes summary of posterior samples
  save - saves a current state of the summary
  load - loads a state of a summary

Summary - Summary of chains of posterior samples for a parameter
  mean - computes mean values
  variance - computes variance to quantify uncertainty
  autocorrelation - computes autocorrelation
  save - saves a current state of the summary
  load - loads a state of a summary
\end{Verbatim}

\subsection{Copyright}
<<tux gnu copyright>>=
// This file is a part of tux.
//
// tux is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// tux is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with tux. If not, see <http://www.gnu.org/licenses/>.
@

\subsection{Main}

<<tux.cpp>>=
<<tux gnu copyright>>
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif 
#include <iostream>
#include <algorithm>
#include <vector>
#include <mpi.h>
#include <gsl/gsl_rng.h>
#include "simpleopt/SimpleOpt.h"
#include "simpleopt/SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "rlstdc.h"
#include "xmalloc.h"
#include <readline/readline.h>
#include <readline/history.h>
#include "tuxHelp.h"
#include "tuxManager.h"
#include "tuxXyz.h"

using namespace std;
using namespace tux;
gsl_rng* gGslRng;
<<tux interative>>
<<command line>>

namespace tux {
  struct c_gslrng {
    unsigned long int operator()() {
      return gsl_ran_get (gGslRng);
    }
  } gslrngRandomNumber;
}

int 
main (int argc, char* argv[])
{
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);
  EZLOGGERFUNCTRACKER;

  const gsl_rng_type* T;
  gsl_rng_evn_setup();
  T = gsl_rng_default;
  gGslRng = gsl_rng_alloc(T);

  // Interactive Mode
  if (argc == 1)
    {
      char *line, *s;

      progname = argv[0];

      initialize_readline ();/* Bind our completer. */

      /* Loop reading and executing lines until the user quits. */
      for ( ; done == 0; )
        {
          line = readline ("> ");

          if (!line)
            break;

          /* Remove leading and trailing whitespace from the line.
             Then, if there is anything left, add it to the history list
             and execute it. */
          s = stripwhite (line);

          if (*s)
            {
              add_history (s);
              execute_line (s);
            }

          free (line);
        }
      return 0;
    }

  // Batch Mode
  int sCommand;
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_HELP) 
            {
              Help::full ();
              return 0;
            }
          else if (args.OptionId() == OPT_VERSION) 
            {
              Help::version ();
            }
          else if (args.OptionId() == OPT_MODEL
                   || args.OptionId() == OPT_MCMC
                   || args.OptionId() == OPT_SUMMARIZE) 
            {
              sCommand = args.OptionId();
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }
  Manager m;
  m.mNumberProcess = 2;
  m.mSeed = 100;
  switch (sCommand)
    {
    case OPT_MODEL:
      cout << "Modelling ..." << endl;
      break;
    case OPT_MCMC:
      cout << "Start MCMC ..." << endl;
      
      gsl_rng_set(gGslRng,m.mSeed);
      m.mProcessSeed.resize(m.mNumberProcess); 
      generate (m.mProcessSeed.begin(), m.mProcessSeed.begin(), gslrngRandomNumber);

      int size,rank;
      int length;
      char name[80];
      MPI_Status status;
      int workerIdx;

      MPI_Init(&argc, &argv);
      MPI_Comm_rank(MPI_COMM_WORLD,&rank);
      MPI_Comm_size(MPI_COMM_WORLD,&size);
      MPI_Get_processor_name(name,&length);

      if (rank==0) 
        {
          printf("Hello MPI from the server process!\n");

          for (workerIdx=1; workerIdx<size; workerIdx++) 
            {
              MPI_Recv(name, 80, MPI_CHAR, workerIdx, 999, MPI_COMM_WORLD, &status);
              printf("Hello MPI!\n");
              printf(" message from %d of %d on %s\n", workerIdx, size, name);
            }
        } 
      else 
        {
          MPI_Send(name,80,MPI_CHAR,0,999,MPI_COMM_WORLD);
        }

      // Now we are in one of the processes.
      // Reset the gGslRng.
      gsl_rng_set(gGslRng,m.mProcessSeed.at(rank));

      m.mcmc (rank); // MCMC Command

      MPI_Finalize(); 

      break;
    case OPT_SUMMARIZE:
      cout << "Summarizing a posterior sample ..." << endl;
      break;
    }

  gsl_rng_free (gGslRng);
  return 0;
}
@

<<command line>>=
enum { 
    OPT_HELP, 
    OPT_MODEL,
    OPT_MCMC,
    OPT_SUMMARIZE,
    OPT_VERSION,
    OPT_INFILE,
    OPT_OUTFILE,

    OPT_CHAIN,
    OPT_LIKELIHOOD,
    OPT_PRIOR,
    OPT_XML,
    OPT_BUILD,
    OPT_PRINT,
    OPT_WHAT,
    OPT_REMOVE,
    OPT_FOO, 
    OPT_BAR, 
    OPT_HOGE 
};
CSimpleOpt::SOption g_rgOptions[] = {
    // ID TEXT TYPE
    { OPT_HELP, "--help", SO_NONE    },
    { OPT_HELP, "-h", SO_NONE    },
    { OPT_VERSION, "--version", SO_NONE },
    { OPT_INFILE, "-i",     SO_REQ_SEP },
    { OPT_OUTFILE, "-o",     SO_REQ_SEP },

    { OPT_FOO,  "-a",     SO_NONE    }, // "-a"
    { OPT_BAR,  "-b",     SO_NONE    }, // "-b"
    { OPT_HOGE, "-f",     SO_REQ_SEP }, // "-f ARG"
    { OPT_PRINT, "-p",     SO_REQ_SEP },
    { OPT_PRINT, "--print", SO_REQ_SEP },
    { OPT_WHAT, "-w",     SO_REQ_SEP },
    { OPT_WHAT, "--what", SO_REQ_SEP },
    { OPT_INFILE, "--infile",   SO_REQ_SEP },
    { OPT_OUTFILE, "--outfile",   SO_REQ_SEP },

    // Commands
    { OPT_MCMC, "mcmc", SO_NONE },
    { OPT_MODEL, "model", SO_NONE },
    { OPT_SUMMARIZE, "summarize", SO_NONE },

    { OPT_CHAIN, "chain", SO_NONE },
    { OPT_LIKELIHOOD, "likelihood", SO_NONE },
    { OPT_PRIOR, "prior", SO_NONE },
    { OPT_XML, "xml", SO_NONE },
    { OPT_BUILD, "build", SO_NONE },
    { OPT_REMOVE, "--remove", SO_REQ_SEP },
    SO_END_OF_OPTIONS // END
};
@

<<tux interative>>=
int com_help PARAMS((char *));
int com_model PARAMS((char *));
int com_mcmc PARAMS((char *));
int com_save PARAMS((char *));
int com_load PARAMS((char *));
int com_quit PARAMS((char *));

typedef struct {
  char *name;/* User printable name of the function. */
  rl_icpfunc_t *func;/* Function to call to do the job. */
  char *doc;/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "model", com_model, "Model" },
  { "mcmc", com_mcmc, "MCMC" },
  { "save", com_save, "Saves a current state to a file" },
  { "load", com_load, "Loads a state from a file" },
  { "quit", com_quit, "Quit using Fileman" },
  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite (char *string);
COMMAND* find_command (char *name);
void too_dangerous (char *caller);
void initialize_readline ();
int execute_line (char *line);
int valid_argument (char *caller, char *arg);

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (char *s)
{
  char *r;

  r = (char *) xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

/* Execute a command line. */
int
execute_line (char *line)
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (char *name)
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (char *string)
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator PARAMS((const char *, int));
char **fileman_completion PARAMS((const char *, int, int));

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
void
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END bound the
   region of rl_line_buffer that contains the word to complete.  TEXT is
   the word to complete.  We can use the entire contents of rl_line_buffer
   in case we want to do some simple parsing.  Return the array of matches,
   or NULL if there aren't any. */
char **
fileman_completion (const char *text, int start, int end)
{
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);
  if (end == 0) { /* No code! */ }
    
  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (const char *text, int state)
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  name = commands[list_index].name;
  while (name)
    {
      list_index++;
      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
      name = commands[list_index].name;
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                       FileMan Commands                           */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
int
com_help (char *arg)
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

int
com_model (char *arg)
{
  too_dangerous ("model");
  return (1);
}

int
com_mcmc (char *arg)
{
  too_dangerous ("mcmc");
  return (1);
}

int
com_summarize (char *arg)
{
  too_dangerous ("summarize");
  return (1);
}

int
com_save (char *arg)
{
  too_dangerous ("save");
  return (1);
}

int
com_load (char *arg)
{
  too_dangerous ("load");
  return (1);
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
int
com_quit (char *arg)
{
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
void
too_dangerous (char *caller)
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (char *caller, char *arg)
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}


@

\subsection{Help}
<<tuxHelp.h>>=
<<tux gnu copyright>>
#ifndef _TUXHELP_H_
#define _TUXHELP_H_
namespace tux {
class Help {
public:
  static void full ();
  static void version ();
};
}
#endif // _TUXHELP_H_

<<tuxHelp.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxHelp.h"
using namespace std;
namespace tux {
void 
Help::full ()
{
  cout << ""
"tux Commands Manual\n"
"\n"
"NAME\n"
"   tux -- Transcripts boundaries uncertainty\n"
"\n"
"SYNOPSIS\n"
"   tux [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The program implements a statistical method of inferring uncertainty\n"
"   of transcript boundaries using RNA-seq data.\n"  
"   The method is described in Choi (2012).\n"
"\n"
"   General options:\n"
"      -h --help -?\n"
"         Shows this help message.\n"
"      --version\n"
"         Shows the version.\n"
"      -i --infile [INFILE]\n"
"         Reads in an input file.\n"
"      --type\n"
"         Input and output files are in XML format.\n" 
"\n"
"   Commands:\n"
"      mcmc\n"
"         Samples recombinant trees.\n"
"      summarize\n"
"         Summarizes a posterior sample of recombinant trees.\n"
"      likelihood\n"
"         Computes the likelihod of a recombinant tree given data.\n"
"      prior\n"
"         Computes the prior of a recombinant tree given model parameters.\n"
"      xml\n"
"         Reads and writes XML files.\n"
"      build\n"
"         Reads an XML file to build a recombinant tree.\n"
"      chain\n"
"         Uses chains.\n"
"\n"
"   Command build options:\n"
"      -w --what [NUMBER]\n"
"         1 Build a recombiant tree by reading the XML file that is\n"
"           created by xml --print 5 -o tuxrectree.xml\n"
"         2 Build a list of events by reading the XML file that is\n"
"           created by xml --print 6 -o tuxevent.xml\n"
"      --remove [NUMBER]\n"
"         Remove a recombinant edge.\n"
"\n"
"   Command xml options:\n"
"      -p --print [NUMBER]\n"
"         1 Default setting\n"
"         2 fastsimcoal file\n"
"         3 tux input file\n"
"         4 tux output file\n"
"         5 tux recombinant tree file\n"
"         6 tux event file\n"
"         7 tux chain state file\n"
"\n"
"   Files:\n"
"      INFILE\n"
"         Different commands can be combined with different formats of input\n"
"         files. An input file with command xml is an XML file.\n" 
"      OUTFILE\n"
"\n"
"   Usages:\n"
"      tux xml --infile INFILE\n"
"         Reads in an XML file, and prints it out to standard output.\n"
"      tux xml --print 1 -o default.xml\n" 
"         Prints the tux default setting.\n"
"      tux likelihood -i tuxoutput.xml\n"
"         Computes the likelihood of data given a recombinant tree.\n"
"      tux xml --print 5 -o tuxrectree.xml\n"
"         Creates a recombinant tree in XML format\n"
"      tux build -w 1 --infile tuxrectree.xml\n"
"         Build a recombinant tree using an XML file.\n"
"      tux build -w 1 --remove 1 --infile tuxrectree.xml\n"
"         Build a recombinant tree using an XML file, and remove the edge.\n"
"      tux build -w 1 --remove 1 --infile tuxrectree.xml -o partialtree.xml\n"
"         Build a recombinant tree using an XML file, and remove the edge.\n"
"      tux xml --print 6 -o tuxevent.xml\n"
"         Creates a list of events in XML format\n"
"      tux build -w 2 --infile tuxevent.xml\n"
"         Build a list of events using an XML file.\n"
"      tux xml --print 7\n"
"         Build a list of events using an XML file.\n"
"      tux xml --print 3 -o tuxinput.xml\n" 
"         Prints the tux input file.\n"
"      tux chain --infile tuxinput.xml\n"
"         Test a chain.\n"
"\n"
"AUTHOR\n"
"   Written by Sang Chul Choi\n"
"\n"
"REPORTING BUGS\n"
"   Report bugs to google group of Transcript Boundaries Uncertainty\n"
"   at http://groups.google.com/group/transcript-boundaries-uncertainty\n"
"\n"
"VERSION\n"
"   tux 1.0 - Build IMRBUILDDATETIME\n"
"\n"
"COPYRIGHT\n"
"   Copyright (C) 2012- Sang Chul Choi\n"
"   See the source for copying conditions.\n"
"   There is NO warranty; not even for MERCHANTABILITY\n"
"\n"
"tux 1.0\n"
"";
}
void 
Help::version ()
{
  cout << ""
"tux 1.0 - Build IMRBUILDDATETIME\n"
"Written by Sang Chul Choi.\n"
"\n"
"Copyright (c) 2012- Sang Chul Choi\n"
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
"";
}
}
@

\subsection{YAML: data serialization}
<<monsters.cpp>>=
#include "yaml-cpp/yaml.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

// our data types
struct Vec3 {
   float x, y, z;
};

struct Power {
   std::string name;
   int damage;
};

struct Monster {
   std::string name;
   Vec3 position;
   std::vector <Power> powers;
};

// now the extraction operators for these types
void operator >> (const YAML::Node& node, Vec3& v) {
   node[0] >> v.x;
   node[1] >> v.y;
   node[2] >> v.z;
}

void operator >> (const YAML::Node& node, Power& power) {
   node["name"] >> power.name;
   node["damage"] >> power.damage;
}

void operator >> (const YAML::Node& node, Monster& monster) {
   node["name"] >> monster.name;
   node["position"] >> monster.position;
   const YAML::Node& powers = node["powers"];
   for(unsigned i=0;i<powers.size();i++) {
      Power power;
      powers[i] >> power;
      monster.powers.push_back(power);
   }
}

int main()
{
   std::ifstream fin("monsters.yaml");
   YAML::Parser parser(fin);
   YAML::Node doc;
   parser.GetNextDocument(doc);
   for(unsigned i=0;i<doc.size();i++) {
      Monster monster;
      doc[i] >> monster;
      std::cout << monster.name << "\n";
   }

   return 0;
}
@

\subsection{YAML: Emitter}
<<yamlEmitter.cpp>>=
#include "yaml-cpp/yaml.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
int main()
{
  YAML::Emitter out;
  out.SetIndent(2); 

  out << "Hello, World!";

  out << YAML::BeginSeq;
  out << "eggs";
  out << "bread";
  out << "milk";
  out << YAML::EndSeq;

  out << YAML::BeginMap;
  out << YAML::Key << "name";
  out << YAML::Value << "Ryan Braun";
  out << YAML::Key << "position";
  out << YAML::Value << "LF";
  out << YAML::EndMap;

  out << YAML::BeginMap;
  out << YAML::Key << "name";
  out << YAML::Value << "Barack Obama";
  out << YAML::Key << "children";
  out << YAML::Value << YAML::BeginSeq << "Sasha" << "Malia" << YAML::EndSeq;
  out << YAML::EndMap;

  out << YAML::Literal << "A\n B\n  C";

  out << YAML::Flow;
  out << YAML::BeginSeq << 2 << 3 << 5 << 7 << 11 << YAML::EndSeq;

  out << YAML::BeginMap;
  out << YAML::Key << "method";
  out << YAML::Value << "least squares";
  out << YAML::Comment("should we change this method?");
  out << YAML::EndMap;

  out << YAML::BeginSeq;
  out << YAML::Anchor("fred");
  out << YAML::BeginMap;
  out << YAML::Key << "name" << YAML::Value << "Fred";
  out << YAML::Key << "age" << YAML::Value << "42";
  out << YAML::EndMap;
  out << YAML::Alias("fred");
  out << YAML::EndSeq;
   
  std::vector <int> squares;
  squares.push_back(1);
  squares.push_back(4);
  squares.push_back(9);
  squares.push_back(16);

  std::map <std::string, int> ages;
  ages["Daniel"] = 26;
  ages["Jesse"] = 24;

  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << ages;
  out << YAML::EndSeq;


//. Genome sequence length: 2032925
//. Short reads positions along the S. mutans genome: FASTQ001.start (1,19,20)
//. Size factors: 0.8700484 1.0158870 1.1285131
//. Number of transcripts: 
//. mean=q*s, size=q*s/d, d=a0+a1/mean
//. a0, a1 = 0.0269 6.2076
//. q is a parameter
//. mean is computed for each transcript
  out << YAML::BeginMap;
  out << YAML::Key << "GenomeLength" << YAML::Value << 2032925;
  out << YAML::Key << "SizeFactor" << YAML::Value << YAML::Flow; 
  out << YAML::BeginSeq << 0.8700484 << 1.0158870 << 1.1285131 << YAML::EndSeq;
  out << YAML::Key << "Alpha0" << YAML::Value << 0.0269;
  out << YAML::Key << "Alpha1" << YAML::Value << 6.2076;
  out << YAML::Key << "NumberK" << YAML::Value << 500;
  out << YAML::Key << "ShortReads" << YAML::Value << YAML::Flow;
  out << YAML::BeginSeq;
  // Read values from FASTQ001.start and write them to YAML.
  std::ifstream myfile ("../../../downloads/FASTQ001.start");
  if (myfile.is_open())
  {
    double value;
    while ( myfile.good() )
    {
      myfile >> value;
      out << value;
    }
    myfile.close();
  }
  // out << 0.8700484 << 1.0158870 << 1.1285131;
  out << YAML::EndSeq;
  out << YAML::EndMap;

  out << YAML::BeginSeq;
  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << YAML::Flow << squares;
  out << YAML::EndSeq;
  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << YAML::Flow << squares;
  out << YAML::EndSeq;
  out << YAML::EndSeq;

  std::cout << "Here's the output YAML:\n" << out.c_str() << std::endl;

  return 0;
}
@

\subsection{GNU Scientific Library}

Use the following environment variables.
\begin{Verbatim}[frame=lines,framesep=5mm]
GSL_RNG_TYPE="taus" GSL_RNG_SEED=123
\end{Verbatim}

<<gsl.cpp>>=
#include <stdio.h>
#include <gsl/gsl_sf_bessel.h>
     
int main (void)
{
  double x = 5.0;
  double y = gsl_sf_bessel_J0 (x);
  printf ("J0(%g) = %.18e\n", x, y);
  return 0;
}
@

<<tuxGslRng.h>>=
<<tux gnu copyright>>
#ifndef _TUXGSLRNG_H_
#define _TUXGSLRNG_H_
namespace tux {
void fGslRngAlloc ();
void fGslRngFree ();
}
#endif /* _TUXGSLRNG_H_ */
@

<<tuxGslRng.cpp>>=
<<tux gnu copyright>>
#include <gsl/gsl_rng.h>
namespace tux {
gsl_rng* gGslRng;
void fGslRngAlloc () 
{
  const gsl_rng_type* T;
  gsl_rng_env_setup();
  T = gsl_rng_default;
  gGslRng = gsl_rng_alloc(T);
}
void fGslRngFree ()
{
  gsl_rng_free (gGslRng);
}
}
@

<<extern tuxGslRng>>=
extern gsl_rng* tux::gGslRng;
@


\subsection{EzLogger Library}
<<ezlogger.cpp>>=
// Example code for EZLOGGER macros
#include "ezlogger_headers.hpp"

void some_funcxx()
{
        EZLOGGERFUNCTRACKER;
}

void some_funcx()
{
        EZLOGGERFUNCTRACKER;
        some_funcxx();
}

void some_func6()
{
        EZLOGGERFUNCTRACKER;
        EZLOGGERDISPLAY_STACK;
}

void some_func5(int &x)
{
        EZLOGGERFUNCTRACKER;
        --x;
        if (x > 0)
                some_func5(x); //test recursion
        else
                some_func6();
}

void some_func4()
{
        EZLOGGERFUNCTRACKER;
        int x = 3;
        some_func5(x);
}

void some_func3()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_funcxx();
        some_func4();
}

void some_func2()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_funcxx();
        some_func3();
        some_funcxx();
}

void some_func1()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_func2();
        some_funcxx();
}

int main(int argc, char**argv)
{
        axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);
        EZLOGGERFUNCTRACKER;
        int ReturnValue = 99;
        EZLOGGER_PRG_MAIN_ARG(argc, argv);
        EZDBGONLYLOGGER_PRG_MAIN_ARG(argc, argv);
        EZLOGGERVL_PRG_MAIN_ARG(axter::log_often, argc, argv);
        int i = 123;
        std::string somedata = "Hello World";
        EZLOGGER(i);
        EZDBGONLYLOGGER(i);
        EZLOGGERVL(axter::log_often)(i);

        EZLOGGERVAR(somedata);
        EZDBGONLYLOGGERVAR(somedata);
        EZLOGGERVLVAR(axter::log_often, somedata);
        
        bool SomeConditionVar = true;
        EZLOGGERVAR(SomeConditionVar == false);
        EZDBGONLYLOGGERVAR(SomeConditionVar == false);
        EZLOGGERVLVAR(axter::log_often, SomeConditionVar == true);

        EZLOGGERVLVARIFY(axter::log_often, SomeConditionVar == false);

        EZLOGGERSTREAM << somedata << " " << i << std::endl;
        EZLOGGERSTREAM << somedata << " next line " << i << std::endl;
        EZLOGGERSTREAM2(std::cerr) << somedata << " next line " << i << std::endl;
        EZDBGONLYLOGGERSTREAM << somedata << " " << i << std::endl;
        EZDBGONLYLOGGERSTREAM << somedata << " next line " << i << std::endl;
        EZLOGGERVLSTREAM(axter::log_often) << somedata << " " << i << std::endl;
        // EZLOGGERVLSTREAM(axter::levels(axter::log_often, axter::warn, __FUNCSIG__ /*or GNU PRETTY_FUNCTION*/,"Xyz Facility")) << somedata << " " << i << std::endl;

        EZLOGGERPRINT("i = %i and somedata = %s", i, somedata.c_str());
        EZDBGONLYLOGGERPRINT("i = %i and somedata = %s", i, somedata.c_str());
        EZLOGGERVLPRINT(axter::log_often)("i = %i and somedata = %s", i, somedata.c_str());
        //Alternative method
        EZLOGGERVL(axter::log_often).cprint("i = %i and somedata = %s", i, somedata.c_str());
        EZLOGGER.cprint("i = %i and somedata = %s", i, somedata.c_str());

        if (1)
        {
                EZLOGGERMARKER;
                EZDBGONLYLOGGERMARKER;
                EZLOGGERVLMARKER(axter::log_often);
        }

        some_func1();

        return EZLOGGERVAR(ReturnValue);
}
@

\subsection{Types}
<<gtypes.h>>=
<<tux gnu copyright>>
#ifndef __G_TYPES_H__
#define __G_TYPES_H__

#include <config.h>

__BEGIN_DECLS

/* Provide type definitions for commonly used types.
 * These are useful because a "gint8" can be adjusted
 * to be 1 byte (8 bits) on all platforms. Similarly and
 * more importantly, "gint32" can be adjusted to be
 * 4 bytes (32 bits) on all platforms.
 */

typedef char   gchar;
typedef short  gshort;
typedef int    gint;
typedef long   glong;
typedef gint   gboolean;

typedef unsigned char   guchar;
typedef unsigned short  gushort;
typedef unsigned int    guint;
typedef unsigned long   gulong;

typedef float   gfloat;
typedef double  gdouble;

typedef signed char gint8;
typedef unsigned char guint8;
typedef signed short gint16;
typedef unsigned short guint16;
typedef signed int gint32;
typedef unsigned int guint32;
typedef signed long gint64;
typedef unsigned long guint64;

/* Define min and max constants for the fixed size numerical types */
#define G_MININT8((gint8)  0x80)
#define G_MAXINT8((gint8)  0x7f)
#define G_MAXUINT8((guint8) 0xff)

#define G_MININT16((gint16)  0x8000)
#define G_MAXINT16((gint16)  0x7fff)
#define G_MAXUINT16((guint16) 0xffff)

#define G_MININT32((gint32)  0x80000000)
#define G_MAXINT32((gint32)  0x7fffffff)
#define G_MAXUINT32((guint32) 0xffffffff)

/* Portable endian checks and conversions
 *
 * glibconfig.h defines G_BYTE_ORDER which expands to one of
 * the below macros.
 */
#define G_LITTLE_ENDIAN 1234
#define G_BIG_ENDIAN    4321
#define G_PDP_ENDIAN    3412/* unused, need specific PDP check */


/* Basic bit swapping functions
 */
#define GUINT16_SWAP_LE_BE_CONSTANT(val)((guint16) ( \
    (guint16) ((guint16) (val) >> 8) |\
    (guint16) ((guint16) (val) << 8)))

#define GUINT32_SWAP_LE_BE_CONSTANT(val)((guint32) ( \
    (((guint32) (val) & (guint32) 0x000000ffU) << 24) | \
    (((guint32) (val) & (guint32) 0x0000ff00U) <<  8) | \
    (((guint32) (val) & (guint32) 0x00ff0000U) >>  8) | \
    (((guint32) (val) & (guint32) 0xff000000U) >> 24)))

__END_DECLS
#endif /* __G_TYPES_H__ */
@

\subsection{Manager}
<<tuxManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXMANAGER_H_
#define _TUXMANAGER_H_
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
namespace tux {
class Manager {
public:
  unsigned int mNumberProcess;
  unsigned long int mSeed;
  vector<unsigned long int> mProcessSeed;
public:
  void show();
  void model();
  void mcmc(int r = 0);
  void summarize();
  void save();
  void load();
  void help();

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return current++;}
  } uniqueNumber;

  struct c_hlinear {
    double halpha;
    unsigned int i;
    c_hlinear () {i=0; halpha=0.5;}
    double operator()() {
      double v = 1.0 / (1.0 + halpha * i);
      i++; 
      return v;
    }
  } hlinearNumber;

  struct c_hgeometric {
    unsigned int numChain;
    double halpha, hbeta;
    unsigned int i;
    c_hgeometric () {i=0; numChain = 10; halpha=0.95; hbeta=0.2;}
    double operator()() {
      double v = 1 
                 - (1 - hbeta) * i 
                 * pow (halpha, (double) (numChain - 1 - i)) 
                 / (double) (numChain - 1);
      i++;
      return v; 
    }
  } hgeometricNumber;

  template <class T> struct c_print {
    void operator() (T i) {std::cout << " " << i;}
  };

};

}
#endif // _TUXMANAGER_H_

<<tuxManager.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <algorithm>
#include <vector>
#include "tuxModel.h"
#include "tuxMcmc.h"
#include "tuxManager.h"
using namespace std;
namespace tux {

void 
Manager::show()
{
  return;
}
void 
Manager::model()
{
  return;
}
void 
Manager::mcmc(int r)
{
  Mcmc m;
  m.lenChain = 5;
  m.lenBurnin = 1;
  m.lenThin = 3;
  m.lenSwap = 2;
  m.lenSwapTry = 1;
  m.mNumberProcess = 2; 
  m.mNumberChain = 5;
  m.numberChainPerProcess ();
  m.createChainManager ((unsigned int)r);

  m.mLikelihoodPrior.resize (m.lenChain);

  m.mChainid.resize(m.lenChain);                                                   
  uniqueNumber.current = 0;                                                     
  generate (m.mChainid.begin(), m.mChainid.end(), uniqueNumber);                  
//  c_print<unsigned int> printInt;                                               
//  for_each (m.chainid.begin(), m.chainid.end(), printInt);                      
//  cout << endl;                                                                 
                                                                                
  m.mTemperature.resize(m.lenChain);                                               
  hlinearNumber.halpha = 0.1;
  generate (m.mTemperature.begin(), m.mTemperature.end(), hlinearNumber);         
//  c_print<double> printDouble ;                                                 
//  for_each (m.temperature.begin(), m.temperature.end(), printDouble);           
//  cout << endl;  

  hgeometricNumber.numChain = m.lenChain;
  hgeometricNumber.halpha = 0.98;
  hgeometricNumber.hbeta = 0.7;
  generate (m.mTemperature.begin(), m.mTemperature.end(), hgeometricNumber);         
//  for_each (m.temperature.begin(), m.temperature.end(), printDouble);           
//  cout << endl;  

  unsigned int s = 0;
  while (s < m.lenChain) 
    {
      unsigned int sThin = 0;
      while (sThin < m.lenThin)
        {
          s += m.lenSwap; 
          sThin++;
          m.step (m.lenSwap);
          m.swap ();
        }
      if (m.lenBurnin < s)
        {
          m.sample ();
        }
    }
  
  return;
}
void 
Manager::summarize()
{
  return;
}
void 
Manager::save()
{
  return;
}
void 
Manager::load()
{
  return;
}
void 
Manager::help()
{
  return;
}
}
@

\subsection{Model}
<<tuxModel.h>>=
<<tux gnu copyright>>
#ifndef _TUXMODEL_H_
#define _TUXMODEL_H_
namespace tux {
class Model {
public:
  void full ();
};
}
#endif // _TUXMODEL_H_

<<tuxModel.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxModel.h"
using namespace std;
namespace tux {
void 
Model::full ()
{
  return;
}
}
@

\subsection{Mcmc}
<<tuxMcmc.h>>=
<<tux gnu copyright>>
#ifndef _TUXMCMC_H_
#define _TUXMCMC_H_
#include <vector>
#include "tuxChainManager.h"
using namespace std;
namespace tux {
class Mcmc {
public:
  unsigned int mRank; 
  vector<double> mTemperature;
  vector<unsigned int> mChainid;
  vector<double> mLikelihoodPrior;
  vector<unsigned int> mNumberChainPerProcess;
  vector<unsigned int> mAccumulateNumberChain;
  unsigned int mNumberProcess; 
  unsigned int mNumberChain;

  unsigned int lenChain;
  unsigned int lenBurnin;
  unsigned int lenThin;
  unsigned int lenSwap;
  unsigned int lenSwapTry;

  ChainManager mChainManager;

  struct c_setNumberChainPerProcess {
    unsigned int current;
    unsigned int numberChainPerProcess;
    unsigned int numberRemainingChain;
    c_setNumberChainPerProcess () {current=0;}
    unsigned int operator() () { 
      if (current++ < numberRemainingChain)
        return numberChainPerProcess + 1;
      else
        return numberChainPerProcess;
    }
  } setNumberChainPerProcess;

  template <class T> struct c_print {
    void operator() (T i) {std::cout << " " << i;}
  };

  struct c_msg1 {
    unsigned int processid;
    unsigned int chainid;
    double likelihoodPrior;
    void set (unsigned int x, unsigned int y, double z) {
      processid = x; chainid = y; likelihoodPrior = z;
    }
  } mMessage;

private:
  double swapWeight (unsigned int ci, unsigned int cj);
  int swapChains ();
public:
  Mcmc ();
  ~Mcmc ();
  int numberChainPerProcess ();
  int createChainManager (unsigned int r);
  int step (unsigned int n);
  int swap ();
  int sample ();
  int save ();
  int load ();
};
}
#endif // _TUXMCMC_H_

<<tuxMcmc.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <sstream>
#include <vector>
#include <numeric>
#include <functional>
#include <algorithm>
#include <mpi.h>
#include <cassert>
#include "ezlogger_headers.hpp"
#include "tuxMcmc.h"
#include "tuxChainManager.h"
using namespace std;
namespace tux {
Mcmc::Mcmc () {}
Mcmc::~Mcmc () {}
int 
Mcmc::numberChainPerProcess ()
{
  setNumberChainPerProcess.current = 0;
  setNumberChainPerProcess.numberChainPerProcess 
    = mNumberChain / mNumberProcess; 
  setNumberChainPerProcess.numberRemainingChain
    = mNumberChain % mNumberProcess;

  mNumberChainPerProcess.resize (mNumberProcess); 
  generate (mNumberChainPerProcess.begin(), 
            mNumberChainPerProcess.end(), 
            setNumberChainPerProcess);

  // Construct a vector of partial sum.
  vector<unsigned int>::iterator iter1;
  mAccumulateNumberChain.clear();
  mAccumulateNumberChain.push_back(0);
  unsigned int j = 0;
  for (iter1 = mNumberChainPerProcess.begin();
       iter1 != mNumberChainPerProcess.end();
       iter1++)
    {
      mAccumulateNumberChain.push_back(
        accumulate(mNumberChainPerProcess.begin(),iter1+1,0)
        );
      j++;
    }
  
//  c_print<unsigned int> printInt;                                               
//  for_each (mNumberChainPerProcess.begin(), 
//            mNumberChainPerProcess.end(), 
//            printInt);                      
//  cout << endl;                                                                 

  return 0;
}
int 
Mcmc::createChainManager (unsigned int r)
{
  mRank = r; 

  // Create chains for a chain manager.
  unsigned int n = mNumberChainPerProcess.at(r);
  mChainManager.createChain (n);
  // Set chain ID by using a vector of partial sum.
  mChainManager.setChainid (mAccumulateNumberChain[r],
                            mAccumulateNumberChain[r+1]-1);

  return 0;
}
int
Mcmc::step (unsigned int n)
{
  mChainManager.step (n);
  return 0;
}
int
Mcmc::swap ()
{
  EZLOGGERFUNCTRACKER;
  MPI_Status status;

  // Get chain IDs and likelihood prior sum values.
  vector<unsigned int> v1;
  mChainManager.chainid (v1);
  vector<double> v2;
  mChainManager.likelihoodPrior (v2);

  if (mRank==0) 
    {
      // Receive messages to fill chain IDs and sums of likelihood and prior.
      for (unsigned int workerIdx = 0; workerIdx < mNumberProcess; workerIdx++) 
        {
          for (unsigned int i = mAccumulateNumberChain[workerIdx], j = 0;
               i < mAccumulateNumberChain[workerIdx+1];
               i++, j++)
            {
              if (mRank == workerIdx)
                {
                  mMessage.set (i, v1.at(j), v2.at(j)); 
                }
              else
                {
                  MPI_Recv(&mMessage, sizeof(struct c_msg1), MPI_BYTE, workerIdx, 999, MPI_COMM_WORLD, &status);
                }
              mChainid.at(mMessage.processid) = mMessage.chainid;
              mLikelihoodPrior.at(mMessage.processid) = mMessage.likelihoodPrior;
            }
        }
     
      stringstream result;
      copy(mChainid.begin(), mChainid.end(), 
           ostream_iterator<unsigned int>(result, " "));
      EZLOGGERPRINT("Before Rank 0 chain IDs: %s",result.str().c_str());  

      // Swap chains.
      swapChains ();

      copy(mChainid.begin(), mChainid.end(), 
           ostream_iterator<unsigned int>(result, " "));
      EZLOGGERPRINT("After Rank 0 chain IDs: %s",result.str().c_str());  
      
      // Send messages
      v1.clear();
      v1.resize(mNumberChainPerProcess.at(mRank));
      for (unsigned int workerIdx = 0; workerIdx < mNumberProcess; workerIdx++) 
        {
          for (unsigned int i = mAccumulateNumberChain[workerIdx], j = 0;
               i < mAccumulateNumberChain[workerIdx+1];
               i++, j++)
            {
              unsigned int pid = mAccumulateNumberChain[workerIdx] + j;
              mMessage.set (pid, mChainid.at(pid), 0); 
              if (mRank == workerIdx)
                {
                  v1.at(mMessage.processid - mAccumulateNumberChain.at(mRank))
                    = mMessage.chainid;
                }
              else
                {
                  MPI_Send(&mMessage, sizeof(struct c_msg1), MPI_BYTE, workerIdx, 999, MPI_COMM_WORLD);
                }
            }
        }
      mChainManager.setChainid (v1);

      // Check if the message passing.
      mChainid.assign (lenChain,9);
      copy(mChainid.begin(), mChainid.end(), 
           ostream_iterator<unsigned int>(result, " "));
      EZLOGGERPRINT("After reset 0 chain IDs: %s",result.str().c_str());  
    }
  else 
    {
      // Send messages to rank 0 process
      for (unsigned int i = mAccumulateNumberChain[mRank], j = 0;
           i < mAccumulateNumberChain[mRank+1];
           i++, j++)
        {
          mMessage.set (i, v1.at(j), v2.at(j)); 
          MPI_Send(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 0, 999, MPI_COMM_WORLD);
        }

      // Wait for the decision of the rank 0 process.
      v1.clear();
      v1.resize(mNumberChainPerProcess.at(mRank));
      for (unsigned int i = mAccumulateNumberChain[mRank], j = 0;
           i < mAccumulateNumberChain[mRank+1];
           i++, j++)
        {
          MPI_Recv(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 0, 999, MPI_COMM_WORLD, &status);
          assert(mMessage.processid - mAccumulateNumberChain.at(mRank) < v1.size());
          v1.at(mMessage.processid - mAccumulateNumberChain.at(mRank))
            = mMessage.chainid;
        }
      mChainManager.setChainid (v1);
    }

  return 0;
}
int
Mcmc::sample ()
{
  return 0;
}
int
Mcmc::save ()
{
  return 0;
}
int
Mcmc::load ()
{
  return 0;
}

double
Mcmc::swapWeight (unsigned int ci, unsigned int cj)
{
  // Note that sumj is the sum of likelihood and prior.
  double sumi; 
  double sumj;
  sumi = mLikelihoodPrior.at(ci);
  sumj = mLikelihoodPrior.at(cj);
  unsigned int bi = mChainid.at(ci);
  unsigned int bj = mChainid.at(cj);
  return (mTemperature[bi] - mTemperature[bj]) * (sumj - sumi);
}

int
Mcmc::swapChains ()
{
#define  MINSWAP  0.1
#define  BETADJUST  1.414
#define  INCADJUST  1.414
#define  MINHEAT  0.0001
#define  MAXHEAT  0.2
#define  MAXINC  100
#define  MININC  0.1
#define  PAUSESWAP 1000
#define  SWAPDIST 7
  for (unsigned i = 0; i < lenSwapTry; i++)
    {
      unsigned int ci, cj;
      ci = 1;
      cj = 4;
    
//    do
//    {
//      ci = (int) (uniform () * numchains);
//    } while (ci < 0 || ci >= numchains);
//    
//    if (numchains < 2*SWAPDIST + 3)
//    {
//      cjmin = 0;
//      cjrange = numchains;
//    }
//    else
//    {
//      cjmin = IMAX(0,ci-SWAPDIST);
//      cjrange = IMIN(numchains, ci+SWAPDIST) -cjmin;
//    }
//    do
//    {
//      cj = cjmin + (int) (uniform () * cjrange);
//    } while (cj == ci || cj < 0 || cj >= numchains);
//
//    if ((ci == 0 && cj == 1) || (ci == 1 && cj == 0))
//      sw01d++;
//    if ((ci == 1 && cj == 2) || (ci == 2 && cj == 1))
//      sw12d++;
//    if (ci < cj)
//    {
//      swapcount[cj][ci]++;
//    }
//    else
//    {
//      swapcount[ci][cj]++;
//    }

      double metropolishastingsterm = swapWeight (ci, cj);
      metropolishastingsterm = 1;
      if (metropolishastingsterm >= 0)
          //|| metropolishastingsterm > uniform ())
        {
          unsigned int t = mChainid.at(ci);
          mChainid.at(ci) = mChainid.at(cj); 
          mChainid.at(cj) = t;
        }
//    {
//
//      swapptr = C[ci];
//      C[ci] = C[cj];
//      C[cj] = swapptr;
//      if (ci < cj)
//
//      {
//        swapcount[ci][cj]++;
//      }
//      else
//      {
//        swapcount[cj][ci]++;
//      }
//      if ((ci == 0 && cj == 1) || (ci == 1 && cj == 0))
//        sw01++;
//      if ((ci == 1 && cj == 2) || (ci == 2 && cj == 1))
//        sw12++;
//      if (ci == 0 || cj == 0)
//        swap0ok |= 1;
//    }
  }
  return 0;
}
}
@

\subsection{ChainManager}
<<tuxChainManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXCHAINMANAGER_H_
#define _TUXCHAINMANAGER_H_
#include <vector>
#include "tuxChain.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class Chain;
class ChainManager {
public:
  Fixed* mTxFixed;
  vector<Reads*> mTxReads;
  vector<Chain*> mChain;
public:
  ChainManager (const char * filename);
  ChainManager ();
  void createChain (unsigned int);
  ~ChainManager ();
  void step (unsigned int);
  void sample ();
  void setChainid (unsigned int, unsigned int);
  void setChainid (vector<unsigned int>& v);
  void chainid (vector<unsigned int>&);
  void likelihoodPrior (vector<double>&);

  struct c_unique {
    Chain* operator() () {return new Chain;}
  } uniqueChain;

  struct c_step {
    unsigned int n;
    void operator() (Chain *i) { i->step (n);}
  } stepChain;
};
}
#endif // _TUXCHAINMANAGER_H_

<<tuxChainManager.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <sstream>
#include <fstream>
#include <algorithm>     // for_each
#include <vector>
#include <cassert>
#include <functional>    // bind2nd, mem_fun
#include <iomanip>
// #include "ezlogger_headers.hpp"
#include "yaml-cpp/yaml.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
using namespace std;
namespace tux {

template <typename T>
void delete_pointed_to (T* p)
{
  delete p;
}
ChainManager::ChainManager (const char * filename)
{
  std::ifstream fin(filename);
  YAML::Parser parser(fin);
  YAML::Node doc;
  mTxFixed = new Fixed;
  parser.GetNextDocument(doc); doc["Fixed"] >> *mTxFixed;
  parser.GetNextDocument(doc);
  const YAML::Node& node = doc["Reads"];
  vector<Reads*> shortRead;
  Reads* r;
  for (unsigned int i = 0; i < node.size(); i++)
    {
      r = new Reads(i);
      doc["Reads"] >> *r;
      mTxReads.push_back(r);
    }
  fin.close();
}
ChainManager::ChainManager ()
{
}
void 
ChainManager::createChain (unsigned int n)
{
  mChain.resize (n);
  generate(mChain.begin(),mChain.end(), uniqueChain);
  for_each(mChain.begin(),mChain.end(),
           bind2nd(mem_fun(&Chain::TxFixed),mTxFixed));
//  for_each(mChain.begin(),mChain.end(),
//           bind2nd(mem_fun(&Chain::TxReads),mTxReads));
  for (vector<Chain*>::iterator i = mChain.begin(); i != mChain.end(); i++)
    (*i)->TxReads (mTxReads);
  for_each(mChain.begin(),mChain.end(),
           mem_fun(&Chain::createParameter));
}
ChainManager::~ChainManager ()
{
  delete mTxFixed;
  for_each(mChain.begin(),mChain.end(),delete_pointed_to<Chain>);
  for_each(mTxReads.begin(),mTxReads.end(),delete_pointed_to<Reads>);
}
void 
ChainManager::step (unsigned int n)
{
  // Send step messages to all of the managed chains. 
  stepChain.n = n;
//  for_each (mChain.begin(), mChain.end(), setStepChain);
  for_each (mChain.begin(), mChain.end(), stepChain);
  return;
}
void 
ChainManager::setChainid (unsigned int s, unsigned int e)
{
  assert (e - s + 1 == mChain.size());
  vector<Chain*>::iterator iter1;
  unsigned int i = 0;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      (*iter1)->chainid = s + i;
      i++;
    }
}
void 
ChainManager::setChainid (vector<unsigned int>& v)
{
  assert (v.size() == mChain.size());
  vector<Chain*>::iterator iter1;
  vector<unsigned int>::iterator iter2;
  for (iter1 = mChain.begin(), iter2 = v.begin();
       iter1 != mChain.end();
       iter1++, iter2++)
    {
      (*iter1)->chainid = *iter2;
    }
}
void 
ChainManager::chainid (vector<unsigned int>& v)
{
  vector<Chain*>::iterator iter1;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      v.push_back((*iter1)->chainid);
    }
}
void 
ChainManager::likelihoodPrior (vector<double>& v)
{
  vector<Chain*>::iterator iter1;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      v.push_back((*iter1)->likelihoodPrior);
    }
}
void 
ChainManager::sample ()
{
  // Write each of the Chains to a separate file.
  fstream f;
  for (vector<Chain*>::iterator i = mChain.begin();
       i != mChain.end();
       i++)
    {
      string fn(mTxFixed->mOutfile);
      fn += ".";
      // See http://www.cplusplus.com/articles/D9j2Nwbp
      string sChainid = 
        static_cast<ostringstream*>(&(ostringstream() << (*i)->chainid))->str();
      fn += sChainid;
      fn += ".p";
      f.open(fn.c_str(), fstream::out | fstream::app);
      f << std::scientific << std::fixed;
      f << std::setprecision(std::numeric_limits<double>::digits);
      f << **i;
      f.close();
    }
}
}
@

\subsection{Chain}
<<tuxChain.h>>=
<<tux gnu copyright>>
#ifndef _TUXCHAIN_H_
#define _TUXCHAIN_H_
#include <vector>
#include <string>
#include "tuxMoverManager.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class TxBoundaries;
class TxExpression;
class Chain {
public:
  unsigned int chainid;

  double likelihoodPrior;
  double mBeta;
  unsigned int mStep;
  vector<Reads*> mTxReads;
  Fixed* mTxFixed;
  MoverManager mMoverManager;
public:
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
public:
  Chain ();
  Chain (Fixed* m, const vector<Reads*>& shortRead, const double beta = 1.L);
  ~Chain ();
  void createParameter ();
  void TxFixed (Fixed* m) {mTxFixed=m;}
  void TxReads (const vector<Reads*>& shortRead) {mTxReads=shortRead;}
  void step (unsigned int n = 0);
  void sample ();
  friend ostream& operator<< (ostream &out, const Chain &t);
};
}
#endif // _TUXCHAIN_H_

<<tuxChain.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <cassert>
#include <vector>
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxMoverManager.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxProbTxBoundaries.h" 
#include "tuxProbTxExpression.h" 
#include "tuxChain.h"

using namespace std;
namespace tux {
Chain::Chain ()
{
}
Chain::Chain (Fixed* m, const vector<Reads*>& shortRead, const double beta)
{
  //likelihoodPrior = 0;
  mTxReads = shortRead;
  mTxFixed = m;
  mBeta = beta;
  createParameter ();
}
Chain::~Chain ()
{
  delete mTxBoundaries;
  delete mTxExpression;
}
void 
Chain::createParameter ()
{
  mStep = 0;
  mBeta = 0;

  Reads* r = mTxReads.front();
  ProbTxBoundaries factoryTxBoundaries (r->size(),mTxFixed->K());
  mTxBoundaries = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  ProbTxExpression factoryTxExpression (mTxFixed->K());
  mTxExpression = static_cast<TxExpression*>(factoryTxExpression.r());

  // Boundaries Mover
  MoverTxBoundaries* d1 = new MoverTxBoundaries;
  d1->mTxBoundaries = mTxBoundaries;
  d1->mTxExpression = mTxExpression;
  d1->mFixed = mTxFixed;
  d1->mReads = mTxReads;
  mMoverManager.add (d1, 1, 1);
  // Expression Mover
  MoverTxExpression* d2 = new MoverTxExpression;
  d2->mTxBoundaries = mTxBoundaries;
  d2->mTxExpression = mTxExpression;
  d2->mFixed = mTxFixed;
  d2->mReads = mTxReads;
  mMoverManager.add (d2, 2, 1);
}
void 
Chain::step (unsigned int n)
{
  assert (n > 0);
  //cout << chainid << ":";
  for (unsigned int i = 0; i < n; i++, mStep++)
    {
      //cout << " " << mStep;
      Mover* m = mMoverManager.choose ();
      m->step ();
    }
  cout << endl;
  return;
}
void 
Chain::sample ()
{
  // Append the chain state to a file.
  // scalar values - beta, likelihood
  // boundaries
  // expression
  //mSample << mTxBoundaries;
  //mSample << mTxExpression;
  //mSample << mLikelihood;
  //mSample.write ();

  //friend Sample& operator<< (Sample &out, const Fixed &t);
}
ostream& 
operator<< (ostream &out, const Chain &t)
{
  out << "-" << endl
      << *(t.mTxBoundaries)
      << *(t.mTxExpression);
  return out;
}
}
@

\subsection{RandomVariable}
<<tuxRandomVariable.h>>=
<<tux gnu copyright>>
#ifndef _TUXRANDOMVARIABLE_H_
#define _TUXRANDOMVARIABLE_H_
namespace tux {
class RandomVariable {
public:
};
}
#endif // _TUXRANDOMVARIABLE_H_

<<tuxRandomVariable.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxRandomVariable.h"
using namespace std;
namespace tux {
}
@

\subsection{Parameter}
<<tuxParameter.h>>=
<<tux gnu copyright>>
#ifndef _TUXPARAMETER_H_
#define _TUXPARAMETER_H_
#include "tuxRandomVariable.h"
namespace tux {
class Parameter: public RandomVariable {
};
}
#endif // _TUXPARAMETER_H_

<<tuxParameter.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxParameter.h"
using namespace std;
namespace tux {
}
@

\subsection{TxBoundaries}
<<tuxTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXBOUNDARIES_H_
#define _TUXTXBOUNDARIES_H_
#include <iostream>
#include <vector>
#include "yaml-cpp/yaml.h"
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxBoundaries: public Parameter {
public:
  vector<unsigned int> mC;
  unsigned int mLengthSampleSegment;
public:
  TxBoundaries ();
  ~TxBoundaries ();
  unsigned int size () {return mC.size();}
  unsigned int L () {return mC.back();}
  void seq (unsigned int from, unsigned int to, unsigned int by);
  void sampleSegment (unsigned int&, unsigned int&);
  struct c_seq {
    unsigned int from,by,c;
    c_seq () {from=0;by=1;c=from-by;}
    void reset (unsigned int ifrom, unsigned int iby) {
      from=ifrom;by=iby;c=from-by;
    }
    unsigned int operator()() {c+=by;return c;}
  } mSeq;
  friend YAML::Emitter& operator<< (YAML::Emitter &out, 
                                    const TxBoundaries &tx);
  friend ostream& operator<< (ostream &out, const TxBoundaries &t);
};
}
#endif // _TUXTXBOUNDARIES_H_

<<tuxTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <iterator>
#include <cassert>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxTxBoundaries.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
TxBoundaries::TxBoundaries () 
{
  mLengthSampleSegment = 0;
}
TxBoundaries::~TxBoundaries () 
{
  
}
void 
TxBoundaries::seq (unsigned int from, unsigned int to, unsigned int by)
{
  mSeq.reset (from, by);
  unsigned int a = (to - from) / by + 1;
  mC.resize(a);
  generate(mC.begin(),mC.end(),mSeq);
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const TxBoundaries &tx)
{
  out << YAML::BeginMap;
  out << YAML::Key << "TxBoundaries";
  out << YAML::Value << YAML::BeginSeq << YAML::Flow << tx.mC << YAML::EndSeq;
  out << YAML::EndMap;
  return out;
}
ostream& 
operator<< (ostream &out, const TxBoundaries &t)
{
  out << "  - [";
  copy(t.mC.begin(), t.mC.end() - 1, 
       ostream_iterator<unsigned int>(out, ", ") );
  out << t.mC.back() << "]" << endl;
  return out;
}
void
TxBoundaries::sampleSegment (unsigned int& left, unsigned int& right)
{
  assert (mLengthSampleSegment > 1);
  unsigned long int l = static_cast<unsigned long int>(mC.back());
  unsigned int s, e, d;
  vector<unsigned int>::iterator upLeft = mC.end();
  vector<unsigned int>::iterator upRight = mC.end();
  while (upLeft == mC.end() || upRight == mC.end() || d < 1)
    {
      s = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
      e = s + mLengthSampleSegment;
      upLeft = upper_bound(mC.begin(),mC.end(),s);
      upRight = upper_bound(mC.begin(),mC.end(),e);
      d = static_cast<unsigned int>(distance(upLeft,upRight));
    }
  left = static_cast<unsigned int>(upLeft - mC.begin());
  right = static_cast<unsigned int>(upRight - mC.begin());
  return;
}
}
@

\subsection{TxExpression}
<<tuxTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXEXPRESSION_H_
#define _TUXTXEXPRESSION_H_
#include <cassert>
#include <vector>
#include "yaml-cpp/yaml.h"
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxExpression: public Parameter {
public:
  vector<double> mDelta;
public:
  TxExpression ();
  ~TxExpression ();
  void seq (unsigned int);
  friend YAML::Emitter& operator<< (YAML::Emitter &out, 
                                    const TxExpression &tx);
  friend ostream& operator<< (ostream &out, const TxExpression &t);
  struct c_seq {
    double by,c;
    c_seq () {by=.1L;c=.0L;}
    void reset (double iby) {
      by=iby;c=.0L;
    }
    double operator()() {c+=by;return c;}
  } mSeq;
};
}
#endif // _TUXTXEXPRESSION_H_

<<tuxTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <iterator>
#include "yaml-cpp/yaml.h"
#include "tuxTxExpression.h"
using namespace std;
namespace tux {
TxExpression::TxExpression ()
{
 
}
TxExpression::~TxExpression ()
{
 
}
void 
TxExpression::seq (unsigned int num)
{
  assert (num > 1);
  double by = 1.0L / static_cast<double>(num); 
  mDelta.resize(num,by);
  return;
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const TxExpression &tx)
{
  out << YAML::BeginMap;
  out << YAML::Key << "TxExpression";
  out << YAML::Value << YAML::BeginSeq;
  out << YAML::Flow << tx.mDelta << YAML::EndSeq;
  out << YAML::EndMap;
  return out;
}
ostream& 
operator<< (ostream &out, const TxExpression &t)
{
  out << "  - [";
  copy(t.mDelta.begin(), t.mDelta.end() - 1, 
       ostream_iterator<double>(out, ", ") );
  out << t.mDelta.back() << "]" << endl;
  return out;
}
}
@

\subsection{Data}
<<tuxData.h>>=
<<tux gnu copyright>>
#ifndef _TUXDATA_H_
#define _TUXDATA_H_
#include "tuxRandomVariable.h"
namespace tux {
class Data: public RandomVariable {
};
}
#endif // _TUXDATA_H_

<<tuxData.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxData.h"
using namespace std;
namespace tux {
}
@

\subsection{Reads}
<<tuxReads.h>>=
<<tux gnu copyright>>
#ifndef _TUXREADS_H_
#define _TUXREADS_H_
#include <iostream>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxData.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
class Reads: public Data {
public:
  vector<unsigned int> mCount;
  unsigned int mN;
  unsigned int mJ;
public:
  Reads (unsigned int j = 0);
  ~Reads ();
  unsigned int size () {return mCount.size();}
  void sample (unsigned int l, unsigned int ul = 10);
  friend YAML::Emitter& operator<< (YAML::Emitter &out, const Reads &tx);
  friend void operator>> (const YAML::Node& node, Reads& t);
  friend ostream& operator<< (ostream &out, const Reads &t);

  struct c_uniformInt {
    unsigned int l;
    c_uniformInt () {l=1000;}
    unsigned int operator()() {
      return static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
    }
  } mUniformInt;

  struct c_print {
    ostream& mOut;
    void operator() (unsigned int i) {mOut << " " << i;}
  } mPrint;
};
}
#endif // _TUXREADS_H_
@

<<tuxReads.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <numeric>          // accumulate
#include <iterator>         // ostream_iterator
#include <cassert>
#include "yaml-cpp/yaml.h"
#include "tuxReads.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
Reads::Reads (unsigned int j)
{
  mJ = j; 
}
Reads::~Reads ()
{
  
}
void
Reads::sample (unsigned int l, unsigned int ul)
{
  mUniformInt.l = ul;
  mCount.resize(l);
  generate(mCount.begin(),mCount.end(),mUniformInt);
  mN = accumulate(mCount.begin(),mCount.end(),0);
}
ostream& 
operator<< (ostream &out, const Reads &t)
{
  assert (t.mCount.size() > 0);
  out << "Reads:" << endl
      << "  - [";
  copy(t.mCount.begin(), t.mCount.end() - 1, 
       ostream_iterator<unsigned int>(out, ", ") );
  out << t.mCount.back() << "]" << endl;
  return out;
  
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const Reads &t)
{
  out << YAML::BeginMap 
      << YAML::Key << "Reads" 
      << YAML::Value << YAML::BeginSeq << YAML::Flow << t.mCount << YAML::EndSeq
      << YAML::EndMap;
  return out;
}
void 
operator>> (const YAML::Node& node, Reads& t)
{
  node[t.mJ] >> t.mCount;
  t.mN = accumulate(t.mCount.begin(),t.mCount.end(),0);
  return;
}
}
@

\subsection{Fixed}
<<tuxFixed.h>>=
<<tux gnu copyright>>
#ifndef _TUXFIXED_H_
#define _TUXFIXED_H_
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxData.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
class Fixed: public Data {
public:
  unsigned int mK;
  double mM;
  vector<double> mZ;
  double mA0;
  double mA1;
  double mAlpha;
  double mAlphaQBoundaries;
  unsigned int mLengthSampleSegment;
  double mAlphaPriorExpression;
  unsigned int mMcmcLength;
  unsigned int mMcmcBurnin;
  unsigned int mMcmcThin;
  unsigned int mNumberProcess;
  unsigned int mNumberChain;
  unsigned int mNumberSwap;
  unsigned int mNumberSwapTry;
  string mOutfile;
public:
  Fixed ();
  ~Fixed ();
  unsigned int K () {return mK;}
  friend YAML::Emitter& operator<< (YAML::Emitter &out, const Fixed &t);
  friend void operator>> (const YAML::Node& node, Fixed& t);
  friend ostream& operator<< (ostream &out, const Fixed& t);
};
}
#endif // _TUXFIXED_H_
@

<<tuxFixed.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "yaml-cpp/yaml.h"
#include "tuxFixed.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
Fixed::Fixed ()
{
  
}
Fixed::~Fixed ()
{
  
}
ostream&
operator<< (ostream &out, const Fixed &t)
{
  out << "Fixed: " << endl
      << "  " << "mK"
      << ": " << t.mK << endl
      << "  " << "mM"
      << ": " << t.mM << endl
      << "  " << "mZ"
      << ": " << endl;
  for (vector<double>::const_iterator i = t.mZ.begin(); i != t.mZ.end(); i++)
    {
      out << "    - " << *i << endl;
    }
  out << "  " << "mA0"
      << ": " << t.mA0 << endl
      << "  " << "mA1"
      << ": " << t.mA1 << endl
      << "  " << "mAlpha"
      << ": " << t.mAlpha << endl
      << "  " << "mAlphaQBoundaries"
      << ": " << t.mAlphaQBoundaries << endl
      << "  " << "mLengthSampleSegment"
      << ": " << t.mLengthSampleSegment << endl
      << "  " << "mAlphaPriorExpression"
      << ": " << t.mAlphaPriorExpression << endl
      << "  " << "mMcmcLength"
      << ": " << t.mMcmcLength << endl
      << "  " << "mMcmcBurnin"
      << ": " << t.mMcmcBurnin << endl
      << "  " << "mMcmcThin"
      << ": " << t.mMcmcThin << endl
      << "  " << "mNumberProcess"
      << ": " << t.mNumberProcess << endl
      << "  " << "mNumberChain"
      << ": " << t.mNumberChain << endl
      << "  " << "mNumberSwap"
      << ": " << t.mNumberSwap << endl
      << "  " << "mNumberSwapTry"
      << ": " << t.mNumberSwapTry << endl
      << "  " << "mOutfile"
      << ": " << t.mOutfile << endl;
  return out;
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const Fixed &t)
{
  out << YAML::BeginMap << YAML::Key << "Fixed" << YAML::Value;
  out << YAML::BeginMap
      << YAML::Key << "mK"
      << YAML::Value << t.mK
      << YAML::Key << "mM"
      << YAML::Value << t.mM
      << YAML::Key << "mZ"
      << YAML::Value << t.mZ
      << YAML::Key << "mA0"
      << YAML::Value << t.mA0
      << YAML::Key << "mA1"
      << YAML::Value << t.mA1
      << YAML::Key << "mAlpha"
      << YAML::Value << t.mAlpha
      << YAML::Key << "mAlphaQBoundaries"
      << YAML::Value << t.mAlphaQBoundaries
      << YAML::Key << "mLengthSampleSegment"
      << YAML::Value << t.mLengthSampleSegment
      << YAML::Key << "mAlphaPriorExpression"
      << YAML::Value << t.mAlphaPriorExpression
      << YAML::Key << "mMcmcLength"
      << YAML::Value << t.mMcmcLength
      << YAML::Key << "mMcmcBurnin"
      << YAML::Value << t.mMcmcBurnin
      << YAML::Key << "mMcmcThin"
      << YAML::Value << t.mMcmcThin
      << YAML::Key << "mNumberProcess"
      << YAML::Value << t.mNumberProcess
      << YAML::Key << "mNumberChain"
      << YAML::Value << t.mNumberChain
      << YAML::Key << "mNumberSwap"
      << YAML::Value << t.mNumberSwap
      << YAML::Key << "mNumberSwapTry"
      << YAML::Value << t.mNumberSwapTry
      << YAML::Key << "mOutfile"
      << YAML::Value << t.mOutfile
      << YAML::EndMap;
  out << YAML::EndMap;
  return out;
}
void 
operator>> (const YAML::Node& node, Fixed& t) 
{
  node["mK"] >> t.mK;
  node["mM"] >> t.mM;
  node["mZ"] >> t.mZ;
  node["mA0"] >> t.mA0;
  node["mA1"] >> t.mA1;
  node["mAlpha"] >> t.mAlpha;
  node["mAlphaQBoundaries"] >> t.mAlphaQBoundaries;
  node["mLengthSampleSegment"] >> t.mLengthSampleSegment;
  node["mAlphaPriorExpression"] >> t.mAlphaPriorExpression;
  node["mMcmcLength"] >> t.mMcmcLength;
  node["mMcmcBurnin"] >> t.mMcmcBurnin;
  node["mMcmcThin"] >> t.mMcmcThin;
  node["mNumberProcess"] >> t.mNumberProcess;
  node["mNumberChain"] >> t.mNumberChain;
  node["mNumberSwap"] >> t.mNumberSwap;
  node["mNumberSwapTry"] >> t.mNumberSwapTry;
  node["mOutfile"] >> t.mOutfile;
  return;
}
}
@

\subsection{Probability}
<<tuxProbability.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBABILITY_H_
#define _TUXPROBABILITY_H_
#include <vector>
#include "tuxRandomVariable.h"
using namespace std;
namespace tux {
class Probability {
protected:
  vector<RandomVariable*> mV;
  vector<RandomVariable*> mC;
public:
  virtual double d () = 0;
  virtual RandomVariable* r () = 0;
};
}
#endif // _TUXPROBABILITY_H_

<<tuxProbability.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxProbability.h"
using namespace std;
namespace tux {
}
@

\subsection{ProbTxBoundaries}
<<tuxProbTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBTXBOUNDARIES_H_
#define _TUXPROBTXBOUNDARIES_H_
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"
<<extern tuxGslRng>>
namespace tux {
class ProbTxBoundaries: public Probability {
public:
  unsigned int mL;
  unsigned int mK;
public:
  ProbTxBoundaries (unsigned int, unsigned int);
  double d ();
  RandomVariable* r (); 

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return ++current;}
  } mUniqueNumber;

//  struct c_multiply {
//    double mL;
//    unsigned int operator()(double i) {
//      return static_cast<unsigned int>(i*mL + 0.5L);
//    }
//  } mMultiply;

//  struct c_uniform {
//    double a;
//    double b;
//    c_uniform () {a=0;b=1;}
//    double operator()() {
//      return gsl_ran_flat (gGslRng,a,b);
//    }
//  } mUniform;

};
}
#endif // _TUXPROBTXBOUNDARIES_H_

<<tuxProbTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_sf_gamma.h>
#include "tuxTxBoundaries.h"
#include "tuxProbTxBoundaries.h"
using namespace std;
namespace tux {
ProbTxBoundaries::ProbTxBoundaries (unsigned int l, unsigned int k)
{
  mL = l;
  mK = k;
}
double
ProbTxBoundaries::d ()
{
  return -gsl_sf_lnchoose(mL-1,mK-1);
}
RandomVariable* 
ProbTxBoundaries::r ()
{
  vector<unsigned int> a(mK-1);
  vector<unsigned int> b(mL-1);
  generate (b.begin(),b.end(),mUniqueNumber);
  gsl_ran_choose (gGslRng, &a[0], mK-1, &b[0], mL-1, sizeof(unsigned int));
  a.push_back(mL);
  TxBoundaries* v = new TxBoundaries;
  v->mC = a;
  return v;
}
}
@

\subsection{ProbTxExpression}
<<tuxProbTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBTXEXPRESSION_H_
#define _TUXPROBTXEXPRESSION_H_
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"
<<extern tuxGslRng>>
namespace tux {
class ProbTxExpression: public Probability {
public:
  vector<double> mAlpha;
  vector<double> mTheta;
public:
  ProbTxExpression (const unsigned int k, const double a = 1.L);
  ~ProbTxExpression ();
  double d ();
  RandomVariable* r (); 
  void theta (vector<double>& t) {mTheta = t;}
  vector<double>& theta () {return mTheta;}

  unsigned int op_cast_unsigned_int (double i) { return static_cast<unsigned int>(i+0.5); }

  struct c_uniform {
    double a;
    double b;
    c_uniform () {a=0;b=1;}
    double operator()() {
      return gsl_ran_flat (gGslRng,a,b);
    }
  } gslrngUniform;

};
}
#endif // _TUXPROBTXEXPRESSION_H_

<<tuxProbTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_block.h>
#include <gsl/gsl_randist.h>
#include "tuxTxExpression.h"
#include "tuxProbTxExpression.h"
using namespace std;
namespace tux {
ProbTxExpression::ProbTxExpression (const unsigned int k, const double a)
{
  mAlpha.resize(k,a);
}
ProbTxExpression::~ProbTxExpression ()
{
}

double
ProbTxExpression::d ()
{
  size_t k = static_cast<size_t>(mAlpha.size());
  return gsl_ran_dirichlet_lnpdf(k,&mAlpha[0],&mTheta[0]);
}
RandomVariable* 
ProbTxExpression::r ()
{
  size_t k = static_cast<size_t>(mAlpha.size());
  gsl_block* t = gsl_block_alloc(k);
  gsl_ran_dirichlet(gGslRng,k,&mAlpha[0],t->data);
  mTheta.resize(k); std::copy(t->data,t->data + k,mTheta.begin());
  gsl_block_free(t);

  TxExpression* v = new TxExpression;
  v->mDelta = mTheta;
  return v;
}
}
@

\subsection{Likelihood}
<<tuxLikelihood.h>>=
<<tux gnu copyright>>
#ifndef _TUXLIKELIHOOD_H_
#define _TUXLIKELIHOOD_H_
#include <vector>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
class Fixed;
class Data;
class TxBoundaries;
class TxExpression;
class Likelihood: public Probability {
public:
  Fixed* mFixed;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  unsigned int mJ;

  // Data members are set by the above RandomVariable objects
  double mA0; // given a_0
  double mA1; // given a_1
  unsigned int mL; // a given chromosome length
  unsigned int mK; // a given segments length
  double mM;       // a given average total counts
  double mSizeFactor; // a given size factor
  vector<double> mDelta;   // sample from a uniform Dirichlet distribution
  vector<unsigned int> mC; // sample from a uniform Dirichlet distribution
  vector<unsigned int> mCount;
public:
  Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te);
  Likelihood (unsigned int, unsigned int, double);
  double d ();
  RandomVariable* r (); 
  void J (unsigned int j);
  double sizeFactor () const {return mSizeFactor;}
  void sizeFactor (const double s) {mSizeFactor=s;}
  void alpha (const double a0, const double a1) {mA0=a0; mA1=a1;}

  // FIXME: in a separte file under tux namespace.
  struct c_uniform {
    double a;
    double b;
    c_uniform () {a=0;b=1;}
    double operator()() {
      return gsl_ran_flat (gGslRng,a,b);
    }
  } gslrngUniform;

  struct c_nb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    unsigned int operator()(double i) {
      double mu = mSizeFactor * mM * i;
      double n = 1/(a0+a1/mu); // multiplied by mu?
      double p = n/(n+mu);
      unsigned int k = gsl_ran_negative_binomial(gGslRng, p, n);
      return k; 
    }
  } gslrngNb;

  struct c_subtract {
    unsigned int operator()(unsigned int i, unsigned int j) {
      return j - i;
    }
  } mSubtract;

  struct c_countRead {
    vector<unsigned int>::iterator mIter;
    vector<unsigned int> mRead;
    c_countRead () {mIter = mRead.begin();}
    void resize() {mIter = mRead.begin();}
    unsigned int operator()(unsigned int l) {
      vector<unsigned int>::iterator mEnd = mIter + l;
      unsigned int sumCk = accumulate(mIter,mEnd,0);
      mIter = mEnd; 
      return sumCk;
    }
  } countRead;

  struct c_probNb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    double operator()(double d,unsigned int k) {
      double mu = d * mM * mSizeFactor; 
      double n = mu/(a0+a1/mu);
      double p = n/(n+mu);
      return log(gsl_ran_negative_binomial_pdf(k,p,n));
    }
  } probNb;

};
}
#endif // _TUXLIKELIHOOD_H_

<<tuxLikelihood.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <functional>       // minus
#include <vector>
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
using namespace std;
namespace tux {
Likelihood::Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te)
{
  // Check the three variables are valid. 
  mFixed = f;
  mTxBoundaries = tb;
  mTxExpression = te;
  mL = tb->L();
  mK = f->mK;
  mM = f->mM;
  mSizeFactor = f->mZ[0];
  mA0 = f->mA0;
  mA1 = f->mA1;
  mC = tb->mC;
  mDelta = te->mDelta;
}

Likelihood::Likelihood (unsigned int l, unsigned int k, double m)
{
  mL = l;
  mK = k;
  mM = m;
  // TxBoundaries is created. Likelihood owns it.
  ProbTxBoundaries priorTxBoundaries (mL, mK);
  priorTxBoundaries.mL = mL;
  priorTxBoundaries.mK = mK;
  TxBoundaries* vTxBoundaries = 
    static_cast<TxBoundaries*>(priorTxBoundaries.r());
  mC = vTxBoundaries->mC;
  delete vTxBoundaries;

  // TxExpression is created. Likelihood owns it.
  ProbTxExpression priorTxExpression (mK,1.L);
  TxExpression* vTxExpression = 
    static_cast<TxExpression*>(priorTxExpression.r());
  mDelta = vTxExpression->mDelta;
  delete vTxExpression;
}
void 
Likelihood::J (unsigned int j) 
{
  mJ=j;
  mSizeFactor = mFixed->mZ.at(mJ);
}
double
Likelihood::d ()
{
  // Find lengths.
  vector<unsigned int> mLk(mC);
  mLk.pop_back();
  mLk.insert(mLk.begin(),0);
  transform(mLk.begin(),mLk.end(),mC.begin(),mLk.begin(),mSubtract);

  // Count reads in ck.
  vector<unsigned int> ck(mDelta.size());
  countRead.mRead = mCount;
  transform(mLk.begin(),mLk.end(),ck.begin(),countRead);

  vector<double> logProbNb(mDelta);
  transform(logProbNb.begin(),logProbNb.end(),ck.begin(),logProbNb.begin(),probNb);
  double v = accumulate(logProbNb.begin(),logProbNb.end(),0);
  return v; 
}
RandomVariable*
Likelihood::r ()
{
  // For each i-th segment, sample j.
  // Use TxBoundaries and TxExpression to generate a set of Data.
  gslrngNb.a0 = mA0;
  gslrngNb.a1 = mA1;
  gslrngNb.mM = mM;
  gslrngNb.mSizeFactor = mFixed->mZ.at(mJ);
  vector<unsigned int> nk(mDelta.size());
  transform(mDelta.begin(),mDelta.end(),nk.begin(),gslrngNb);
   
  // Lengths of segments
  vector<unsigned int> lk(mC);
  lk.pop_back();
  lk.insert(lk.begin(),0);
  transform(mC.begin(),mC.end(),lk.begin(),lk.begin(),minus<double>());

  // Place counts on mRead of gslrngRead.
  vector<unsigned int> reads(mL,0);
  unsigned int s; 
  unsigned int p = 0;
  for (unsigned int i = 0; i < nk.size(); i++)
    {
      unsigned int n = nk.at(i);
      unsigned int l = lk.at(i);
      for (unsigned int j = 0; j < n; j++)
        {
          s = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
          reads.at(p + s)++;
        }
      p += l;
    }

  // Data
  Reads* v = new Reads;
  v->mCount = reads;
  return v;
}
}
@

\subsection{MoverManager}
<<tuxMoverManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERMANAGER_H_
#define _TUXMOVERMANAGER_H_
#include <vector>
#include <gsl/gsl_randist.h>
using namespace std;
namespace tux {
class Mover;
class MoverManager {
public:
  vector<Mover*> mMover;
  vector<unsigned int> mId;
  vector<double> mWeight;
  gsl_ran_discrete_t* mGslRanDiscrete;
public:
  MoverManager ();
  ~MoverManager ();
  void add (Mover*, const unsigned int, const double);
  Mover* choose ();

  template <class T> struct c_delete {
    void operator() (T i) {delete i;}
  };
};
}
#endif // _TUXMOVERMANAGER_H_

<<tuxMoverManager.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <cassert>
#include <gsl/gsl_block.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxMover.h"
#include "tuxMoverManager.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
MoverManager::MoverManager ()
{
  mGslRanDiscrete = NULL;
}
MoverManager::~MoverManager ()
{
  c_delete<Mover*> deleteMover;
  for_each (mMover.begin(), mMover.end(), deleteMover);           
  if (mGslRanDiscrete != NULL) 
    {
      gsl_ran_discrete_free(mGslRanDiscrete);
      mGslRanDiscrete = NULL;
    }
}
void
MoverManager::add (Mover* m, const unsigned int id, const double weight)
{
  mId.push_back(id); 
  mWeight.push_back(weight);
  mMover.push_back(m);

  size_t k = mMover.size();
  if (k > 1)
    {
      if (mGslRanDiscrete != NULL) 
        {
          gsl_ran_discrete_free(mGslRanDiscrete);
          mGslRanDiscrete = NULL;
        }
      mGslRanDiscrete = gsl_ran_discrete_preproc (k,&mWeight[0]); 
    }
}
Mover*
MoverManager::choose()
{
  assert (mMover.size() > 1);
  size_t k = gsl_ran_discrete(gGslRng,mGslRanDiscrete);
  return mMover.at(k);
}
}
@

\subsection{Mover}
<<tuxMover.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVER_H_
#define _TUXMOVER_H_
namespace tux {
class Mover {
public:
  virtual int step () = 0;
};
}
#endif // _TUXMOVER_H_

<<tuxMover.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxMover.h"
using namespace std;
namespace tux {
}
@

\subsection{MoverTxBoundaries}
<<tuxMoverTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXBOUNDARIES_H_
#define _TUXMOVERTXBOUNDARIES_H_
#include <vector>
#include <cmath>
#include <functional> // unary_function
#include <numeric>    // accumulate
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxMover.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
class TxBoundaries;
class TxExpression;
class Reads;
class Fixed;
class MoverTxBoundaries: public Mover {
public:
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  vector<Reads*> mReads;
  Fixed* mFixed;
  bool mIsData;
public:
  MoverTxBoundaries ();
  int step ();

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return current++;}
  } uniqueNumber;

  struct c_subtract {
    unsigned int operator()(unsigned int i, unsigned int j) {
      return j - i;
    }
  } mSubtract;

  struct c_subtractJfromI {
    unsigned int operator()(unsigned int i, unsigned int j) {
      return i - j;
    }
  } mSubtractJfromI;

  struct c_multiply {
    double operator()(double i, unsigned int j) {
      return i * j;
    }
  } mMultiply;

  struct c_countRead {
    vector<unsigned int>::iterator mIter;
    vector<unsigned int> mRead;
    c_countRead () {mIter = mRead.begin();}
    void resize() {mIter = mRead.begin();}
    unsigned int operator()(unsigned int l) {
      vector<unsigned int>::iterator mEnd = mIter + l;
      unsigned int sumCk = accumulate(mIter,mEnd,0);
      mIter = mEnd; 
      return sumCk;
    }
  } countRead;

  // Duplicate
  struct c_probNb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    double operator()(double d,unsigned int k) {
      double mu = d * mM * mSizeFactor; 
      double n = mu/(a0+a1/mu);
      double p = n/(n+mu);
      return log(gsl_ran_negative_binomial_pdf(k,p,n));
    }
  } probNb;

  struct c_round {
    unsigned int operator()(double i) {
      return static_cast<unsigned int>(i + 0.5L);
    }
  } mRound;
};
}
#endif // _TUXMOVERTXBOUNDARIES_H_

<<tuxMoverTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <cassert>
#include <cmath>
#include <iostream>
#include <numeric>    // partial_sum
#include <algorithm>  // generate
#include <functional> // plus
#include <vector>
#include <gsl/gsl_block.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxGsl.h"
#include "tuxMoverTxBoundaries.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
MoverTxBoundaries::MoverTxBoundaries ()
{
}
int 
MoverTxBoundaries::step ()
{
  mTxBoundaries->mLengthSampleSegment = mFixed->mLengthSampleSegment;
  unsigned int left, right;
  mTxBoundaries->sampleSegment (left, right);
  vector<unsigned int> ck(mTxBoundaries->mC.begin() + left,
                          mTxBoundaries->mC.begin() + right + 1);
  vector<unsigned int> aCk(ck);
  vector<double> deltaK(mTxExpression->mDelta.begin() + left,
                        mTxExpression->mDelta.begin() + right + 1);
  // Compute lk
  vector<unsigned int> lk(ck);
  vector<unsigned int> lkLeft;
  if (left == 0)
    lkLeft.push_back(0);
  else
    lkLeft.push_back(mTxBoundaries->mC.at(left - 1));
  lkLeft.insert(lkLeft.end(),lk.begin(),lk.end()-1);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<double>());
  
  // Propose new boundaries
  unsigned int sumLk = accumulate(lk.begin(),lk.end(),0);
  unsigned int kappa = lk.size();
  unsigned int sumLkStar = sumLk - kappa;
  vector<double> b(lk.size());
  transform(lk.begin(), lk.end(), b.begin(), 
            bind2nd(divides<double>(),static_cast<double>(sumLk)));
  vector<double> a(lk.size());
  vector<double> aAlpha(lk.size());
  vector<double> bAlpha(lk.size());
  transform(b.begin(), b.end(), bAlpha.begin(), 
            bind2nd(multiplies<double>(),mFixed->mAlphaQBoundaries));
  gsl_ran_dirichlet(gGslRng,kappa,&bAlpha[0],&a[0]);
  transform(a.begin(), a.end(), aAlpha.begin(), 
            bind2nd(multiplies<double>(),mFixed->mAlphaQBoundaries));

  // No prior ratio because of uniform prior on TxBoundaries
  double prExpression = 0;
  // MH ratio.
  double mhAtoB = gsl_ran_dirichlet_lnpdf(kappa,&aAlpha[0],&b[0]);
  double mhBtoA = gsl_ran_dirichlet_lnpdf(kappa,&bAlpha[0],&a[0]);
  double mhExpression = mhAtoB - mhBtoA;
  // Likelihood ratio.
  double likelihoodExpression; 
  vector<unsigned int> lkA;
  if (mIsData == true)
    {
      vector<double> aPartialSum(a.size());
      partial_sum(a.begin(),a.end(),aPartialSum.begin());
      vector<double> aCkDouble(a.size());
      transform(aPartialSum.begin(), aPartialSum.end(), aCkDouble.begin(), 
                bind2nd(multiplies<double>(),static_cast<double>(sumLkStar)));
      transform (aCkDouble.begin(),aCkDouble.end(),aCk.begin(),mRound);
      // Now, we have ending positions. We will use the first kappa-1 elements.
      //aCk.at(aCk.size()-1) = sumLkStar;
      aCk.back() = sumLkStar;
      vector<unsigned int> s1(a.size());
      uniqueNumber.current = lkLeft.front() + 1;
          
      generate(s1.begin(),s1.end(),uniqueNumber);                  
      transform(aCk.begin(),aCk.end(),s1.begin(),aCk.begin(),plus<unsigned int>());
      assert(aCk.back()==ck.back());

      // Compute lkA
      lkA = aCk;
      vector<unsigned int> lkALeft;
      if (left == 0)
        lkALeft.push_back(0);
      else
        lkALeft.push_back(mTxBoundaries->mC.at(left - 1));
      lkALeft.insert(lkALeft.end(),lkA.begin(),lkA.end()-1);
      transform(lkA.begin(),lkA.end(),lkALeft.begin(),lkA.begin(),minus<double>());

      // We count reads on the segments.
      vector<double> logNb;
      vector<unsigned int> cA;
      vector<unsigned int> cB;
      for (unsigned int j = 0; j < mReads.size(); j++)
        {
          Reads* d = mReads.at(j);
          cA.clear();
          unsigned int posA = lkLeft.front();
          // Where is lkA?
          for (vector<unsigned int>::iterator i = lkA.begin(); 
               i != lkA.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posA,
                                              d->mCount.begin() + posA + *i,
                                              0);
              posA += *i;
              cA.push_back(sumCk);
           }
          cB.clear();
          unsigned int posB = lkLeft.front();
          for (vector<unsigned int>::iterator i = lk.begin(); 
               i != lk.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posB,
                                              d->mCount.begin() + posB + *i,
                                              0);
              posB += *i;
              cB.push_back(sumCk);
           }

          // Compute the probability of observing the counts using a and b.
          for (unsigned int k = 0; k < deltaK.size(); k++)
            {
              unsigned int xkA = cA.at(k);
              double muA = d->mN * deltaK.at(k);
              double nA = 1.L/(mFixed->mA0 + mFixed->mA1/muA);
              double pA = nA/(nA+muA);
              double vA = gsl_ran_negative_binomial_lnpdf (xkA, pA, nA);

              unsigned int xkB = cB.at(k);
              double muB = d->mN * deltaK.at(k);
              double nB = 1.L/(mFixed->mA0 + mFixed->mA1/muB);
              double pB = nB/(nB+muB);
              double vB = gsl_ran_negative_binomial_lnpdf (xkB, pB, nB);
              logNb.push_back(vA - vB);
            }
        }
      likelihoodExpression = accumulate(logNb.begin(),logNb.end(),.0L);
    }
  else
    {
      likelihoodExpression = 0;
    }
  double logAlpha = likelihoodExpression + prExpression + mhExpression;
  double logAlphaUniform = log(gsl_rng_uniform (gGslRng));
  if (logAlpha < logAlphaUniform)
    {
      // Reject it.
      // Keep the value of TxExpression* mTxExpression;
    }
  else
    {
      // Accept it.
      // Change the value of TxExpression* mTxExpression;
      for (unsigned int i = 0; i < aCk.size() - 1; i++)
        {
          mTxBoundaries->mC.at(i + left) = aCk.at(i);
        }
      // FIXME: Movers checks something about acceptance frequency.
      // Do we need another class? We would have to use this class.
      // In MC3 we need to use the output file to compute acceptance frequency
      // because it would be complicated to access this from class.
    }
  return 0;
}
}
@

\subsection{MoverTxExpression}
<<tuxMoverTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXEXPRESSION_H_
#define _TUXMOVERTXEXPRESSION_H_
#include <vector>
#include <cmath>
#include <functional> // unary_function
#include "tuxMover.h"
using namespace std;
namespace tux {
class TxBoundaries;
class TxExpression;
class Reads;
class Fixed;
class MoverTxExpression: public Mover {
public:
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  vector<Reads*> mReads;
  Fixed* mFixed;
  bool mIsData;
public:
  MoverTxExpression ();
  int step ();

  struct unaryLog: public unary_function<double,double> {
    double operator() (double number) {return log(number);}
  } mUnaryLog;

};
}
#endif // _TUXMOVERTXEXPRESSION_H_

<<tuxMoverTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <numeric>
#include <algorithm>
#include <functional>
#include <vector>
#include <cassert>
#include <cmath>
#include <gsl/gsl_block.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxGsl.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverTxExpression.h"
using namespace std;
namespace tux {
MoverTxExpression::MoverTxExpression ()
{
//  mAlpha = 1.L;
  mIsData = true;
  mFixed = NULL;
}
int 
MoverTxExpression::step ()
{
  mTxBoundaries->mLengthSampleSegment = mFixed->mLengthSampleSegment;
  unsigned int left, right;
  mTxBoundaries->sampleSegment (left, right);

  vector<double> dk(mTxExpression->mDelta.begin() + left,
                    mTxExpression->mDelta.begin() + right + 1);

  size_t kappa = static_cast<size_t>(dk.size());
  assert (kappa > 1);
  vector<double> aDk(dk);
  vector<double> a(kappa);
  vector<double> b(kappa);
  vector<double> aAlpha(kappa);
  vector<double> bAlpha(kappa);
  double sumDk = accumulate(dk.begin(),dk.end(),.0L);
  transform(dk.begin(),dk.end(),b.begin(), 
            bind2nd(multiplies<double>(),1.L / sumDk));
  transform(b.begin(),b.end(),bAlpha.begin(), 
            bind2nd(multiplies<double>(),mFixed->mAlpha));
  gsl_ran_dirichlet(gGslRng,kappa,&bAlpha[0],&a[0]);
  transform(a.begin(), a.end(), aAlpha.begin(), 
            bind2nd(multiplies<double>(),mFixed->mAlpha));
  transform(a.begin(), a.end(), aDk.begin(), 
            bind2nd(multiplies<double>(),sumDk));

  double priorExpressionAlpha = mFixed->mAlphaPriorExpression - 1.L;
  vector<double> logA(a);
  vector<double> logB(b);
  vector<double> logAminusB(a.size());
  vector<double> logAminusBtimesAlphaMinusOne(a.size());
  transform(logA.begin(),logA.end(),logA.begin(),mUnaryLog);
  transform(logB.begin(),logB.end(),logB.begin(),mUnaryLog);
  transform(logA.begin(),logA.end(),logB.begin(),logAminusB.begin(),
            minus<double>());
  transform(logAminusB.begin(), logAminusB.end(), 
            logAminusBtimesAlphaMinusOne.begin(), 
            bind2nd(multiplies<double>(),priorExpressionAlpha));
  double prExpression = accumulate(logAminusBtimesAlphaMinusOne.begin(),
                                   logAminusBtimesAlphaMinusOne.end(),.0L);
  // MH ratio.
  double mhAtoB = gsl_ran_dirichlet_lnpdf(kappa,&aAlpha[0],&b[0]);
  double mhBtoA = gsl_ran_dirichlet_lnpdf(kappa,&bAlpha[0],&a[0]);
  double mhExpression = mhAtoB - mhBtoA;
  // Likelihood ratio.
  double likelihoodExpression; 
  if (mIsData == true)
    {
      vector<unsigned int> ck(mTxBoundaries->mC.begin() + left,
                              mTxBoundaries->mC.begin() + right + 1);
      vector<unsigned int> lk(ck);
      vector<unsigned int> lkLeft;
      if (left == 0)
        lkLeft.push_back(0);
      else
        lkLeft.push_back(mTxBoundaries->mC.at(left - 1));
      lkLeft.insert(lkLeft.end(),lk.begin(),lk.end()-1);
      transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(), minus<double>());

      // We count reads on the segments.
      vector<double> logNb;
      vector<unsigned int> c;
      for (unsigned int j = 0; j < mReads.size(); j++)
        {
          Reads* d = mReads.at(j);
          c.clear();
          unsigned int pos = lkLeft.front();
          for (vector<unsigned int>::iterator i = lk.begin(); 
               i != lk.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + pos,
                                              d->mCount.begin() + pos + *i,
                                              0);
              pos += *i;
              c.push_back(sumCk);
           }
          // Compute the probability of observing the counts using a and b.
          for (unsigned int k = 0; k < ck.size(); k++)
            {
              unsigned int xk = c.at(k);
              double muA = d->mN * a.at(k);
              double nA = 1.L/(mFixed->mA0 + mFixed->mA1/muA);
              double pA = nA/(nA+muA);
              double vA = gsl_ran_negative_binomial_lnpdf (xk, pA, nA);

              double muB = d->mN * b.at(k);
              double nB = 1.L/(mFixed->mA0 + mFixed->mA1/muB);
              double pB = nB/(nB+muB);
              double vB = gsl_ran_negative_binomial_lnpdf (xk, pB, nB);
              logNb.push_back(vA - vB);
            }
        }
      likelihoodExpression = accumulate(logNb.begin(),logNb.end(),.0L);
    }
  else
    {
      likelihoodExpression = .0L;
    }
  double logAlpha = likelihoodExpression + prExpression + mhExpression;
  double logAlphaUniform = log(gsl_rng_uniform(gGslRng));
  if (logAlpha < logAlphaUniform)
    {
      // Reject it.
      // Keep the value of TxExpression* mTxExpression;
    }
  else
    {
      // Accept it.
      // Change the value of TxExpression* mTxExpression;
      for (unsigned int i = 0; i < aDk.size(); i++)
        {
          mTxExpression->mDelta.at(i + left) = aDk.at(i);
        }
      // FIXME: Movers checks something about acceptance frequency.
      // Do we need another class? We would have to use this class.
      // In MC3 we need to use the output file to compute acceptance frequency
      // because it would be complicated to access this from class.
    }
  return 0;
}
}
@

\subsection{Sample}
<<tuxSample.h>>=
<<tux gnu copyright>>
#ifndef _TUXSAMPLE_H_
#define _TUXSAMPLE_H_
#include <fstream>
namespace tux {
class Sample {
public:
  string mFilename;
  ofstream mOs;
public:
  void open (const char* filename);
  void close ();
  void write (); 
};
}
#endif // _TUXSAMPLE_H_

<<tuxSample.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSample.h"
using namespace std;
namespace tux {
void 
Sample::full ()
{
  return;
}
}
@

\subsection{Summarizer}
<<tuxSummarizer.h>>=
<<tux gnu copyright>>
#ifndef _TUXSUMMARIZER_H_
#define _TUXSUMMARIZER_H_
namespace tux {
class Summarizer {
public:
  void full ();
};
}
#endif // _TUXSUMMARIZER_H_

<<tuxSummarizer.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSummarizer.h"
using namespace std;
namespace tux {
void 
Summarizer::full ()
{
  return;
}
}
@

\subsection{Summary}
<<tuxSummary.h>>=
<<tux gnu copyright>>
#ifndef _TUXSUMMARY_H_
#define _TUXSUMMARY_H_
namespace tux {
class Summary {
public:
  void full ();
};
}
#endif // _TUXSUMMARY_H_

<<tuxSummary.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSummary.h"
using namespace std;
namespace tux {
void 
Summary::full ()
{
  return;
}
}
@

\subsection{System}
<<tuxSystem.h>>=
<<tux gnu copyright>>
#ifndef _TUXSYSTEM_H_
#define _TUXSYSTEM_H_
namespace tux {
class System {
public:
  void full ();
};
}
#endif // _TUXSYSTEM_H_

<<tuxSystem.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSystem.h"
using namespace std;
namespace tux {
void 
System::full ()
{
  return;
}
}
@

\subsection{TUX GSL}
<<tuxGsl.h>>=
<<tux gnu copyright>>
#ifndef _TUXGSL_H_
#define _TUXGSL_H_
namespace tux {
double                                                                          
gsl_ran_negative_binomial_lnpdf (const unsigned int k, 
                                 const double p, 
                                 const double n);
}
#endif // _TUXGSL_H_

<<tuxGsl.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <cmath>
#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGsl.h"
using namespace std;
namespace tux {
double                                                                          
gsl_ran_negative_binomial_lnpdf (const unsigned int k, 
                                 const double p, 
                                 const double n)
{ 
  double f = gsl_sf_lngamma (k + n);                                           
  double a = gsl_sf_lngamma (n);                                               
  double b = gsl_sf_lngamma (k + 1.0);                                         

  double P = (f-a-b) + n * log(p) + static_cast<double>(k) * log(1 - p); 
  return P;
}
}
@

\subsection{Xyz}
<<tuxXyz.h>>=
<<tux gnu copyright>>
#ifndef _TUXXYZ_H_
#define _TUXXYZ_H_
namespace tux {
class Xyz {
public:
  void full ();
};
}
#endif // _TUXXYZ_H_

<<tuxXyz.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxXyz.h"
using namespace std;
namespace tux {
void 
Xyz::full ()
{
  return;
}
}
@

\subsection{GNU Readline Library}
<<config.h.in>>=
#ifndef _CONFIG_H_
#define _CONFIG_H_

#undef __BEGIN_DECLS
#undef __END_DECLS
#ifdef __cplusplus
# define __BEGIN_DECLS extern "C" {
# define __END_DECLS }
#else
# define __BEGIN_DECLS /* empty */
# define __END_DECLS /* empty */
#endif

#define tux_VERSION_MAJOR @tux_VERSION_MAJOR@
#define tux_VERSION_MINOR @tux_VERSION_MINOR@

#cmakedefine USE_MYMATH

#cmakedefine HAVE_LOG
#cmakedefine HAVE_EXP

#cmakedefine HAVE_MALLOC_H 1
#cmakedefine HAVE_SYS_FILE_H
#cmakedefine HAVE_UNISTD_H
#cmakedefine HAVE_STRING_H
#cmakedefine HAVE_STDLIB_H

#endif /* _CONFIG_H_ */

<<fileman.cpp>>=
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif 

#include "rlstdc.h"

#include <sys/types.h>
#ifdef HAVE_SYS_FILE_H
#  include <sys/file.h>
#endif
#include <sys/stat.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include <fcntl.h>
#include <stdio.h>
#include <errno.h>

#if defined (HAVE_STRING_H)
#  include <string.h>
#else /* !HAVE_STRING_H */
#  include <strings.h>
#endif /* !HAVE_STRING_H */

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#endif

#include <time.h>

#include "xmalloc.h"

#include <readline/readline.h>
#include <readline/history.h>


// extern char *xmalloc PARAMS((size_t));

/* The names of functions that actually do the manipulation. */
int com_list PARAMS((char *));
int com_view PARAMS((char *));
int com_rename PARAMS((char *));
int com_stat PARAMS((char *));
int com_pwd PARAMS((char *));
int com_delete PARAMS((char *));
int com_help PARAMS((char *));
int com_cd PARAMS((char *));
int com_quit PARAMS((char *));

/* A structure which contains information on the commands this program
   can understand. */

typedef struct {
  char *name;/* User printable name of the function. */
  rl_icpfunc_t *func;/* Function to call to do the job. */
  char *doc;/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "cd", com_cd, "Change to directory DIR" },
  { "delete", com_delete, "Delete FILE" },
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "list", com_list, "List files in DIR" },
  { "ls", com_list, "Synonym for `list'" },
  { "pwd", com_pwd, "Print the current working directory" },
  { "quit", com_quit, "Quit using Fileman" },
  { "rename", com_rename, "Rename FILE to NEWNAME" },
  { "stat", com_stat, "Print out statistics on FILE" },
  { "view", com_view, "View the contents of FILE" },
  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite (char *string);
COMMAND* find_command (char *name);
void too_dangerous (char *caller);
void initialize_readline ();
int execute_line (char *line);
int valid_argument (char *caller, char *arg);

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (char *s)
{
  char *r;

  r = (char *) xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

int
main (int argc, char **argv)
{
  char *line, *s;

  progname = argv[0];
  if (argc == 1) { }

  initialize_readline ();/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}

/* Execute a command line. */
int
execute_line (char *line)
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (char *name)
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (char *string)
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator PARAMS((const char *, int));
char **fileman_completion PARAMS((const char *, int, int));

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
void
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END bound the
   region of rl_line_buffer that contains the word to complete.  TEXT is
   the word to complete.  We can use the entire contents of rl_line_buffer
   in case we want to do some simple parsing.  Return the array of matches,
   or NULL if there aren't any. */
char **
fileman_completion (const char *text, int start, int end)
{
  char **matches;

  if (end == 0) {}

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);

  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (const char *text, int state)
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  name = commands[list_index].name;
  while (name) 
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
      name = commands[list_index].name;
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                       FileMan Commands                           */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* List the file(s) named in arg. */
int
com_list (char *arg)
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}

int 
com_view (char *arg)
{
  if (!valid_argument ("view", arg))
    return 1;

#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "less %s", arg);
#else
  sprintf (syscom, "more %s", arg);
#endif
  return (system (syscom));
}

int
com_rename (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "rename %s", arg);
#else
  sprintf (syscom, "rename %s", arg);
#endif
  too_dangerous (syscom);
  return (1);
}

int
com_stat (char *arg)
{
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %d byte%s in length.\n",
  arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          (int) finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}

int
com_delete (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "delete %s", arg);
#else
  sprintf (syscom, "delete %s", arg);
#endif
  too_dangerous (syscom);
  return (1);
}

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
int
com_help (char *arg)
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

/* Change to the directory ARG. */
int
com_cd (char *arg)
{
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}

/* Print out the current working directory. */
int
com_pwd (char *ignore)
{
  char dir[1024], *s;

  s = getcwd (dir, sizeof(dir) - 1);
  if (s == 0)
    {
      printf ("Error getting pwd: %s %s\n", dir, ignore);
      return 1;
    }

  printf ("Current directory is %s %s\n", dir, ignore);
  return 0;
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
int
com_quit (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "quit %s", arg);
#else
  sprintf (syscom, "quit %s", arg);
#endif
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
void
too_dangerous (char *caller)
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (char *caller, char *arg)
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}
@

\subsection{Logarithm of sum}
We use a head file log-double.H of BAli-Phy.
<<benLogDouble.h>>=
// The following is a header file of BAli-Phy authored by Ben.

/*
   Copyright (C) 2004-2005 Benjamin Redelings

This file is part of BAli-Phy.

BAli-Phy is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

BAli-Phy is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with BAli-Phy; see the file COPYING.  If not see
<http://www.gnu.org/licenses/>.  */

#ifndef LOG_DOUBLE_H
#define LOG_DOUBLE_H

#include <cassert>
#include "logsum.H"

/// A class for handling positive real number in terms of their natural log.
class log_double_t {
  /// Natural log of the number.
  double value;
public:

  /// Access the log of the number.
  double  log() const {return value;}
  /// Access the log of the number.
  double& log()       {return value;}

  log_double_t& operator +=(const log_double_t& y) {loginc(value,y.log()); return *this;}
  log_double_t& operator -=(const log_double_t& y) {value = logdiff(log(),y.log()); return *this;}
  log_double_t& operator *=(const log_double_t& y) {value += y.log(); return *this;}
  log_double_t& operator /=(const log_double_t& y) {value -= y.log(); return *this;}

  operator double() const {return exp(value);}

  log_double_t& operator=(double y) {
    assert(y >= 0);
    if (y == 0)
      value = log_0;
    else if (y == 1)
      value = 0;
    else
      value = ::log(y);
    return *this;
  }


  log_double_t():value(log_0) {}

  log_double_t(double x) {
    operator=(x);
  }
};

inline double log(log_double_t x) {
  return x.log();
}

#define decl_double(rtype,op)  \
inline rtype operator op (double x,log_double_t y) { \
  return log_double_t(x) op y; \
} \
\
inline rtype operator op (log_double_t x,double y) {\
  return x op log_double_t(y);\
}

inline log_double_t operator+(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z += y;
  return z;
}

inline log_double_t operator-(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z -= y;
  return z;
}

inline log_double_t operator*(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z *= y;
  return z;
}

inline log_double_t operator/(log_double_t x,log_double_t y) {
  log_double_t z=x;
  z /= y;
  return z;
}

decl_double(log_double_t,+)
decl_double(log_double_t,-)
decl_double(log_double_t,*)
decl_double(log_double_t,/)

inline bool operator< (log_double_t x,log_double_t y) {
  return log(x)<log(y);
}

decl_double(bool,<)

inline bool operator<=(log_double_t x,log_double_t y) {
  return log(x)<=log(y);
}

decl_double(bool,<=)

inline bool operator> (log_double_t x,log_double_t y) {
  return log(x)>log(y);
}

inline bool operator>(log_double_t x,double y) {
  if (y==0)
    return log(x) > log_limit;
  else
    return x > log_double_t(y);
}

inline bool operator>(double  x,log_double_t y) {
  return log_double_t(x) > y;
}

inline bool operator>=(log_double_t x,log_double_t y) {
  return log(x)>=log(y);
}

decl_double(bool,>=)


inline bool operator==(log_double_t x,log_double_t y) {
  return log(x)==log(y);
}

inline bool operator==(log_double_t x,double y) {
  if (y==0.0)
    return log(x) <= log_limit;
  else if (y==1)
    return log(x) == 0.0;
  else
    return double(x) == y;
}

/*
inline bool operator==(log_double_t x,double y) {
  if (y==0)
    return (x==log_0);
  else if (y==1)
    return (x==0);
  else
    return (x==log(y));
}
*/

inline bool operator!=(log_double_t x,log_double_t y) {
  return log(x)!=log(y);
}

inline bool operator!=(log_double_t x,double y) {
  if (y==0.0)
    return log(x) > log_limit;
  else if (y==1)
    return log(x) != 0.0;
  else
    return double(x) != y;
}

#undef decl_double

inline log_double_t pow(log_double_t x,double p) 
{
  x.log() *= p;
  return x;
}

inline bool different(log_double_t x,log_double_t y,double tol=1.0e-9)
{
  double diff = log(x) - log(y);

  if (std::abs(diff)<tol) return false;

  if (x == y) return false;

  return true;
}

template<class T> T exp(double);

template<> inline log_double_t exp<log_double_t>(double x) {
  log_double_t y;
  y.log() = x;
  return y;
}

// Don't do pow<log_double_t>(x,y): do pow(log_double_t(x),y), instead.
//
// template<class T> T pow(double,double);
// 
// template<> inline log_double_t pow<log_double_t>(double x,double p) {
//   log_double_t y;
//   y.log() = p * ::log(x);
//   return y;
// }

#endif
@

\section{Tests}

\subsection{Generation of data}
Data generation requires procedures. The \Cclass{RandomVariable} and its two
other subclasses of \Cclass{Parameter} and \Cclass{Data} are abstract. The
\Cclass{TxBoundaries}, \Cclass{TxExpression}, and \Cclass{Reads} are concrete.  

\subsection{Test of Main}
<<tux-v1.cpp>>=
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include "config.h"

#ifdef USE_MYMATH
#include "MathFunctions.h"
#endif

int main (int argc, char *argv[])
{
  if (argc < 2)
    {
      fprintf(stdout,"%s Version %d.%d\n",
      argv[0],
      tux_VERSION_MAJOR,
      tux_VERSION_MINOR);
      fprintf(stdout,"Usage: %s number\n",argv[0]);
      return 1;
    }

  double inputValue = atof(argv[1]);

#ifdef USE_MYMATH
  double outputValue = mysqrt(inputValue);
#else
  double outputValue = sqrt(inputValue);
#endif

  fprintf(stdout,"The square root of %g is %g\n",
          inputValue, outputValue);
  return 0;
}
@

<<MathFunctions/mysqrt.cpp>>=
#include <cstdio>
#include "MathFunctions.h"
#include "TutorialConfig.h"

// include the generated table
#include "Table.h"

#include <math.h>

// a hack square root calculation using simple operations
double mysqrt(double x)
{
  if (x <= 0)
    {
    return 0;
    }
  
  double result;

  // if we have both log and exp then use them
  double delta;  

  // use the table to help find an initial value
  result = x;
  if (x >= 1 && x < 10)
    {
    result = sqrtTable[static_cast<int>(x)];
    }

  // do ten iterations
  int i;
  for (i = 0; i < 10; ++i)
    {
    if (result <= 0)
      {
      result = 0.1;
      }
    delta = x - (result*result);
    result = result + 0.5*delta/result;
    fprintf(stdout,"Computing sqrt of %g to be %g\n",x,result);
    }

  return result;
}
@

<<MathFunctions/MakeTable.cpp>>=
// A simple program that builds a sqrt table 
#include <stdio.h>
#include <math.h>

int main (int argc, char *argv[])
{
  int i;
  double result;

  // make sure we have enough arguments
  if (argc < 2)
    {
    return 1;
    }
  
  // open the output file
  FILE *fout = fopen(argv[1],"w");
  if (!fout)
    {
    return 1;
    }
  
  // create a source file with a table of square roots
  fprintf(fout,"double sqrtTable[] = {\n");
  for (i = 0; i < 10; ++i)
    {
    result = sqrt(static_cast<double>(i));
    fprintf(fout,"%g,\n",result);
    }

  // close the table with a zero
  fprintf(fout,"0};\n");
  fclose(fout);
  return 0;
}
@

\subsection{GSL}
<<tux-gsl.cpp>>=
#include <fstream>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
<<extern tuxGslRng>>
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  gsl_rng_set(gGslRng,100);
  unsigned long int s = gsl_rng_uniform_int(gGslRng,100);

  std::fstream f;
  f.open (argv[1], std::fstream::out);
  f << s << std::endl;

  // Test of Dirichlet and vectors
  std::vector<double> a(3,1.L);
  std::vector<double> b;
  b.resize(3);
  gsl_ran_dirichlet(gGslRng,3,&a[0],&b[0]);
  for (std::vector<double>::iterator i = b.begin(); i != b.end(); i++) {
    f << *i << "\t";
  }
  f << std::endl;

  f.close();

  fGslRngFree ();
  return 0;
}
@


\subsection{STL}
<<stl-transform.cpp>>=
#include <iostream>
#include <string>
#include <algorithm>  // transform, copy
#include <vector>
#include <functional> // bind2nd, unary_function
#include <numeric>    // accumulate
#include <iterator>   // ostream_iterator
#include <cmath>
using namespace std;
struct myclass {
  void operator() (double i) {cout << " " << i;}
} myobject;

struct unaryLog : public unary_function<double,double> {
  double operator() (double number) {return log(number);}
};

int
main ()
{
  static const double a[] = {1,2,3};
  static const double b[] = {1,2,3};
  vector<double> v (a, a + sizeof(a) / sizeof(a[0]) );
  vector<double> vb (b, b + sizeof(b) / sizeof(a[0]) );
  // Sum of a.
  double s = accumulate(v.begin(),v.end(),0);
  // Divide a by the sum.
  transform(v.begin(),v.end(),v.begin(),bind2nd(divides<double>(),s));
  // Print the a/sum.
  for_each(v.begin(),v.end(),myobject);
  cout << endl;

  // Log of a.
  unaryLog unaryLogObject;
  transform(v.begin(),v.end(),v.begin(),unaryLogObject);
  for_each(v.begin(),v.end(),myobject);
  cout << endl;

  // vector A minus vector B = vector C.
  vector<double> vc(v.size());
  transform(v.begin(),v.end(),vb.begin(),vc.begin(),minus<double>());
  for_each(vc.begin(),vc.end(),myobject);
  cout << endl;

  //    We would need to
  return 0;
}
@

\subsection{Test-Fixed and YAML}
<<tux-fixed.cpp>>=
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxFixed.h"
#include "tuxReads.h"
<<extern tuxGslRng>>
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  std::fstream f;
  f.open (argv[1], std::fstream::out);

  // Add your source codes.
  YAML::Emitter out;

  Fixed m;
  m.mK = 5u;
  static const double sf[] = {0.8700484, 1.0158870, 1.1285131};
  //vector<double> sizeFactor(sf, sf + sizeof(sf)/sizeof(sf[0]));
  m.mZ.assign(sf, sf + sizeof(sf)/sizeof(sf[0]));
  m.mA0 = .1L;
  m.mA1 = 1.L;
  m.mAlpha = 1.L;
  m.mAlphaQBoundaries = 1.L;
  m.mLengthSampleSegment = 100u;
  m.mAlphaPriorExpression = .01L;
  m.mMcmcLength = 1000u;
  m.mMcmcBurnin = 100u;
  m.mMcmcThin = 50u;
  out << m;

  Reads r;
  static const unsigned int a[] = {16,2,77,29,5,2,3,3,2,3};
  r.mCount.assign(a,a+sizeof(a)/sizeof(a[0]));
  out << r;
  //std::cout << r;
   
  // Write the file to a YAML file.
  f << out.c_str();
  f << std::endl;
  f.close();

  // Read in a file.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; std::cout << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  r.mJ = 0; doc["Reads"] >> r; std::cout << r;
  r.mJ = 1; doc["Reads"] >> r; std::cout << r;
  r.mJ = 2; doc["Reads"] >> r; std::cout << r;
  fin.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{TxBoundaries, TxExpression, and Reads}
<<tux-tx.cpp>>=
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
<<extern tuxGslRng>>
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();

  std::fstream f;
  f.open (argv[1], std::fstream::out);

  // Add your source codes.
  YAML::Emitter out;

  Fixed m;
  Reads r;
  // Read in a file: the same code as tux-fixed.cpp.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; out << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  r.mJ = 0; doc["Reads"] >> r; out << r;
  fin.close();

  // TxBoundaries
  TxBoundaries txb;
  txb.seq (2,r.size(),2); 
  out << txb;

  // Sample two points
//  out << YAML::BeginMap << YAML::Key << "SegmentSubset";
//  out << YAML::Value << YAML::BeginSeq;
//  unsigned int l1,l2;
//  for (unsigned int i = 0; i < 3; i++)
//    {
//      txb.mLengthSampleSegment = 200;
//      txb.sampleSegment (l1,l2);
//      out << l1 << l2;
//    }
//  out << YAML::EndSeq << YAML::EndMap;

  // TxExpression
  TxExpression txe;
  txe.seq (txb.size());
  out << txe;

  // Reads
  Reads shortReads;
  shortReads.sample (txb.L());
  std::cout << shortReads;

  // Write the file to a YAML file.
  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{ProbTxBoundaries, ProbTxExpression, and Likelihood}
<<tux-prob.cpp>>=
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);

  // Add your source codes.
  YAML::Emitter out;
  
  // Read in a YAML file.
  Fixed m;
  Reads r;
  // Read in a file: the same code as tux-fixed.cpp.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; out << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  r.mJ = 0; doc["Reads"] >> r; out << r;
  fin.close();

  ProbTxBoundaries factoryTxBoundaries (r.size(),m.K());
  out << YAML::BeginMap;
  out << YAML::Key << "ProbTxBoundaries";
  out << YAML::Value << factoryTxBoundaries.d (); 
  out << YAML::EndMap;
  TxBoundaries* txb = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  out << *txb; 

  ProbTxExpression factoryTxExpression (m.K());
  TxExpression* txe = static_cast<TxExpression*>(factoryTxExpression.r());
  out << *txe;

  // L: 1000, K:10, M:10000 
  //static const double sf[] = {0.8700484, 1.0158870, 1.1285131};
  //vector<double> sizeFactor(sf, sf + sizeof(sf)/sizeof(sf[0]));
  Likelihood factoryData (&m,txb,txe);
  for (unsigned int i = 0; i < m.mZ.size(); i++)
    {
      factoryData.J(i);
      Reads* shortRead = static_cast<Reads*>(factoryData.r());
      out << *shortRead;
      delete shortRead;
    }

  delete txb;
  delete txe;

  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{Movers}
<<tux-move.cpp>>=
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);
  YAML::Emitter out;

  // Add your source codes.
  // Read in a YAML file.
  Fixed m;
  // Read in a file: the same code as tux-fixed.cpp.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; out << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  const YAML::Node& node = doc["Reads"];
  vector<Reads*> shortRead;
  Reads* r;
  for (unsigned int i = 0; i < node.size(); i++)
    {
      r = new Reads(i);
      doc["Reads"] >> *r;
      shortRead.push_back(r);
    }
  fin.close();
//  for (vector<Reads*>::iterator i = shortRead.begin(); 
//       i != shortRead.end(); 
//       i++)
//    {
//      std::cout << **i;
//    }
  // Initial values;
  r = shortRead.front();
  ProbTxBoundaries factoryTxBoundaries (r->size(),m.K());
  TxBoundaries* txb = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  out << *txb; 
  ProbTxExpression factoryTxExpression (m.K());
  TxExpression* txe = static_cast<TxExpression*>(factoryTxExpression.r());
  out << *txe; 

  // MCMC
  MoverManager mMoverManager;
  MoverTxBoundaries* d1;
  MoverTxExpression* d2;
  // Boundaries Mover
  d1 = new MoverTxBoundaries;
  d1->mTxBoundaries = txb;
  d1->mTxExpression = txe;
  d1->mFixed = &m;
  d1->mReads = shortRead;
  mMoverManager.add (d1, 1, 1);
  // Expression Mover
  d2 = new MoverTxExpression;
  d2->mTxBoundaries = txb;
  d2->mTxExpression = txe;
  d2->mFixed = &m;
  d2->mReads = shortRead;
  mMoverManager.add (d2, 2, 1);

  for (unsigned int i = 0; i < m.mMcmcLength; i++)
    {
      Mover* mover = mMoverManager.choose ();
      mover->step ();
      // Other information for steps.
      out << *txb;
      out << *txe;
    }
  // Movers are deleted by MoverManager.
  // RandomVariables must be removed.
  delete txb;
  delete txe;
  for (vector<Reads*>::iterator i = shortRead.begin(); 
       i != shortRead.end(); 
       i++)
    {
      delete *i;
    }

  // END of TEST
  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{Chains and chain manager}
<<tux-chain.cpp>>=
#include <iomanip>
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);
  f << std::scientific;// << std::fixed;
  f << std::setprecision(std::numeric_limits<double>::digits);
  //f << std::setprecision(std::numeric_limits<int>::max());
  YAML::Emitter out;

  // Add your source codes.
  // Read in a YAML file.
  Fixed m;
  // Read in a file: the same code as tux-fixed.cpp.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; out << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  const YAML::Node& node = doc["Reads"];
  vector<Reads*> shortRead;
  Reads* r;
  for (unsigned int i = 0; i < node.size(); i++)
    {
      r = new Reads(i);
      doc["Reads"] >> *r;
      shortRead.push_back(r);
    }
  fin.close();

  // Create a chain.
  Chain mChain (&m, shortRead);

  // Run the chain.
  unsigned int s = 0;
  while (s < m.mMcmcLength) 
    {
      mChain.step (m.mMcmcThin);
      s += m.mMcmcThin;
      if (m.mMcmcBurnin < s)
        {
          f << mChain;
          // mChain.sample ();
        }
    }

  // Delelet data.
  for (vector<Reads*>::iterator i = shortRead.begin(); 
       i != shortRead.end(); 
       i++)
    {
      delete *i;
    }

  // END of TEST
  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

<<tux-cm.cpp>>=
#include <iomanip>
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);
  f << std::scientific;// << std::fixed;
  f << std::setprecision(std::numeric_limits<double>::digits);
  //f << std::setprecision(std::numeric_limits<int>::max());
  YAML::Emitter out;

  // Create a chain manager.
  ChainManager mChainManager ("fixed.yaml");
  mChainManager.createChain (3);
  mChainManager.setChainid (1,3);
  unsigned int s = 0;
  while (s < 10) 
    {
      mChainManager.step (1);
      s += 1;
      if (2 < s)
        {
          mChainManager.sample ();
        }
    }

  // END of TEST
  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{Summary}

<<tux-sum.cpp>>=
#include <iomanip>
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"

#include "tuxSummarizer.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);
  f << std::scientific;// << std::fixed;
  f << std::setprecision(std::numeric_limits<double>::digits);
  //f << std::setprecision(std::numeric_limits<int>::max());
  YAML::Emitter out;

  // Create a chain manager.
  Summarizer mSum ("fixed.yaml");
  mSum.do ();
  f << mSum;

  // END of TEST
  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{MPI}

\end{document}
