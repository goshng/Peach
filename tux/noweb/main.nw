\documentclass{article}
\usepackage[T1]{fontenc}                                                        
\usepackage[latin9]{inputenc}                                                   
\usepackage{mdwlist}           % less spaces between items
\usepackage{bm}                % bold math letters
\usepackage{noweb}
\usepackage{fancyvrb}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in}
\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\parskip}{1ex}

\newcommand{\Cclass}[1]{class \textit{#1}}
\newcommand{\Cmember}[1]{member \textit{#1}}
\newcommand{\Cmethod}[1]{method \textit{#1}}
\newcommand{\Cpackage}[1]{package \textit{#1}}
\newcommand{\program}[1]{\texttt{#1}}
\newcommand{\Cfile}[1]{\texttt{#1}}

\begin{document}
\raggedright

\title{Inferring transcript boundaries and expression levels using RNA-seq}
\author{Sang Chul Choi\\
Department of Biological Statistics and Computational Biology, \\
Cornell University,\\
Ithaca, NY 14850}

\maketitle

\tableofcontents

\newpage
\section{Introduction}

Users comand \program{tux} via \Cclass{Mananger}.

We use \Cclass{Mcmc} to run a number of chains. A chain is a cold chain, and the
rest of chains are hot chains. The \Cclass{Mcmc} coordinates multiple
simultaneous runs of chains. We need to know what chains are running in which
machine. This can be done using MPI. Each chain needs to know what temperature
to use. The \Cclass{Mcmc} contains \Cmember{temperature} and \Cmember{chainid}
for accessing chains. 

The \Cclass {Manager} creates a list of temperature using \Cclass{c\_hlinear},
\Cclass{c\_hgeometric}. It sets \Cmember{chainid} as a sequence of non-negative
integers. It also sets values of \Cmember{temperature}. We need to set up a list
of chains before running them. The \Cclass{Mcmc} creates a list of chains and
executes each chain one at a time using \Cmethod{step}. We have two classes for
chains. One is for a chain that does the sampling job, and the other is for a
chain manager. The \Cclass{Mcmc}'s \Cmethod{step} commands all of the chains to
move a finite number of steps in their own process. The chain manager will be
run in a separate process. We may need Message Passing Interface (MPI), which
is an application interface that allows processes to communicate by sending and
receiving messages. In essence, it facilitates communication when multiple
computers/processors/cores are performing distributed calculations.

The \Cclass{Mcmc} sends a message of \Cmethod{step} to \Cclass{ChainManager},
which in turn sends a message of \Cmethod{step} to a list of \Cclass{Chain}.
A process owns one \Cclass{ChainManager}, which communicates with \Cclass{Mcmc}.
After finishing all of the messages of \Cmethod{step} in the list of
\Cclass{Chain}, the \Cclass{ChainManager} sends a message to \Cclass{Mcmc} to
check whether it can continue to move steps of the chains. The \Cclass{Mcmc}
would swap chains by receciving necessary values from \Cclass{ChainManager}. 

Members of \Cclass{Manager}:
\begin{enumerate*}
\item Data member
\item mNumberProcess; The program should know the number of CPUs to create
resources for jobs.
\item Method
\item void show();
\item void model();
\item void mcmc(int r = 0); a main MCMC loop. 
\item void summarize();
\item void save();
\item void load();
\item void help();
\end{enumerate*}

Members of \Cclass{Mcmc}:
\begin{enumerate*}
\item vector<unsigned int> chainid; 
\item vector<unsigned int> mNumberChainPerProcess; e.g., c(3,3,2) 
\item vector<unsigned int> mAccumulateNumberChain; e.g., c(0,3,6,8)
\item vector<double> likelihoodPrior; the sum of likelihood and prior for each
chain. 
\item unsigned int lenChain; total length of a chain
\item unsigned int lenBurnin; length of a burn-in 
\item unsigned int lenThin; length of a sampling frequency
\item unsigned int lenSwap; length of a chain swapping frequency
\item unsigned int lenSwapTry; the number of attempts of swapping two chains.
This value can be smaller than ${n \choose 2}$ where $n$ is the number of
chains.
\item
\item The followings are nested structures:
\item struct c\_msg1 mMessage;
\item 
\item The following methods are public:
\item Mcmc ();
\item \~{}Mcmc ();
\item int numberChainPerProcess (); computes allocated numbers of chains for
each process
\item int createChainManager (unsigned int r);
\item int step (unsigned int n);
\item int swap (); swaps chains temperatures
\item int sample (); 
\item int save ();
\item int load ();
\item
\item The following methods are private:
\item int swapChains (); uses values from all of the chains to arrange chain
temperatures - called by \Cmethod{swap}
\item double swapWeight (unsigned int, unsigned int); computes an acceptance
ratio for swapping two chains - called by \Cmethod{swapChains}
\end{enumerate*}

\Cclass{c\_msg1} is used to send a message to the rank 0 process:
\begin{enumerate*}
\item unsigned int processid; the ordered ID of a process
\item unsigned int chainid; the designated chain ID
\item double likelihoodPrior; the sum of likelihood and prior of a chain
\end{enumerate*}

The \Cmethod{swap} for the rank 0 process waits for the rest of processes to
finish their \Cmethod{step}. Positively ranked processes send the rank 0 process
a message of likelihood and other values. The rank 0 process uses all of the
likelihood values to attempt swapping of chain temperature values. It finishes
the chain swapping by sending the rest of positively ranked processes a message
of the chosen temperature.
The \Cclass{ChainManager} sends the chain ID, and the sum of likelihood and
prior to the rank 0 process for each of the chains that it manages. The rank 0
process fills \Cmember{chainid} and \Cmember{likelihoodPrior} with those
received values. Note that the two vectors index chains managed by
\Cclass{ChainManager}. An element of \Cmember{chainid} is used to reference
a temperature value. Let us read the \Cmethod{swap} in detail.
Whatever the ranks are, \Cclass{ChainManager} calls \Cmethod{chainid} and
\Cmethod{likelihoodPrior} to get chain IDs, and sums of likelihood and prior for
the chains managed by the \Cclass{ChainManager} of the current rank process.
We start with the rank 0 process. We need sums of likelihood and prior from each
chain. We receive a message from each chain. Because \Cclass{ChainManager}
can contains multiple chains, we have two loops: one for the
\Cclass{ChainManager} and another for each chain in the \Cclass{ChainManager}.
A message is stored \Cmember{mMessage}. The \Cmember{processid} of 
\Cmember{mMessage} is the ordered index of a process that runs one chain. Do not
be confused by the name process. For example, if 
\Cmember{mNumberChainPerProcess} is c(3,3,2), the process indices run from 0 to
7. Processes are different in the assigned chain index, which is stored in
\Cmember{chainid} of \Cmember{mMessage}. We use \Cmember{processid} to index 
\Cmember{mChainid} and \Cmember{mLikelihoodPrior}. Now that we have chain
IDs, and sums of likelihood and prior. We call \Cmethod{swapChains}, and
rearrange \Cmember{mChainid}. 
We need to configure chains with the rearranged chain IDs. For the rank 0
process we find the chain IDs and save them in a vector of size being equal to
the number of chains in the rank 0 process. We send messages to the rest of
positively ranked processes. Let us turn to a postively ranked process. Note
that we have already stored chain IDs and sums of likelihood and prior. We send
those to the rank 0 process, and wait and receive messages from the rank 0
process. After getting all of the chain IDs we use \Cclass{ChainManager} to call
\Cmethod{setChainid}.


Members of \Cclass{ChainManager}:
\begin{enumerate*}
\item The followings are data members:
\item vector<Chain> chain; a list of chains
\item The followings are public:
\item ChainManager (); creates a single chain
\item ChainManager (unsigned int n); creates $n$ chains
\item void delete\_pointed\_to (T* p); function template to delete chains
\item void chainid (vector<unsigned int>\&); returns a vector of Chain IDs from
the list of chains
\item void setChainid (vector<unsigned int>\&); assigns chain IDs 
\end{enumerate*}

Members of \Cclass{Chain}:
\begin{enumerate*}
\item Data Member:
\item unsigned int chainid; the ID of a chain
\item double likelihoodPrior; the sum of likelihood and prior
\item double mBeta; the temperature 
\item unsigned int mStep; the number of steps
\item Parameter* mTxBoundaries; a set of transcript boundaries
\item Parameter* mTxExpression; a set of transcript expression
\item Data* mTxData; a set of short reads alignment data
\end{enumerate*}

The \Cclass{Chain} owns objects from \Cclass{RandomVariable}:
\Cmember{mTxBoundaries}, \Cmember{mTxExpression}, and \Cmember{mTxData}. The
first two \Cclass{Parameter} objects change their contents through
\Cclass{Mover} objects that are managed by \Cclass{MoverManager}. Methods of
\Cclass{Chain} would create \Cclass{Parameter} objects. Additionally,
\Cclass{Mover} objects are created in methods of \Cclass{Chain}. Objects of
\Cclass{Mover}'s subclasses such as \Cclass{MoverTxBoundaries} are allowed to
access \Cclass{Parameter} members in \Cclass{Chain}. We do this by giving
\Cclass{MoverTxBoundaries} a pointer to the object of \Cclass{TxBoundaries}.
Let us check how we could propose a new state of \Cclass{TxBoundaries}, and
accept or reject it in \Cclass{MoverTxBoundaries}. Do this 
in \Cclass{MoverTxExpression} as well.

\Cclass{MoverTxBoundaries} \Cmethod{step}
\begin{Verbatim}[frame=lines,framesep=5mm]
  // 1. We choose a subset of the K segments.
  // 1.1 We choose a site of the L sites.
  // 1.2 We choose a length from a distribution or fixed value.
  // 1.3 Group segments in the chosen region.
  // 2. Find the lengths of the subset of the segments.
  // 2.1 Sum the lengths.
  // 2.2 Compute the fractions of the legnths with respect to the sum of the
  // length.
  // 2.3 Multiply the factions by a pseudo-concentration parameter.
  // 3. Use the multiplied factions as a set of concentration parameters to
  // sample a new set of random variates from the Dirichlet distribution.
  // 3.1 Multiply the sum of the lengths of the subset to recover a new set of
  // segments. 
  // 3.2 Adjust legnths of the segments so that legnths fit the remaining
  // segments.
  // 4. Compute acceptance probability by using likelihood, priors, and
  // Metropolis-Hastings ratio.
  // 4.1 The priors are p(mu|s)p(s)=p(mu)p(s). This value does not change
  // before and after the proposal.
  // 4.2 Count reads on the subset and compute p(x|theta*)/p(x|theta).
  // Optimization of the likelihood ratio can be done by using forms of the
  // negative binomial probability functions.
  // 4.3 Compute the Metropolis-Hastings ratio using the proposal.
\end{Verbatim}


TxBoundaries is created in a method of class Chain.
MoverTxBoundaries should be also created in a method of class Chain.
Then, Chain can connect its Parameters and Data to MoverTxBoundaries.
It passes the connected MoverTxBoundaries to MoverManager.

The chain uses \Cclass{Probability} and \Cclass{RandomVariable} to change the
value of \Cclass{Parameter}. The \Cclass{Data} is a \Cclass{RandomVariable} that
does not change its value. The \Cclass{Probability} is not a part of the chain. 
The chain must contain objects of \Cclass{RandomVariable}. The \Cclass{Mover} is
applied to \Cclass{ChainManager} or \Cclass{Mcmc}. The \Cclass{Chain} may have
access to \Cclass{Mover}. There are multiple possible movers of parameters. The
\Cclass{Chain} is manipulated to switch from one mover to another. Each step
multiple movers are chosen to be applied to \Cclass{Chain}. The \Cclass{Mover}
may have access to \Cclass{Probability}: it could use some \Cclass{Probability}
to replace a current state of \Cclass{Parameter} with another. The
\Cclass{Chain} has an object of \Cclass{MoverManager}, which manages several
\Cclass{Mover} objects. The \Cclass{MoverManager} is operational in that it
returns a \Cclass{Mover} among the set of \Cclass{Mover} objects with
multinomial probability.

Members of \Cclass{MoverManager}:
\begin{enumerate*}
\item Data Member:
\item vector<Mover*> mMover; a set of \Cclass{Mover} objects.
The \Cclass{MoverManager} owns the \Cclass{Mover} object elements in
\Cmember{mMover}. The \Cmethod{add} allocates the memory of a \Cclass{Mover}
object. The \Cclass{MoverManager}'s destructor must deallocate the memory.
\item gsl\_ran\_discrete\_t* mGslRanDiscrete; a lookup tabl for the discrete
random number generator
\item Method:
\item MoverManager (); 
\item ~MoverManager ();
\item void add (const unsigned int, const double); a mover of ID with weight
\item Mover* choose ();
\end{enumerate*}

A \Cclass{Mover} may contain many different things. We would give an identifier
for a mover. A mover should be subclassed from the abstract \Cclass{Mover}.  

The \Cclass{Probability} is tightly linked with \Cclass{RandomVariable}. Two
sets of random variables are considered: one that is concerned, and the other
that is conditioned. We can sample random variates of the former set from
\Cclass{Probability}. We can compute the probability density for a specific
set of random variates. The set of random variables that are conditioned is
optional. We use \Cclass{Probability} for non-standard valued random variables.
We would use simpler functions or classes for sampling a random variate from a
uniform. 

Let us consider usages of \Cclass{Probability}. We want a negative binomial with
two parameters: mean and variance. The probability of a segment configuration is
distributed as a uniform with a probability of $\frac{1}{{L-1 \choose K-1}}$
where $L$ is the length of a genome where we have $K$ segments. A $k$-th segment
boundary is between $c_{k-1}+1$ and $c_k$ inclusively. The $c_0$ is 0, and $c_K$
is $L$. We impose a Dirichlet on expression level $\bm{\mu}$. An expression
level of $k$-th segment is $\mu_k$, which is $\delta_k M$ where $M$ is the total
expression level of a RNA-seq experiment. We should give a ``very''
uninformative prior on $\bm{\mu}$ using a set of values $\bm{\alpha}$. We use a
lagarithmic scale of $\bm{\mu}$. Given the prior we start with $\bm{s}^{(0)}$
and $\bm{\mu}^{(0)}$. These two values are sampled from each of their prior
distribution. The boundary value, $\bm{s}^{(0)}$, consists of
$\{c_{k}\}_{k=1\ldots K-1}$ where $c_k$ is the end position of $k$-th segment.
We need $K-1$ positive values. The expression value, $\bm{\mu}^{(0)}$, consists
of $K$ real values. We use $\bm{\delta}^{(0)}$ which is a set of fractions, and
only need $K-1$ values. We convert them in logarithmic scale. Let us go to
\Cclass{TxBoundaries} and \Cclass{TxExpression}, which are \Cclass{Parameter},
which in turn is \Cclass{RandomVariable}. A random variate is created from a
probability distribution. A class of \Cclass{Probability}, or a probability of a
set of transcript boundaries, would create an object of \Cclass{TxBoundaries}.
Let us create a probability of a set of transcript boundaries:
\Cclass{ProbTxBoundaries}. 

Members of \Cclass{Probability}
\begin{enumerate*}
\item Data members:
\item vector<RandomVariable*> mV; a list of random variables
\item vector<RandomVariable*> mC; a list of conditioning random variables
\item
\item virtual double d () = 0; a value of a probability
\item virtual RandomVariable* r () = 0; a random variate
\end{enumerate*}

Members of \Cclass{ProbTxBoundaries}
\begin{enumerate*}
\item Data members:
\item double d (); a value of a probability of a transcipt boundaries
\item RandomVariable* r (); a random variate of a transcript boundaries
\end{enumerate*}

Members of \Cclass{RandomVariable}
\begin{enumerate*}
\item Data members:
\end{enumerate*}

Members of \Cclass{Parameter}
\begin{enumerate*}
\item Data members:
\end{enumerate*}

Members of \Cclass{TxBoundaries}
\begin{enumerate*}
\item Data members:
\item vector<unsigned int> mC; the end position of $c_k$ where $k$ runs from 0
to $K$. $c_0$ is 0, and $c_K$ is $L$. \Cmember{mC} runs from 0 to $K-1$. The
$0$-th element is $c_1$, and $K-1$-th element is $c_K$. 
\end{enumerate*}
The \Cclass{TxBoundaries} object is created by \Cclass{ProbTxBoundaries}.

Members of \Cclass{ProbTxBoundaries}
\begin{enumerate*}
\item Data members:
\item unsigned int mL; the length of a genome
\item unsigned int mK; the number of segments
\item Method
\item double d (); logarithmic value of $1/{(L-1) \choose (K-1)}$
\item RandomVariable* r (); a random variate of \Cclass{TxBoundaries} object
\end{enumerate*}

Members of \Cclass{Data}
\begin{enumerate*}
\item vector<unsigned int> mCount; number of counts of reads at the position. We
only consider 5' end positions of short reads to count. 
\end{enumerate*}

We would need to read and write \Cclass{RandomVariable} from and to a file using
YAML. We have a likelihood that is used to compute the likelihood and to sample
data given parameters.

Members of \Cclass{Data}
\begin{enumerate*}
\item  unsigned int mL; the length of the genome
\item  unsigned int mK; the number of segments
\item  double mM; a sequencing depth
\item  vector<double> mSizeFactor; size factors of all of J samples
\item  vector<double> mDelta; fractions of short reads on mK segments
\item  vector<double> mSigma; fractions of mK segment boundaries
\end{enumerate*}

Global variables
\begin{enumerate*}
\item const gsl\_rng *gGslRng; the main function calls MPI\_Init function to create
processes. Prior to that function call we should create as many seeds as
processes.
\end{enumerate*}

We borrow \Cfile{gtypes.h} from gnome's \Cfile{glib/gtypes.h}. 

Main function
\begin{enumerate*}
\item OPT\_MCMC: creates multiple random seeds using a single seed.
\end{enumerate*}

We have a number of boundaries. We can compute the average number of times a
boundary exists to the right of a site. We compute average expression level for
each site. We do this using the posterior samples of boundaries and expression
levels. Use \Cclass{Summary} and \Cclass{Summarizer}. Multiple files should be
handled by \Cclass{Summarizer} because MPI processors create their own output
files. 

The \Cclass{System} inspects the local computer system. What do we need to know?
We need to know the number of CPUs, the size of memory, the number of computes
nodes, the speed of CPUs, etc.

\section{Compilation}
Build a debug version using CMake.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ cd output/src
$ mkdir debug
$ cd debug
$ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ CC=openmpicc CXX=openmpic++ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ openmpirun -n 2 tux mcmc
$ make
$ make VERBOSE=1
$ cd ..;rm -rf b;mkdir b;cd b;cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ cd ../../..;./run 2;cd output/src;rm -rf b;mkdir b;cd b;cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug;make
\end{Verbatim}

\section{Code}

\subsection{Tux classes}

\begin{Verbatim}[frame=lines,framesep=5mm]
Manager - Dispatches user commands
  show - shows states of data, model, mcmc, and others
  model - sets model parameters
  mcmc - executes MCMC to sample from the posterior
  summarize - summarizes a posterior sample 
  save - saves the current state of data, model, mcmc, and others to a file
  load - loads a state of data, model, mcmc, and others from a file
  help - shows commands and their usages

Mcmc - Command MCMC
  show - shows a state of MCMC
  step - samples a next set of parameter values
  save - saves a current state of MCMC
  load - loads a state of mcmc from MCMC parts of a file
  burn - explores a posterior distribution without saving states of MCMC
  sample - continues to sample parameter values till a next save of a MCMC state
  swap - swaps chains of different temparatures

ChainManager - A controler of Markov chains
  step - proceeds to a next step of the chain
  save - saves a current state of the chain
  load - laods a state of a chain 
  temperature - temperature of the chain
  
Chain - A Markov chain of parameters
  step - proceeds to a next step of the chain
  save - saves a current state of the chain
  load - laods a state of a chain 
  temperature - temperature of the chain
  
Model - Command Model
  show - shows a state of model
  save - saves a current state of model
  load - loads a state of model

System - Computer system configuration
  show - shows info of CPUs, GPUs, memory, compute nodes

Help - Command help
  show - shows help messages by reading messages

Memory - Customized memory management

Probability - Probability distribution
  rv - add a set of random variables
  conditionalRv - add a set of conditional random variables
  d - computes density of the distribution
  r - generates random deviates of the distribution
  logD - computes log of density of the distribution

Likelihood - A probability of data given parameters
Posterior - A probability of parameters given data
Prior - A probability of paramters
Proposal - A probability of a set of parameters given another

ProbabilityRatio - A ratio of probabilities

RandomVariable - Random variables; e.g., data, parameters

Mover - Proposal of a new set of parameters

MoverTxBoundaries - Proposal of transcript boundaries
MoverTxExpression - Proposal of transcript expression

Data - A random variable that does not change

Reads - A data of short reads mapped on a genome

Parameter - A random variable that can vary

Temperature - A parameter of chain IDs 
TxBoundaries - A parameter of transcript boundaries
TxExpression - A parameter of transcript expression levels

Summarizer - Command summarize of chains of posterior samples
  show - shows a state of summarization
  do - computes summary of posterior samples
  save - saves a current state of the summary
  load - loads a state of a summary

Summary - Summary of chains of posterior samples for a parameter
  mean - computes mean values
  variance - computes variance to quantify uncertainty
  autocorrelation - computes autocorrelation
  save - saves a current state of the summary
  load - loads a state of a summary
\end{Verbatim}

\subsection{Copyright}
<<tux gnu copyright>>=
// This file is a part of tux.
//
// tux is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// tux is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with tux. If not, see <http://www.gnu.org/licenses/>.
@

\subsection{CMake}

Find CMake modules at the following directory:
\begin{Verbatim}[frame=lines,framesep=5mm]
/Applications/CMake\ 2.8-8.app/Contents/share/cmake-2.8/Modules/
\end{Verbatim}

To add a custom CMake package
\begin{Verbatim}[frame=lines,framesep=5mm]
cp downloads/FindReadline.cmake output/src/cmake/Modules/
http://www.vtk.org/Wiki/CMake:How_To_Find_Libraries
\end{Verbatim}

<<CMakeLists.txt>>=
cmake_minimum_required(VERSION 2.8)

PROJECT (tux)
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/Modules/")
SET (tux_SRCS 
  "tux.cpp"
  "tuxHelp.cpp"
  "tuxManager.cpp"
  "tuxModel.cpp"
  "tuxMcmc.cpp"
  "tuxChainManager.cpp"
  "tuxChain.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxData.cpp"
  "tuxSystem.cpp"
  "tuxProbability.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxSummarizer.cpp"
  "tuxSummary.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxReads.cpp"
  "tuxXyz.cpp"
  "xmalloc.c"
  "xfree.c"
)
SET (monsters_SRCS 
  "monsters.cpp"
)
SET (gsl_SRCS 
  "gsl.cpp"
)
SET (yamlEmitter_SRCS 
  "yamlEmitter.cpp"
)
SET (fileman_SRCS 
  "fileman.cpp"
  "xmalloc.c"
  "xfree.c"
)
SET (ezlogger_SRCS 
  "ezlogger.cpp"
)

# SET (CMAKE_EXE_LINKER_FLAGS "-static")
ADD_DEFINITIONS(-DHAVE_CONFIG_H) 
# SET (CMAKE_C_FLAGS_DEBUG "-Wno-write-strings -g3 -ggdb -O0")
# SET (CMAKE_CXX_FLAGS_DEBUG "-Wno-write-strings -g3 -ggdb -O0")
SET (CMAKE_C_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")
SET (CMAKE_CXX_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")

# YAML
add_library(yaml STATIC IMPORTED)
set_property(TARGET yaml PROPERTY IMPORTED_LOCATION /usr/local/lib/libyaml-cpp.a)
ADD_EXECUTABLE (monsters ${monsters_SRCS})
target_link_libraries(monsters yaml)
ADD_EXECUTABLE (yamlEmitter ${yamlEmitter_SRCS})
target_link_libraries(yamlEmitter yaml)

# GSL
ADD_EXECUTABLE (gsl ${gsl_SRCS})
find_package (GSL)
if (GSL_FOUND)
  include_directories(${GSL_INCLUDE_DIR})
  target_link_libraries (gsl ${GSL_LIBRARIES})
endif (GSL_FOUND)

# EzLogger
ADD_EXECUTABLE (ezlogger ${ezlogger_SRCS})

# Readline
# find_package (Readline)
add_library(readline STATIC IMPORTED)
set_property(TARGET readline PROPERTY IMPORTED_LOCATION /usr/local/lib/libreadline.a)
include_directories(${CMAKE_CURRENT_BINARY_DIR})
ADD_EXECUTABLE (fileman ${fileman_SRCS})
target_link_libraries(fileman readline)
target_link_libraries(fileman -ltermcap)

# TUX
SET(CMAKE_C_COMPILER openmpicc)
SET(CMAKE_CXX_COMPILER openmpicxx)
ADD_EXECUTABLE (tux ${tux_SRCS})
target_link_libraries(tux mpi readline -ltermcap)

INCLUDE (CheckIncludeFiles)
CHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)
CHECK_INCLUDE_FILES (sys/file.h HAVE_SYS_FILE_H)
CHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)
CHECK_INCLUDE_FILES (string.h HAVE_STRING_H)
CHECK_INCLUDE_FILES (stdlib.h HAVE_STDLIB_H)
CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/config.h.in ${CMAKE_CURRENT_BINARY_DIR}/config.h)

@

\subsection{Main}

<<tux.cpp>>=
<<tux gnu copyright>>
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif 
#include <iostream>
#include <algorithm>
#include <vector>
#include <mpi.h>
#include <gsl/gsl_rng.h>
#include "simpleopt/SimpleOpt.h"
#include "simpleopt/SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "rlstdc.h"
#include "xmalloc.h"
#include <readline/readline.h>
#include <readline/history.h>
#include "tuxHelp.h"
#include "tuxManager.h"
#include "tuxXyz.h"

using namespace std;
using namespace tux;
gsl_rng* gGslRng;
<<tux interative>>
<<command line>>

namespace tux {
  struct c_gslrng {
    unsigned long int operator()() {
      return gsl_ran_get (gGslRng);
    }
  } gslrngRandomNumber;
}

int 
main (int argc, char* argv[])
{
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);
  EZLOGGERFUNCTRACKER;

  const gsl_rng_type* T;
  gsl_rng_evn_setup();
  T = gsl_rng_default;
  gGslRng = gsl_rng_alloc(T);

  // Interactive Mode
  if (argc == 1)
    {
      char *line, *s;

      progname = argv[0];

      initialize_readline ();	/* Bind our completer. */

      /* Loop reading and executing lines until the user quits. */
      for ( ; done == 0; )
        {
          line = readline ("> ");

          if (!line)
            break;

          /* Remove leading and trailing whitespace from the line.
             Then, if there is anything left, add it to the history list
             and execute it. */
          s = stripwhite (line);

          if (*s)
            {
              add_history (s);
              execute_line (s);
            }

          free (line);
        }
      return 0;
    }

  // Batch Mode
  int sCommand;
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_HELP) 
            {
              Help::full ();
              return 0;
            }
          else if (args.OptionId() == OPT_VERSION) 
            {
              Help::version ();
            }
          else if (args.OptionId() == OPT_MODEL
                   || args.OptionId() == OPT_MCMC
                   || args.OptionId() == OPT_SUMMARIZE) 
            {
              sCommand = args.OptionId();
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }
  Manager m;
  m.mNumberProcess = 2;
  m.mSeed = 100;
  switch (sCommand)
    {
    case OPT_MODEL:
      cout << "Modelling ..." << endl;
      break;
    case OPT_MCMC:
      cout << "Start MCMC ..." << endl;
      
      gsl_rng_set(gGslRng,m.mSeed);
      m.mProcessSeed.resize(m.mNumberProcess); 
      generate (m.mProcessSeed.begin(), m.mProcessSeed.begin(), gslrngRandomNumber);

      int size,rank;
      int length;
      char name[80];
      MPI_Status status;
      int workerIdx;

      MPI_Init(&argc, &argv);
      MPI_Comm_rank(MPI_COMM_WORLD,&rank);
      MPI_Comm_size(MPI_COMM_WORLD,&size);
      MPI_Get_processor_name(name,&length);

      if (rank==0) 
        {
          printf("Hello MPI from the server process!\n");

          for (workerIdx=1; workerIdx<size; workerIdx++) 
            {
              MPI_Recv(name, 80, MPI_CHAR, workerIdx, 999, MPI_COMM_WORLD, &status);
              printf("Hello MPI!\n");
              printf(" message from %d of %d on %s\n", workerIdx, size, name);
            }
        } 
      else 
        {
          MPI_Send(name,80,MPI_CHAR,0,999,MPI_COMM_WORLD);
        }

      // Now we are in one of the processes.
      // Reset the gGslRng.
      gsl_rng_set(gGslRng,m.mProcessSeed.at(rank));

      m.mcmc (rank); // MCMC Command

      MPI_Finalize(); 

      break;
    case OPT_SUMMARIZE:
      cout << "Summarizing a posterior sample ..." << endl;
      break;
    }

  gsl_rng_free (gGslRng);
  return 0;
}
@

<<command line>>=
enum { 
    OPT_HELP, 
    OPT_MODEL,
    OPT_MCMC,
    OPT_SUMMARIZE,
    OPT_VERSION,
    OPT_INFILE,
    OPT_OUTFILE,

    OPT_CHAIN,
    OPT_LIKELIHOOD,
    OPT_PRIOR,
    OPT_XML,
    OPT_BUILD,
    OPT_PRINT,
    OPT_WHAT,
    OPT_REMOVE,
    OPT_FOO, 
    OPT_BAR, 
    OPT_HOGE 
};
CSimpleOpt::SOption g_rgOptions[] = {
    // ID TEXT TYPE
    { OPT_HELP, "--help", SO_NONE    },
    { OPT_HELP, "-h", SO_NONE    },
    { OPT_VERSION, "--version", SO_NONE },
    { OPT_INFILE, "-i",     SO_REQ_SEP },
    { OPT_OUTFILE, "-o",     SO_REQ_SEP },

    { OPT_FOO,  "-a",     SO_NONE    }, // "-a"
    { OPT_BAR,  "-b",     SO_NONE    }, // "-b"
    { OPT_HOGE, "-f",     SO_REQ_SEP }, // "-f ARG"
    { OPT_PRINT, "-p",     SO_REQ_SEP },
    { OPT_PRINT, "--print", SO_REQ_SEP },
    { OPT_WHAT, "-w",     SO_REQ_SEP },
    { OPT_WHAT, "--what", SO_REQ_SEP },
    { OPT_INFILE, "--infile",   SO_REQ_SEP },
    { OPT_OUTFILE, "--outfile",   SO_REQ_SEP },

    // Commands
    { OPT_MCMC, "mcmc", SO_NONE },
    { OPT_MODEL, "model", SO_NONE },
    { OPT_SUMMARIZE, "summarize", SO_NONE },

    { OPT_CHAIN, "chain", SO_NONE },
    { OPT_LIKELIHOOD, "likelihood", SO_NONE },
    { OPT_PRIOR, "prior", SO_NONE },
    { OPT_XML, "xml", SO_NONE },
    { OPT_BUILD, "build", SO_NONE },
    { OPT_REMOVE, "--remove", SO_REQ_SEP },
    SO_END_OF_OPTIONS // END
};
@

<<tux interative>>=
int com_help PARAMS((char *));
int com_model PARAMS((char *));
int com_mcmc PARAMS((char *));
int com_save PARAMS((char *));
int com_load PARAMS((char *));
int com_quit PARAMS((char *));

typedef struct {
  char *name;			/* User printable name of the function. */
  rl_icpfunc_t *func;		/* Function to call to do the job. */
  char *doc;			/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "model", com_model, "Model" },
  { "mcmc", com_mcmc, "MCMC" },
  { "save", com_save, "Saves a current state to a file" },
  { "load", com_load, "Loads a state from a file" },
  { "quit", com_quit, "Quit using Fileman" },
  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite (char *string);
COMMAND* find_command (char *name);
void too_dangerous (char *caller);
void initialize_readline ();
int execute_line (char *line);
int valid_argument (char *caller, char *arg);

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (char *s)
{
  char *r;

  r = (char *) xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

/* Execute a command line. */
int
execute_line (char *line)
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (char *name)
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (char *string)
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator PARAMS((const char *, int));
char **fileman_completion PARAMS((const char *, int, int));

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
void
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END bound the
   region of rl_line_buffer that contains the word to complete.  TEXT is
   the word to complete.  We can use the entire contents of rl_line_buffer
   in case we want to do some simple parsing.  Return the array of matches,
   or NULL if there aren't any. */
char **
fileman_completion (const char *text, int start, int end)
{
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);
  if (end == 0) { /* No code! */ }
    
  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (const char *text, int state)
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  name = commands[list_index].name;
  while (name)
    {
      list_index++;
      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
      name = commands[list_index].name;
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                       FileMan Commands                           */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
int
com_help (char *arg)
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

int
com_model (char *arg)
{
  too_dangerous ("model");
  return (1);
}

int
com_mcmc (char *arg)
{
  too_dangerous ("mcmc");
  return (1);
}

int
com_summarize (char *arg)
{
  too_dangerous ("summarize");
  return (1);
}

int
com_save (char *arg)
{
  too_dangerous ("save");
  return (1);
}

int
com_load (char *arg)
{
  too_dangerous ("load");
  return (1);
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
int
com_quit (char *arg)
{
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
void
too_dangerous (char *caller)
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (char *caller, char *arg)
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}


@

\subsection{Help}
<<tuxHelp.h>>=
<<tux gnu copyright>>
#ifndef _TUXHELP_H_
#define _TUXHELP_H_
namespace tux {
class Help {
public:
  static void full ();
  static void version ();
};
}
#endif // _TUXHELP_H_

<<tuxHelp.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxHelp.h"
using namespace std;
namespace tux {
void 
Help::full ()
{
  cout << ""
"tux Commands Manual\n"
"\n"
"NAME\n"
"   tux -- Transcripts boundaries uncertainty\n"
"\n"
"SYNOPSIS\n"
"   tux [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The program implements a statistical method of inferring uncertainty\n"
"   of transcript boundaries using RNA-seq data.\n"  
"   The method is described in Choi (2012).\n"
"\n"
"   General options:\n"
"      -h --help -?\n"
"         Shows this help message.\n"
"      --version\n"
"         Shows the version.\n"
"      -i --infile [INFILE]\n"
"         Reads in an input file.\n"
"      --type\n"
"         Input and output files are in XML format.\n" 
"\n"
"   Commands:\n"
"      mcmc\n"
"         Samples recombinant trees.\n"
"      summarize\n"
"         Summarizes a posterior sample of recombinant trees.\n"
"      likelihood\n"
"         Computes the likelihod of a recombinant tree given data.\n"
"      prior\n"
"         Computes the prior of a recombinant tree given model parameters.\n"
"      xml\n"
"         Reads and writes XML files.\n"
"      build\n"
"         Reads an XML file to build a recombinant tree.\n"
"      chain\n"
"         Uses chains.\n"
"\n"
"   Command build options:\n"
"      -w --what [NUMBER]\n"
"         1 Build a recombiant tree by reading the XML file that is\n"
"           created by xml --print 5 -o tuxrectree.xml\n"
"         2 Build a list of events by reading the XML file that is\n"
"           created by xml --print 6 -o tuxevent.xml\n"
"      --remove [NUMBER]\n"
"         Remove a recombinant edge.\n"
"\n"
"   Command xml options:\n"
"      -p --print [NUMBER]\n"
"         1 Default setting\n"
"         2 fastsimcoal file\n"
"         3 tux input file\n"
"         4 tux output file\n"
"         5 tux recombinant tree file\n"
"         6 tux event file\n"
"         7 tux chain state file\n"
"\n"
"   Files:\n"
"      INFILE\n"
"         Different commands can be combined with different formats of input\n"
"         files. An input file with command xml is an XML file.\n" 
"      OUTFILE\n"
"\n"
"   Usages:\n"
"      tux xml --infile INFILE\n"
"         Reads in an XML file, and prints it out to standard output.\n"
"      tux xml --print 1 -o default.xml\n" 
"         Prints the tux default setting.\n"
"      tux likelihood -i tuxoutput.xml\n"
"         Computes the likelihood of data given a recombinant tree.\n"
"      tux xml --print 5 -o tuxrectree.xml\n"
"         Creates a recombinant tree in XML format\n"
"      tux build -w 1 --infile tuxrectree.xml\n"
"         Build a recombinant tree using an XML file.\n"
"      tux build -w 1 --remove 1 --infile tuxrectree.xml\n"
"         Build a recombinant tree using an XML file, and remove the edge.\n"
"      tux build -w 1 --remove 1 --infile tuxrectree.xml -o partialtree.xml\n"
"         Build a recombinant tree using an XML file, and remove the edge.\n"
"      tux xml --print 6 -o tuxevent.xml\n"
"         Creates a list of events in XML format\n"
"      tux build -w 2 --infile tuxevent.xml\n"
"         Build a list of events using an XML file.\n"
"      tux xml --print 7\n"
"         Build a list of events using an XML file.\n"
"      tux xml --print 3 -o tuxinput.xml\n" 
"         Prints the tux input file.\n"
"      tux chain --infile tuxinput.xml\n"
"         Test a chain.\n"
"\n"
"AUTHOR\n"
"   Written by Sang Chul Choi\n"
"\n"
"REPORTING BUGS\n"
"   Report bugs to google group of Transcript Boundaries Uncertainty\n"
"   at http://groups.google.com/group/transcript-boundaries-uncertainty\n"
"\n"
"VERSION\n"
"   tux 1.0 - Build IMRBUILDDATETIME\n"
"\n"
"COPYRIGHT\n"
"   Copyright (C) 2012- Sang Chul Choi\n"
"   See the source for copying conditions.\n"
"   There is NO warranty; not even for MERCHANTABILITY\n"
"\n"
"tux 1.0\n"
"";
}
void 
Help::version ()
{
  cout << ""
"tux 1.0 - Build IMRBUILDDATETIME\n"
"Written by Sang Chul Choi.\n"
"\n"
"Copyright (c) 2012- Sang Chul Choi\n"
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
"";
}
}
@

\subsection{Data serialization: YAML}
<<monsters.cpp>>=
#include "yaml-cpp/yaml.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

// our data types
struct Vec3 {
   float x, y, z;
};

struct Power {
   std::string name;
   int damage;
};

struct Monster {
   std::string name;
   Vec3 position;
   std::vector <Power> powers;
};

// now the extraction operators for these types
void operator >> (const YAML::Node& node, Vec3& v) {
   node[0] >> v.x;
   node[1] >> v.y;
   node[2] >> v.z;
}

void operator >> (const YAML::Node& node, Power& power) {
   node["name"] >> power.name;
   node["damage"] >> power.damage;
}

void operator >> (const YAML::Node& node, Monster& monster) {
   node["name"] >> monster.name;
   node["position"] >> monster.position;
   const YAML::Node& powers = node["powers"];
   for(unsigned i=0;i<powers.size();i++) {
      Power power;
      powers[i] >> power;
      monster.powers.push_back(power);
   }
}

int main()
{
   std::ifstream fin("monsters.yaml");
   YAML::Parser parser(fin);
   YAML::Node doc;
   parser.GetNextDocument(doc);
   for(unsigned i=0;i<doc.size();i++) {
      Monster monster;
      doc[i] >> monster;
      std::cout << monster.name << "\n";
   }

   return 0;
}
@

\subsection{YAML Emitter}
<<yamlEmitter.cpp>>=
#include "yaml-cpp/yaml.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
int main()
{
  YAML::Emitter out;
  out.SetIndent(8);                                                               

  out << "Hello, World!";

  out << YAML::BeginSeq;
  out << "eggs";
  out << "bread";
  out << "milk";
  out << YAML::EndSeq;

  out << YAML::BeginMap;
  out << YAML::Key << "name";
  out << YAML::Value << "Ryan Braun";
  out << YAML::Key << "position";
  out << YAML::Value << "LF";
  out << YAML::EndMap;

  out << YAML::BeginMap;
  out << YAML::Key << "name";
  out << YAML::Value << "Barack Obama";
  out << YAML::Key << "children";
  out << YAML::Value << YAML::BeginSeq << "Sasha" << "Malia" << YAML::EndSeq;
  out << YAML::EndMap;

  out << YAML::Literal << "A\n B\n  C";

  out << YAML::Flow;
  out << YAML::BeginSeq << 2 << 3 << 5 << 7 << 11 << YAML::EndSeq;

  out << YAML::BeginMap;
  out << YAML::Key << "method";
  out << YAML::Value << "least squares";
  out << YAML::Comment("should we change this method?");
  out << YAML::EndMap;

  out << YAML::BeginSeq;
  out << YAML::Anchor("fred");
  out << YAML::BeginMap;
  out << YAML::Key << "name" << YAML::Value << "Fred";
  out << YAML::Key << "age" << YAML::Value << "42";
  out << YAML::EndMap;
  out << YAML::Alias("fred");
  out << YAML::EndSeq;
   
  std::vector <int> squares;
  squares.push_back(1);
  squares.push_back(4);
  squares.push_back(9);
  squares.push_back(16);

  std::map <std::string, int> ages;
  ages["Daniel"] = 26;
  ages["Jesse"] = 24;

  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << ages;
  out << YAML::EndSeq;


//. Genome sequence length: 2032925
//. Short reads positions along the S. mutans genome: FASTQ001.start (1,19,20)
//. Size factors: 0.8700484 1.0158870 1.1285131
//. Number of transcripts: 
//. mean=q*s, size=q*s/d, d=a0+a1/mean
//. a0, a1 = 0.0269 6.2076
//. q is a parameter
//. mean is computed for each transcript
  out << YAML::BeginMap;
  out << YAML::Key << "GenomeLength" << YAML::Value << 2032925;
  out << YAML::Key << "SizeFactor" << YAML::Value << YAML::Flow; 
  out << YAML::BeginSeq << 0.8700484 << 1.0158870 << 1.1285131 << YAML::EndSeq;
  out << YAML::Key << "Alpha0" << YAML::Value << 0.0269;
  out << YAML::Key << "Alpha1" << YAML::Value << 6.2076;
  out << YAML::Key << "NumberK" << YAML::Value << 500;
  out << YAML::Key << "ShortReads" << YAML::Value << YAML::Flow;
  out << YAML::BeginSeq;
  // Read values from FASTQ001.start and write them to YAML.
  std::ifstream myfile ("../../../downloads/FASTQ001.start");
  if (myfile.is_open())
  {
    double value;
    while ( myfile.good() )
    {
      myfile >> value;
      out << value;
    }
    myfile.close();
  }
  // out << 0.8700484 << 1.0158870 << 1.1285131;
  out << YAML::EndSeq;
  out << YAML::EndMap;

  std::cout << "Here's the output YAML:\n" << out.c_str(); 

  return 0;
}
@

\subsection{GNU Scientific Library}
<<gsl.cpp>>=
#include <stdio.h>
#include <gsl/gsl_sf_bessel.h>
     
int main (void)
{
  double x = 5.0;
  double y = gsl_sf_bessel_J0 (x);
  printf ("J0(%g) = %.18e\n", x, y);
  return 0;
}
@

\subsection{EzLogger Library}
<<ezlogger.cpp>>=
// Example code for EZLOGGER macros
#include "ezlogger_headers.hpp"

void some_funcxx()
{
        EZLOGGERFUNCTRACKER;
}

void some_funcx()
{
        EZLOGGERFUNCTRACKER;
        some_funcxx();
}

void some_func6()
{
        EZLOGGERFUNCTRACKER;
        EZLOGGERDISPLAY_STACK;
}

void some_func5(int &x)
{
        EZLOGGERFUNCTRACKER;
        --x;
        if (x > 0)
                some_func5(x); //test recursion
        else
                some_func6();
}

void some_func4()
{
        EZLOGGERFUNCTRACKER;
        int x = 3;
        some_func5(x);
}

void some_func3()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_funcxx();
        some_func4();
}

void some_func2()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_funcxx();
        some_func3();
        some_funcxx();
}

void some_func1()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_func2();
        some_funcxx();
}

int main(int argc, char**argv)
{
        axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);
        EZLOGGERFUNCTRACKER;
        int ReturnValue = 99;
        EZLOGGER_PRG_MAIN_ARG(argc, argv);
        EZDBGONLYLOGGER_PRG_MAIN_ARG(argc, argv);
        EZLOGGERVL_PRG_MAIN_ARG(axter::log_often, argc, argv);
        int i = 123;
        std::string somedata = "Hello World";
        EZLOGGER(i);
        EZDBGONLYLOGGER(i);
        EZLOGGERVL(axter::log_often)(i);

        EZLOGGERVAR(somedata);
        EZDBGONLYLOGGERVAR(somedata);
        EZLOGGERVLVAR(axter::log_often, somedata);
        
        bool SomeConditionVar = true;
        EZLOGGERVAR(SomeConditionVar == false);
        EZDBGONLYLOGGERVAR(SomeConditionVar == false);
        EZLOGGERVLVAR(axter::log_often, SomeConditionVar == true);

        EZLOGGERVLVARIFY(axter::log_often, SomeConditionVar == false);

        EZLOGGERSTREAM << somedata << " " << i << std::endl;
        EZLOGGERSTREAM << somedata << " next line " << i << std::endl;
        EZLOGGERSTREAM2(std::cerr) << somedata << " next line " << i << std::endl;
        EZDBGONLYLOGGERSTREAM << somedata << " " << i << std::endl;
        EZDBGONLYLOGGERSTREAM << somedata << " next line " << i << std::endl;
        EZLOGGERVLSTREAM(axter::log_often) << somedata << " " << i << std::endl;
        // EZLOGGERVLSTREAM(axter::levels(axter::log_often, axter::warn, __FUNCSIG__ /*or GNU PRETTY_FUNCTION*/,"Xyz Facility")) << somedata << " " << i << std::endl;

        EZLOGGERPRINT("i = %i and somedata = %s", i, somedata.c_str());
        EZDBGONLYLOGGERPRINT("i = %i and somedata = %s", i, somedata.c_str());
        EZLOGGERVLPRINT(axter::log_often)("i = %i and somedata = %s", i, somedata.c_str());
        //Alternative method
        EZLOGGERVL(axter::log_often).cprint("i = %i and somedata = %s", i, somedata.c_str());
        EZLOGGER.cprint("i = %i and somedata = %s", i, somedata.c_str());

        if (1)
        {
                EZLOGGERMARKER;
                EZDBGONLYLOGGERMARKER;
                EZLOGGERVLMARKER(axter::log_often);
        }

        some_func1();

        return EZLOGGERVAR(ReturnValue);
}
@

\subsection{Types}
<<gtypes.h>>=
<<tux gnu copyright>>
#ifndef __G_TYPES_H__
#define __G_TYPES_H__

#include <config.h>

__BEGIN_DECLS

/* Provide type definitions for commonly used types.
 * These are useful because a "gint8" can be adjusted
 * to be 1 byte (8 bits) on all platforms. Similarly and
 * more importantly, "gint32" can be adjusted to be
 * 4 bytes (32 bits) on all platforms.
 */

typedef char   gchar;
typedef short  gshort;
typedef int    gint;
typedef long   glong;
typedef gint   gboolean;

typedef unsigned char   guchar;
typedef unsigned short  gushort;
typedef unsigned int    guint;
typedef unsigned long   gulong;

typedef float   gfloat;
typedef double  gdouble;

typedef signed char gint8;
typedef unsigned char guint8;
typedef signed short gint16;
typedef unsigned short guint16;
typedef signed int gint32;
typedef unsigned int guint32;
typedef signed long gint64;
typedef unsigned long guint64;

/* Define min and max constants for the fixed size numerical types */
#define G_MININT8	((gint8)  0x80)
#define G_MAXINT8	((gint8)  0x7f)
#define G_MAXUINT8	((guint8) 0xff)

#define G_MININT16	((gint16)  0x8000)
#define G_MAXINT16	((gint16)  0x7fff)
#define G_MAXUINT16	((guint16) 0xffff)

#define G_MININT32	((gint32)  0x80000000)
#define G_MAXINT32	((gint32)  0x7fffffff)
#define G_MAXUINT32	((guint32) 0xffffffff)

/* Portable endian checks and conversions
 *
 * glibconfig.h defines G_BYTE_ORDER which expands to one of
 * the below macros.
 */
#define G_LITTLE_ENDIAN 1234
#define G_BIG_ENDIAN    4321
#define G_PDP_ENDIAN    3412		/* unused, need specific PDP check */	


/* Basic bit swapping functions
 */
#define GUINT16_SWAP_LE_BE_CONSTANT(val)	((guint16) ( \
    (guint16) ((guint16) (val) >> 8) |	\
    (guint16) ((guint16) (val) << 8)))

#define GUINT32_SWAP_LE_BE_CONSTANT(val)	((guint32) ( \
    (((guint32) (val) & (guint32) 0x000000ffU) << 24) | \
    (((guint32) (val) & (guint32) 0x0000ff00U) <<  8) | \
    (((guint32) (val) & (guint32) 0x00ff0000U) >>  8) | \
    (((guint32) (val) & (guint32) 0xff000000U) >> 24)))

__END_DECLS
#endif /* __G_TYPES_H__ */
@

\subsection{Manager}
<<tuxManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXMANAGER_H_
#define _TUXMANAGER_H_
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
namespace tux {
class Manager {
public:
  unsigned int mNumberProcess;
  unsigned long int mSeed;
  vector<unsigned long int> mProcessSeed;
public:
  void show();
  void model();
  void mcmc(int r = 0);
  void summarize();
  void save();
  void load();
  void help();

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return current++;}
  } uniqueNumber;

  struct c_hlinear {
    double halpha;
    unsigned int i;
    c_hlinear () {i=0; halpha=0.5;}
    double operator()() {
      double v = 1.0 / (1.0 + halpha * i);
      i++; 
      return v;
    }
  } hlinearNumber;

  struct c_hgeometric {
    unsigned int numChain;
    double halpha, hbeta;
    unsigned int i;
    c_hgeometric () {i=0; numChain = 10; halpha=0.95; hbeta=0.2;}
    double operator()() {
      double v = 1 
                 - (1 - hbeta) * i 
                 * pow (halpha, (double) (numChain - 1 - i)) 
                 / (double) (numChain - 1);
      i++;
      return v; 
    }
  } hgeometricNumber;

  template <class T> struct c_print {
    void operator() (T i) {std::cout << " " << i;}
  };

};

}
#endif // _TUXMANAGER_H_

<<tuxManager.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <algorithm>
#include <vector>
#include "tuxModel.h"
#include "tuxMcmc.h"
#include "tuxManager.h"
using namespace std;
namespace tux {

void 
Manager::show()
{
  return;
}
void 
Manager::model()
{
  return;
}
void 
Manager::mcmc(int r)
{
  Mcmc m;
  m.lenChain = 5;
  m.lenBurnin = 1;
  m.lenThin = 3;
  m.lenSwap = 2;
  m.lenSwapTry = 1;
  m.mNumberProcess = 2; 
  m.mNumberChain = 5;
  m.numberChainPerProcess ();
  m.createChainManager ((unsigned int)r);

  m.mLikelihoodPrior.resize (m.lenChain);

  m.mChainid.resize(m.lenChain);                                                   
  uniqueNumber.current = 0;                                                     
  generate (m.mChainid.begin(), m.mChainid.end(), uniqueNumber);                  
//  c_print<unsigned int> printInt;                                               
//  for_each (m.chainid.begin(), m.chainid.end(), printInt);                      
//  cout << endl;                                                                 
                                                                                
  m.mTemperature.resize(m.lenChain);                                               
  hlinearNumber.halpha = 0.1;
  generate (m.mTemperature.begin(), m.mTemperature.end(), hlinearNumber);         
//  c_print<double> printDouble ;                                                 
//  for_each (m.temperature.begin(), m.temperature.end(), printDouble);           
//  cout << endl;  

  hgeometricNumber.numChain = m.lenChain;
  hgeometricNumber.halpha = 0.98;
  hgeometricNumber.hbeta = 0.7;
  generate (m.mTemperature.begin(), m.mTemperature.end(), hgeometricNumber);         
//  for_each (m.temperature.begin(), m.temperature.end(), printDouble);           
//  cout << endl;  

  unsigned int s = 0;
  while (s < m.lenChain) 
    {
      unsigned int sThin = 0;
      while (sThin < m.lenThin)
        {
          s += m.lenSwap; 
          sThin++;
          m.step (m.lenSwap);
          m.swap ();
        }
      if (m.lenBurnin < s)
        {
          m.sample ();
        }
    }
  
  return;
}
void 
Manager::summarize()
{
  return;
}
void 
Manager::save()
{
  return;
}
void 
Manager::load()
{
  return;
}
void 
Manager::help()
{
  return;
}
}
@

\subsection{Model}
<<tuxModel.h>>=
<<tux gnu copyright>>
#ifndef _TUXMODEL_H_
#define _TUXMODEL_H_
namespace tux {
class Model {
public:
  void full ();
};
}
#endif // _TUXMODEL_H_

<<tuxModel.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxModel.h"
using namespace std;
namespace tux {
void 
Model::full ()
{
  return;
}
}
@

\subsection{Mcmc}
<<tuxMcmc.h>>=
<<tux gnu copyright>>
#ifndef _TUXMCMC_H_
#define _TUXMCMC_H_
#include <vector>
#include "tuxChainManager.h"
using namespace std;
namespace tux {
class Mcmc {
public:
  unsigned int mRank; 
  vector<double> mTemperature;
  vector<unsigned int> mChainid;
  vector<double> mLikelihoodPrior;
  vector<unsigned int> mNumberChainPerProcess;
  vector<unsigned int> mAccumulateNumberChain;
  unsigned int mNumberProcess; 
  unsigned int mNumberChain;

  unsigned int lenChain;
  unsigned int lenBurnin;
  unsigned int lenThin;
  unsigned int lenSwap;
  unsigned int lenSwapTry;

  ChainManager mChainManager;

  struct c_setNumberChainPerProcess {
    unsigned int current;
    unsigned int numberChainPerProcess;
    unsigned int numberRemainingChain;
    c_setNumberChainPerProcess () {current=0;}
    unsigned int operator() () { 
      if (current++ < numberRemainingChain)
        return numberChainPerProcess + 1;
      else
        return numberChainPerProcess;
    }
  } setNumberChainPerProcess;

  template <class T> struct c_print {
    void operator() (T i) {std::cout << " " << i;}
  };

  struct c_msg1 {
    unsigned int processid;
    unsigned int chainid;
    double likelihoodPrior;
    void set (unsigned int x, unsigned int y, double z) {
      processid = x; chainid = y; likelihoodPrior = z;
    }
  } mMessage;

private:
  double swapWeight (unsigned int ci, unsigned int cj);
  int swapChains ();
public:
  Mcmc ();
  ~Mcmc ();
  int numberChainPerProcess ();
  int createChainManager (unsigned int r);
  int step (unsigned int n);
  int swap ();
  int sample ();
  int save ();
  int load ();
};
}
#endif // _TUXMCMC_H_

<<tuxMcmc.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <sstream>
#include <vector>
#include <numeric>
#include <functional>
#include <algorithm>
#include <mpi.h>
#include <cassert>
#include "ezlogger_headers.hpp"
#include "tuxMcmc.h"
#include "tuxChainManager.h"
using namespace std;
namespace tux {
Mcmc::Mcmc () {}
Mcmc::~Mcmc () {}
int 
Mcmc::numberChainPerProcess ()
{
  setNumberChainPerProcess.current = 0;
  setNumberChainPerProcess.numberChainPerProcess 
    = mNumberChain / mNumberProcess; 
  setNumberChainPerProcess.numberRemainingChain
    = mNumberChain % mNumberProcess;

  mNumberChainPerProcess.resize (mNumberProcess); 
  generate (mNumberChainPerProcess.begin(), 
            mNumberChainPerProcess.end(), 
            setNumberChainPerProcess);

  // Construct a vector of partial sum.
  vector<unsigned int>::iterator iter1;
  mAccumulateNumberChain.clear();
  mAccumulateNumberChain.push_back(0);
  unsigned int j = 0;
  for (iter1 = mNumberChainPerProcess.begin();
       iter1 != mNumberChainPerProcess.end();
       iter1++)
    {
      mAccumulateNumberChain.push_back(
        accumulate(mNumberChainPerProcess.begin(),iter1+1,0)
        );
      j++;
    }
  
//  c_print<unsigned int> printInt;                                               
//  for_each (mNumberChainPerProcess.begin(), 
//            mNumberChainPerProcess.end(), 
//            printInt);                      
//  cout << endl;                                                                 

  return 0;
}
int 
Mcmc::createChainManager (unsigned int r)
{
  mRank = r; 

  // Create chains for a chain manager.
  unsigned int n = mNumberChainPerProcess.at(r);
  mChainManager.createChain (n);
  // Set chain ID by using a vector of partial sum.
  mChainManager.setChainid (mAccumulateNumberChain[r],
                            mAccumulateNumberChain[r+1]-1);

  return 0;
}
int
Mcmc::step (unsigned int n)
{
  mChainManager.step (n);
  return 0;
}
int
Mcmc::swap ()
{
  EZLOGGERFUNCTRACKER;
  MPI_Status status;

  // Get chain IDs and likelihood prior sum values.
  vector<unsigned int> v1;
  mChainManager.chainid (v1);
  vector<double> v2;
  mChainManager.likelihoodPrior (v2);

  if (mRank==0) 
    {
      // Receive messages to fill chain IDs and sums of likelihood and prior.
      for (unsigned int workerIdx = 0; workerIdx < mNumberProcess; workerIdx++) 
        {
          for (unsigned int i = mAccumulateNumberChain[workerIdx], j = 0;
               i < mAccumulateNumberChain[workerIdx+1];
               i++, j++)
            {
              if (mRank == workerIdx)
                {
                  mMessage.set (i, v1.at(j), v2.at(j)); 
                }
              else
                {
                  MPI_Recv(&mMessage, sizeof(struct c_msg1), MPI_BYTE, workerIdx, 999, MPI_COMM_WORLD, &status);
                }
              mChainid.at(mMessage.processid) = mMessage.chainid;
              mLikelihoodPrior.at(mMessage.processid) = mMessage.likelihoodPrior;
            }
        }
     
      stringstream result;
      copy(mChainid.begin(), mChainid.end(), 
           ostream_iterator<unsigned int>(result, " "));
      EZLOGGERPRINT("Before Rank 0 chain IDs: %s",result.str().c_str());  

      // Swap chains.
      swapChains ();

      copy(mChainid.begin(), mChainid.end(), 
           ostream_iterator<unsigned int>(result, " "));
      EZLOGGERPRINT("After Rank 0 chain IDs: %s",result.str().c_str());  
      
      // Send messages
      v1.clear();
      v1.resize(mNumberChainPerProcess.at(mRank));
      for (unsigned int workerIdx = 0; workerIdx < mNumberProcess; workerIdx++) 
        {
          for (unsigned int i = mAccumulateNumberChain[workerIdx], j = 0;
               i < mAccumulateNumberChain[workerIdx+1];
               i++, j++)
            {
              unsigned int pid = mAccumulateNumberChain[workerIdx] + j;
              mMessage.set (pid, mChainid.at(pid), 0); 
              if (mRank == workerIdx)
                {
                  v1.at(mMessage.processid - mAccumulateNumberChain.at(mRank))
                    = mMessage.chainid;
                }
              else
                {
                  MPI_Send(&mMessage, sizeof(struct c_msg1), MPI_BYTE, workerIdx, 999, MPI_COMM_WORLD);
                }
            }
        }
      mChainManager.setChainid (v1);

      // Check if the message passing.
      mChainid.assign (lenChain,9);
      copy(mChainid.begin(), mChainid.end(), 
           ostream_iterator<unsigned int>(result, " "));
      EZLOGGERPRINT("After reset 0 chain IDs: %s",result.str().c_str());  
    }
  else 
    {
      // Send messages to rank 0 process
      for (unsigned int i = mAccumulateNumberChain[mRank], j = 0;
           i < mAccumulateNumberChain[mRank+1];
           i++, j++)
        {
          mMessage.set (i, v1.at(j), v2.at(j)); 
          MPI_Send(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 0, 999, MPI_COMM_WORLD);
        }

      // Wait for the decision of the rank 0 process.
      v1.clear();
      v1.resize(mNumberChainPerProcess.at(mRank));
      for (unsigned int i = mAccumulateNumberChain[mRank], j = 0;
           i < mAccumulateNumberChain[mRank+1];
           i++, j++)
        {
          MPI_Recv(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 0, 999, MPI_COMM_WORLD, &status);
          assert(mMessage.processid - mAccumulateNumberChain.at(mRank) < v1.size());
          v1.at(mMessage.processid - mAccumulateNumberChain.at(mRank))
            = mMessage.chainid;
        }
      mChainManager.setChainid (v1);
    }

  return 0;
}
int
Mcmc::sample ()
{
  return 0;
}
int
Mcmc::save ()
{
  return 0;
}
int
Mcmc::load ()
{
  return 0;
}

double
Mcmc::swapWeight (unsigned int ci, unsigned int cj)
{
  // Note that sumj is the sum of likelihood and prior.
  double sumi; 
  double sumj;
  sumi = mLikelihoodPrior.at(ci);
  sumj = mLikelihoodPrior.at(cj);
  unsigned int bi = mChainid.at(ci);
  unsigned int bj = mChainid.at(cj);
  return (mTemperature[bi] - mTemperature[bj]) * (sumj - sumi);
}

int
Mcmc::swapChains ()
{
#define  MINSWAP  0.1
#define  BETADJUST  1.414
#define  INCADJUST  1.414
#define  MINHEAT  0.0001
#define  MAXHEAT  0.2
#define  MAXINC  100
#define  MININC  0.1
#define  PAUSESWAP 1000
#define  SWAPDIST 7
  for (unsigned i = 0; i < lenSwapTry; i++)
    {
      unsigned int ci, cj;
      ci = 1;
      cj = 4;
    
//    do
//    {
//      ci = (int) (uniform () * numchains);
//    } while (ci < 0 || ci >= numchains);
//    
//    if (numchains < 2*SWAPDIST + 3)
//    {
//      cjmin = 0;
//      cjrange = numchains;
//    }
//    else
//    {
//      cjmin = IMAX(0,ci-SWAPDIST);
//      cjrange = IMIN(numchains, ci+SWAPDIST) -cjmin;
//    }
//    do
//    {
//      cj = cjmin + (int) (uniform () * cjrange);
//    } while (cj == ci || cj < 0 || cj >= numchains);
//
//    if ((ci == 0 && cj == 1) || (ci == 1 && cj == 0))
//      sw01d++;
//    if ((ci == 1 && cj == 2) || (ci == 2 && cj == 1))
//      sw12d++;
//    if (ci < cj)
//    {
//      swapcount[cj][ci]++;
//    }
//    else
//    {
//      swapcount[ci][cj]++;
//    }

      double metropolishastingsterm = swapWeight (ci, cj);
      metropolishastingsterm = 1;
      if (metropolishastingsterm >= 0)
          //|| metropolishastingsterm > uniform ())
        {
          unsigned int t = mChainid.at(ci);
          mChainid.at(ci) = mChainid.at(cj); 
          mChainid.at(cj) = t;
        }
//    {
//
//      swapptr = C[ci];
//      C[ci] = C[cj];
//      C[cj] = swapptr;
//      if (ci < cj)
//
//      {
//        swapcount[ci][cj]++;
//      }
//      else
//      {
//        swapcount[cj][ci]++;
//      }
//      if ((ci == 0 && cj == 1) || (ci == 1 && cj == 0))
//        sw01++;
//      if ((ci == 1 && cj == 2) || (ci == 2 && cj == 1))
//        sw12++;
//      if (ci == 0 || cj == 0)
//        swap0ok |= 1;
//    }
  }
  return 0;
}
}
@

\subsection{ChainManager}
<<tuxChainManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXCHAINMANAGER_H_
#define _TUXCHAINMANAGER_H_
#include <vector>
#include "tuxChain.h"
using namespace std;
namespace tux {
class Chain;
class ChainManager {
public:
  vector<Chain*> mChain;
public:
  ChainManager ();
  void createChain (unsigned int);
  ~ChainManager ();
  void step (unsigned int);
  void setChainid (unsigned int, unsigned int);
  void setChainid (vector<unsigned int>& v);
  void chainid (vector<unsigned int>&);
  void likelihoodPrior (vector<double>&);

  struct c_unique {
    Chain* operator() () {return new Chain;}
  } uniqueChain;

  struct c_step {
    unsigned int n;
    void operator() (Chain *i) { i->step (n);}
  } stepChain;

//  struct c_setStep {
//    unsigned int mStep;
//    void operator() (Chain *i) { i->mStep = mStep;}
//  } setStepChain;
};
}
#endif // _TUXCHAINMANAGER_H_

<<tuxChainManager.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <algorithm>
#include <vector>
#include <cassert>
#include "tuxChain.h"
#include "tuxChainManager.h"
#include "ezlogger_headers.hpp"
using namespace std;
namespace tux {

template <typename T>
void delete_pointed_to (T* p)
{
  delete p;
}
ChainManager::ChainManager ()
{
}
void 
ChainManager::createChain (unsigned int n)
{
  mChain.resize (n);
  generate (mChain.begin(), mChain.end(), uniqueChain);
}
ChainManager::~ChainManager ()
{
  for_each (mChain.begin(), mChain.end(), delete_pointed_to<Chain>);
}
void 
ChainManager::step (unsigned int n)
{
  // Send step messages to all of the managed chains. 
  stepChain.n = n;
//  for_each (mChain.begin(), mChain.end(), setStepChain);
  for_each (mChain.begin(), mChain.end(), stepChain);
  return;
}
void 
ChainManager::setChainid (unsigned int s, unsigned int e)
{
  cout << "s: " << s << ", e: " << e << ", size: " << mChain.size() << endl;
  assert (e - s + 1 == mChain.size());
  vector<Chain*>::iterator iter1;
  unsigned int i = 0;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      (*iter1)->chainid = s + i;
      i++;
    }
}
void 
ChainManager::setChainid (vector<unsigned int>& v)
{
  assert (v.size() == mChain.size());
  vector<Chain*>::iterator iter1;
  vector<unsigned int>::iterator iter2;
  for (iter1 = mChain.begin(), iter2 = v.begin();
       iter1 != mChain.end();
       iter1++, iter2++)
    {
      (*iter1)->chainid = *iter2;
    }
}
void 
ChainManager::chainid (vector<unsigned int>& v)
{
  vector<Chain*>::iterator iter1;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      v.push_back((*iter1)->chainid);
    }
}
void 
ChainManager::likelihoodPrior (vector<double>& v)
{
  vector<Chain*>::iterator iter1;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      v.push_back((*iter1)->likelihoodPrior);
    }
}
}
@

\subsection{Chain}
<<tuxChain.h>>=
<<tux gnu copyright>>
#ifndef _TUXCHAIN_H_
#define _TUXCHAIN_H_
#include <vector>
#include "tuxMoverManager.h"
namespace tux {
class Parameter;
class Data;
class Chain {
public:
  unsigned int chainid;
  double likelihoodPrior;
  double mBeta;
  unsigned int mStep;
  Parameter* mTxBoundaries;
  Parameter* mTxExpression;
  Data* mTxData;
  MoverManager mMoverManager;
public:
  Chain ();
  ~Chain ();
  void step (unsigned int n = 0);
};
}
#endif // _TUXCHAIN_H_

<<tuxChain.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <cassert>
#include "tuxMoverTxExpression.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverManager.h"
#include "tuxChain.h"
using namespace std;
namespace tux {
Chain::Chain ()
{
  mBeta = 1; 
  mStep = 0;
  likelihoodPrior = 0;

  // Create TxBoundaries
  ProbTxBoundaries factoryTxBoundaries;
  factoryTxBoundaries.mL = 10;
  factoryTxBoundaries.mK = 2;
  mTxBoundaries = factoryTxBoundaries.d (); 
  // Create TxExpression
  vector<double> a(factoryTxBoundaries.mK,10.0L);
  ProbTxExpression factoryTxExpression (a);
  mTxExpression = factoryTxExpression.d ();

  Mover* m;
  MoverTxBoundaries* d1;
  MoverTxExpression* d2;

  // Boundaries Mover
  m = new MoverTxBoundaries;
  d1 = dynamic_cast<MoverTxBoundaries*>(m);
  d1->mTxBoundaries = mTxBoundaries;
  d1->mTxExpression = mTxExpression;
  mMoverManager.add (m, 1, 1);

  // Expression Mover
  m = new MoverTxExpression;
  d2 = dynamic_cast<MoverTxBoundaries*>(m);
  d2->mTxBoundaries = mTxBoundaries;
  d2->mTxExpression = mTxExpression;
  mMoverManager.add (m, 2, 1);

}
Chain::~Chain ()
{
}
void 
Chain::step (unsigned int n)
{
  assert (n > 0);
  cout << chainid << ":";
  for (unsigned int i = 0; i < n; i++, mStep++)
    {
      cout << " " << mStep;
      Mover* m = mMoverManager.choose ();
      // The Mover m needs to get RandomVariables from Chain.
      // We need to access members of MoverTxBoundaries.
      // 
      m->step ();
    }
  cout << endl;
  return;
}
}
@

\subsection{RandomVariable}
<<tuxRandomVariable.h>>=
<<tux gnu copyright>>
#ifndef _TUXRANDOMVARIABLE_H_
#define _TUXRANDOMVARIABLE_H_
namespace tux {
class RandomVariable {
};
}
#endif // _TUXRANDOMVARIABLE_H_

<<tuxRandomVariable.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxRandomVariable.h"
using namespace std;
namespace tux {
}
@

\subsection{Parameter}
<<tuxParameter.h>>=
<<tux gnu copyright>>
#ifndef _TUXPARAMETER_H_
#define _TUXPARAMETER_H_
#include "tuxRandomVariable.h"
namespace tux {
class Parameter: public RandomVariable {
};
}
#endif // _TUXPARAMETER_H_

<<tuxParameter.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxParameter.h"
using namespace std;
namespace tux {
}
@

\subsection{TxBoundaries}
<<tuxTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXBOUNDARIES_H_
#define _TUXTXBOUNDARIES_H_
#include <vector>
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxBoundaries: public Parameter {
public:
  vector<unsigned int> mC;
public:
  TxBoundaries ();
  ~TxBoundaries ();
};
}
#endif // _TUXTXBOUNDARIES_H_

<<tuxTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include "tuxTxBoundaries.h"
using namespace std;
namespace tux {
TxBoundaries::TxBoundaries () 
{
    
}
TxBoundaries::~TxBoundaries () 
{
  
}
}
@

\subsection{TxExpression}
<<tuxTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXEXPRESSION_H_
#define _TUXTXEXPRESSION_H_
#include <vector>
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxExpression: public Parameter {
public:
  vector<double> mDelta;
public:
  TxExpression ();
  ~TxExpression ();
};
}
#endif // _TUXTXEXPRESSION_H_

<<tuxTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxTxExpression.h"
using namespace std;
namespace tux {
TxExpression::TxExpression ()
{
 
}
TxExpression::~TxExpression ()
{
 
}
}
@

\subsection{Data}
<<tuxData.h>>=
<<tux gnu copyright>>
#ifndef _TUXDATA_H_
#define _TUXDATA_H_
#include "tuxRandomVariable.h"
namespace tux {
class Data: RandomVariable {
// FIXME:
public:
  
};
}
#endif // _TUXDATA_H_

<<tuxData.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxData.h"
using namespace std;
namespace tux {
}
@

\subsection{Reads}
<<tuxReads.h>>=
<<tux gnu copyright>>
#ifndef _TUXREADS_H_
#define _TUXREADS_H_
#include <vector>
#include "tuxData.h"
namespace tux {
class Reads: Data {
public:
  vector<unsigned int> mCount;
public:
  Reads ();
  ~Reads ();
}
#endif // _TUXREADS_H_

<<tuxReads.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxReads.h"
using namespace std;
namespace tux {
// FIXME
Reads::Reads ()
{
  
}
Reads::~Reads ()
{
  
}
}
@


\subsection{Probability}
<<tuxProbability.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBABILITY_H_
#define _TUXPROBABILITY_H_
#include <vector>
#include "tuxRandomVariable.h"
using namespace std;
namespace tux {
class Probability {
protected:
  vector<RandomVariable*> mV;
  vector<RandomVariable*> mC;
public:
  virtual double d () = 0;
  virtual RandomVariable* r () = 0;
};
}
#endif // _TUXPROBABILITY_H_

<<tuxProbability.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxProbability.h"
using namespace std;
namespace tux {
}
@

\subsection{ProbTxBoundaries}
<<tuxProbTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBTXBOUNDARIES_H_
#define _TUXPROBTXBOUNDARIES_H_
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"

extern gsl_rng* gGslRng;

namespace tux {
class ProbTxBoundaries : public Probability {
public:
  unsigned int mL;
  unsigned int mK;
public:
  double d ();
  RandomVariable* r (); 
  double op_multiply (double i) { return i*mL; }
  unsigned int op_cast_unsigned_int (double i) { return static_cast<unsigned int>(i+0.5); }

  struct c_uniform {
    double a;
    double b;
    c_uniform () {a=0;b=1;}
    double operator()() {
      return gsl_ran_flat (gGslRng,a,b);
    }
  } gslrngUniform;

};
}
#endif // _TUXPROBTXBOUNDARIES_H_

<<tuxProbTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_sf_gamma.h>
#include "tuxTxBoundaries.h"
#include "tuxProbTxBoundaries.h"
using namespace std;
namespace tux {
double
ProbTxBoundaries::d ()
{
  return -gsl_sf_lnchoose(mL-1,mK-1);
}
RandomVariable* 
ProbTxBoundaries::r ()
{
  vector<double> a(mK);
  generate(a.begin(),a.end(),gslrngUniform);
  vector<double> b(mK);
  transform(a.begin(),a.end(),b.begin(),op_multiply);
  vector<unsigned int> c(mK);
  transform(b.begin(),b.end(),c.begin(),op_cast_unsigned_int);
  // We could have combine op_multiply and op_cast_unsigned_int.
  // I do this just for the sake of learning C++.
  // We could have used gsl_rng_uniform_int.
  // Set the transcript boundaries to the sampled value c.
  TxBoundaries* v = new TxBoundaries;
  v->mC = c;
  return dynamic_cast<RandomVariable*>(v);
}
}
@

\subsection{ProbTxExpression}
<<tuxProbTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBTXEXPRESSION_H_
#define _TUXPROBTXEXPRESSION_H_
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"

extern gsl_rng* gGslRng;

namespace tux {
class ProbTxExpression: public Probability {
public:
  vector<double> mAlpha;
  vector<double> mTheta;
public:
  ProbTxExpression (const vector<double>& a);
  ~ProbTxExpression ();

  double d ();
  RandomVariable* r (); 
  unsigned int op_cast_unsigned_int (double i) { return static_cast<unsigned int>(i+0.5); }

  struct c_uniform {
    double a;
    double b;
    c_uniform () {a=0;b=1;}
    double operator()() {
      return gsl_ran_flat (gGslRng,a,b);
    }
  } gslrngUniform;

};
}
#endif // _TUXPROBTXEXPRESSION_H_

<<tuxProbTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_block.h>
#include <gsl/gsl_randist.h>
#include "tuxTxExpression.h"
#include "tuxProbTxExpression.h"
using namespace std;
namespace tux {
ProbTxExpression::ProbTxExpression (const vector<double>& a)
{
  mAlpha = a; 
}
ProbTxExpression::~ProbTxExpression ()
{
}
double
ProbTxExpression::d ()
{
  size_t k = static_cast<size_t>(mAlpha.size());
  return gsl_ran_dirichlet_lnpdf(k,&mAlpha[0],&mTheta[0]);
}
RandomVariable* 
ProbTxExpression::r ()
{
  size_t k = static_cast<size_t>(mAlpha.size());
  gsl_block* t = gsl_block_alloc(k);
  gsl_ran_dirichlet(gGslRng,k,&mAlpha[0],t->data);
  mTheta.resize(k); std::copy(t->data,t->data + k,mTheta.begin());
  gsl_block_free(t);

  TxExpression* v = new TxExpression;
  v->mDelta = mTheta;
  return dynamic_cast<RandomVariable*>(v);
}
}
@

\subsection{Likelihood}
<<tuxLikelihood.h>>=
<<tux gnu copyright>>
#ifndef _TUXLIKELIHOOD_H_
#define _TUXLIKELIHOOD_H_
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"

extern gsl_rng* gGslRng;

namespace tux {
class Likelihood: public Probability {
public:
  unsigned int mL; // given
  unsigned int mK; // given
  double mM;       // given
  vector<double> mSizeFactor; // sample from a uniform distribution
  vector<double> mDelta;      // sample from a uniform Dirichlet distribution
  vector<unsigned int> mC;    // sample from a uniform Dirichlet distribution
  vector<unsigned int> mCount;
public:
  Likelihood (unsigned int, unsigned int, unsigned int, double);
  double d ();
  RandomVariable* r (); 

  // FIXME: in a separte file under tux namespace.
  struct c_uniform {
    double a;
    double b;
    c_uniform () {a=0;b=1;}
    double operator()() {
      return gsl_ran_flat (gGslRng,a,b);
    }
  } gslrngUniform;

  struct c_nb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    unsigned int operator()(double i) {
      double mu = i * mM * mSizeFactor; 
      double n = mu/(a0+a1/mu);
      double p = n/(n+mu);
      unsigned int k = gsl_ran_negative_binomial(gGslRng, p, n);
      return k; 
    }
  } gslrngNb;

  struct c_read {
    unsigned int mPosition;
    vector<unsigned int> mRead;
    c_read () {};
    c_read (size_t n) {mRead.resize(n); mPosition = 0;}
    void resize(size_t n) {mRead.resize(n,0); mPosition = 0;}
    unsigned int operator()(unsigned int n,unsigned int l) {
      unsigned int s; 
      for (unsigned int i = 0; i < n; i++)
        {
          s = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
          mRead.at(mPosition + s)++;
        }
      return n;
    }
  } gslrngRead;

  unsigned int op_subtract (unsigned int i, unsigned int j) {
    return j - i;
  }

  struct c_countRead {
    vector<unsigned int>::iterator mIter;
    vector<unsigned int> mRead;
    c_countRead () {mIter = mRead.begin();}
    void resize() {mIter = mRead.begin();}
    unsigned int operator()(unsigned int l) {
      vector<unsigned int>::iterator mEnd = mIter + l;
      unsigned int sumCk = accumulate(mIter,mEnd,0);
      mIter = mEnd; 
      return sumCk;
    }
  } countRead;

  struct c_probNb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    double operator()(double d,unsigned int k) {
      double mu = d * mM * mSizeFactor; 
      double n = mu/(a0+a1/mu);
      double p = n/(n+mu);
      return log(gsl_ran_negative_binomial_pdf(k,p,n));
    }
  } probNb;

};
}
#endif // _TUXLIKELIHOOD_H_

<<tuxLikelihood.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
using namespace std;
namespace tux {
Likelihood::Likelihood (unsigned int j, unsigned int l, unsigned int k, double m)
{
  mL = l;
  mK = k;
  mM = m;
  // TxBoundaries is created. Likelihood owns it.
  ProbTxBoundaries priorTxBoundaries;
  priorTxBoundaries.mL = mL;
  priorTxBoundaries.mK = mK;
  TxBoundaries* vTxBoundaries 
    = dynamic_cast<MoverTxBoundaries*>(priorTxBoundaries.r ());
  mC = vTxBoundaries->mC;
  delete vTxBoundaries;

  // TxExpression is created. Likelihood owns it.
  vector<double> a(mK,1.0L);
  ProbTxExpression priorTxExpression (a);
  TxExpression* vTxExpression 
    = dynamic_cast<MoverTxExpression*>(priorTxExpression.r ());
  mDelta = vTxExpression->mDelta
  delete vTxExpression;
  
  // Sizefactors are created.
  mSizeFactor.resize(j,1.0L);
  gslrngUniform.a = 0.5L;
  gslrngUniform.b = 1.5L;
  generate(mSizeFactor.begin(),mSizeFactor.end(),gslrngUniform);

}
double
Likelihood::d ()
{
  // Find lengths.
  vector<unsigned int> mLk(mC);
  mLk.pop_back();
  mLk.insert(mLk.begin(),0);
  transform(mLk.begin(),mLk.end(),mC.begin(),mLk.begin(),op_subtract);

  // Count reads in ck.
  vector<unsigned int> ck(mDelta.size());
  countRead.mRead = mCount;
  transform(mLk.begin(),mLk.end(),ck.begin(),countRead);

  // 
  gsl_ran_negative_binomial_pdf(k,p,n); 

  gslrngRead.resize (mL);
  vector<double> logProbNb(mDelta);
  transform(logProbNb.begin(),logProbNb.end(),ck.begin(),logProbNb.begin(),probNb);
  double v = accumulate(logProbNb.begin(),logProbNb.end(),0);
  return v; 
}
RandomVariable*
Likelihood::r ()
{
  // For each i-th segment, sample j.
  // Use TxBoundaries and TxExpression to generate a set of Data.
  vector<unsigned int> ck(mDelta.size());
  transform(mDelta.begin(),mDelta.end(),ck.begin(),gslrngNb);
  // 
  vector<unsigned int> mLk(mC);
  mLk.pop_back();
  mLk.insert(mLk.begin(),0);
  transform(mLk.begin(),mLk.end(),mC.begin(),mLk.begin(),op_subtract);

  gslrngRead.resize (mL);
  transform(ck.begin(),ck.end(),mLk.begin(),ck.begin(),gslrngRead);

  // Data
  Reads* v = new Reads;
  v->mCount = gslrngRead.mRead;
  return dynamic_cast<RandomVariable*>(v);
}
}
@

\subsection{MoverManager}
<<tuxMoverManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERMANAGER_H_
#define _TUXMOVERMANAGER_H_
#include <vector>
#include <gsl/gsl_randist.h>
namespace tux {
class Mover;
class MoverManager {
public:
  vector<Mover*> mMover;
  vector<unsigned int> mId;
  vector<double> mWeight;
  gsl_ran_discrete_t* mGslRanDiscrete;
public:
  MoverManager ();
  ~MoverManager ();
  void add (const unsigned int, const double);
  void add (Mover*, const unsigned int, const double);
  Mover* choose ();

  template <class T> struct c_delete {
    void operator() (T i) {delete i;}
  };
};
}
#endif // _TUXMOVERMANAGER_H_

<<tuxMoverManager.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <cassert>
#include <gsl/gsl_block.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxMover.h"
#include "tuxMoverManager.h"
extern gsl_rng* gGslRng;
using namespace std;
namespace tux {
MoverManager::MoverManager ()
{

}
MoverManager::~MoverManager ()
{
  c_delete<Mover*> deleteMover;
  for_each (mMover.begin(), mMover.end(), deleteMover);           
}
void
MoverManager::add (const unsigned int id, const double weight)
{
  mId.push_back(id); 
  mWeight.push_back(weight);
  Mover* m;
  switch (id) 
    {
    case 1: m = new MoverTxBoundaries;
    break;
    case 2: m = new MoverTxBoundaries;
    break;
    }
  mMover.push_back(m);
  if (mMover.size() > 1)
    {
      size_t k = mMover.size();
      gsl_block* w = gsl_block_alloc(k);
      mGslRanDiscrete = gsl_ran_discrete_preproc (k,w->data); 
    }
}
void
MoverManager::add (Mover* m, const unsigned int id, const double weight)
{
  mId.push_back(id); 
  mWeight.push_back(weight);
  mMover.push_back(m);
  if (mMover.size() > 1)
    {
      size_t k = mMover.size();
      gsl_block* w = gsl_block_alloc(k);
      mGslRanDiscrete = gsl_ran_discrete_preproc (k,w->data); 
    }
}
Mover*
MoverManager::choose()
{
  assert (mMover.size() > 1);
  size_t k = gsl_ran_discrete(gGslRng,mGslRanDiscrete);
  return mMover.at(k);
}
}
@

\subsection{Mover}
<<tuxMover.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVER_H_
#define _TUXMOVER_H_
namespace tux {
class Mover {
public:
  virtual int step () = 0;
};
}
#endif // _TUXMOVER_H_

<<tuxMover.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxMover.h"
using namespace std;
namespace tux {
}
@

\subsection{MoverTxBoundaries}
<<tuxMoverTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXBOUNDARIES_H_
#define _TUXMOVERTXBOUNDARIES_H_
#include "txMover.h"
namespace tux {
class TxBoundaries;
class TxExpression;
class MoverTxBoundaries: Mover {
public:
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
public:
  MoverTxBoundaries ();
  int step ();
  unsigned int op_subtract (unsigned int i, unsigned int j) {
    return j - i;
  }
  double op_multiply (double i, unsigned int j) {
    return i * j;
  }

};
}
#endif // _TUXMOVERTXBOUNDARIES_H_

<<tuxMoverTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <numeric>
#include <algorithm>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxMoverTxBoundaries.h"

extern gsl_rng* gGslRng;

using namespace std;
namespace tux {
void 
MoverTxBoundaries::MoverTxBoundaries ()
{
}
int 
MoverTxBoundaries::step ()
{
  // 1. We choose a subset of the K segments.
  // 1.1 We choose a site of the L sites.
  // 1.2 We choose a length from a distribution or fixed value.
  // 1.3 Group segments in the chosen region.
  // 2. Find the lengths of the subset of the segments.
  // 2.1 Sum the lengths.
  // 2.2 Compute the fractions of the legnths with respect to the sum of the
  // length.
  // 2.3 Multiply the factions by a pseudo-concentration parameter.
  // 3. Use the multiplied factions as a set of concentration parameters to
  // sample a new set of random variates from the Dirichlet distribution.
  // 3.1 Multiply the sum of the lengths of the subset to recover a new set of
  // segments. 
  // 3.2 Adjust legnths of the segments so that legnths fit the remaining
  // segments.
  // 4. Compute acceptance probability by using likelihood, priors, and
  // Metropolis-Hastings ratio.
  // 4.1 The priors are p(mu|s)p(s)=p(mu)p(s). This value does not change
  // before and after the proposal.
  // 4.2 Count reads on the subset and compute p(x|theta*)/p(x|theta).
  // Optimization of the likelihood ratio can be done by using forms of the
  // negative binomial probability functions.
  // 4.3 Compute the Metropolis-Hastings ratio using the proposal.
  unsigned long int l = static_cast<unsigned long int>(mTxBoundaries->mC.back());
  unsigned int s = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
  unsigned int e = s + 10000;
  // Use mTxBoundaries->mC to find the subset.
  // Find two points that minimally bound either s or e.
  vector<unsigned int>::iterator upLeft;
  vector<unsigned int>::iterator upRight;
  upLeft = upper_bound(mTxBoundaries->mC.begin(),mTxBoundaries->mC.end(),s);
  upRight = upper_bound(mTxBoundaries->mC.begin(),mTxBoundaries->mC.end(),e);
  while (upLeft < upRight) 
    {
      l = static_cast<unsigned long int>(mTxBoundaries->mC.back());
      s = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
      e = s + 10000;
      upLeft = upper_bound(mTxBoundaries->mC.begin(),mTxBoundaries->mC.end(),s);
      upRight = upper_bound(mTxBoundaries->mC.begin(),mTxBoundaries->mC.end(),e);
    }
  vector<unsigned int> lk(upRight-upLeft);
  vector<unsigned int>::iterator second = lk.begin() + 1;
  copy(upLeft,upRight-1,second);
  if (upLeft == mTxBoundaries.begin())
    {
      lk.at(0) = 0;
    }
  else
    {
      lk.at(0) = *(upLeft - 1);
    }
  transform(lk.begin(),lk.end(),upLeft,lk.begin(),op_subtract);
  // sumLk can be computed by subtracting lk.at(0) from *upRight.
  unsigned int sumLk = accumulate(lk.begin(),lk.end(),0);
  double concentrationParameter = 10.0L;
  vector<double> alpha(lk.size(),concentrationParameter/static_cast<double>(sumLk));
  transform(alpha.begin(),alpha.end(),lk.begin(),alpha.begin(),op_multiply);

  size_t k = static_cast<size_t>(alpha.size());
  gsl_block* t = gsl_block_alloc(k);
  gsl_ran_dirichlet(gGslRng,k,&alpha[0],t->data);
  vector<double> theta(k);
  copy(t->data,t->data + k,theta.begin());
  gsl_block_free(t);

  vector<unsigned int> a;
  if (upLeft == mTxBoundaries.begin())
    a.push_back(0);
  else
    a.push_back(*(upLeft - 1));
  for (size_t i = 0; i < k-1; i++)
    {
      a.push_back(a.back() + theta.at(i) * sumLk);
    }
  
  // a[1] to a[k-1] are the new middle points.
  // Compute the likelihood.
  // a[0] to a[k] (,which does not exist) are used to count reads.
  // FIXME: We do not have data yet. Find Data.
   
}
}
@

\subsection{MoverTxExpression}
<<tuxMoverTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXEXPRESSION_H_
#define _TUXMOVERTXEXPRESSION_H_
#include "txMover.h"
namespace tux {
class TxBoundaries;
class TxExpression;
class MoverTxExpression: Mover {
public:
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
public:
  MoverTxExpression ();
  int step ();
};
}
#endif // _TUXMOVERTXEXPRESSION_H_

<<tuxMoverTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxMoverTxExpression.h"
using namespace std;
namespace tux {
void 
MoverTxExpression::MoverTxExpression ()
{
}
int 
MoverTxExpression::step ()
{
}
}
@

\subsection{Summarizer}
<<tuxSummarizer.h>>=
<<tux gnu copyright>>
#ifndef _TUXSUMMARIZER_H_
#define _TUXSUMMARIZER_H_
namespace tux {
class Summarizer {
public:
  void full ();
};
}
#endif // _TUXSUMMARIZER_H_

<<tuxSummarizer.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSummarizer.h"
using namespace std;
namespace tux {
void 
Summarizer::full ()
{
  return;
}
}
@

\subsection{Summary}
<<tuxSummary.h>>=
<<tux gnu copyright>>
#ifndef _TUXSUMMARY_H_
#define _TUXSUMMARY_H_
namespace tux {
class Summary {
public:
  void full ();
};
}
#endif // _TUXSUMMARY_H_

<<tuxSummary.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSummary.h"
using namespace std;
namespace tux {
void 
Summary::full ()
{
  return;
}
}
@

\subsection{System}
<<tuxSystem.h>>=
<<tux gnu copyright>>
#ifndef _TUXSYSTEM_H_
#define _TUXSYSTEM_H_
namespace tux {
class System {
public:
  void full ();
};
}
#endif // _TUXSYSTEM_H_

<<tuxSystem.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSystem.h"
using namespace std;
namespace tux {
void 
System::full ()
{
  return;
}
}
@

\subsection{Xyz}
<<tuxXyz.h>>=
<<tux gnu copyright>>
#ifndef _TUXXYZ_H_
#define _TUXXYZ_H_
namespace tux {
class Xyz {
public:
  void full ();
};
}
#endif // _TUXXYZ_H_

<<tuxXyz.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxXyz.h"
using namespace std;
namespace tux {
void 
Xyz::full ()
{
  return;
}
}
@

\subsection{GNU Readline Library}
<<config.h.in>>=
#ifndef _CONFIG_H_
#define _CONFIG_H_

#undef __BEGIN_DECLS
#undef __END_DECLS
#ifdef __cplusplus
# define __BEGIN_DECLS extern "C" {
# define __END_DECLS }
#else
# define __BEGIN_DECLS /* empty */
# define __END_DECLS /* empty */
#endif

#cmakedefine HAVE_MALLOC_H 1
#cmakedefine HAVE_SYS_FILE_H
#cmakedefine HAVE_UNISTD_H
#cmakedefine HAVE_STRING_H
#cmakedefine HAVE_STDLIB_H

#endif /* _CONFIG_H_ */

<<fileman.cpp>>=
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif 

#include "rlstdc.h"

#include <sys/types.h>
#ifdef HAVE_SYS_FILE_H
#  include <sys/file.h>
#endif
#include <sys/stat.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include <fcntl.h>
#include <stdio.h>
#include <errno.h>

#if defined (HAVE_STRING_H)
#  include <string.h>
#else /* !HAVE_STRING_H */
#  include <strings.h>
#endif /* !HAVE_STRING_H */

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#endif

#include <time.h>

#include "xmalloc.h"

#include <readline/readline.h>
#include <readline/history.h>


// extern char *xmalloc PARAMS((size_t));

/* The names of functions that actually do the manipulation. */
int com_list PARAMS((char *));
int com_view PARAMS((char *));
int com_rename PARAMS((char *));
int com_stat PARAMS((char *));
int com_pwd PARAMS((char *));
int com_delete PARAMS((char *));
int com_help PARAMS((char *));
int com_cd PARAMS((char *));
int com_quit PARAMS((char *));

/* A structure which contains information on the commands this program
   can understand. */

typedef struct {
  char *name;			/* User printable name of the function. */
  rl_icpfunc_t *func;		/* Function to call to do the job. */
  char *doc;			/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "cd", com_cd, "Change to directory DIR" },
  { "delete", com_delete, "Delete FILE" },
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "list", com_list, "List files in DIR" },
  { "ls", com_list, "Synonym for `list'" },
  { "pwd", com_pwd, "Print the current working directory" },
  { "quit", com_quit, "Quit using Fileman" },
  { "rename", com_rename, "Rename FILE to NEWNAME" },
  { "stat", com_stat, "Print out statistics on FILE" },
  { "view", com_view, "View the contents of FILE" },
  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite (char *string);
COMMAND* find_command (char *name);
void too_dangerous (char *caller);
void initialize_readline ();
int execute_line (char *line);
int valid_argument (char *caller, char *arg);

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (char *s)
{
  char *r;

  r = (char *) xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

int
main (int argc, char **argv)
{
  char *line, *s;

  progname = argv[0];
  if (argc == 1) { }

  initialize_readline ();	/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}

/* Execute a command line. */
int
execute_line (char *line)
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (char *name)
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (char *string)
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator PARAMS((const char *, int));
char **fileman_completion PARAMS((const char *, int, int));

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
void
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END bound the
   region of rl_line_buffer that contains the word to complete.  TEXT is
   the word to complete.  We can use the entire contents of rl_line_buffer
   in case we want to do some simple parsing.  Return the array of matches,
   or NULL if there aren't any. */
char **
fileman_completion (const char *text, int start, int end)
{
  char **matches;

  if (end == 0) {}

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);

  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (const char *text, int state)
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  name = commands[list_index].name;
  while (name) 
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
      name = commands[list_index].name;
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                       FileMan Commands                           */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* List the file(s) named in arg. */
int
com_list (char *arg)
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}

int 
com_view (char *arg)
{
  if (!valid_argument ("view", arg))
    return 1;

#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "less %s", arg);
#else
  sprintf (syscom, "more %s", arg);
#endif
  return (system (syscom));
}

int
com_rename (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "rename %s", arg);
#else
  sprintf (syscom, "rename %s", arg);
#endif
  too_dangerous (syscom);
  return (1);
}

int
com_stat (char *arg)
{
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %d byte%s in length.\n",
	  arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          (int) finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}

int
com_delete (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "delete %s", arg);
#else
  sprintf (syscom, "delete %s", arg);
#endif
  too_dangerous (syscom);
  return (1);
}

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
int
com_help (char *arg)
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

/* Change to the directory ARG. */
int
com_cd (char *arg)
{
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}

/* Print out the current working directory. */
int
com_pwd (char *ignore)
{
  char dir[1024], *s;

  s = getcwd (dir, sizeof(dir) - 1);
  if (s == 0)
    {
      printf ("Error getting pwd: %s %s\n", dir, ignore);
      return 1;
    }

  printf ("Current directory is %s %s\n", dir, ignore);
  return 0;
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
int
com_quit (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "quit %s", arg);
#else
  sprintf (syscom, "quit %s", arg);
#endif
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
void
too_dangerous (char *caller)
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (char *caller, char *arg)
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}
@


\end{document}
