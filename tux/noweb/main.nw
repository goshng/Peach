\documentclass[12pt]{article}
\usepackage[T1]{fontenc}                                                        
\usepackage[latin9]{inputenc}                                                   
\usepackage{mdwlist}           % less spaces between items
\usepackage{bm}                % bold math letters
\usepackage{amssymb}
\usepackage{noweb}
\usepackage{fancyvrb}
\usepackage[letterpaper]{geometry}
% \geometry{verbose,tmargin=1in,bmargin=1in}
\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\parskip}{1ex}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

% Text layout
\oddsidemargin -.5in
\evensidemargin 0in
\topmargin -.5in
\textwidth 7.5in
\textheight 9in

\newcommand{\Ccommand}[1]{command \textbf{#1}}
\newcommand{\Coption}[1]{option \texttt{#1}}
\newcommand{\Cclass}[1]{class \textit{#1}}
\newcommand{\Cmember}[1]{member \texttt{#1}}
\newcommand{\Cmethod}[1]{method \texttt{#1}}
\newcommand{\Cglobal}[1]{\texttt{#1}}
\newcommand{\Cvariable}[1]{\texttt{#1}}
\newcommand{\Cfunction}[1]{function \texttt{#1}}
\newcommand{\Cpackage}[1]{package \textit{#1}}
\newcommand{\program}[1]{program \texttt{#1}}
\newcommand{\library}[1]{\texttt{#1}}
\newcommand{\Cfile}[1]{file \texttt{#1}}

\begin{document}
\raggedright

\title{Inferring transcript boundaries and expression levels using RNA-seq}
\author{Sang Chul Choi\\
Department of Biological Statistics and Computational Biology, \\
Cornell University,\\
Ithaca, NY 14850}

\maketitle

\tableofcontents

\newpage
\section{Introduction}
We have two versions of \program{tux}. The first version uses
\Cclass{McmcSingle}, and the latter \Cclass{McmcMpi}. When the openmpi is not
available, use \Cclass{McmcSingle}.  Read more documentation in the lyx 
\Cfile{Peach/notes/researches/siepel-transcript.lyx}.

\subsection{Tux}
The \program{tux} uses libraries including \library{readline}, \library{yaml-cpp}, \library{SimpleOpt}, \library{gsl}, and \library{ezlogger}. A companion of \program{tux} uses
\library{openmpi} to implement an Message Passing Interface (MPI) version of \program{tux} using compiler definition of \texttt{-D\_MPI}. We have yet to implement parallelization schemes of multiple
threads, or GPUs using CUDA. We focus on the MPI implementation first. We borrow the source code of \Cfile{fileman.c} from \library{readline} to implement a
command line environment in the main program source \Cfile{tux.cpp}, in which we have
three main global-scope objects: \Cglobal{gFixed}, \Cglobal{gShortRead}, and
\Cglobal{gManager}.  We log the flow of \program{tux} using
\library{ezlogger}. In the \Cfunction{main}, we set the verbosity level using
the following line:  
\begin{Verbatim}[frame=lines,framesep=5mm]
axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);
Use one of log_always, log_often, log_regularly, log_rarely, log_very_rarely.
\end{Verbatim}
Set the log verbosity level using \program{tux} command line option \texttt{--logverbosity} with a number
argument ranging from 1 to 5. In order to create log files properly we use
\emph{log\_rarely} or \texttt{--logverbosity 4} for logging the detail of MCMC
procedure, and \emph{log\_regularly} or \texttt{--logverbosity 3} for MC3
debugging. We create a log file for the main program, and another kind of log
files for chain or chain manager process. This allows us to see activities in
MPI processes. In addition to the three main global variables we use
\Cglobal{gGslRng}. For the main log file we use \Cglobal{tux::lf}. In the
\Cfunction{main} we use once  
\begin{Verbatim}[frame=lines,framesep=5mm]
fGslRngAlloc ();
\end{Verbatim}
at the start, and call the following line before exiting the program.
\begin{Verbatim}[frame=lines,framesep=5mm]
fGslRngFree ();
\end{Verbatim}
We enter the interactive mode without options or \program{tux}'s command
\texttt{interactive}.
\begin{Verbatim}[frame=lines,framesep=5mm]
./tux interactive
\end{Verbatim}
The \program{tux} can show a manual page, its version, or execute commands
including \Ccommand{fixed}, \Ccommand{mcmc}, and \Ccommand{summarize}. The main
option is for an input file name: \Coption{-i}, \Coption{--in}, or
\Coption{--infile}. The input file describes the overall setup of the
\program{tux}. We use \library{yaml-cpp} to read in the program setup. If no
such file with the input file name is found, then the \program{tux} exits with
an error message. The input file contains \Cmember{mDatafile}. We read in the
file and save it as \Cglobal{gShortRead}. With the two global variables ready we use \Cglobal{gManager}. When being finished with the batch mode, we delete
the memory to each short read in \Cglobal{gShortRead}. We also call
\Cfunction{fGslRngFree} before the exit. Now, let us see \Cclass{Manager}. 

\subsection{Manager}
The \Cclass{Manager} is one of the main global objects. This accesses
\Cclass{Fixed} and \Cclass{Reads}. In the \Cmethod{mcmc} we use \Cclass{Mcmc} to
run a number of chains. One of them is ``cold,'' and the others are
``hot'' when \Cmember{mNumberProcess} is greater than 1.  The \Cclass{Mcmc}
coordinates multiple simultaneous runs of chains.  Each chain needs to know what
temperature to use. The \Cclass{Fixed} owns the temperature member. The
\Cclass{ChainManager} specifies the temperature for the chains that it
manages. The \Cclass{Fixed} does contain \Cmember{mTemperature}. \Cclass{ChainManager} owns \Cmember{mChainid} for accessing chains.  The \Cclass {Fixed} creates a list of
temperature using \Cclass{c\_hlinear}, or \Cclass{c\_hgeometric} setting values
of \Cmember{mTemperature}. The \Cclass{ChainManager} initializes \Cmember{mChainid} as a sequence of
non-negative integers. We set up a list of chains before running them. The
\Cclass{Mcmc} creates a list of chains, and executes each chain one at a time
using \Cmethod{step}. We have two classes for chains. One is for a chain that
does the sampling job, and the other is for a chain manager. The \Cclass{Mcmc}'s
\Cmethod{step} commands all of the chains to move a finite number of steps in
their own process. The chain manager will be run in a separate process. We use
Message Passing Interface, which is an application interface that allows
processes to communicate by sending and receiving messages. In essence, it
facilitates communication when multiple computers/processors/cores are
performing distributed computation. 

Let's see how the communication works.  The \Cclass{Mcmc} sends a message of
\Cmethod{step} to \Cclass{ChainManager}, which in turn sends a message of
\Cmethod{step} to a list of \Cclass{Chain}.  A process owns one object of
\Cclass{ChainManager}, which communicates with \Cclass{Mcmc}.  After finishing
all of the messages of \Cmethod{step} in the list of \Cclass{Chain}, the
\Cclass{ChainManager} sends a message to \Cclass{Mcmc} to check whether it can
continue to move steps of the chains. The \Cclass{Mcmc} would swap chains by
receciving necessary values from \Cclass{ChainManager}. 
The \Cmethod{mcmc} creates an instance of \Cclass{McmcSingle} or
\Cclass{McmcMpi}. We move as many steps as \Cmethod{mNumberSwap}. Then, we swap
chains. After the swap we save the state of each chain if the thinning count is
greater than the user specified number, or \Cmember{mMcmcThin}. 

We discuss output files. Each process has a \Cclass{ChainManager} object.
The process opens an output file and a log file. The output file name consists
of \Cmember{mChainDirectory}, and \Cmember{mPrefix}. The process rank ID or chain
manager ID follows the name with addition extension of ``chain.'' The log file
name is constructed similarly except for the extension of ``log.'' 

FIXME: We still need to code the \Cmethod{summarize} of \Cclass{Manager}.

FIXME: We have yet to implement the following feature to save and load MCMC states.
We wish to control the \program{tux} using signals by allowing \program{tux}
to monitor signals. A signal turns off the currently running MCMC, and makes the
\program{tux} save the states and exit. We use SIGUSR1 or SIGUSR2 to customize
signals for this purpose.  See
http://www.alexonlinux.com/signal-handling-in-linux.  The main process or rank 0
process receives the signal. Depending on the state of the main process we need
different actions. If the main process was moving the parameter state, then the
process needs to finish with it. If the main process was swapping chains, then
the process still needs to finish with it.  Because the main process has to
communicate the saving message with the rest of worker processes, the on-going
moves have to be finished. This would not make the \program{tux} stop instantly.
It would take time for the \program{tux} to stop. We need MPI message passing
for saving the state of the \program{tux} MCMC. When the signal caputre is not
available, we could use a file to let \program{tux} know that it is time to stop
and save the state of MCMC for later use.

Members of \Cclass{Manager} are
\begin{itemize*}
\item public: 
\item   Fixed* mFixed; a mere pointer to the program setup
\item   vector<Reads*> mTxReads; mere pointers to short reads
processes
\item public:
\item   Manager (); 
\item   Manager (Fixed* m, const vector<Reads*>\& shortRead);
\item   void show(); Not Yet Implemented (NYI) - shows the current status in the
shell
\item   void model(); NYI - shows the current model
\item   void mcmc(int r); executes an MCMC with rank $r$
\item   void summarize(); summarizes the posterior sample
\item   void save(); NYI - saves the state of the
currently running MCMC
\item   void load(); NYI - loads the state of a saved MCMC
\item   void help(); NYI - shows the manual page
\end{itemize*}

We now detail \Cclass{Manager}. The \Cmember{mFixed} and \Cmember{mReads} are mere pointers to the two global objects. The two global variables could be encapsulated in \Cclass{Manager}. I will consider this option later. This class should serve the user's request. We provide \Cmethod{mcmc} and \Cmethod{summarize}. Using \Cclass{Fixed} we create several file names, one of which is the chain file. A process of MPI or a thread of multiple threads program owns a chain file. A chain file contains samples from multiple chains. In \Cmethod{mcmc} an instance of \Cclass{Mcmc} is created and executed. We print \Cclass{Mcmc} out in a chain file. A chain file name consists of \Cmember{mChainDirectory}, \Cmember{mPrefix}, chain manager or MPI process ID, and extension of  ``chain.'' The \Cmethod{report} prints out the acceptance ratio of movers or updaters and chain swap ratios in a file name made up of  \Cmember{mOutDirectory}, \Cmember{mPrefix}, process ID, and extension of ``rpt.'' The \Cmethod{repportSitewiseFrequencyBoundaries} of \Cclass{Mcmc} creates a file name consisting of \Cmember{mOutDirectory}, \Cmember{mPrefix}, process ID, and extension of ``sfb.'' The \Cmethod{reportSitewiseExpression} creates a file with ``swe'' extension. We have yet to implement a method of summarizing these process-specific files.  The \Cmethod{summarize} creates an instance of \Cclass{Summarizer}, and calls \Cmethod{execute}. This method could feature more functions.  Note The input file variables, mOutDirectory, mChainDirectory, and mLogDirectory must end with a slash denoting a directory.  The \Cmethod{reportMC3} writes swap chain ratios in a file of \Cmember{mOutDirectory}, \Cmember{mPrefix}, and extension of ``mc3.''

\subsection{Mcmc}
The \Cclass{Mcmc} steps and swaps chains. We distribute chains among multiple processes using the class's process management. While in the previous section the \Cclass{Manager} handles user inputs, the \Cclass{Mcmc} does an actual job of running Markov chains. The \Cclass{Mcmc} might have two things in it: process management and Markov chains management.  We employ Metropolis-coupled Markov chain Monte Carlo (MC3).  See http://probability.ca/jeff/ftpdir/mcmcmc.pdf. 

Members of \Cclass{Mcmc}:
\begin{itemize*}
\item public:
\item   unsigned int mRank; the process ID, 0 for \Cclass{McmcSingle}
\item   Fixed* mFixed; a mere pointer to the program setup
\item   vector<Reads*> mReads; mere pointers to short reads
\item   ChainManager mChainManager; the chain manager
\item   vector<unsigned int> mChainid; chain IDs of the processes, e.g.,
c(1,4,0,5,3,2) is the chain IDs for the six processes
\item   vector<double> mLogLikelihoodPrior; sums of likelihood and prior of the processes, which is used for chain swaps
\item   vector<vector<unsigned int> > mSwapCount; number of successful swap
tries between chains
\item   vector<vector<unsigned int> > mSwapTryCount; number of swap tries
between chains
\item public:
\item   int swapChains (); uses values from all of the chains to arrange chain
temperatures - called by \Cmethod{swap}
\item   Mcmc (Fixed* m, const vector<Reads*>\& shortRead, unsigned int rank);
\item   ~Mcmc ();
\item   int step (unsigned int n);
\item   virtual int swap () = 0; derived classes implement this method
\item   int sample (); 
\item   int save (); NYI
\item   int load (); NYI
\item   void report (ostream \&out); prints MCMC diagnostics.
\item   void reportSitewiseExpression (ostream\& out); prints site-wise expression level.
\item   void reportSitewiseFrequencyBoundaries (ostream\& out); prints site-wise frequency of boundaries along the chromosome.
\item   friend ostream\& operator$\ll$ (ostream \&out, const Mcmc \&t);
\end{itemize*}

The \Cclass{c\_msg1} is used to send a message to the rank 0 process:
\begin{itemize*}
\item unsigned int processid; the ordered ID of a process
\item unsigned int chainid; the designated chain ID
\item double likelihoodPrior; the sum of likelihood and prior of a chain
\end{itemize*}

The \Cclass{Mcmc::c\_unique} is an unary operator for generating a sequence of non-negative integers. The constructor needs pointers to \Cclass{Fixed} and \Cclass{Reads}. It also needs rank ID of the process where the \Cclass{Mcmc} object is created. We compute how many chains are needed for each process using \Cclass{Fixed}. Then, we create chains for the current process. The \Cclass{Fixed} prepares temperature. The \Cclass{Mcmc} prepares chain IDs, and log likelihood/prior for chain swaps. The acceptance ratio for chain swaps is prepared in \Cmember{mSwapCount} and \Cmember{SwapTryCount}.  The \Cclass{McmcSingle} and \Cclass{McmcMpi} implements \Cmethod{swap}.  Subclass \Cclass{Mcmc} to create other swap implementation. While \Cclass{Mcmc} manages different processes and chain swaps, the \Cclass{ChainManager} handles a finite number of chains. Without process manangement feature of \Cclass{Mcmc} we had no reason to separate the two classes. The \Cclass{Mcmc} owns an instance of \Cclass{ChainManager}. All of the chains managed by \Cclass{ChainManager} have their own chain IDs, which are used to index temperature values. We also need the sums of log likelihood and log prior to swap chains. We use \Cmethod{chainid} and \Cmethod{likelihoodPrior} to access chain IDs and the sum of log likelihood and log prior from the chains managed by \Cclass{ChainManager}.  We swap chain IDs and the sums of log likelihood and log prior.  We know neighboring chains in temperature values to swap chains nearby.  Let us see \Cmethod{swapChains}.  For example, we have the following \Cmember{mChainid} and \Cmember{mLogLikelihoodPrior}. We find chain IDs using \Cmember{mChainid} with process index or ``Index.'' We also want to know the process index using ``chainIndex'' with chain IDs. We create ``chainIndex'' using \Cmember{mChainid}, and swap values in ``chainIndex'' not in \Cmember{mChainid}. After swaps we can recreate \Cmember{mChainid} using ``chainIndex.''

\begin{Verbatim}[frame=lines,framesep=5mm]
Index               0  1  2  3  4  5
mChainid            3  2  0  5  1  4   <- Keep these
mLogLikelihoodPrior v3 v2 v0 v5 v1 v4  <-   and these values.
chainIndex          2  4  1  0  5  3   <- We swap indices.
\end{Verbatim}
In order to swap chains we choose two chains nearby. See \Cfunction{fGslRanMirror}. We give distance of either side and jump distance, and get 1-based value from the left-hand side position. 

The \Cmethod{swap} for the rank 0 process waits for the rest of processes to
finish their \Cmethod{step}. Positively ranked processes send the rank 0 process
a message of likelihood and other values. The rank 0 process uses all of the
likelihood values to attempt swapping of chain temperature values. It finishes
the chain swapping by sending the rest of positively ranked processes a message
of the chosen temperature.
The \Cclass{ChainManager} sends the chain ID, and the sum of likelihood and
prior to the rank 0 process for each of the chains that it manages. The rank 0
process fills \Cmember{chainid} and \Cmember{likelihoodPrior} with those
received values. Note that the two vectors index chains managed by
\Cclass{ChainManager}. An element of \Cmember{chainid} is used to reference
a temperature value. Let us read the \Cmethod{swap} in detail.
Whatever the ranks are, \Cclass{ChainManager} calls \Cmethod{chainid} and
\Cmethod{likelihoodPrior} to get chain IDs, and sums of likelihood and prior for
the chains managed by the \Cclass{ChainManager} of the current rank process.
We start with the rank 0 process. We need sums of likelihood and prior from each
chain. We receive a message from each chain. Because \Cclass{ChainManager}
can contains multiple chains, we have two loops: one for the
\Cclass{ChainManager} and another for each chain in the \Cclass{ChainManager}.
A message is stored \Cmember{mMessage}. The \Cmember{processid} of 
\Cmember{mMessage} is the ordered index of a process that runs one chain. Do not
be confused by the name process. For example, if 
\Cmember{mNumberChainPerProcess} is c(3,3,2), the process indices run from 0 to
7. Processes are different in the assigned chain index, which is stored in
\Cmember{chainid} of \Cmember{mMessage}. We use \Cmember{processid} to index 
\Cmember{mChainid} and \Cmember{mLogLikelihoodPrior}. Now that we have chain
IDs, and sums of likelihood and prior. We call \Cmethod{swapChains}, and
rearrange \Cmember{mChainid}. 
We need to configure chains with the rearranged chain IDs. For the rank 0
process we find the chain IDs and save them in a vector of size being equal to
the number of chains in the rank 0 process. We send messages to the rest of
positively ranked processes. Let us turn to a postively ranked process. Note
that we have already stored chain IDs and sums of likelihood and prior. We send
those to the rank 0 process, and wait and receive messages from the rank 0
process. After getting all of the chain IDs we use \Cclass{ChainManager} to call
\Cmethod{setChainid}.

The constructor of \Cclass{Mcmc} initializes the rank of the class or the process, \Cmember{mFixed}, \Cmember{mReads}, and \Cmember{mChainManager}. We also initialize the two members of \Cmember{mLogLikelihoodPrior} and \Cmember{mChainid} for chain swaps. Additionally, we prepare chain swap acceptance ratios or \Cmember{mSwapCount} and \Cmember{mSwapTryCount}. Then, the constructor of \Cclass{ChainManager} creates an alloted number of chains for the process, and \Cmethod{setChainid} of the chain manager class sets the chain IDs and temperatures. See \Cmethod{setChainid} of the chain manager class. Now, turn to the most important method of \Cclass{Mcmc}, \Cmethod{swapChains}. The virtual \Cmethod{swap} of the class calls \Cmethod{swapChains} after collecting chain IDs and log likelihood/prior values from all of the chain managers and before distributing new chain IDs. See above for example of a chain index created from a vector of chain IDs. The chain index is the order vector of the indices of the vector of chain IDs. We refer to the log likelihood/prior using the value of a chain index. We need such a chain index vector because we wish to swap chains nearby. 
\begin{Verbatim}[frame=lines,framesep=5mm]
Index               0  1  2  3  4  5  6  7
mChainid            7  2  1  3  0  6  4  5
mLogLikelihoodPrior v7 v2 v1 v3 v0 v6 v4 v5
chainIndex          4  2  1  3  6  7  5  0
First move: c1 <> c4
chainIndex          4  6  1  3  2  7  5  0
Second move: c4 <> c6
chainIndex          4  6  1  3  5  7  2  0
Now, we find
mChainid            7  2  6  3  0  4  1  5
Results are:
c1 (> c4) > c6; c6 > c4; c4 > c1
Note that log likelihood/prior does not change in their indices.
\end{Verbatim}
We first construct \Cvariable{chainIndex} using \Cmember{mChainid}. We sample two nearby chain IDs. We find the two chain indices of the two chain IDs, respectively. We find log likelihood/prior values of the indices, and temperature values of the chain IDs. Upon accept of the swap of the two chain IDs we swap the chain indices. During the \Cmember{mNumberSwapTry}-many tries of chain swaps we keep trying to change \Cvariable{chainIndex}. Then, we convert the \Cvariable{chainIndex} to \Cmember{mChainid}.

We just delegate \Cmethod{reportSitewiseFrequencyBoundaries} and \Cmethod{reportSitewiseExpression} of \Cclass{ChainManager} when calling the methods of the same name of \Cclass{Mcmc}. The \Cmethod{report} prints out MCMC diagnostics including chain swap rates. We also delegate output stream operator using \Cclass{ChainManager}'s output stream operator.

Now, we turn to subclasses, \Cclass{McmcMpi} and \Cclass{McmcSingle} of \Cclass{Mcmc}. The \Cclass{McmcSingle} implements the virtual \Cmethod{swap}. Let us see how the method works. First, the \Cclass{McmcSingle} sends \Cmethod{chainid} and \Cmethod{likelihoodPrior} to the \Cclass{ChainManager} to query chain IDs and log likelihood/prior values. The chain manager asks its managed chains for chain IDs, and replies to the query of \Cclass{McmcSingle}. The chain manager also does similarly for log likelihood/prior values. We make \Cmember{mChainid} and \Cmember{mLogLikelihoodPrior} using the values retrieved from chains. Then, the \Cclass{McmcSingle} calls \Cmethod{swapChains} to swap chain IDs of \Cmember{mChainid}. The \Cclass{McmcSingle} sends \Cclass{ChainManager} \Cmethod{setChainid} with the \Cmember{mChainid}.

The \Cclass{McmcMpi} implements \Cmethod{swap} similarly but more complication. The \Cmethod{swap} starts just as that of \Cclass{McmcSingle}. Note that multiple MPI processes enter the method. Each MPI process sends \Cclass{ChainManager} the messages of \Cmethod{chainid} and \Cmethod{likelihoodPrior} in order to retrieve chain IDs and log likelihood/prior values. The zero rank MPI process waits for MPI messages from non-zero rank MPI processes. The zero rank MPI process call \Cmethod{swapChains} when it is finished with receiving messages from all of the processes including itself. After chain swaps we pack messages with new chain IDs to send them back to non-zero rank MPI processes. The non-zero rank MPI processes receive those chains IDs, and calls \Cmethod{setChainid} of \Cclass{ChainManager}. Note that \Cmember{processid} is the chain index of total chains when collecting chain IDs, and it is the chain index among the subset of chains managed by the chain manager when distributing chain IDs.

\subsection{ChainManager}
The \Cclass{Mcmc} owns an object of \Cclass{ChainManager}, which connects \Cclass{Mcmc} and \Cclass{Chain}. It manages a list of chains that runs on a single processor or thread.  The \Cclass{ChainManager} does not own objects of \Cmember{mFixed}, and \Cmember{mReads} just like \Cclass{Mcmc}. It accesses the two classes using the mere pointers to the objects of them.  The \Cclass{Mcmc} would not own them either. The \Cclass{ChainManager} owns \Cclass{Chain} objects in a vector, or \Cmember{mChain}. The call of the constructor with \Cmember{mFixed} and \Cmember{mReads} also creates chains in \Cmember{mChain}. The \Cclass{Chain} contains parameters of the model. Some of parameters are summarized by compiling posterior sample output files from each process or thread managed by \Cclass{Mcmc}, and \Cclass{ChainManager}. Other aspects of the parameters need on-line sampling because posterior output files can be too large to be stored in storage medias. The \Cmember{mSitewiseFrequencyBoundaries} and \Cmember{mSitewiseExpression} contains on-line samples of boundaries and expression levels. 

The \Cclass{ChainMananger} owns Markov chains, each of which is sent a message of chain IDs by the chain manager. When a chain manager informs chains of their chain IDs, the chains change their temperature before moving on next steps. The \Cclass{Mcmc} sends \Cclass{ChainManager} messages of \Cmethod{setChainid} to set chain IDs in the chains managed by the chain manager. We have two version of \Cmethod{setChainid}. We use the two-integer argument version when creating chains, and the vector argument one when swapping chains.  We send chain IDs and sums of log likelihood and log prior to \Cclass{Mcmc}, which uses \Cmethod{chainid} and \Cmethod{likelihoodPrior} to get those values.  The chain of writing sample in a file is as follows.
\begin{Verbatim}[frame=lines,framesep=5mm]
Manager::mcmc > operator Mcmc > operator ChainManager > operator Chain
\end{Verbatim}
We call \Cmethod{report} at the end of \Cmethod{mcmc}.
\begin{Verbatim}[frame=lines,framesep=5mm]
Manager::mcmc > Mcmc.report > ChainManager.report > Chain.report
\end{Verbatim}
The \Cmethod{report} is different from writing samples in a file. It reports some summary of each chains activity including chain ID changes, temperature changes, likelihood changes, etc. The \Cmethod{report} is called at the end of the \Cmethod{mcmc}. The \Cclass{Mcmc} sends the \Cclass{ChainManager} message of other reports such as \Cmethod{reportSitewiseExpression} and \Cmethod{reportSitewiseFrequencyBoundaries}. The \Cclass{ChainManager} collects sitewise frequency of boundaries and sitewise expression level from \Cclass{Chain}. The sitewise frequency of boundaries is stored in \Cmember{mSitewiseFrequencyBoundaries}, and the sitewise expression level in \Cmember{mSitewiseExpression}.

Members of \Cclass{ChainManager}:
\begin{itemize*}
\item private:
\item   ChainManager (); We do not allow a default constructor.
\item public:
\item   Fixed* mFixed; is a mere pointer to the program setup.
\item   vector<Reads*> mTxReads; is a list of short reads data.
\item   vector<Chain*> mChain; are chains. The class owns the memory of the chains.
\item   vector<unsigned int> mSitewiseFrequencyBoundaries; is a posterior sample of boundary frequency along the chromosome.
\item   vector<double> mSitewiseExpression; is another posterior sample of expression levels along the chromosome.
\item public:
\item   ChainManager (Fixed* m, const vector<Reads*>\& shortRead); constructs with \Cclass{Fixed} and \Cclass{Reads}.
\item   ~ChainManager (); frees the memory of chains. 
\item   void step (unsigned int); lets chains move and updates on-line parameter sampler such as \Cmember{mSitewiseExpression}.
\item   void setChainid (unsigned int s, unsigned int e); assigns chain IDs from $s$ and $e$, inclusively. Each chain changes the temperature using the newly assigned ID.
\item   void setChainid (vector<unsigned int>\& v); assigns chain IDs using $v$ when swapping chains. In the same manner each chain changes the temperature using the newly assigned ID.
\item   void chainid (vector<unsigned int>\&); returns the chain IDs. The \Cclass{Mcmc} sends this message to \Cclass{ChainManager} during chain swaps.
\item   void likelihoodPrior (vector<double>\&); returns the sums of log likelihood and log prior. The \Cclass{Mcmc} sends this message to \Cclass{ChainManager} during chain swaps.
\item   void reportSitewiseExpression (ostream\& out); reports values in \Cmember{mSitewiseExpression}. 
\item   void reportSitewiseFrequencyBoundaries (ostream\& out); reports values in \Cmember{mSitewiseFrequencyBoundaries}.
\item   void report (ostream \&out); reports MCMC diagnostics.
\item   friend ostream\& operator$\ll$ (ostream \&out, const ChainManager \&t); delegates output streams to chains in \Cmember{mChains}.
\end{itemize*}

The constructor of \Cclass{ChainManager} allocates memory of chains and summary. The \Cmethod{step} iterates each elment of chains, and sends a message of a single step to \Cclass{Chain}. The \Cclass{ChainManager} updates \Cmember{mSitewiseFrequencyBoundaries} and \Cmember{mSitewiseExpression} by sending \Cclass{Chain} update messages. The \Cclass{ChainManager} sends \Cmethod{chainid} to \Cclass{Chain} when setting chain IDs in the managed chains. It is sent \Cmethod{chainid} of \Cclass{ChainManager} not \Cclass{Chain}, and \Cmethod{likelihoodPrior} of \Cclass{ChainManager} by \Cclass{Mcmc} during chain swaps. See the trivial report methods.

\subsection{Chain}
The \Cclass{Chain} owns objects from \Cclass{RandomVariable}: \Cmember{mTxBoundaries}, and \Cmember{mTxExpression}.  The \Cmember{mMoverManager} is auto variable, and the others are pointers, which need to be deleted in the destructor.  The \Cclass{Chain} has access to \Cmember{mFixed}, and \Cmember{mReads}.  The first two \Cclass{Parameter} objects change their contents through \Cclass{Mover} objects that are managed by \Cclass{MoverManager}.  A mover manager allows us to call different movers with different proportion of MCMC runs. Additionally, \Cclass{Mover} objects are created in methods of \Cclass{Chain}. Objects of \Cclass{Mover}'s subclasses such as \Cclass{MoverTxBoundaries} are allowed to access \Cclass{Parameter} members in \Cclass{Chain}. We do this by giving \Cclass{MoverTxBoundaries} a pointer to the object of \Cclass{TxBoundaries}.  Let us check how we could propose a new state of \Cclass{TxBoundaries}, and accept or reject it in \Cclass{MoverTxBoundaries}. Do this in \Cclass{MoverTxExpression} as well.

A chain has an ID, \Cmember{mID}, which is used to set the temperature of the chain. The generation step of a chain is recored in \Cmember{mStep}. The \Cclass{Chain} still contains mere pointers to \Cclass{Fixed} and \Cclass{Reads}. The \Cclass{Parameter} subclass objects members include \Cmember{mTxBoundaries}, \Cmember{mTxExpression}, and \Cmember{mTxParameter}. The first two parameters are key to the model of \program{tux}. Additional more simpler parameters are stored in \Cclass{TxParameter}, which contains log likelihood, $\beta$ temperature, and the like. A chain moves through the Markov chain with a $\beta$ temperature value that is between 0 and 1 inclusively. The \Cclass{ChainManager} sends \Cclass{Chain} the message of \Cmethod{chainid} to change the chain ID and the $\beta$ temperature. We call \Cmethod{updateSitewiseFrequencyBoundaries} or \Cmethod{updateSitewiseExpression} to update these on-line parameter. The report and output stream operator prints out acceptance ratios and parameters, respectively.

We print out the state of a chain in the following format in a file at
\Cmember{mChainDirectory}/\Cmember{mPrefix}.rankID.chain.
\begin{Verbatim}[frame=lines,framesep=5mm]
-
  - [mID, mStep]            <- integers
  - [mBeta, mLoglikelihood] <- doubles
  - [c0, c1, ..., ck, ... ] <- integers
  - [e0, e1, ..., ek, ... ] <- doubles
\end{Verbatim}

The \Cclass{Summarizer} reads in chain files.

Members of \Cclass{Chain}:
\begin{itemize*}
\item private:
\item   Chain (); can be not instantiated as default constructor.
\item public:
\item   unsigned int mID; the chain ID, which is used to find $\beta$, the heating temperature
\item   unsigned int mStep; the numbers steps.
\item   Fixed* mFixed; is a mere pointer to the program setup.
\item   vector<Reads*> mReads; is a list of mere pointers to the data.
\item   MoverManager mMoverManager; is the mover manager.
\item   TxBoundaries* mTxBoundaries; the first parameter of boundaries
\item   TxExpression* mTxExpression; the second parameter of expression
\item   TxParameter* mTxParameter; is a simpler parameter than the other two. It contains log likelihood/prior, and $\beta$ temperature.
\item   vector<unsigned int> mTallyChainid; is the number of steps, for which a chain ID stays.
\item public:
\item   Chain (Fixed* m, const vector<Reads*>\& shortRead); creates a chain.
\item   ~Chain (); deletes the two parameters
\item   void TxFixed (Fixed* m); sets the program setup.
\item   void TxReads (const vector<Reads*>\& shortRead); sets the data.
\item   void step (unsigned int n); moves $n$ steps.
\item   void report (ostream \&out); writes some summary of the chain activity.
\item   friend ostream\& operator$\ll$ (ostream \&out, const Chain \&t); writes the state of the parameters.
\end{itemize*}

We creates \Cmember{mTxBoundaries}, \Cmember{mTxExpression}, and \Cmember{mTxParameter} in the constructor of \Cclass{Chain}. We also setup \Cclass{Mover} objects using \Cclass{MoverManager}. Before exiting the constructor we set the value of \Cmember{mLoglikelihood} using \Cclass{Likelihood}. The \Cmember{mTallyChainid} is initialized as well. Because \Cclass{Chain} owns the \Cclass{Parameters} objects, it deletes the memory of the three \Cclass{Parameters} objects. The \Cclass{MoverManager} owns \Cclass{Mover} subclass objects. The \Cclass{ChainManager} sends the message, \Cmethod{chainid}, to \Cclass{Chain} to change the chain ID and the temperature. The \Cclass{ChainManager} queries \Cclass{Chain} for the value of log likelihood and prior. See how \Cmethod{updateSitewiseExpression} and \Cmethod{updateSitewiseFrequencyBoundaries} works. We simply sum values without considering overflow problems. The \Cclass{Chain} sends the message of \Cclass{step} to \Cclass{Mover} subclasses. At the end of \Cmethod{step} of \Cclass{Chain} we increase counts for the chain ID in \Cmember{mTallyChainid}. In the report method we prints out acceptance ratios of movers using \Cclass{MoverManager}, and fractions of residence time of chain IDs in the current chain. 

\subsection{RandomVariables}
The \Cclass{TxBoundaries} is created in a method of class \Cclass{Chain}.  The \Cclass{MoverTxBoundaries} is created in a method of \Cclass{Chain}. Then, \Cclass{Chain} can connect its \Cclass{Parameters} and \Cclass{Data} to \Cclass{MoverTxBoundaries}.  It passes the connected \Cclass{MoverTxBoundaries} to \Cclass{MoverManager}. The chain uses \Cclass{Probability} and \Cclass{RandomVariable} to change the value of \Cclass{Parameter}. The \Cclass{Data} is a \Cclass{RandomVariable} that does not change its value. The \Cclass{Probability} is not a part of the chain. The chain must contain objects of \Cclass{RandomVariable}. The \Cclass{Chain} has access to \Cclass{Mover} via \Cclass{MoverManager}. There are multiple possible movers of parameters. The \Cclass{Chain} is manipulated to switch from one mover to another. Each step multiple movers are chosen to be applied to \Cclass{Chain}. The \Cclass{Mover} has access to \Cclass{Probability}: it could use some \Cclass{Probability} to replace a current state of \Cclass{Parameter} with another. The \Cclass{Chain} has an object of \Cclass{MoverManager}, which manages several \Cclass{Mover} objects. The \Cclass{MoverManager} is operational in that it returns a \Cclass{Mover} among the set of \Cclass{Mover} objects with multinomial probability.

\subsection{Parameter}
This is merely connecting \Cclass{RandomVariable} and other concrete classes such as \Cclass{TxBoundaries} or \Cclass{TxExpression}.

\subsection{TxBoundaries}
The \Cclass{TxBoundaries} object is created by \Cclass{ProbTxBoundaries}. The \Cclass{TxBoundaries}'s main features include writing the content to a file, and sampling segments to update. The \Cclass{TxBoundaries} is owned by \Cclass{Chain}, and be accessed by \Cclass{MoverTxBoundaries}. The boundary sites are 1-based positions in a chromosome. A value in \Cmember{mC} is 1-based position at the right-hand side of a segment. The last element of \Cmember{mC} is the size of the chromosome. When moving the state of a boundary site we choose one of $K$ boundary sites and change its position using so called mirror proposal. See \Cclass{MoverTxBSingle} for details. We also consider neighboring boundary sites on either side of a randomly chosen boundary site. See \Cclass{MoverTxBoundaries} for details. The \Cclass{TxBoundaries} can be printed out using \library{yaml-cpp} or the standard ostream. It prints out boundary sites separated by commas and braketed on either side. 

Members of \Cclass{TxBoundaries}:
\begin{itemize*}
\item public: 
\item   vector<unsigned int> mC; is 1-based ending positions of segments. The end position of $c_k$ where $k$ runs from 0 to $K$. $c_0$ is 0, and $c_K$ is $L$. \Cmember{mC} runs from 0 to $K-1$. The $0$-th element is $c_1$, and $K-1$-th element is $c_K$. Note that the first element is not 1.
\item public:
\item   TxBoundaries (); a default constructor.
\item   bool check (); checks if the data members are valid.
\item   unsigned int size (); is the number of segments.
\item   unsigned int L (); is the length of the chromosome.
\item   friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, const TxBoundaries \&tx); prints \Cmember{mC} in YAML format.
\item   friend ostream\& operator$\ll$ (ostream \&out, const TxBoundaries \&t);
\end{itemize*}

\subsection{TxExpression}
The \Cclass{TxExpression}'s main features include writing the content to a file, and sampling segments to update. The \Cclass{TxExpression} is owned by \Cclass{Chain}, and be accessed by \Cclass{MoverTxExpression}. The \Cmember{mDelta}'s length is that of a chromosome. The values of \Cmember{mDelta} are written similarly to that of \Cmember{mC} of \Cclass{TxBoundaries}.

Members of \Cclass{TxExpression}:
\begin{itemize*}
\item public:
\item   vector<double> mDelta; 
\item public:
\item   TxExpression ();
\item   friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, 
                                    const TxExpression \&tx);
\item   friend ostream\& operator$\ll$ (ostream \&out, const TxExpression \&t);
\end{itemize*}

\subsection{TxParameter}
We track other micellaneous parameters. See the data members of \Cclass{TxParameter}.

Members of \Cclass{TxParameter}:
\begin{itemize*}
\item public:
\item  double mLoglikelihood; is the total log likelihood.
\item  double mLogprior; is the total log prior, which is set to zero.
\item  double mBeta; is the $\beta$ temperature of the owner of a chain.
\item public:
\item  TxParameter ();
\item  friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, const TxParameter \&tx);
\item  friend ostream\& operator$\ll$ (ostream \&out, const TxParameter \&t);
\end{itemize*}

\subsection{Data}
We do not have members yet. This is just a base of fixed parameters. We would need to read and write \Cclass{RandomVariable} from and to a file using YAML. We have a likelihood that is used to compute the likelihood and to sample data given parameters.

\subsection{Reads}
We create a vector of \Cclass{Reads} to store the data for \program{tux}. We can find the index of the data using \Cmember{mJ}. The \Cmember{mN} is the total number of short reads.

Members of \Cclass{Reads}
\begin{itemize*}
\item public: 
\item   vector<unsigned int> mCount; is the number of counts of reads at the position. We only consider 5' end positions of short reads to count. 
\item   unsigned int mN; is the total number of counts derived from \Cmember{mCount}
\item   unsigned int mJ; is the index of replicates.
\item public:
\item   Reads (unsigned int j); is a constructor setting \Cmember{mJ} to $j$.
\item   unsigned int size (); the length of a chromosome 
\item   void sample (unsigned int l, unsigned int ul=10); sets counts for each site to random values, the random values are between 0 and ul. The number of sites becomes $l$. This initializes the data members.
\item   void summary (ostream\& out); prints out total counts of reads with the index of replicates.
\item   friend YAML::Emitter operator (YAML::Emitter out, const Reads tx);
\item   istream\& operator$\gg$ (istream \&fin, Reads \&t); reads a replicate of short reads counts.
\item   ostream\& operator$\ll$ (ostream \&out, const Reads \&t); prints out counts separated by a space.
\item   void cut (const unsigned int b, const unsigned int e); deletes regions outside of the specified regions between $b$ and $e$.
\end{itemize*}

\subsection{Fixed}
The \Cclass{Fixed} is for the global program setup variable. The value of \Cmember{mL} is set to the number of sites in a chromosome. We use the short reads data to set the value of it. The options of the \program{tux} are configured using an input file, command line options, or command line options in the interactive mode. If options values are specified by neither the input file nor command line options, we use values in \Cclass{Default}. We illustrate the usage of \program{tux} using those default values. The command line options in the interactive mode override any values in \Cclass{Fixed}. In the batch mode, command line options override any values set by an input file. Some values are derived from values given by users. This includes temperature, random number seeds for MPI processes, and number of chains per process. 

The user can specify the start and end positions of a chromosome using \Cmember{mPosition}. The default of the variable is from 1 to the end of the chromosome. In the source code, we set the default of the start to 0. The first set of the variable happens when reading the tux input file. This value can be overrided by command line options.


Members of \Cclass{Fixed}
\begin{itemize*}
\item public: Data members
\item   double mMoverTxBSingleWeight; the weight of boundary single move.
\item   double mMoverTxBWeight; the weight of boundary move.
\item   double mMoverTxEWeight; the weight of expression move.
\item   unsigned int mLogVerbosity; the log verbosity level ranging from 1 to 5.
\item   unsigned long int mSeed; the random number generator seed
\item   unsigned int mK; the number of segments
\item   unsigned int mM; the number of segments
\item   vector<double> mZ; the size factors
\item   unsigned int mL; the length of a chromosome
\item   double mA0; the coefficient $a_0$ of the function $\phi$
\item   double mA1; the coefficient $a_1$ of the function $\phi$
\item   double mAlphaQExpression; the proposal controller of expression levels
\item   double mAlphaQBoundaries; the proposal controller of boundaries
\item   unsigned int mLengthSampleSegmentA; the length of sampled segments
\item   unsigned int mLengthSampleSegmentB; the length of sampled segments
\item   double mAlphaPriorExpression; constant $\alpha_k$ value for the
Dirichlet prior, we would set 0.01 to $\alpha_k$. 
\item   unsigned int mMcmcLength; total length of a MCMC chain
\item   unsigned int mMcmcBurnin; length of burn-in of the total length
\item   unsigned int mMcmcThin; length of generation between sampling
\item   unsigned int mNumberProcess; the number of processes
\item   unsigned int mNumberChain; the number of chains
\item   unsigned int mNumberSwap; the number of swap 
\item   unsigned int mNumberSwapTry; the number of swap tries
\item   unsigned int mSwapDistance; the jump distance from a chain ID
\item   string mPrefix; the prefix of all of output files
\item   string mOutDirectory; the output Directory name
\item   string mChainDirectory; the output chain Directory name
\item   string mLogDirectory; the log output Directory name
\item   string mDatafile; the output file name
\item   vector<unsigned long int> mProcessSeed; random seeds for separate
\item public:
\item   vector<double> mTemperature; a list of $\beta$ values.
\item   vector<unsigned long int> mProcessSeed; a list of random seeds for MPI version of tux.
\item   vector<unsigned int> mNumberChainPerProcess; e.g., c(3,3,2)  
\item   vector<unsigned int> mAccumulateNumberChain; e.g., c(0,3,6,8)
\item   pair<unsigned int,unsigned int> mPosition; the start and end positions of the chromosome to analyaze.
\item public: Methods
\item   Fixed (); default setup, when the user does not provide tux with values
in the input yaml file, it uses the initialized values in this constructor.
\item   \~{}Fixed ();
\item   int numberChainPerProcess (); sets \Cmember{mNumberChainPerProcess} and \Cmember{mAccumulateNumberChain} using the number of processors and compute nodes
\item   unsigned int K(); returns the number of segments
\item   friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, const Fixed \&t);
\item   friend void operator$\gg$ (const YAML::Node\& node, Fixed\& t);
\item   friend ostream\& operator$\ll$ (ostream \&out, const Fixed \&t);
\item   string chainFilename (unsigned int i);                                        
\item   string outFilename (unsigned int i);                                          
\item   string logFilename (unsigned int i);                                          
\item   string pFilename (int i = -1);                                                
\item   string prefixFilename (int i = -1);                                           
\item   void temperature ();                                                          
\item  int numberChainPerProcess ();      
\end{itemize*}


\subsection{Probability}

The \Cclass{Probability} is tightly linked with \Cclass{RandomVariable}. Two
sets of random variables are considered: one that is concerned, and the other
that is conditioned. We can sample random variates of the former set from
\Cclass{Probability}. We can compute the probability density for a specific
set of random variates. The set of random variables that are conditioned is
optional. We use \Cclass{Probability} for non-standard valued random variables.
We would use simpler functions or classes for sampling a random variate from a
uniform. 
Let us consider usages of \Cclass{Probability}. We want a negative binomial with
two parameters: mean and variance. The probability of a segment configuration is
distributed as a uniform with a probability of $\frac{1}{{L-1 \choose K-1}}$
where $L$ is the length of a genome where we have $K$ segments. A $k$-th segment
boundary is between $c_{k-1}+1$ and $c_k$ inclusively. The $c_0$ is 0, and $c_K$
is $L$. We impose a Dirichlet on expression level $\bm{\mu}$. An expression
level of $k$-th segment is $\mu_k$, which is $\delta_k M$ where $M$ is the total
expression level of a RNA-seq experiment. We should give a ``very''
uninformative prior on $\bm{\mu}$ using a set of values $\bm{\alpha}$. We use a
lagarithmic scale of $\bm{\mu}$. Given the prior we start with $\bm{s}^{(0)}$
and $\bm{\mu}^{(0)}$. These two values are sampled from each of their prior
distribution. The boundary value, $\bm{s}^{(0)}$, consists of
$\{c_{k}\}_{k=1\ldots K-1}$ where $c_k$ is the end position of $k$-th segment.
We need $K-1$ positive values. The expression value, $\bm{\mu}^{(0)}$, consists
of $K$ real values. We use $\bm{\delta}^{(0)}$ which is a set of fractions, and
only need $K-1$ values. We convert them in logarithmic scale. Let us go to
\Cclass{TxBoundaries} and \Cclass{TxExpression}, which are \Cclass{Parameter},
which in turn is \Cclass{RandomVariable}. A random variate is created from a
probability distribution. A class of \Cclass{Probability}, or a probability of a
set of transcript boundaries, would create an object of \Cclass{TxBoundaries}.
Let us create a probability of a set of transcript boundaries:
\Cclass{ProbTxBoundaries}. 

Members of \Cclass{Probability}
\begin{itemize*}
\item virtual double d () = 0; a value of a probability
\item virtual RandomVariable* r () = 0; a random variate
\end{itemize*}

\subsection{ProbTxBoundaries}
Two data members of the class are the length of a chromosome, and the number of sepecified segments. The constructor sets the two values. The probability of a configuration of boundary sites is $1/{(L-1) \choose (K-1)}.$ The \Cclass{ProbTxBoundaries} implements \Cmethod{r} by generating a sequence of positive integers from 1 to $L-1$ and sampling $K-1$ out of the $L-1$ values. We append the vector with $L.$ Then, we allocate the memory of \Cclass{TxBoundaries} using default constructor, and set the vector to the \Cmember{mC} of the \Cclass{TxBoundaries}.

Members of \Cclass{ProbTxBoundaries}
\begin{itemize*}
\item public:
\item   unsigned int mL; the length of a chromosome. 
\item   unsigned int mK; the number of segments.
\item public:
\item   ProbTxBoundaries (unsigned int l, unsigned int k); sets the length of a chromsome to l, and the number of segments to k. 
\item   double d (); a value of a probability of a transcipt boundaries: logarithmic value of $1/{(L-1) \choose (K-1)}.$
\item   RandomVariable* r (); a random variate of a transcript boundaries, \Cclass{TxBoundaries}.
\end{itemize*}

\subsection{ProbTxExpression}
The \Cmember{mDelta} is the main variable for expression level parameter. The other \Cmember{mAlpha} is a concentration parameter, which we assume usually be 1. The class implements the \Cmethod{r}, where we construct a vector of real values by sampling from Dirichlet distribution, and set the vector to \Cmember{mDelta} of a newly created \Cclass{TxExpression}.

Members of \Cclass{ProbTxExpression}
\begin{itemize*}
\item Data members:
\item vector<double> mAlpha; a concentration parameter
\item vector<double> mDelta; a random variate of Dirichlet
\item Methods:
\item  ProbTxExpression (const unsigned int k, const double a = 1.L); sets the
concentration parameter of Dirichlet distribution. The size is $k$, and
$\alpha_k$ is 1.
\item double d (); a value of a probability of transcipt expressions 
\item RandomVariable* r (); a random variate of transcript expressions
\end{itemize*}

\subsection{Likelihood}
The \Cclass{Likelihood} is used to compute the likelihood of data given the model parameters. It is useful in generating data given model parameters. The parameters would be generated by \Cclass{ProbTxBoundaries} and \Cclass{ProbTxExpression}. The length $L$ of a chromosome and the number $K$ of segments is the parameter to create the two parameters of boundaries ${c_k}$ and expression ${\delta_k}$. We need the average number $M$ of short reads, and/or the size factor, $Z$, of $J$ samples. We would be given $a_0$ and $a_1$ of negative binomial dispersion to sample short reads counts using the expression intensity $\mu$, which is equal to $z_j M \delta_k.$ The \Cclass{Fixed} is created from a YAML file. Two probability classes create \Cclass{TxBoundaries} and \Cclass{TxExpression}. The \Cclass{Likelihood} needs the three \Cclass{RandomVariable} objects to create \Cclass{Data} object. It does not own none of \Cclass{RandomVariable} objects.

Let us discuss this class in generating data under the model and computing the probability of data under the same model. The class implements \Cmethod{r} to generate data. We create a integer vector of size being equal to the number of sites of a chromosome. Then, we instantiate \Cclass{Reads} and set \Cmember{mCount} to the created integer vector. A number of fixed parameters are necessary for creating an integer vector. We need two parameters, \Cmember{mA0} and \Cmember{mA1}, for a dispersion function. We need total sequencing depth, \Cmember{mM}. Replicates of short reads can vary in their depth, which is specified by a size factor. Finally, we need expression level parameter, \Cmember{mDelta}, which is given by an object of \Cclass{TxExpression}. Given all of these parameters we sample number of reads mapped on the segments. We now compute the lengths of segments, and randomly position short reads on the segments. 

Let us turn to the implementation of \Cmethod{d} for computing the total likelihood. We assume dispersion function parameters, \Cmember{mA0} and \Cmember{mA1}. We need neither \Cmember{mM} nor a size factor. We first compute the lengths of all of the segments, and count short reads mapped on segments. We compute the probabilities of count data given expression level, \Cmember{mDelta}, and dispersion function parameter, and expression level under the negative binomial model. Then, we sum all of the log likelihood across all of the segments.

Members of \Cclass{Likelihood}
\begin{itemize*}
\item public:
\item   Fixed* mFixed; is a mere pointer to the \program{tux} setup.
\item   unsigned int mJ; is the replicate index.
\item   double mA0; is the first parameter of a dispersion function.
\item   double mA1; is the second parameter of a dispersion function.
\item   unsigned int mL; the length of a chromosome
\item   unsigned int mK; the number of segments
\item   double mM; the level of total expression 
\item   double mSizeFactor; a size factors
\item   vector<double> mDelta; a set of delta given by TxExpression
\item   vector<unsigned int> mC; a set of segments given by TxBoundaries
\item   vector<unsigned int> mCount; a set of reads counts along a chromosome
\item   unsigned int mN; the total number of reads
\item public:
\item   Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te); creates a likelihood object using the three random variables objects
\item   RandomVariable* r (); creates a data set.
\item   double d (); computes the likelihood.
\item   void J (unsigned int j); sets the replicate index.
\item   double sizeFactor (); returns the size factor.
\item   void sizeFactor (const double s); sets the size factor.
\item   void alpha (const double a0, const double a1); sets the dispersion function parameters.
\end{itemize*}

\subsection{TotalLikelihood}
The \Cclass{TotalLikelihood} is a convenient class for computing the likelihood of all of the replicates using all of the \Cclass{Parameter}, and \Cclass{Data}. This is used in setting up the starting likelihood.

\subsection{MoverManager}
The Markov chain Monte Carlo features mostly movers of the state of parameters. We often employ multiple movers. Calling multiple movers can be tuned so that bolder movers are more frequently tried. The \Cclass{MoverManager} registers multiple movers with weights. 

mId and mWeight could be owned by \Cclass{Mover}.

Members of \Cclass{MoverManager}:
\begin{itemize*}
\item public:
\item   vector<Mover*> mMover; a set of \Cclass{Mover} objects. The \Cclass{MoverManager} owns the \Cclass{Mover} object elements in \Cmember{mMover}. The \Cmethod{add} allocates the memory of a \Cclass{Mover} object. The \Cclass{MoverManager}'s destructor must deallocate the memory.
\item   vector<unsigned int> mId; is the Mover ID of the movers.
\item   vector<double> mWeight; is the weight of the movers.
\item   gsl\_ran\_discrete\_t* mGslRanDiscrete; is a lookup tabl for the discrete random number generator.
\item public:
\item   MoverManager (); 
\item   ~MoverManager (); frees mover objects, and \Cmember{mGslRanDiscrete}.
\item   void add (Mover*, const unsigned int, const double); adds a mover object with an ID and weight.
\item   Mover* choose (); chooses a mover.
\item   ostream\& operator$\ll$ (ostream \&out, const MoverManager \&t); prints out acceptance ratios.
\end{itemize*}

\subsection{Mover}

A \Cclass{Mover} may contain many different things. We would give an identifier
for a mover. A mover should be subclassed from the abstract \Cclass{Mover}.  

Members of \Cclass{Mover}:
\begin{itemize*}
\item  public:
\item    unsigned int mTry; the number of the move try
\item    unsigned int mAccepted; the number of the accepted ones
\item    bool mIsData; the flag of sampling from posterior (true) or from prior (false)
\item    unsigned int mID; is the ID of the mover.
\item    double mWeight; is the weight of the mover.
\item  public:
\item    Mover () : mTry(0), mAccepted(0) {}
\item    virtual int step () = 0;
\item    double acceptanceRatio (); returns the acceptance ratio in percent.
\end{itemize*}

\subsection{MoverTxBoundaries}
The \Cclass{MoverTxBoundaries} is one of the movers for transcript boundaries. We have most of \Cclass{RandomVariable} objects. The \Cmethod{step} chooses one of the bounary sites. We also choose neighboring boundary sites on either side. We then update the subset of boundary sites. We need to see details of \Cmethod{step} with two integer arguments.

We shuffle $c_k$ first, then choose $k$ many boundaries on either side, resulting in an odd number of boundaries except either end of the chromosome. Then, we will apply MoverTxBoundaries update. This is the same as MoverTxBoundaries update except the way we choose boundaries. Let us change the MoverTxBoundaries. We use \Cmember{mLengthSampleSegmentA} for the count of the either side boundary sites.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Find \texttt{left} and \texttt{right} of a sampled segment $\kappa$.
The size of $\kappa$ is \texttt{kappa}. We retrieve $\left\{ \delta_{k}\right\} _{k\in\kappa}$
in \texttt{deltaK}. We get $\left\{ c_{k}\right\} _{k\in\kappa}$
using \texttt{ck}. Compute the lengths, \texttt{lk}, of the segments.
The $\sum_{k\in\kappa}l_{k}$ is \texttt{sumLk}. We compute $\left\{ l_{k}\right\} _{k\in\kappa}$
using $\left\{ c_{k}\right\} _{k\in\kappa}.$ We find \texttt{bAlpha}
\[
\left\{ \frac{l_{k}}{\sum_{k'\in\kappa}l_{k'}}\alpha_{\mathrm{b}}\right\} 
\]
where $\alpha_{\mathrm{b}}$ is \texttt{mAlphaQBoundaries}, and $\sum_{k'\in\kappa}l_{k'}$
is \texttt{sumLk}. We sample 
\[
\left\{ \frac{l_{k}^{*}}{\sum_{k'\in\kappa}l_{k'}}\right\} 
\]
from Dirichlet distribution of concentration parameters just above,
stored in \texttt{a}. Because we let the length of a segment be greater
than or equal to 1, the proposal of boundaries is a little more complicated
than just described. Let us see the proposal of a new set of boundaries.
We compute \texttt{sumLkStar} as $\sum_{k'\in\kappa}l_{k'}-\left|\kappa\right|.$
The fraction $l_{k}/\sum_{k'\in\kappa}l_{k'}$ is \texttt{b}. We find
\texttt{bAlpha} 
\[
\left\{ \frac{l_{k}}{\sum_{k'\in\kappa}l_{k'}}\alpha_{\mathrm{b}}\right\} 
\]
where $\alpha_{\mathrm{b}}$ is \texttt{mAlphaQBoundaries}, and $\sum_{k'\in\kappa}l_{k'}$
is \texttt{sumLk}. Now, we use \texttt{bAlpha} to sample \texttt{a}.
We have to check if the sample \texttt{a} does not produce nemerical
errors when computing the proposal. In that case, we have to resample
\texttt{a} until the proposal ratio is well defined. We compute \texttt{aAlpha}
as 
\[
\left\{ \lambda_{k}^{*}\alpha_{\mathrm{b}}\right\} .
\]
We have not yet find the actual proposed boundaries. We compute the
partial sum, \texttt{aPartialSum}, $\left\{ \sum_{i=\mathrm{begin}(\kappa)}^{\mathrm{end}\left(\kappa\right)}\lambda_{i}^{*}=\overline{\lambda_{k}}\right\} _{k\in\kappa}$
where $\mathrm{begin}(\kappa)$ and $\mathrm{end}\left(\kappa\right)$
are the first and last elements of the set $\kappa,$ respectively.
We compute $\left\{ L_{\kappa}^{*}\overline{\lambda_{k}}=l_{k}^{*}\right\} _{k\in\kappa}$
where $L_{\kappa}^{*}=L_{\kappa}-\left|\kappa\right|,$ and convert
them to integers, stored in \texttt{ckA}. We let the last value be
$l_{\mathrm{end}\left(\kappa\right)}=L_{\kappa}^{*}.$ We set $\left\{ l_{k}^{*}\right\} _{k\in\kappa}$
to $\left\{ c_{\mathrm{begin}\left(\kappa\right)-1}+k\right\} _{k=1}^{\left|\kappa\right|},$
and store it in \texttt{s1}. Now, we add \texttt{s1} to \texttt{ckA}. 

This \texttt{ckA} is a new boundaries set for $k\in\kappa.$ We compute
the lengths of the new boundaries set stored in \texttt{lkA}. We use
them as ending positions of the first $\left|\kappa\right|-1$ segments.
The ending position of the last segment remains unchanged. Now, we
need to count reads in the new set of boundaries. The count vector
is of 0-based position. The number of reads at the first site of the
first segment of the set $\left|\kappa\right|$ is found at $c_{\mathrm{begin}\left(\kappa\right)-1},$
which is the right terminal 1-based position of the first segment.
We store the counts of reads of the set $\kappa^{*}$ in \texttt{cA}.
Similarly, we compute the counts of reads of the old set $\kappa$
in \texttt{cB}. We find $\mu_{k}=M\delta_{k},$ $n_{k}=1/\left(a_{0}+a_{1}/\mu_{k}\right),$
and $p_{k}=n_{k}/\left(n_{k}+\mu_{k}\right),$ stored in \texttt{muB},
\texttt{nB}, and \texttt{pB}, respectively. We use the three values
to compute the probability of observing the number of count \texttt{xkB}
under negative binomial distribution. We compute the probability for
the new set $\kappa^{*},$ similarly. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{MoverTxBSingle}
We shuffle $c_k$ first, then move one at a time. This is a second try of move of boundaries. We give the ID 3 for this move. Given a boundary site we find the left-hand side distance and the right-hand side one. We sample a new boundary site given the two distances.

\subsection{MoverTxExpression}

\begin{itemize*}
\item public: 
\item   Fixed* mFixed; is the \program{tux} setup.
\item   vector<Reads*> mReads; are pointers to Reads.
\item   TxBoundaries* mTxBoundaries; is a pointer to TxBoundaries.
\item   TxExpression* mTxExpression; is a pointer to TxExpression.
\item   TxParameter* mTxParameter; is a pointer to TxParameter.
\item   double mAverageTotalCount; the average of total reads counts
\item public:
\item   MoverTxExpression ();
\item   MoverTxExpression (Fixed* f, vector<Reads*>\& r, 
                          TxBoundaries* txb, TxExpression* txe); sets program
                          setup, data, boundaries, and expression.
\item  int step ();
\item  int step (unsigned int left, unsigned int right); 
\end{itemize*}

Use the different theta to compute the likeilhood ratio.
Compute the prior ratio because we give a diffuse Dirichlet prior.
Compute the MH ratio based on our move.
We need to access the prior of gene expression.
We need a point to the prior probability of expression.

Now, lK contains lengths of the segments.

Nj, a0, a1 are fixed for one sample. These are also fixed parameter.
They should be a part of data. We need a class of data for storing these
fixed parameters. Let us assume that we be given those fixed parameters.
ck, mDelta, 
ck, and Nj are for each sample.
gsl\_ran\_negative\_binomial\_pdf (k, p, n);
k is from ck.
mu is (Nj * mDelta)
p is n/(n+mu)
n is 1/(a0+a1/mu).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We sample \texttt{left} and \texttt{right} end positions of a segment
using \texttt{sampleSegment}. The \texttt{left} is uniformly chosen
among all of the sites in a chromosome. We use a value \texttt{mLengthSampleSegment}
to find \texttt{right}. We use \texttt{Fixed} class member \texttt{mLengthSampleSegment}.
In this \texttt{step} function we try to change $\left\{ \delta_{k}\right\} _{k\in\kappa}$
where $\kappa=\left\{ k:k\in[\mathrm{left},\mathrm{right}],k\in\mathbb{N}_{0}\right\} $
and $\mathbb{N}_{0}$ is a set of non-negative integers. Note that
here $k=0$ is for the first segment among the chosen segments in
$\kappa.$ The class \texttt{TxBoundaries} method \texttt{sampleSegment}
returns \texttt{left} and \texttt{right}. We grab $\left\{ \delta_{k}\right\} _{k\in\kappa}$
in a vector \texttt{dk} and \texttt{dkA}. Note that $k\in[\mathrm{left},\mathrm{right}]$
not $k\in[\mathrm{left},\mathrm{right})$ when we create \texttt{dk}
variable. We sum \texttt{dk} to find \texttt{sumDk}, or $\sum_{k'\in\kappa}\delta_{k'}.$
We compute 
\[
\left\{ \frac{\delta_{k}}{\sum_{k'\in\kappa}\delta_{k'}}\right\} _{k\in\kappa}
\]
as \texttt{b}.\texttt{ }We multiply \texttt{b }by $\alpha_{\mathrm{e}}$
to find\texttt{ bAlpha} where $\alpha_{\mathrm{e}}$ is \texttt{mAlpha}
of class \texttt{Fixed. }Now, we sample \texttt{a} from Dirichlet
distribution with concentration parameter \texttt{bAlpha}. Then, we
multiply \texttt{a} by \texttt{mAlpha} or $\alpha_{\mathrm{e}}$ to
have a new value of \texttt{aAlpha}. We also multiply \texttt{a} by
the sum \texttt{sumDk} to find \texttt{dkA}. Now that we sampled a
new $\left\{ \delta_{k}^{*}\right\} _{k\in\kappa}$ in \texttt{dkA},
we need to compute the acceptance probability for the expression level
move. An acceptance probability consists of likelihood ratio, prior
ratio, and MH ratio. 

We assume a diffused Dirichlet prior on the expression level parameter
$\left\{ \delta_{k}\right\} $ by having $\alpha_{k}=1.$ When we
move expression levels of a part of segment, we would need to compute
the prior ratio
\[
\frac{p\left(\bm{x}^{*};\bm{\alpha}\right)}{p\left(\bm{x};\bm{\alpha}\right)}=\prod_{k\in\kappa}\left(\frac{x_{k}^{*}}{x_{k}}\right)^{\alpha_{k}-1}
\]
where $\kappa$ is the index set of the part of segment. The logarithm
of the value is
\[
\sum_{k\in\kappa}\left(\alpha_{k}-1\right)\left(\log x_{k}^{*}-\log x_{k}\right)
\]
where $\alpha_{k}=1.$ In \texttt{MoverTxExpression::step} logA is
$\log x_{k}^{*},$ and \texttt{logB} is $\log x_{k}.$ We store the
prior ratio of expression in \texttt{prExpression}. The prior ratio
for transcript boundaries is 1 because of no changes to the boudaries
parameter. 

The Metropolis-Hastings ratio is
\[
\frac{q\left(\left\{ \delta_{k}^{*}\right\} _{k\in\kappa}\rightarrow\left\{ \delta_{k}\right\} _{k\in\kappa}\right)}{q\left(\left\{ \delta_{k}\right\} _{k\in\kappa}\rightarrow\left\{ \delta_{k}^{*}\right\} _{k\in\kappa}\right)}=\frac{\mathrm{Dirichlet}\left(\left\{ \delta_{k}\right\} _{k\in\kappa};\left\{ \frac{\alpha_{\mathrm{e}}\delta_{k}^{*}}{\sum_{k'\in\kappa}\delta_{k'}^{*}}\right\} _{k\in\kappa}\right)}{\mathrm{Dirichlet}\left(\left\{ \delta_{k}^{*}\right\} _{k\in\kappa};\left\{ \frac{\alpha_{\mathrm{e}}\delta_{k}}{\sum_{k'\in\kappa}\delta_{k'}}\right\} _{k\in\kappa}\right)}
\]


Computing likelihood ratio involves counting reads. First find $\left\{ c_{k}\right\} _{k\in\kappa}$
using \texttt{ck}. We compute $\left\{ l_{k}\right\} _{k\in\kappa}$
or \texttt{lK} where $l_{k}=c_{k}-c_{k-1}$ where $c_{-1}=0.$ 

Note that we still need to make Reads a vector.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Summarizer}

We combine all of .sfb files to a single .sbf file. Similarly, we combine values from .swe files.  The \Cmethod{listLoglikelihood} creates a .p file using one or more chain files.  Use Tracer to view the trajectory of log likelihoods of all of the chains.

HERE

We reads in posterior sample files from multiple chains to create
\Cclass{Summary} object.  

I consider a couple of options of summarizing boundaries. The first is
the sitewise boundary site frequency. Using a 100 or 1,000 of
boundaries posterior sample leads to too sparse values. So, we keep a vector of
size being equal to the number of total sites. For each iteration we increase
the number of counts for the boundary sites in the vector. We might consider a
range of possible $K$ or the number of segments. After all I am interested in
whether a site is a boundary site or not. 
As a second summarization option we compute sitewise expression levels using 
$\delta_k M / l_k$ where $M$ is the geometric mean of the total read counts. We
also have a vector of double for the logarithm of the sitewise value. We use the
log scale because some can be too large. 

The \Cmethod{fillStepIndex} finds the steps and associate them with indices, so
that we can use the index of a step when collecting values from chain files.


The \Cmethod{computeFrequencyBoundaries} creates a .wig file using one or more
chain files. Upload the wig file to the genome browser.


Use the following command line to print boundaries.
\begin{Verbatim}[frame=lines,framesep=5mm]
awk 'NR%5==4' s1.out.0.chain | less
\end{Verbatim}

\subsection{Summary}
We have a number of boundaries. We can compute the average number of times a
boundary exists to the right of a site. We compute average expression level for
each site. We do this using the posterior samples of boundaries and expression
levels. Use \Cclass{Summary} and \Cclass{Summarizer}. Multiple files should be
handled by \Cclass{Summarizer} because MPI processors create their own output
files. 

I could not find a good example for \Cclass{Summary} till the summary of
sitewise frequency of boundaries. I wish to count boundary sites, which is a
vector of size being equal to the number of sites of a chromosome. The
\Cclass{Mover} subclass objects need to access the vector. After more thoughts I
think that \Cclass{ChainManager} should access \Cclass{Chain}'s member or the
boundaries, and get boundary sites.


\subsection{System}
The \Cclass{System} inspects the local computer system. What do we need to know?
We need to know the number of CPUs, the size of memory, the number of computes
nodes, the speed of CPUs, etc.

\subsection{CAC MPI}

\begin{Verbatim}[frame=lines,framesep=5mm]
nsub mpi.sh
\end{Verbatim}

<<mpi2.sh>>=
CPUPERNODE=`grep processor /proc/cpuinfo|wc -l`
NODECNT=`wc -l<"$PBS_NODEFILE"`
PROCESSCNT=$$((CPUPERNODE * NODECNT))
 
mpdboot -n $NODECNT -r /usr/bin/ssh -f "$PBS_NODEFILE"
mpiexec -n $PROCESSCNT /your/program

<<mpi.sh>>=
#!/bin/sh
#PBS -A AcctNumber
#PBS -l walltime=02:00,nodes=4
#PBS -N mpiTest
#PBS -j oe
#PBS -q v4
 
# Because jobs start in the HOME directory, move to where we submitted.
cd "$PBS_O_WORKDIR" 
 
#Count the number of nodes
np=$(wc -l < $PBS_NODEFILE)
 
#boot mpi on the nodes
mpdboot -n $np --verbose -r /usr/bin/ssh -f $PBS_NODEFILE

# Copy data
mpiexec -ppn 1 -np $np cp $HOME/somedir/file.dat $TMPDIR/file.dat
 
#now execute one process per node
mpiexec -np $np $HOME/v4Test/hello.out
mpdallexit

<<hello.c>>=
#include <stdio.h>
#include <mpi.h>
 
int main(int argc, char ** argv)
{
  int size,rank;
  int length;
  char name[80];
  MPI_Status status;
  int workerIdx;
 
  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD,&rank);
  MPI_Comm_size(MPI_COMM_WORLD,&size);
  MPI_Get_processor_name(name,&length);
 
  if (rank==0) {
    printf("Hello MPI from the server process!\n");
 
    for (workerIdx=1; workerIdx<size; workerIdx++) {
      MPI_Recv(name, 80, MPI_CHAR, workerIdx, 999, MPI_COMM_WORLD, &status);
      printf("Hello MPI!\n");
      printf(" message from %d of %d on %s\n", workerIdx, size, name);
    }
  } else {
    MPI_Send(name,80,MPI_CHAR,0,999,MPI_COMM_WORLD);
  }
 
  MPI_Finalize(); 
}
@

\subsection{TUX GSL}

\begin{itemize*}
\item double gsl\_ran\_negative\_binomial\_lnpdf (const unsigned int k, const
double p, const double n); This computes logarithm of 
gsl\_ran\_negative\_binomial\_pdf funtion.
\end{itemize*}




Global variables
\begin{itemize*}
\item const gsl\_rng *gGslRng; the main function calls MPI\_Init function to create
processes. Prior to that function call we should create as many seeds as
processes.
\end{itemize*}


\subsection{GNU Scientific Library}

\begin{itemize*}
\item double                                                                          
gsl\_ran\_negative\_binomial\_lnpdf (const unsigned int k, 
                                 const double p, 
                                 const double n); computes logarithm of negaive
                                 binomial distribution
\item unsigned int 
fGslDistance (const vector<unsigned int>\& a, const vector<unsigned int>\& b);
computes the distance between two sets of boundaries.
\end{itemize*}

\begin{itemize*}
\item void fGslRngAlloc (); creates an random number generator.
\item void fGslRngFree (); deletes the random number genrator.
\item fGslRanDirichlet (vector<double>\& alpha, vector<double>\& theta, double e);
samples theta from Dirichlet distribution of concentration parameter
of alpha until all of the components in theta are greater than e.
\end{itemize*}

We borrow \Cfile{gtypes.h} from gnome's \Cfile{glib/gtypes.h}. 

\subsection{tux-gsl}
It tests GSL.

\subsection{tux-fixed}
We creates a \Cclass{Fixed} object and write the object to a file. We also
change the property of the object by reading in another file. This needs YAML
library.  We create a yaml file.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./tux-fixed tux-fixed.out
$ cp tux-fixed.out fixed.yaml
$ Edit fixed.yaml
\end{Verbatim}

The fixed.yaml should look like this.
\begin{Verbatim}[frame=lines,framesep=5mm]
Fixed:
  mA0: 0.5
  mA1: 2.5
  mAlphaQExpression: 1.5
  mAlphaQBoundaries: 1.7
  mLengthSampleSegmentA: 300
  mLengthSampleSegmentB: 600
  mAlphaPriorExpression: 0.04
  mMcmcLength: 3000
  mMcmcBurnin: 700
  mMcmcThin: 82
---
Reads:
  - [1, 32, 7, 9, 97, 3, 2, 5, 3, 7]
  - [2, 12, 7, 9, 98, 3, 1, 2, 3, 8]
  - [3, 13, 7, 8, 99, 3, 8, 4, 4, 9]
\end{Verbatim}

\subsection{tux-tx}
We use fixed.yaml to create tx.yaml.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./tux-tx tux-tx.out
$ cp tux-tx.out tx.yaml
\end{Verbatim}

The tx.yaml should look like the following verbatim section.
\begin{Verbatim}[frame=lines,framesep=5mm]
Fixed:
  mA0: 0.5
  mA1: 2.5
  mAlphaQExpression: 1.5
  mAlphaQBoundaries: 1.7
  mLengthSampleSegmentA: 300
  mLengthSampleSegmentB: 600
  mAlphaPriorExpression: 0.04
  mMcmcLength: 3000
  mMcmcBurnin: 700
  mMcmcThin: 82
---
Reads:
  - [1, 32, 7, 9, 97, 3, 2, 5, 3, 7]
---
TxBoundaries:
  - [2, 4, 6, 8, 10]
---
TxExpression:
  - [0.2, 0.2, 0.2, 0.2, 0.2]
\end{Verbatim}

\subsection{tux-probtx}
We test \Cclass{ProbTxBoundaries} and \Cclass{ProbTxExpression}.

\subsection{tux-prob}
We use \Cclass{Probability} to create \Cclass{RandomVariable} objects.

\subsection{tux-move}
We would read in input files. We change parameters. We do not include chains
yet.

\subsection{tux-chain}
We would test a single chain using \Cclass{Chain}.

\subsection{tux-log}
We would summarize an output file.

\subsection{tux-cm}
We would test multiple chains using \Cclass{ChainManager}.

\subsection{tux-sum}
We would summarize an output file.

\subsection{tux-mcmc}
We would test multiple chains in multiple processes.

\subsection{tux-cmd}
We would test tux commands using Readline library.

\subsection{tux-likelihood}

We generate a data set under the model. A number of model parameters include:
\begin{itemize*}
\item $J$ : 3
\item $L$ : 1,000 base pairs
\item $K$ : 5
\item $\bm{\lambda}$, $\bm{s}$ : a sample from Dirichlet(1)
\item $\bm{\delta}$, $\bm{\mu}$ : a sample from Dirichlet(1)
\item $\phi$ : a size as a function of $\mu$
\item $\bm{z}$ : a sample from uniform between 0.5 and 1.5
\item We repeat the above of simulation and inference 10 times. Note that we fix
the sampled values of $\bm{s}$, $\bm{\mu}$, and $\bm{z}$ throughout the 10 times
of simulation.
\end{itemize*}
We use \Cclass{Likelihood}, \Cclass{ProbTxBoundaries}, and
\Cclass{ProbTxExpression} to create objects of \Cclass{Reads},
\Cclass{TxBoundaries}, and \Cclass{TxExpression}. Then, we save them in a YAML
file. The three objects are serialized to YAML output stream. 

\section{Compilation}

\subsection{MacPort packages}

\subsection{Ubuntu packages}
Search http://packages.ubuntu.com for packages to install.
\begin{Verbatim}[frame=lines,framesep=5mm]
libgsl0-dev
libopenmpi-dev
libreadline6-dev
\end{Verbatim}

Build a debug version using CMake.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ cd output/src
$ mkdir debug
$ cd debug
$ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ CC=mpicc CXX=mpicxx cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ mpirun -n 2 tux mcmc
$ make
$ make VERBOSE=1
$ cd ..;rm -rf b;mkdir b;cd b;cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ cd ../../..;./run 2;cd output/src;rm -rf b;mkdir b;cd b;cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug;make
\end{Verbatim}

Delete CMakeCache.txt when you compile in a different machine.

Create a PDF document of this document. 
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./run 1
\end{Verbatim}

Tangle source codes of this document.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ mkdir -p output/src
$ ./run 2
$ pushd ../../..;./run 2;popd;make
\end{Verbatim}

To add a project create a source code, add it an executable in the CMakeLists
file, and tangle the source code by editting sh/noweb-tangle.sh script.

Debugging
\begin{Verbatim}[frame=lines,framesep=5mm]
print *(aAlpha._M_impl._M_start)@aAlpha.size()
\end{Verbatim}

\subsection{CMake}

See the following page for a tutorial of CTest.
\begin{Verbatim}
http://www.cmake.org/Wiki/CMake_Testing_With_CTest
\end{Verbatim}

\begin{Verbatim}
ENABLE_TESTING()
ADD_TEST(SimpleTest ${CMAKE_CURRENT_BINARY_DIR}/SimpleTest Hello)
\end{Verbatim}

When using Makefile generators, such as Unix Makefiles, Borland Makefiles, or
NMake Makefiles, the CTest can simply be run by running:
\begin{Verbatim}
make test
\end{Verbatim}

Use CMake, CTest, CDash, and CPack.

Find CMake modules at the following directory:
\begin{Verbatim}[frame=lines,framesep=5mm]
/Applications/CMake\ 2.8-8.app/Contents/share/cmake-2.8/Modules/
\end{Verbatim}

To add a custom CMake package
\begin{Verbatim}[frame=lines,framesep=5mm]
cp downloads/FindReadline.cmake output/src/cmake/Modules/
http://www.vtk.org/Wiki/CMake:How_To_Find_Libraries

cd test/cmake
./build s009
Find the CMAKE_ROOT
and copy downloads/FindGSL.cmake to CMAKE_ROOT
\end{Verbatim}

Set the version number.
Check if this system provide the log and exp functions.
See if we should use our own math functions.
Configure a header file to pass some of the CMake settings
to the source code.
Add the binary tree to the search path for include files
so that we will find config.h
Add the MathFunctions library.
Add the executable.
Add the install targets.
Enable dashboard scripting

-D\_DEBUG for having debug log.

cmake ../kdelibs -DCMAKE\_INSTALL\_PREFIX=/opt/kde4
CMAKE\_BUILD\_TYPE


<<CMakeLists.txt>>=
cmake_minimum_required(VERSION 2.8)
project (tux)
# find_package( MPI )
# set (CMAKE_VERBOSE_MAKEFILE true)
set (CMAKE_BUILD_TYPE DEBUG)
SET (yamlEmitter_SRCS 
  "yamlEmitter.cpp"
)
SET (monsters_SRCS 
  "monsters.cpp"
)
SET (ezlogger_SRCS 
  "ezlogger.cpp"
)
set (tux-log_SRCS 
  "tux-log.cpp"
)
set (tux-fixed_SRCS 
  "tux-fixed.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxData.cpp"
  "tuxFixed.cpp"
  "tuxReads.cpp"
)
set (tux-tx_SRCS 
  "tux-tx.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxData.cpp"
  "tuxFixed.cpp"
  "tuxReads.cpp"
)
set (tux-prob_SRCS 
  "tux-prob.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
)
set (tux-move_SRCS 
  "tux-move.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
)
set (tux-chain_SRCS 
  "tux-chain.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-cm_SRCS 
  "tux-cm.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-mcmc_SRCS 
  "tux-mcmc.cpp"
  "tuxMcmc.cpp"
  "tuxMcmcMpi.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-single_SRCS 
  "tux-single.cpp"
  "tuxMcmc.cpp"
  "tuxMcmcSingle.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-likelihood_SRCS 
  "tux-likelihood.cpp"
  "tuxDefault.cpp"
  "tuxError.cpp"
  "tuxMcmc.cpp"
  "tuxMcmcSingle.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-probtx_SRCS 
  "tux-probtx.cpp"
  "tuxDefault.cpp"
  "tuxError.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
)
set (tux-sum_SRCS 
  "tux-sum.cpp"
  "tuxSummarizer.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
)
set (tux_SRCS 
  "tux.cpp"
  "tuxProgress.cpp"
  "tuxSummary.cpp"
  "tuxSummarizer.cpp"
  "tuxMcmcSingle.cpp"
  "tuxDefault.cpp"
  "tuxError.cpp"
  "tuxSignal.cpp"
  "tuxHelp.cpp"
  "tuxManager.cpp"
  "tuxMcmc.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxTxParameter.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxMoverTxBSingle.cpp"
  "tuxLikelihood.cpp"
  "tuxTotalLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tuxmpi_SRCS 
  "tux.cpp"
  "tuxProgress.cpp"
  "tuxSummary.cpp"
  "tuxSummarizer.cpp"
  "tuxMcmcMpi.cpp"
  "tuxDefault.cpp"
  "tuxError.cpp"
  "tuxSignal.cpp"
  "tuxHelp.cpp"
  "tuxManager.cpp"
  "tuxMcmc.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxTxParameter.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxMoverTxBSingle.cpp"
  "tuxLikelihood.cpp"
  "tuxTotalLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
SET (fileman_SRCS 
  "fileman.cpp"
)

set (CMAKE_C_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -g3 -ggdb -O0")
set (CMAKE_CXX_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -g3 -ggdb -O0")

################################################################################
# This is for tux without MPI version.
# Comment the following two lines when compiling with MPI
################################################################################
################################################################################
# Uncomment two of the following lines to compile using openmpi compilers
# Comment the following four lines when compiling without MPI
# Add -D_MPI definition for MPI verstion.
################################################################################
# Under Ubuntu with Package installation
set (CMAKE_C_COMPILER mpicc)
set (CMAKE_CXX_COMPILER mpicxx)
# Under MacOSX with MacPort installation
#set (CMAKE_C_COMPILER openmpicc)
#set (CMAKE_CXX_COMPILER openmpicxx)
################################################################################
# Definitions
################################################################################
#add_definitions (-D_DEBUG)
add_definitions (-D_MPI -D_DEBUG)

set (CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}")
set (tux_VERSION_MAJOR 0)
set (tux_VERSION_MINOR 1)
include (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake)
include (${CMAKE_ROOT}/Modules/CheckIncludeFiles.cmake)
check_function_exists (log HAVE_LOG)
check_function_exists (exp HAVE_EXP)
check_include_files (malloc.h HAVE_MALLOC_H)
check_include_files (sys/file.h HAVE_SYS_FILE_H)
check_include_files (unistd.h HAVE_UNISTD_H)
check_include_files (string.h HAVE_STRING_H)
check_include_files (stdlib.h HAVE_STDLIB_H)
option(USE_MYMATH "Use my math implementation" OFF)
configure_file (
  "${PROJECT_SOURCE_DIR}/config.h.in"
  "${PROJECT_BINARY_DIR}/config.h"
  )
include_directories ("${PROJECT_BINARY_DIR}")
if (USE_MYMATH)
  include_directories ("${PROJECT_SOURCE_DIR}/MathFunctions")
  add_subdirectory (MathFunctions)
  set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
endif (USE_MYMATH)
#  set (EXTRA_LIBS ${EXTRA_LIBS})

# add_executable (ezlogger ${ezlogger_SRCS})
#add_executable (tux-log tux-log.cpp)

# GNU Scientific Library
find_package (GSL)
if (GSL_FOUND)
  include_directories (${GSL_INCLUDE_DIRS})
#  add_executable (tux-gsl tux-gsl.cpp tuxGslRng.cpp)
#  target_link_libraries (tux-gsl ${GSL_LIBRARIES})
else (GSL_FOUND)
  message (FATAL_ERROR "No GNU GSL library found")
endif (GSL_FOUND)

# YAML-CPP static library
find_library(YAMLCPP yaml-cpp /home/fs01/sc2265/usr/lib)
# find_library(YAMLCPP yaml-cpp)
if(${YAMLCPP} MATCHES NOTFOUND)
  message(FATAL_ERROR "No yaml-cpp found")
else(${YAMLCPP} MATCHES NOTFOUND)
  include_directories (/home/fs01/sc2265/usr/include)
  add_library(yaml STATIC IMPORTED)
  set_property(TARGET yaml PROPERTY IMPORTED_LOCATION ${YAMLCPP})
  set (tux-tx_LIBS ${tux-tx_LIBS} yaml)

  set (tux-tx_LIBS ${tux-tx_LIBS} ${GSL_LIBRARIES})
#  add_executable (tux-tx ${tux-tx_SRCS})
#  target_link_libraries (tux-tx ${tux-tx_LIBS})

  set (tux-probtx_LIBS ${tux-tx_LIBS})
#  add_executable (tux-probtx ${tux-probtx_SRCS})
#  target_link_libraries (tux-probtx ${tux-probtx_LIBS})

  set (tux-prob_LIBS ${tux-tx_LIBS})
#  add_executable (tux-prob ${tux-prob_SRCS})
#  target_link_libraries (tux-prob ${tux-prob_LIBS})

  set (tux-move_LIBS ${tux-tx_LIBS})
#  add_executable (tux-move ${tux-move_SRCS})
#  target_link_libraries (tux-move ${tux-move_LIBS})
  
  set (tux-chain_LIBS ${tux-tx_LIBS})
#  add_executable (tux-chain ${tux-chain_SRCS})
#  target_link_libraries (tux-chain ${tux-chain_LIBS})
  
  set (tux-cm_LIBS ${tux-tx_LIBS})
#  add_executable (tux-cm ${tux-cm_SRCS})
#  target_link_libraries (tux-cm ${tux-cm_LIBS})
  
  set (tux-mcmc_LIBS ${tux-tx_LIBS})
#  add_executable (tux-mcmc ${tux-mcmc_SRCS})
#  target_link_libraries (tux-mcmc ${tux-mcmc_LIBS})
  
  set (tux-likelihood_LIBS ${tux-tx_LIBS})
#  add_executable (tux-likelihood ${tux-likelihood_SRCS})
#  target_link_libraries (tux-likelihood ${tux-likelihood_LIBS})
  
  set (tux-single_LIBS ${tux-tx_LIBS})
#  add_executable (tux-single ${tux-single_SRCS})
#  target_link_libraries (tux-single ${tux-single_LIBS})
  
  set (tux-sum_LIBS ${tux-tx_LIBS})
#  add_executable (tux-sum ${tux-sum_SRCS})
#  target_link_libraries (tux-sum ${tux-sum_LIBS})
  
  set (tux-fixed_LIBS ${tux-tx_LIBS})
#  add_executable (tux-fixed ${tux-fixed_SRCS})
#  target_link_libraries (tux-fixed ${tux-fixed_LIBS})

  set (yamlEmitter_LIBS ${tux-tx_LIBS})
#  add_executable (yamlEmitter ${yamlEmitter_SRCS})
#  target_link_libraries (yamlEmitter ${yamlEmitter_LIBS})

  set (monsters_LIBS ${tux-tx_LIBS})
#  add_executable (monsters ${monsters_SRCS})
#  target_link_libraries (monsters ${monsters_LIBS})

  set (tux_LIBS ${tux-tx_LIBS})
endif(${YAMLCPP} MATCHES NOTFOUND)

# Not needed.
# add_library(readline STATIC IMPORTED)
# set_property(TARGET readline PROPERTY IMPORTED_LOCATION /usr/local/lib/libreadline.a)
# include_directories(${CMAKE_CURRENT_BINARY_DIR})

# fileman test
#add_executable (fileman ${fileman_SRCS})
#target_link_libraries(fileman readline)
#target_link_libraries(fileman -ltermcap)

################################################################################
# TUX
# 1. No tux version - do this for compiling other programs
# 2. tux without MPI
# 3. tux with MPI
################################################################################
# 1.
#add_executable (tux tux-v1.cpp)
# 2.
#set (tux_LIBS ${tux-tx_LIBS})
#add_executable (tux ${tux_SRCS})
#target_link_libraries(tux ${tux_LIBS} readline termcap)
# 3.
set (tux_LIBS ${tux-tx_LIBS})
add_executable (tux ${tuxmpi_SRCS})
target_link_libraries(tux ${tux_LIBS} mpi readline termcap)

#target_link_libraries (tux ${EXTRA_LIBS})

#add_executable (stl-transform stl-transform.cpp)

# Install
install (TARGETS tux DESTINATION bin)

# Tests
enable_testing ()
add_test (tuxUsage tux)
set_tests_properties (tuxUsage
  PROPERTIES 
  PASS_REGULAR_EXPRESSION "Usage:.*number"
  )

add_test (tuxGslCreate tux-gsl ${CMAKE_CURRENT_BINARY_DIR}/tux-gsl.out)
add_test (tuxGslCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-gsl.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-gsl.out)
add_test (tuxTxCreate tux-tx ${CMAKE_CURRENT_BINARY_DIR}/tux-tx.out)
add_test (tuxTxCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-tx.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-tx.out)
add_test (tuxProbCreate tux-prob ${CMAKE_CURRENT_BINARY_DIR}/tux-prob.out)
add_test (tuxProbCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-prob.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-prob.out)
add_test (tuxMoveCreate tux-move ${CMAKE_CURRENT_BINARY_DIR}/tux-move.out)
add_test (tuxMoveCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-move.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-move.out)
add_test (tuxChainCreate tux-chain ${CMAKE_CURRENT_BINARY_DIR}/tux-chain.out)
add_test (tuxChainCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-chain.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-chain.out)
add_test (tuxCMCreate tux-cm ${CMAKE_CURRENT_BINARY_DIR}/tux-cm.out)
add_test (tuxCMCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-cm.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-cm.out)
add_test (tuxSumCreate tux-sum ${CMAKE_CURRENT_BINARY_DIR}/tux-sum.out)
add_test (tuxSumCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-sum.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-sum.out)
add_test (tuxFixedCreate tux-fixed ${CMAKE_CURRENT_BINARY_DIR}/tux-fixed.out)
add_test (tuxFixedCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-fixed.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-fixed.out)

include (${CMAKE_ROOT}/Modules/InstallRequiredSystemLibraries.cmake)
set (CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/gpl-3.0.txt")
set (CPACK_PACKAGE_VERSION_MAJOR "${tux_VERSION_MAJOR}")
set (CPACK_PACKAGE_VERSION_MINOR "${tux_VERSION_MINOR}")
set (CPACK_PACKAGE_CONTACT       "tuxg@googlegroups.com")
include (CPack)

include (CTest)
@

<<MathFunctions/CMakeLists.txt>>=
# first we add the executable that generates the table
add_executable(MakeTable MakeTable.cpp)

get_target_property(MakeTableLocation MakeTable LOCATION)

# add the command to generate the source code
add_custom_command (
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  DEPENDS MakeTable
  COMMAND ${MakeTableLocation}
  ARGS ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  )

set_source_files_properties (
  mysqrt.cpp PROPERTIES 
  OBJECT_DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  )

# add the binary tree directory to the search path for include files
include_directories( ${CMAKE_CURRENT_BINARY_DIR} )

# add the main library
add_library(MathFunctions mysqrt.cpp)

install (TARGETS MathFunctions DESTINATION bin)
install (FILES MathFunctions.h DESTINATION include)
@

<<CMakeListsV1.txt>>=
cmake_minimum_required(VERSION 2.8)
ENABLE_TESTING()

PROJECT (tux)
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/Modules/")
SET (gsl_SRCS 
  "gsl.cpp"
)

# SET (CMAKE_EXE_LINKER_FLAGS "-static")
ADD_DEFINITIONS(-DHAVE_CONFIG_H) 
# SET (CMAKE_C_FLAGS_DEBUG "-Wno-write-strings -g3 -ggdb -O0")
# SET (CMAKE_CXX_FLAGS_DEBUG "-Wno-write-strings -g3 -ggdb -O0")
SET (CMAKE_C_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")
SET (CMAKE_CXX_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")

# YAML
add_library(yaml STATIC IMPORTED)
set_property(TARGET yaml PROPERTY IMPORTED_LOCATION /usr/local/lib/libyaml-cpp.a)
ADD_EXECUTABLE (monsters ${monsters_SRCS})
target_link_libraries(monsters yaml)
ADD_EXECUTABLE (yamlEmitter ${yamlEmitter_SRCS})
target_link_libraries(yamlEmitter yaml)

# GSL
ADD_EXECUTABLE (gsl ${gsl_SRCS})
find_package (GSL)
if (GSL_FOUND)
  include_directories(${GSL_INCLUDE_DIR})
  target_link_libraries (gsl ${GSL_LIBRARIES})
endif (GSL_FOUND)

# EzLogger
ADD_EXECUTABLE (ezlogger ${ezlogger_SRCS})

# Readline
# find_package (Readline)
add_library(readline STATIC IMPORTED)
set_property(TARGET readline PROPERTY IMPORTED_LOCATION /usr/local/lib/libreadline.a)
include_directories(${CMAKE_CURRENT_BINARY_DIR})
ADD_EXECUTABLE (fileman ${fileman_SRCS})
target_link_libraries(fileman readline)
target_link_libraries(fileman -ltermcap)

INCLUDE (CheckIncludeFiles)
CHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)
CHECK_INCLUDE_FILES (sys/file.h HAVE_SYS_FILE_H)
CHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)
CHECK_INCLUDE_FILES (string.h HAVE_STRING_H)
CHECK_INCLUDE_FILES (stdlib.h HAVE_STDLIB_H)
CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/config.h.in ${CMAKE_CURRENT_BINARY_DIR}/config.h)

@

\section{Code}

\subsection{Tux classes}

\begin{Verbatim}[frame=lines,framesep=5mm]
Manager - Dispatches user commands
  show - shows states of data, model, mcmc, and others
  model - sets model parameters
  mcmc - executes MCMC to sample from the posterior
  summarize - summarizes a posterior sample 
  save - saves the current state of data, model, mcmc, and others to a file
  load - loads a state of data, model, mcmc, and others from a file
  help - shows commands and their usages

Mcmc - Command MCMC
  show - shows a state of MCMC
  step - samples a next set of parameter values
  save - saves a current state of MCMC
  load - loads a state of mcmc from MCMC parts of a file
  burn - explores a posterior distribution without saving states of MCMC
  sample - continues to sample parameter values till a next save of a MCMC state
  swap - swaps chains of different temparatures

ChainManager - A controler of Markov chains
  step - proceeds to a next step of the chain
  save - saves a current state of the chain
  load - laods a state of a chain 
  temperature - temperature of the chain
  
Chain - A Markov chain of parameters
  step - proceeds to a next step of the chain
  save - saves a current state of the chain
  load - laods a state of a chain 
  temperature - temperature of the chain
  
Model - Command Model
  show - shows a state of model
  save - saves a current state of model
  load - loads a state of model

System - Computer system configuration
  show - shows info of CPUs, GPUs, memory, compute nodes

Help - Command help
  show - shows help messages by reading messages

Memory - Customized memory management

Probability - Probability distribution
  rv - add a set of random variables
  conditionalRv - add a set of conditional random variables
  d - computes density of the distribution
  r - generates random deviates of the distribution
  logD - computes log of density of the distribution

Likelihood - A probability of data given parameters
Posterior - A probability of parameters given data
Prior - A probability of paramters
Proposal - A probability of a set of parameters given another

ProbabilityRatio - A ratio of probabilities

RandomVariable - Random variables; e.g., data, parameters

Mover - Proposal of a new set of parameters

MoverTxBoundaries - Proposal of transcript boundaries
MoverTxExpression - Proposal of transcript expression

Data - A random variable that does not change

Reads - A data of short reads mapped on a genome

Parameter - A random variable that can vary

Temperature - A parameter of chain IDs 
TxBoundaries - A parameter of transcript boundaries
TxExpression - A parameter of transcript expression levels

Summarizer - Command summarize of chains of posterior samples
  show - shows a state of summarization
  do - computes summary of posterior samples
  save - saves a current state of the summary
  load - loads a state of a summary

Summary - Summary of chains of posterior samples for a parameter
  mean - computes mean values
  variance - computes variance to quantify uncertainty
  autocorrelation - computes autocorrelation
  save - saves a current state of the summary
  load - loads a state of a summary
\end{Verbatim}

\subsection{Copyright}
<<tux gnu copyright>>=
// This file is a part of tux.
//
// tux is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// tux is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with tux. If not, see <http://www.gnu.org/licenses/>.
@

\subsection{Main}

<<main gslrngrandomnumber>>=
namespace tux {
  struct c_gslrng {
    unsigned long int operator()() {
      return gsl_rng_get (gGslRng);
    }
  } gslrngRandomNumber;
}
<<tux.cpp>>=
<<tux gnu copyright>>
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif 
#ifdef _MPI
#include <mpi.h>
#endif // _MPI
#include <cstdlib>               // strtoul
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <vector>
#include <gsl/gsl_rng.h>
#include <readline/readline.h>
#include <readline/history.h>
#include "yaml-cpp/yaml.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxGslRng.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxHelp.h"
#include "tuxDefault.h"
#include "tuxError.h"
#include "tuxSignal.h"
#include "tuxString.h"
#include "tuxManager.h"
<<xmalloc decl>>
<<xmalloc defn>>
using namespace std;
using namespace tux;
Fixed gFixed;
vector<Reads*> gShortRead;
Manager gManager;
<<tux createArgvFromChar>>
<<main tuxlf>>
<<tux interative>>
<<command line>>
<<main gslrngrandomnumber>>
<<tux logfilename>>
int 
main (int argc, char* argv[])
{
  gFixed.init ();
  <<register signal>>
  stringstream ss; 
  string strLog;

  //////////////////////////////////////////////////////////////////////////////
  // Command lines - read a commmand and an input file name
  //////////////////////////////////////////////////////////////////////////////
  string logfilename = Default::mLogfilename;
  string infilename = Default::mInfilename;
  int sCommand = OPT_HELP;
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_HELP) 
            {
              Help::full ();
              return 0;
            }
          else if (args.OptionId() == OPT_VERSION) 
            {
              Help::version ();
              return 0;
            }
          else if (args.OptionId() == OPT_INFILE) 
            {
              infilename = args.OptionArg();
            }
          else if (args.OptionId() == OPT_LOGFILE) 
            {
              logfilename = args.OptionArg();
            }
          else if (args.OptionId() == OPT_FIXED
                   || args.OptionId() == OPT_INTERACTIVE
                   || args.OptionId() == OPT_MCMC
                   || args.OptionId() == OPT_SUMMARIZE) 
            {
              if (sCommand == OPT_HELP)
                {
                  sCommand = args.OptionId();
                }
              else
                {
                  cerr << "Error: Only one commmand is allowed!" << endl;
                  return 1;
                }
            }
        }
      else 
        {
          cerr << "Error: Invalid argument - " << args.OptionText() << endl;
          return 1;
        }
    }
  
  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  lf.open(logfilename.c_str(),std::fstream::out);
  if (lf.is_open() == false)
    {
      cerr << "Error: Could not open file ``" 
           << logfilename 
           << "''! Check if the file can be created!" << endl;
      return 1;
    }
  fGslRngAlloc ();

  //////////////////////////////////////////////////////////////////////////////
  // Interactive Mode
  //////////////////////////////////////////////////////////////////////////////
  if (argc == 1 || sCommand == OPT_INTERACTIVE)
    {
      char *line, *s;
      progname = argv[0];
      initialize_readline (); /* Bind our completer. */
      /* Loop reading and executing lines until the user quits. */
      for ( ; done == 0; )
        {
          line = readline ("> ");
          if (!line) break;
          /* Remove leading and trailing whitespace from the line.
             Then, if there is anything left, add it to the history list
             and execute it. */
          s = stripwhite (line);
          if (*s)
            {
              add_history (s);
              execute_line (s);
            }
          free (line);
        }
      fGslRngFree ();
      lf.close();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  ifstream fin(infilename.c_str());
  if (fin.is_open())
    {
      try 
        {
          YAML::Parser parser(fin);
          YAML::Node doc;
          parser.GetNextDocument(doc);
          doc["Fixed"] >> gFixed;
          fin.close();
        }
      catch(YAML::BadDereference& e) 
        {
          cerr << e.what() << "\n";
          cerr << "Error: Check if the file ``" << infilename
               << " is a proper tux yaml file." << endl;
          fin.close();
          lf.close();
          fGslRngFree ();
          return 1;
        }
      catch(YAML::ParserException& e) 
        {
          cerr << e.what() << "\n";
          fin.close();
          lf.close();
          fGslRngFree ();
          return 1;
        }
    }
  else
    {
      cerr << "Error: Could not open file ``" 
           << infilename 
           << "''! Check if the file exists." << endl;
      lf.close();
      fGslRngFree ();
      return 1;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Batch Mode - override options in the input file
  //////////////////////////////////////////////////////////////////////////////
  args.Init(argc, argv, g_rgOptions);
  bool isArgumentProcessedSuccessfully = true;
  while (args.Next()) 
    {
      string strArg;
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_POSITION) 
            {
              strArg = args.OptionArg();
              vector <string> fields;
              split (fields, strArg, "-" );
              if (fields.size() == 2)
                {
                  gFixed.mPosition.first = strtoul(fields.front().c_str(),NULL,0);
                  gFixed.mPosition.second = strtoul(fields.back().c_str(),NULL,0);
                }
              else
                {
                  isArgumentProcessedSuccessfully = false;
                }
              if (!(gFixed.mPosition.first < gFixed.mPosition.second))
                isArgumentProcessedSuccessfully = false;
            }
          else if (args.OptionId() == OPT_WITH_SITEWISEEXPRESSION) 
            gFixed.mSitewiseExpression = true;
          else if (args.OptionId() == OPT_WITH_SITEWISEBOUNDARIES) 
            gFixed.mSitewiseBoundaries = true;
          else if (args.OptionId() == OPT_WITH_LISTLIKELIHOOD) 
            gFixed.mListlikelihood = true;
          else if (args.OptionId() == OPT_WITHOUT_SITEWISEEXPRESSION) 
            gFixed.mSitewiseExpression = false;
          else if (args.OptionId() == OPT_WITHOUT_SITEWISEBOUNDARIES) 
            gFixed.mSitewiseBoundaries = false;
          else if (args.OptionId() == OPT_WITHOUT_LISTLIKELIHOOD) 
            gFixed.mListlikelihood = false;
          else if (args.OptionId() == OPT_WITHOUT_DATA) 
            gFixed.mIsData = false;
          else if (args.OptionId() == OPT_WITH_DATA) 
            gFixed.mIsData = true;
          else if (args.OptionId() == OPT_DATAFILE) 
            gFixed.mDatafile = args.OptionArg();
          else if (args.OptionId() == OPT_PREFIX) 
            gFixed.mPrefix = args.OptionArg();
          else if (args.OptionId() == OPT_OUTDIRECTORY) 
            gFixed.mOutDirectory = args.OptionArg();
          else if (args.OptionId() == OPT_CHAINDIRECTORY) 
            gFixed.mChainDirectory = args.OptionArg();
          else if (args.OptionId() == OPT_LOGDIRECTORY) 
            gFixed.mLogDirectory = args.OptionArg();
          else if (args.OptionId() == OPT_SEED) 
            gFixed.mSeed = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_MCMCLENGTH) 
            gFixed.mMcmcLength = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_MCMCBURNIN) 
            gFixed.mMcmcBurnin = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_MCMCTHIN) 
            gFixed.mMcmcThin = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_NUMBERCHAIN) 
            gFixed.mNumberChain = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_NUMBERSWAP) 
            gFixed.mNumberSwap = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_NUMBERSWAPTRY) 
            gFixed.mNumberSwapTry = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_SWAPDISTANCE) 
            gFixed.mSwapDistance = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_HALPHA) 
            gFixed.mHAlpha = atof(args.OptionArg());
          else if (args.OptionId() == OPT_HBETA) 
            gFixed.mHBeta = atof(args.OptionArg());
          else if (args.OptionId() == OPT_LOGVERBOSITY) 
            gFixed.mLogVerbosity = atoi(args.OptionArg());
          else if (args.OptionId() == OPT_SIZEFACTOR) 
            {
              isArgumentProcessedSuccessfully = DoMultiArgs(args, -1);
            }
          else if (args.OptionId() == OPT_LENGTHSAMPLESEGMENTA) 
            {
              gFixed.mLengthSampleSegmentA = strtoul(args.OptionArg(),NULL,0);
            }
          else if (args.OptionId() == OPT_LENGTHSAMPLESEGMENTB) 
            {
              gFixed.mLengthSampleSegmentB = strtoul(args.OptionArg(),NULL,0);
            }
          else if (args.OptionId() == OPT_NUMBER_BOUNDARIES) 
            gFixed.mK = strtoul(args.OptionArg(),NULL,0);
        }
    }
  gFixed.mSeed = fGslRngSeed (gFixed.mSeed);
  if (gFixed.check () == false || args.LastError() != SO_SUCCESS
      || isArgumentProcessedSuccessfully == false )
    {
      lf.close();
      fGslRngFree ();
      return 1;
    }
  else
    { 
      ss << gFixed; 
      strLog = ss.str();
      EZLOGGERVLSTREAM2(axter::log_always,lf) << strLog << endl; 
    }
  axter::ezlogger<>::set_verbosity_level_tolerance(
    static_cast<axter::verbosity>(gFixed.mLogVerbosity)
  );
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_very_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  bool isReadComplete = true;
  Reads* r;
  fin.open(gFixed.mDatafile.c_str());
  if (fin.is_open()) 
    {
      unsigned int i = 0;
      while (!fin.eof())
        {
          r = new Reads(i++);
          fin >> *r;
          if (r->mN == 0)
            {
              
            }
          else 
            {
              gShortRead.push_back(r);
            }
        }

      fin.close();
      unsigned int numberSite = r->size ();
      for (vector<Reads*>::iterator it = gShortRead.begin(); 
           it != gShortRead.end(); 
           it++)
        {
          if ((*it)->size() != numberSite)
            {
              isReadComplete = false;
            }
        }
    }
  else
    {
      cerr << "Error: Could not open file ``" 
           << gFixed.mDatafile
           << "''! Check if the file exists." << endl;
      lf.close();
      fGslRngFree ();
      return 1;
    }
  if (isReadComplete == true)
    {
      r = gShortRead.front();
      gFixed.mL = r->size ();
      double geometricMean = 0;
      for (vector<Reads*>::iterator it = gShortRead.begin(); 
           it != gShortRead.end(); 
           it++)
        {
          geometricMean += log(static_cast<double>((*it)->mN));
        }
      geometricMean /= static_cast<double>(gShortRead.size());
      gFixed.mM = exp(geometricMean);

      // Change the size of the data.
      if (gFixed.mPosition.first == 0)
        {
          gFixed.mPosition.first = 1;
          gFixed.mPosition.second = gFixed.mL;
        }
      for (vector<Reads*>::iterator it = gShortRead.begin(); 
           it != gShortRead.end(); 
           it++)
        {
          (*it)->cut (gFixed.mPosition.first,gFixed.mPosition.second);
        }
    }
  else
    {
      cerr << "Error: Could not successfully read file ``" 
           << gFixed.mDatafile
           << "''! Check the file." << endl;
      for (vector<Reads*>::iterator it = gShortRead.begin(); 
           it != gShortRead.end(); 
           it++)
        {
          delete *it;
        }
      lf.close();
      fGslRngFree ();
      return 1;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Execute the command.
  //////////////////////////////////////////////////////////////////////////////
  gManager.mFixed = &gFixed;
  gManager.mReads= gShortRead;

  switch (sCommand)
    {
    case OPT_MODEL:
      cout << "Modelling ..." << endl;
      break;
    case OPT_FIXED:
      cout << gFixed;
      for (vector<Reads*>::iterator it = gShortRead.begin(); 
           it != gShortRead.end(); 
           it++)
        {
          (*it)->summary(cout);
        }
      break;
    case OPT_MCMC:
      // cout << "Starting MCMC ..." << endl;
#ifdef _MPI
      int size,rank;
      int length;
      char name[80];
      MPI_Init(&argc, &argv);
      MPI_Comm_rank(MPI_COMM_WORLD,&rank);
      MPI_Comm_size(MPI_COMM_WORLD,&size);
      MPI_Get_processor_name(name,&length);
      assert(static_cast<unsigned int>(size)==gFixed.mNumberProcess);
      fGslRngSeed (gFixed.mProcessSeed.at(rank));
      axter::ezlogger_output_policy::mEzloggerOutputFilename 
        = gFixed.logFilename (rank);
      gManager.mcmc (rank);
      MPI_Finalize(); 
#else
      axter::ezlogger_output_policy::mEzloggerOutputFilename 
        = gFixed.logFilename (0);
      gManager.mcmc (0);
#endif // _MPI
      break;
    case OPT_SUMMARIZE:
      cout << "Summarizing a posterior sample ..." << endl;
      gManager.summarize ();
      break;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = gShortRead.begin(); 
       it != gShortRead.end(); 
       it++)
    {
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngFree ();
  lf.close();
  return 0;
}
@

<<tux createArgvFromChar>>=
namespace tux {
int 
createArgvFromChar (string &c, const char* arg, char*** argv, int* argc)
{
  string s(arg);
  istringstream iss(s);
  *argc = 0; 
  do
    {
       string sub; iss >> sub; (*argc)++;
    } 
  while (iss);

  iss.str(s); iss.clear();
  (*argv) = (char**) malloc ((*argc)*sizeof(char*));
  (*argv)[0] = (char*) malloc ((c.size()+1)*sizeof(char));
  strcpy((*argv)[0],c.c_str());
  for (int i = 1; i < (*argc); i++)
    {
       string sub;
       iss >> sub;
       (*argv)[i] = (char*) malloc ((sub.size()+1)*sizeof(char));
       strcpy((*argv)[i],sub.c_str());
    }
  return 0;
}
}
<<command line>>=
enum { 
    OPT_HELP, 
    OPT_INTERACTIVE,
    OPT_MODEL,
    OPT_FIXED,
    OPT_MCMC,
    OPT_SUMMARIZE,
    OPT_VERSION,
    OPT_INFILE,
    OPT_OUTFILE,
    OPT_LOGFILE,
    OPT_WITHOUT_DATA,
    OPT_WITH_DATA,
    OPT_DATAFILE,
    OPT_PREFIX,
    OPT_OUTDIRECTORY,
    OPT_CHAINDIRECTORY,
    OPT_LOGDIRECTORY,
    OPT_SEED,
    OPT_MCMCLENGTH,
    OPT_MCMCBURNIN,
    OPT_MCMCTHIN,
    OPT_NUMBERCHAIN,
    OPT_NUMBERSWAP,
    OPT_NUMBERSWAPTRY,
    OPT_SWAPDISTANCE,
    OPT_HALPHA,
    OPT_HBETA,
    OPT_LOGVERBOSITY,
    OPT_ALPHAQEXPRESSION,
    OPT_ALPHAQBOUNDARIES,
    OPT_SIZEFACTOR,
    OPT_LENGTHSAMPLESEGMENTA,
    OPT_LENGTHSAMPLESEGMENTB,
    OPT_WITH_SITEWISEEXPRESSION,
    OPT_WITH_SITEWISEBOUNDARIES,
    OPT_WITH_LISTLIKELIHOOD,
    OPT_WITHOUT_SITEWISEEXPRESSION,
    OPT_WITHOUT_SITEWISEBOUNDARIES,
    OPT_WITHOUT_LISTLIKELIHOOD,
    OPT_POSITION,
    OPT_NUMBER_BOUNDARIES,

    OPT_CHAIN,
    OPT_LIKELIHOOD,
    OPT_PRIOR,
    OPT_PRINT
};
CSimpleOpt::SOption g_rgOptions[] = {
    // ID TEXT TYPE
    { OPT_HELP,      "-h",        SO_NONE    },
    { OPT_HELP,      "--help",    SO_NONE    },
    { OPT_VERSION,   "--version", SO_NONE    },
    { OPT_INFILE,    "-i",        SO_REQ_SEP },
    { OPT_INFILE,    "--in",      SO_REQ_SEP },
    { OPT_INFILE,    "--infile",  SO_REQ_SEP },
    { OPT_OUTFILE,   "-o",        SO_REQ_SEP },
    { OPT_OUTFILE,   "--out",     SO_REQ_SEP },
    { OPT_OUTFILE,   "--outfile", SO_REQ_SEP },
    { OPT_LOGFILE,   "-l",        SO_REQ_SEP },
    { OPT_LOGFILE,   "--log",     SO_REQ_SEP },
    { OPT_LOGFILE,   "--logfile", SO_REQ_SEP },
    { OPT_PREFIX,    "--prefix",  SO_REQ_SEP },
    { OPT_OUTDIRECTORY,"--outdirectory", SO_REQ_SEP },
    { OPT_CHAINDIRECTORY,"--chaindirectory", SO_REQ_SEP },
    { OPT_LOGDIRECTORY,"--logdirectory", SO_REQ_SEP },
    // Commands
    { OPT_MODEL,     "model",     SO_NONE    },
    { OPT_INTERACTIVE,"interactive", SO_NONE},
    { OPT_FIXED,     "fixed",     SO_NONE    },
    { OPT_MCMC,      "mcmc",      SO_NONE    },
    { OPT_SUMMARIZE, "summarize", SO_NONE    },
    // Detailed options
    { OPT_WITHOUT_DATA, "--without-data", SO_NONE },
    { OPT_WITH_DATA, "--with-data", SO_NONE },
    { OPT_DATAFILE,  "--datafile", SO_REQ_SEP },
    { OPT_SEED,      "--seed", SO_REQ_SEP },
    { OPT_MCMCLENGTH,"--mcmclength", SO_REQ_SEP },
    { OPT_MCMCBURNIN,"--mcmcburnin", SO_REQ_SEP },
    { OPT_MCMCTHIN,  "--mcmcthin",   SO_REQ_SEP },
    { OPT_NUMBERCHAIN,"--numberchain", SO_REQ_SEP },
    { OPT_NUMBERSWAP,"--numberswap", SO_REQ_SEP },
    { OPT_NUMBERSWAPTRY,"--numberswaptry", SO_REQ_SEP },
    { OPT_SWAPDISTANCE,"--swapdistance", SO_REQ_SEP },
    { OPT_HALPHA,    "--halpha", SO_REQ_SEP },
    { OPT_HBETA,     "--hbeta", SO_REQ_SEP },
    { OPT_LOGVERBOSITY,"--logverbosity", SO_REQ_SEP },
    { OPT_ALPHAQEXPRESSION,"--alphaqexpression", SO_REQ_SEP },
    { OPT_ALPHAQBOUNDARIES,"--alphaqboundaries", SO_REQ_SEP },
    { OPT_SIZEFACTOR,"--sizefactor", SO_MULTI },
    { OPT_LENGTHSAMPLESEGMENTA,"--lengthsamplesegmenta", SO_REQ_SEP },
    { OPT_LENGTHSAMPLESEGMENTB,"--lengthsamplesegmentb", SO_REQ_SEP },
    { OPT_WITH_SITEWISEEXPRESSION, "--without-sitewiseexpression", SO_NONE },
    { OPT_WITH_SITEWISEBOUNDARIES, "--without-sitewiseboundaries", SO_NONE },
    { OPT_WITH_LISTLIKELIHOOD, "--without-listlikelihood", SO_NONE },
    { OPT_WITHOUT_SITEWISEEXPRESSION, "--with-sitewiseexpression", SO_NONE },
    { OPT_WITHOUT_SITEWISEBOUNDARIES, "--with-sitewiseboundaries", SO_NONE },
    { OPT_WITHOUT_LISTLIKELIHOOD, "--with-listlikelihood", SO_NONE },
    { OPT_POSITION, "--position", SO_REQ_SEP },
    { OPT_NUMBER_BOUNDARIES, "--number-boundaries", SO_REQ_SEP },

    // Other used commands
    { OPT_CHAIN, "chain", SO_NONE },
    { OPT_LIKELIHOOD, "likelihood", SO_NONE },
    { OPT_PRIOR, "prior", SO_NONE },
    SO_END_OF_OPTIONS // END
};

bool
DoMultiArgs(
    CSimpleOpt &    args, 
    int             nMultiArgs
    )
{
  bool v = true;
  char ** rgpszArg = NULL;

  // get the number of arguments if necessary
  if (nMultiArgs == -1) 
    {
      // first arg is a count of how many we have
      rgpszArg = args.MultiArg(1);
      if (!rgpszArg) 
        {
          cout << "Put --sizefactor at the end of the command line\n";
          v = false;
          return v;
        }
      nMultiArgs = atoi(rgpszArg[0]);
    }

  // get the arguments to follow
  rgpszArg = args.MultiArg(nMultiArgs);
  if (!rgpszArg) 
    {
      printf("%d: '%s' (1 use --help to get command line help) - %d\n",
             args.LastError(), args.OptionText(), nMultiArgs);
      v = false;
      return v;
    }

  if (args.OptionId() == OPT_SIZEFACTOR) 
    {
      gFixed.mZ.clear();
      for (int n = 0; n < nMultiArgs; ++n) 
        {
          double sizeFactor = atof(rgpszArg[n]);
          gFixed.mZ.push_back(sizeFactor);
        }
    } 
//  else if (args.OptionId() == OPT_LENGTHSAMPLESEGMENT) 
//    {
//      if (nMultiArgs == 2)
//        {
//          cout << rgpszArg[0] << " " << rgpszArg[1] << endl;
//          gFixed.mLengthSampleSegmentA = strtoul(rgpszArg[0],NULL,0);
//          gFixed.mLengthSampleSegmentB = strtoul(rgpszArg[1],NULL,0);
//        }
//      else 
//        {
//          v = false;
//        }
//    }
  return v;
}
@

<<tux interative>>=
int com_list PARAMS((char *));
int com_help PARAMS((char *));
int com_model PARAMS((char *));
int com_mcmc PARAMS((char *));
int com_save PARAMS((char *));
int com_load PARAMS((char *));
int com_fixed PARAMS((char *));
int com_reads PARAMS((char *));
int com_sum PARAMS((char *));
int com_quit PARAMS((char *));

typedef struct {
  char *name;/* User printable name of the function. */
  rl_icpfunc_t *func;/* Function to call to do the job. */
  char *doc;/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "list", com_list, "List files in DIR" },
  { "ls", com_list, "Synonym for `list'" },
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "model", com_model, "Model" },
  { "fixed", com_fixed, "Fixed" },
  { "reads", com_reads, "Reads" },
  { "sum", com_sum, "Summarize" },
  { "mcmc", com_mcmc, "MCMC" },
  { "save", com_save, "Saves a current state to a file" },
  { "load", com_load, "Loads a state from a file" },
  { "quit", com_quit, "Quit using tux" },
  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite (char *string);
COMMAND* find_command (char *name);
void too_dangerous (char *caller);
void initialize_readline ();
int execute_line (char *line);
int valid_argument (char *caller, char *arg);

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (char *s)
{
  char *r;

  r = (char *) xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

/* Execute a command line. */
int
execute_line (char *line)
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for tux.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (char *name)
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (char *string)
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator PARAMS((const char *, int));
char **fileman_completion PARAMS((const char *, int, int));

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
void
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "tux";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END bound the
   region of rl_line_buffer that contains the word to complete.  TEXT is
   the word to complete.  We can use the entire contents of rl_line_buffer
   in case we want to do some simple parsing.  Return the array of matches,
   or NULL if there aren't any. */
char **
fileman_completion (const char *text, int start, int end)
{
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);
  if (end == 0) { /* No code! */ }
    
  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (const char *text, int state)
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  name = commands[list_index].name;
  while (name)
    {
      list_index++;
      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
      name = commands[list_index].name;
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                          tux Commands                            */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* List the file(s) named in arg. */
int
com_list (char *arg)
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
int
com_help (char *arg)
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

int
com_model (char *arg)
{
  too_dangerous (arg);
  return (1);
}

enum { 
    OPT_FIXED_INFILE,
    OPT_FIXED_SHOW,
    OPT_FIXED_HELP
};
CSimpleOpt::SOption g_fixedOptions[] = {
    { OPT_FIXED_HELP,   "-h",       SO_NONE    },
    { OPT_FIXED_HELP,   "--help",   SO_NONE    },
    { OPT_FIXED_INFILE, "-i",       SO_REQ_SEP },
    { OPT_FIXED_INFILE, "--in",     SO_REQ_SEP },
    { OPT_FIXED_INFILE, "--infile", SO_REQ_SEP },
    { OPT_FIXED_SHOW,   "-s",       SO_NONE    },
    { OPT_FIXED_SHOW,   "--show",   SO_NONE    },
    SO_END_OF_OPTIONS // END
};

int
com_fixed (char *arg)
{
  string c("fixed");
  string infilename; 

  if (strlen(arg) == 0)
    {
      Help::fixed ();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Construct argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int argc;
  char** argv;
  createArgvFromChar (c, arg, &argv, &argc);

  //////////////////////////////////////////////////////////////////////////////
  // Use argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int sCommand;
  CSimpleOpt args(argc, argv, g_fixedOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_FIXED_HELP) 
            {
              sCommand = OPT_FIXED_HELP;
            }
          else if (args.OptionId() == OPT_FIXED_INFILE) 
            {
              infilename = args.OptionArg();
            }
          else if (args.OptionId() == OPT_FIXED_SHOW) 
            {
              cout << gFixed;
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }

  if (sCommand == OPT_FIXED_HELP)
    {
      Help::fixed ();
    }
  else if (infilename.size() > 0)
    {
      ifstream fin(infilename.c_str());
      if (fin.is_open())
        {
          YAML::Parser parser(fin);
          YAML::Node doc;
          parser.GetNextDocument(doc);
          doc["Fixed"] >> gFixed;
          fin.close();
          cout << "The file ``" << infilename 
               << "'' has been read successfully." << endl;
        }
      else
        {
          cout << "Check if the file ``" << infilename << "'' exists." << endl;
        }
      gFixed.check();
    }

  //////////////////////////////////////////////////////////////////////////////
  // Finalize argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < argc; i++)
    {
      free(argv[i]);
    }
  free(argv);

  return (1);
}

enum { 
    OPT_READS_INFILE,
    OPT_READS_SHOW,
    OPT_READS_HELP
};
CSimpleOpt::SOption g_readsOptions[] = {
    { OPT_READS_HELP,   "-h",       SO_NONE    },
    { OPT_READS_HELP,   "--help",   SO_NONE    },
    { OPT_READS_INFILE, "-i",       SO_REQ_SEP },
    { OPT_READS_INFILE, "--in",     SO_REQ_SEP },
    { OPT_READS_INFILE, "--infile", SO_REQ_SEP },
    { OPT_READS_SHOW,   "-s",       SO_NONE    },
    { OPT_READS_SHOW,   "--show",   SO_NONE    },
    SO_END_OF_OPTIONS // END
};
int
com_reads (char *arg)
{
  string c("reads");
  string infilename; 

  if (strlen(arg) == 0)
    {
      Help::reads ();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Construct argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int argc;
  char** argv;
  createArgvFromChar (c, arg, &argv, &argc);

  //////////////////////////////////////////////////////////////////////////////
  // Use argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int sCommand;
  CSimpleOpt args(argc, argv, g_readsOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_READS_HELP) 
            {
              sCommand = OPT_READS_HELP;
            }
          else if (args.OptionId() == OPT_READS_INFILE) 
            {
              infilename = args.OptionArg();
            }
          else if (args.OptionId() == OPT_READS_SHOW) 
            {
              for (vector<Reads*>::iterator it = gShortRead.begin(); 
                   it != gShortRead.end(); 
                   it++)
                {
                  (*it)->summary(cout);
                }
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }

  if (sCommand == OPT_READS_HELP)
    {
      Help::reads ();
    }
  else if (infilename.size() > 0)
    {
      Reads* r;
      ifstream fin(infilename.c_str());
      if (fin.is_open()) 
        {
          unsigned int i = 0;
          while (!fin.eof())
            {
              r = new Reads(i++);
              fin >> *r;
              if (r->mN == 0)
                {
                  //EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                                      //<< m.mDatafile << std::endl;
                }
              else 
                {
                  gShortRead.push_back(r);
                }
            }
          fin.close();
          cout << "The data file ``" << infilename 
               << "'' has been read successfully." << endl;
        }
      else
        {
          cout << "Unable to open file " << infilename << endl;
          cout << "Check if the file ``" << infilename << "'' exists." << endl;
        }
    }

  //////////////////////////////////////////////////////////////////////////////
  // Finalize argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < argc; i++)
    {
      free(argv[i]);
    }
  free(argv);
  return (1);
}

enum { 
    OPT_MCMC_HELP,
    OPT_MCMC_RUN,
    OPT_MCMC_SHOW
};
CSimpleOpt::SOption g_mcmcOptions[] = {
    { OPT_MCMC_HELP,   "-h",       SO_NONE    },
    { OPT_MCMC_HELP,   "--help",   SO_NONE    },
    { OPT_MCMC_RUN,    "-r",       SO_NONE    },
    { OPT_MCMC_RUN,    "--run",    SO_NONE    },
    { OPT_MCMC_SHOW,   "-s",       SO_NONE    },
    { OPT_MCMC_SHOW,   "--show",   SO_NONE    },
    SO_END_OF_OPTIONS // END
};
int
com_mcmc (char *arg)
{
  string c("mcmc");
  string infilename; 

  if (strlen(arg) == 0)
    {
      Help::mcmc ();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Construct argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int argc;
  char** argv;
  createArgvFromChar (c, arg, &argv, &argc);

  //////////////////////////////////////////////////////////////////////////////
  // Use argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int sCommand;
  CSimpleOpt args(argc, argv, g_mcmcOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_MCMC_HELP) 
            {
              sCommand = OPT_MCMC_HELP;
            }
          else if (args.OptionId() == OPT_MCMC_RUN) 
            {
              sCommand = OPT_MCMC_RUN;
            }
          else if (args.OptionId() == OPT_MCMC_SHOW) 
            {
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }

  if (sCommand == OPT_MCMC_RUN)
    {
      gManager.mFixed = &gFixed;
      gManager.mReads= gShortRead;
      gManager.mcmc (0);
    }
  else if (sCommand == OPT_MCMC_HELP)
    {
      Help::mcmc ();
    }

  //////////////////////////////////////////////////////////////////////////////
  // Finalize argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < argc; i++)
    {
      free(argv[i]);
    }
  free(argv);
  return (1);
}

enum { 
    OPT_SUM_HELP,
    OPT_SUM_RUN
};
CSimpleOpt::SOption g_sumOptions[] = {
    { OPT_SUM_HELP, "-h", SO_NONE    },
    { OPT_SUM_HELP, "--help", SO_NONE    },
    { OPT_SUM_RUN, "-r",   SO_NONE },
    { OPT_SUM_RUN, "--run",   SO_NONE },
    SO_END_OF_OPTIONS // END
};
int
com_sum (char *arg)
{
  string c("sum");
  string infilename; 

  if (strlen(arg) == 0)
    {
      Help::sum ();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Construct argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int argc;
  char** argv;
  createArgvFromChar (c, arg, &argv, &argc);

  //////////////////////////////////////////////////////////////////////////////
  // Use argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int sCommand;
  CSimpleOpt args(argc, argv, g_sumOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_SUM_HELP) 
            {
              sCommand = OPT_SUM_HELP;
            }
          else if (args.OptionId() == OPT_SUM_RUN) 
            {
              sCommand = OPT_SUM_RUN;
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }

  if (sCommand == OPT_SUM_RUN)
    {
      gManager.mFixed = &gFixed;
      gManager.mReads= gShortRead;
      gManager.summarize ();
    }
  else if (sCommand == OPT_SUM_HELP)
    {
      Help::sum ();
    }

  //////////////////////////////////////////////////////////////////////////////
  // Finalize argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < argc; i++)
    {
      free(argv[i]);
    }
  free(argv);
  return (1);
}

int
com_save (char *arg)
{
  too_dangerous (arg);
  return (1);
}

int
com_load (char *arg)
{
  too_dangerous (arg);
  return (1);
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
int
com_quit (char *arg)
{
  if (!arg)
    arg = "";
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
void
too_dangerous (char *caller)
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (char *caller, char *arg)
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}


@

\subsection{String}
See the web site at http://www.cplusplus.com/faq/sequences/strings/split.
<<tuxString.h>>=
<<tux gnu copyright>>
#ifndef _TUXSTRING_H_
#define _TUXSTRING_H_
#include <cstddef>
namespace tux {
enum empties_t { empties_ok, no_empties };
template <typename Container>
Container& split(
  Container&                            result,
  const typename Container::value_type& s,
  const typename Container::value_type& delimiters,
  empties_t                      empties = empties_ok )
{
  result.clear();
  size_t current;
  size_t next = -1;
  do
  {
    if (empties == no_empties)
    {
      next = s.find_first_not_of( delimiters, next + 1 );
      if (next == Container::value_type::npos) break;
      next -= 1;
    }
    current = next + 1;
    next = s.find_first_of( delimiters, current );
    result.push_back( s.substr( current, next - current ) );
  }
  while (next != Container::value_type::npos);
  return result;
}
}
#endif // _TUXSTRING_H_
<<tuxString.cpp>>=
<<tux gnu copyright>>
@

\subsection{Help}
<<tuxHelp.h>>=
<<tux gnu copyright>>
#ifndef _TUXHELP_H_
#define _TUXHELP_H_
namespace tux {
class Help {
public:
  static void full ();
  static void fixed ();
  static void reads ();
  static void mcmc ();
  static void sum ();
  static void version ();
};
}
#endif // _TUXHELP_H_

<<tuxHelp.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxDefault.h"
#include "tuxHelp.h"
using namespace std;
namespace tux {
void 
Help::full ()
{
  cout << ""
"tux Commands Manual\n"
"\n"
"NAME\n"
"   tux -- Transcripts boundaries uncertainty\n"
"\n"
"SYNOPSIS\n"
"   tux [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The program implements a statistical method of inferring uncertainty\n"
"   of transcript boundaries using RNA-seq data.\n"  
"   The method is described in Choi (2012).\n"
"\n"
"   General options: (Default Values)\n"
"      -h --help\n"
"         Shows this help message.\n"
"      --version\n"
"         Shows the version.\n"
"      -i, --in, --infile [INFILE]\n"
"         Reads in an input file (" 
<< Default::mInfilename << ").\n" << 
"      --datafile [DATAFILE]\n"
"         Reads the data file not specified in the input file ("
<< Default::mDatafile << ").\n" << 
"      -l, --log, --logfile [INFILE]\n"
"         Logs non-MCMC in a file (" 
<< Default::mLogfilename << ").\n" << 
"      --prefix [NAME]\n"
"         Output and log files prefix for MCMC (" 
<< Default::mPrefix << ").\n" << 
"      --outdirectory [DIRECTORY]\n"
"         Directory for MCMC summary output (" 
<< Default::mOutDirectory << ").\n" << 
"      --chaindirectory [DIRECTORY]\n"
"         Directory for MCMC output (" 
<< Default::mChainDirectory << ").\n" << 
"      --logdirectory [DIRECTORY]\n"
"         Directory for MCMC log (" 
<< Default::mLogDirectory << ").\n" << 
"      --without-data\n"
"         Runs MCMC without data or samples from the prior.\n"
"      --with-data\n"
"         Runs MCMC with data or samples from the posterior [Default].\n"
"      --seed [NUMBER]\n"
"         Sets the seed for the random number generator ("
<< Default::mSeed << ").\n" << 
"      --sizefactor [K] [N_1] [N_2] ... [N_K]\n"
"         Sets the size factors. Put this option at the end of the command line.\n"
"      --number-boundaries [NUMBER]\n"
"         Sets the number of boundaries ("
<< Default::mK << ").\n" <<
"      --lengthsamplesegmenta [NUMBER]\n"
"         Sets the number of boundaries on either side. (Recommended value is <10)\n"
"         Sets the start of the range of sampling segments ("
<< Default::mLengthSampleSegmentA << ").\n" <<
"      --lengthsamplesegmentb [NUMBER]\n"
"         Sets the end of the range of sampling segments ("
<< Default::mLengthSampleSegmentB << ").\n" <<
"      --mcmclength [NUMBER]\n"
"         Sets the total chain length ("
<< Default::mMcmcLength << ").\n" <<
"      --mcmcburnin [NUMBER]\n"
"         Sets the chain bunrin length ("
<< Default::mMcmcBurnin << ").\n" <<
"      --mcmcthin [NUMBER]\n"
"         Sets the chain thin length ("
<< Default::mMcmcThin << ").\n" <<
"      --numberchain [NUMBER]\n"
"         Sets the number of chains ("
<< Default::mNumberChain << ").\n" <<
"      --numberswap [NUMBER]\n"
"         Sets the interval between chain swaps ("
<< Default::mNumberSwap << ").\n" <<
"      --numberswaptry [NUMBER]\n"
"         Sets the number of swap tries ("
<< Default::mNumberSwapTry << ").\n" <<
"      --swapdistance [NUMBER]\n"
"         Sets twice the distance between two chains for swap ("
<< Default::mSwapDistance << ").\n" <<
"      --halpha [NUMBER]\n"
"         Sets the alpha for Metropolis-Coupled MCMC ("
<< Default::mHAlpha << ").\n" <<
"      --hbeta [NUMBER]\n"
"         Sets the beta for Metropolis-Coupled MCMC ("
<< Default::mHBeta << ").\n" <<
"      --position [NUMBER-NUMBER]\n"
"         Sets the two positions (1-END)\n" 
"      --logverbosity [NUMBER]\n"
"         Sets the verbosity level from 1 (lowest) to 5 (highest) (" 
<< Default::mLogVerbosity << ")\n"
<<
"\n"
"   Summarize options:\n"
"      --without-sitewiseexpression\n"
"         Do not summarize sitewise expression.\n"
"      --with-sitewiseexpression\n"
"         Summarizes sitewise expression [Default].\n"
"      --without-sitewiseboundaries\n"
"         Do not summarize sitewise boundaries.\n"
"      --with-sitewiseboundaries\n"
"         Summarizes sitewise boundaries [Default].\n"
"      --without-listlikelihood\n"
"         Do not list likelihoods.\n"
"      --with-listlikelihood\n"
"         List likelihoods [Default].\n"
"\n"
"   Commands:\n"
"      interactive\n"
"         Runs in interactive mode.\n"
"      fixed\n"
"         Shows the input file.\n"
"      mcmc\n"
"         Samples transcript boundaries.\n"
"      summarize\n"
"         Summarizes a posterior sample of transcript boundaries.\n"
"\n"
"   Files:\n"
"      INFILE\n"
"         A YAML file\n"
"      DATAFILE\n"
"         A short read counts data file\n"
"      OUTFILE\n"
"         Output and log files\n"
"      LOGFILE\n"
"         A log file\n"
"\n"
"   Usages:\n"
"      tux or tux interactive\n"
"         Run the interactive mode of tux.\n"
"      tux mcmc --infile INFILE\n"
"         Reads in an YAML file, and prints it out to standard output.\n"
"      tux summarize --infile INFILE\n"
"         Summarizes a posterior sample of transcript boundaries.\n"
"      tux mcmc -i INFILE --without-data --with-data\n"
"         The latter option --with-data overrides the former option.\n"
"      mpirun -n 2 tux mcmc -i INFILE\n"
"         Runs two MPI processes.\n"
"\n"
"AUTHOR\n"
"   Written by Sang Chul Choi\n"
"\n"
"REPORTING BUGS\n"
"   Report bugs to google group of tuxg at tuxg at googlegroups dot com\n"
"   You can visit a website at http://code.google.com/p/tuxg/\n"
"\n"
"VERSION\n"
"   tux 1.0 - Build IMRBUILDDATETIME\n"
"\n"
"COPYRIGHT\n"
"   Copyright (C) 2012- Sang Chul Choi\n"
"   See the source for copying conditions.\n"
"   There is NO warranty; not even for MERCHANTABILITY\n"
"\n"
"tux 1.0\n"
"";
}
void 
Help::fixed ()
{
  cout << ""
"NAME\n"
"   tux-fixed -- Read in an .yaml file\n"
"\n"
"SYNOPSIS\n"
"   fixed [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The program reads in an .yaml file to setup the program.\n"
"\n"
"   General options:\n"
"      -h --help\n"
"         Shows this help message.\n"
"      -i --infile [INFILE]\n"
"         Reads in an input file.\n"
"      -s --show\n"
"         Prints out the input file.\n"
"";
}
void 
Help::reads ()
{
  cout << ""
"NAME\n"
"   tux-reads -- Read in a short-reads count file\n"
"\n"
"SYNOPSIS\n"
"   reads [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The command reads in a short-reads count file.\n"
"\n"
"   General options:\n"
"      -h --help\n"
"         Shows this help message.\n"
"      -i --infile [INFILE]\n"
"         Reads in a count file.\n"
"      -s --show\n"
"         Prints out some of the count file.\n"
"";
}
void 
Help::mcmc ()
{
  cout << ""
"NAME\n"
"   tux-mcmc -- Execute an Markov chain Monte Carlo\n"
"\n"
"SYNOPSIS\n"
"   mcmc [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The command executes an Markov chain Monte Carlo.\n"
"\n"
"   General options:\n"
"      -h --help\n"
"         Shows this help message.\n"
"      -r --run\n"
"         Executes an MCMC.\n"
"      -s --show\n"
"         Prints out what?.\n"
"";
}
void 
Help::sum ()
{
  cout << ""
"NAME\n"
"   tux-sum -- Summarize a posterior sample\n"
"\n"
"SYNOPSIS\n"
"   sum [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The command summarizes a posterior sample.\n"
"\n"
"   General options:\n"
"      -h --help\n"
"         Shows this help message.\n"
"      -r --run\n"
"         Executes an MCMC.\n"
"";
}
void 
Help::version ()
{
  cout << ""
"tux 1.0 - Build IMRBUILDDATETIME\n"
"Written by Sang Chul Choi.\n"
"\n"
"Copyright (c) 2012- Sang Chul Choi\n"
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
"";
}
}
@

\subsection{YAML: data serialization}
<<monsters.cpp>>=
#include "yaml-cpp/yaml.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

// our data types
struct Vec3 {
   float x, y, z;
};

struct Power {
   std::string name;
   int damage;
};

struct Monster {
   std::string name;
   Vec3 position;
   bool alive;
   std::vector <Power> powers;
};

// now the extraction operators for these types
void operator >> (const YAML::Node& node, Vec3& v) {
   node[0] >> v.x;
   node[1] >> v.y;
   node[2] >> v.z;
}

void operator >> (const YAML::Node& node, Power& power) {
   node["name"] >> power.name;
   node["damage"] >> power.damage;
}

void operator >> (const YAML::Node& node, Monster& monster) {
   node["name"] >> monster.name;
   node["position"] >> monster.position;
   node["alive"] >> monster.alive;
   const YAML::Node& powers = node["powers"];
   for(unsigned i=0;i<powers.size();i++) {
      Power power;
      powers[i] >> power;
      monster.powers.push_back(power);
   }
}

int main()
{
   std::ifstream fin("monsters.yaml");
   YAML::Parser parser(fin);
   YAML::Node doc;
   parser.GetNextDocument(doc);
   for(unsigned i=0;i<doc.size();i++) {
      Monster monster;
      doc[i] >> monster;
      std::cout << monster.name << " alive? " << monster.alive << "\n";
   }

   return 0;
}
@

\subsection{YAML: Emitter}
<<yamlEmitter.cpp>>=
#include "yaml-cpp/yaml.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
int main()
{
  YAML::Emitter out;
  out.SetIndent(2); 
  bool tf = true;

  out << "Hello, World!";

  out << YAML::BeginSeq;
  out << "eggs";
  out << "bread";
  out << "milk";
  out << YAML::EndSeq;

  out << YAML::BeginMap;
  out << YAML::Key << "name";
  out << YAML::Value << "Ryan Braun";
  out << YAML::Key << "position";
  out << YAML::Value << "LF";
  out << YAML::EndMap;

  out << YAML::BeginMap;
  out << YAML::Key << "name";
  out << YAML::Value << "Barack Obama";
  out << YAML::Key << "children";
  out << YAML::Value << YAML::BeginSeq << "Sasha" << "Malia" << YAML::EndSeq;
  out << YAML::Key << "TFTRUE";
  out << YAML::Value << tf;
  tf = false;
  out << YAML::Key << "TFFALSE";
  out << YAML::Value << tf;
  out << YAML::EndMap;

  out << YAML::Literal << "A\n B\n  C";

  out << YAML::Flow;
  out << YAML::BeginSeq << 2 << 3 << 5 << 7 << 11 << YAML::EndSeq;

  out << YAML::BeginMap;
  out << YAML::Key << "method";
  out << YAML::Value << "least squares";
  out << YAML::Comment("should we change this method?");
  out << YAML::EndMap;

  out << YAML::BeginSeq;
  out << YAML::Anchor("fred");
  out << YAML::BeginMap;
  out << YAML::Key << "name" << YAML::Value << "Fred";
  out << YAML::Key << "age" << YAML::Value << "42";
  out << YAML::EndMap;
  out << YAML::Alias("fred");
  out << YAML::EndSeq;
   
  std::vector <int> squares;
  squares.push_back(1);
  squares.push_back(4);
  squares.push_back(9);
  squares.push_back(16);

  std::map <std::string, int> ages;
  ages["Daniel"] = 26;
  ages["Jesse"] = 24;

  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << ages;
  out << YAML::EndSeq;


//. Genome sequence length: 2032925
//. Short reads positions along the S. mutans genome: FASTQ001.start (1,19,20)
//. Size factors: 0.8700484 1.0158870 1.1285131
//. Number of transcripts: 
//. mean=q*s, size=q*s/d, d=a0+a1/mean
//. a0, a1 = 0.0269 6.2076
//. q is a parameter
//. mean is computed for each transcript
  out << YAML::BeginMap;
  out << YAML::Key << "GenomeLength" << YAML::Value << 2032925;
  out << YAML::Key << "SizeFactor" << YAML::Value << YAML::Flow; 
  out << YAML::BeginSeq << 0.8700484 << 1.0158870 << 1.1285131 << YAML::EndSeq;
  out << YAML::Key << "Alpha0" << YAML::Value << 0.0269;
  out << YAML::Key << "Alpha1" << YAML::Value << 6.2076;
  out << YAML::Key << "NumberK" << YAML::Value << 500;
  out << YAML::Key << "ShortReads" << YAML::Value << YAML::Flow;
  out << YAML::BeginSeq;
  // Read values from FASTQ001.start and write them to YAML.
  std::ifstream myfile ("../../../downloads/FASTQ001.start");
  if (myfile.is_open())
  {
    double value;
    while ( myfile.good() )
    {
      myfile >> value;
      out << value;
    }
    myfile.close();
  }
  // out << 0.8700484 << 1.0158870 << 1.1285131;
  out << YAML::EndSeq;
  out << YAML::EndMap;

  out << YAML::BeginSeq;
  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << YAML::Flow << squares;
  out << YAML::EndSeq;
  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << YAML::Flow << squares;
  out << YAML::EndSeq;
  out << YAML::EndSeq;

  std::cout << "Here's the output YAML:\n" << out.c_str() << std::endl;

  return 0;
}
@



\subsection{EzLogger Library}
<<ezlogger.cpp>>=
// Example code for EZLOGGER macros
#include "ezlogger_headers.hpp"

void some_funcxx()
{
        EZLOGGERFUNCTRACKER;
}

void some_funcx()
{
        EZLOGGERFUNCTRACKER;
        some_funcxx();
}

void some_func6()
{
        EZLOGGERFUNCTRACKER;
        EZLOGGERDISPLAY_STACK;
}

void some_func5(int &x)
{
        EZLOGGERFUNCTRACKER;
        --x;
        if (x > 0)
                some_func5(x); //test recursion
        else
                some_func6();
}

void some_func4()
{
        EZLOGGERFUNCTRACKER;
        int x = 3;
        some_func5(x);
}

void some_func3()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_funcxx();
        some_func4();
}

void some_func2()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_funcxx();
        some_func3();
        some_funcxx();
}

void some_func1()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_func2();
        some_funcxx();
}

int main(int argc, char**argv)
{
        axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);
        EZLOGGERFUNCTRACKER;
        int ReturnValue = 99;
        EZLOGGER_PRG_MAIN_ARG(argc, argv);
        EZDBGONLYLOGGER_PRG_MAIN_ARG(argc, argv);
        EZLOGGERVL_PRG_MAIN_ARG(axter::log_often, argc, argv);
        int i = 123;
        std::string somedata = "Hello World";
        EZLOGGER(i);
        EZDBGONLYLOGGER(i);
        EZLOGGERVL(axter::log_often)(i);

        EZLOGGERVAR(somedata);
        EZDBGONLYLOGGERVAR(somedata);
        EZLOGGERVLVAR(axter::log_often, somedata);
        
        bool SomeConditionVar = true;
        EZLOGGERVAR(SomeConditionVar == false);
        EZDBGONLYLOGGERVAR(SomeConditionVar == false);
        EZLOGGERVLVAR(axter::log_often, SomeConditionVar == true);

        EZLOGGERVLVARIFY(axter::log_often, SomeConditionVar == false);

        EZLOGGERSTREAM << somedata << " " << i << std::endl;
        EZLOGGERSTREAM << somedata << " next line " << i << std::endl;
        EZLOGGERSTREAM2(std::cerr) << somedata << " next line " << i << std::endl;
        EZDBGONLYLOGGERSTREAM << somedata << " " << i << std::endl;
        EZDBGONLYLOGGERSTREAM << somedata << " next line " << i << std::endl;
        EZLOGGERVLSTREAM(axter::log_often) << somedata << " " << i << std::endl;
        // EZLOGGERVLSTREAM(axter::levels(axter::log_often, axter::warn, __FUNCSIG__ /*or GNU PRETTY_FUNCTION*/,"Xyz Facility")) << somedata << " " << i << std::endl;

        EZLOGGERPRINT("i = %i and somedata = %s", i, somedata.c_str());
        EZDBGONLYLOGGERPRINT("i = %i and somedata = %s", i, somedata.c_str());
        EZLOGGERVLPRINT(axter::log_often)("i = %i and somedata = %s", i, somedata.c_str());
        //Alternative method
        EZLOGGERVL(axter::log_often).cprint("i = %i and somedata = %s", i, somedata.c_str());
        EZLOGGER.cprint("i = %i and somedata = %s", i, somedata.c_str());

        if (1)
        {
                EZLOGGERMARKER;
                EZDBGONLYLOGGERMARKER;
                EZLOGGERVLMARKER(axter::log_often);
        }

        some_func1();

        return EZLOGGERVAR(ReturnValue);
}
@

\subsection{Types}
<<gtypes.h>>=
<<tux gnu copyright>>
#ifndef __G_TYPES_H__
#define __G_TYPES_H__

#include <config.h>

__BEGIN_DECLS

/* Provide type definitions for commonly used types.
 * These are useful because a "gint8" can be adjusted
 * to be 1 byte (8 bits) on all platforms. Similarly and
 * more importantly, "gint32" can be adjusted to be
 * 4 bytes (32 bits) on all platforms.
 */

typedef char   gchar;
typedef short  gshort;
typedef int    gint;
typedef long   glong;
typedef gint   gboolean;

typedef unsigned char   guchar;
typedef unsigned short  gushort;
typedef unsigned int    guint;
typedef unsigned long   gulong;

typedef float   gfloat;
typedef double  gdouble;

typedef signed char gint8;
typedef unsigned char guint8;
typedef signed short gint16;
typedef unsigned short guint16;
typedef signed int gint32;
typedef unsigned int guint32;
typedef signed long gint64;
typedef unsigned long guint64;

/* Define min and max constants for the fixed size numerical types */
#define G_MININT8((gint8)  0x80)
#define G_MAXINT8((gint8)  0x7f)
#define G_MAXUINT8((guint8) 0xff)

#define G_MININT16((gint16)  0x8000)
#define G_MAXINT16((gint16)  0x7fff)
#define G_MAXUINT16((guint16) 0xffff)

#define G_MININT32((gint32)  0x80000000)
#define G_MAXINT32((gint32)  0x7fffffff)
#define G_MAXUINT32((guint32) 0xffffffff)

/* Portable endian checks and conversions
 *
 * glibconfig.h defines G_BYTE_ORDER which expands to one of
 * the below macros.
 */
#define G_LITTLE_ENDIAN 1234
#define G_BIG_ENDIAN    4321
#define G_PDP_ENDIAN    3412/* unused, need specific PDP check */


/* Basic bit swapping functions
 */
#define GUINT16_SWAP_LE_BE_CONSTANT(val)((guint16) ( \
    (guint16) ((guint16) (val) >> 8) |\
    (guint16) ((guint16) (val) << 8)))

#define GUINT32_SWAP_LE_BE_CONSTANT(val)((guint32) ( \
    (((guint32) (val) & (guint32) 0x000000ffU) << 24) | \
    (((guint32) (val) & (guint32) 0x0000ff00U) <<  8) | \
    (((guint32) (val) & (guint32) 0x00ff0000U) >>  8) | \
    (((guint32) (val) & (guint32) 0xff000000U) >> 24)))

__END_DECLS
#endif /* __G_TYPES_H__ */
@

\subsection{Manager}
<<tuxManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXMANAGER_H_
#define _TUXMANAGER_H_
#include <sstream>
#include <vector>
#include <ctime>
using namespace std;
namespace tux {
class Manager {
private:
  void printRemainingTime (stringstream& ss, 
                           unsigned int, unsigned int, unsigned int);
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  time_t mPrevTime;
public:
  Manager ();
  Manager (Fixed* m, const vector<Reads*>& shortRead);
  void show();
  void model();
  void mcmc(int r = 0);
  void summarize();
  void save();
  void load();
  void help();
};
}
#endif // _TUXMANAGER_H_

<<tuxManager.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <string>
#include <iomanip>
#include <fstream>
#include <algorithm>
#include <vector>
#include <ctime>
#include "ezlogger_headers.hpp"
#include "tuxFixed.h"
#include "tuxReads.h"
#ifdef _MPI
#  include "tuxMcmcMpi.h"
#else
#  include "tuxMcmcSingle.h"
#endif // _MPI
#include "tuxSummarizer.h"
#include "tuxManager.h"
using namespace std;
namespace tux {
Manager::Manager ()
{
}
Manager::Manager (Fixed* m, const vector<Reads*>& shortRead)
  : mFixed(m), mReads(shortRead)
{
}
void 
Manager::show()
{
  return;
}
void 
Manager::model()
{
  return;
}
void 
Manager::mcmc(int r)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  stringstream ss;
  string strLog;

  string cfn = mFixed->chainFilename (r);
  ofstream fout(cfn.c_str());
  if (fout.is_open() == false)
    {
      ss << "Error: Could not open file ``" 
         << cfn
         << "'' for MCMC output!";
      strLog = ss.str(); 
      EZLOGGERSTREAM << strLog << endl;
      return;
    }
#ifdef _MPI
  McmcMpi mMcmc (mFixed,mReads,r);
#else
  McmcSingle mMcmc (mFixed,mReads);
#endif // _MPI
  unsigned int s = 0;
  unsigned int sThin = mFixed->mMcmcThin;
  unsigned int sSwap = 0;
  unsigned int sTime = 0;
  time(&mPrevTime);
  while (s <= mFixed->mMcmcLength) 
    {
      // Total steps, Current steps, Steps taken, Times taken
      if (r == 0)
        {
          if (!(sTime < mFixed->mMcmcThin))
            {
              ss.str(string());
              ss << "Step: " << setw(10) << s << " - ";
              printRemainingTime (ss, mFixed->mMcmcLength, 
                                  s, mFixed->mMcmcThin);
              strLog = ss.str(); 
              EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog << endl;
              sTime = 0;
            }
          sTime++;
        }

      if (mFixed->mNumberChain > 1)
        {
          if (!(sSwap < mFixed->mNumberSwap))
            {
              mMcmc.swap ();
              sSwap = 0;
            }
          sSwap++;
        }
      if (mFixed->mMcmcBurnin <= s)
        {
          if (!(sThin < mFixed->mMcmcThin))
            {
              fout << mMcmc;
              sThin = 0;
            }
          sThin++;
        }
      mMcmc.step (1U, s);
      s++;
    }
  fout.close();

  // Reports chain swap ratios.
  if (r == 0)
    {
      cfn = mFixed->prefixFilename () + "mc3";
      fout.open(cfn.c_str());
      if (fout.is_open() == false)
        {
          ss << "Error: Could not open file ``" 
             << cfn
             << "'' for MCMC output!";
          strLog = ss.str(); 
          EZLOGGERSTREAM << strLog << endl;
          return;
        }
      mFixed->reportTemperature (fout);
      mMcmc.reportMC3 (fout);
      fout.close();
    }

  // Reports MCMC diagnostics.
  cfn = mFixed->prefixFilename (r) + "rpt";
  fout.open(cfn.c_str());
  if (fout.is_open() == false)
    {
      ss << "Error: Could not open file ``" 
         << cfn
         << "'' for MCMC output!"; 
      strLog = ss.str(); 
      EZLOGGERSTREAM << strLog << endl;
      return;
    }
  mMcmc.report (fout);
  fout.close();

  // Prints out site-wise frequency boundaries in file prefix.[rank].sfb
  cfn = mFixed->prefixFilename (r) + "sfb";
  fout.open(cfn.c_str());
  if (fout.is_open() == false)
    {
      ss << "Error: Could not open file ``" 
         << cfn
         << "'' for MCMC output!"; 
      strLog = ss.str(); 
      EZLOGGERSTREAM << strLog << endl;
      return;
    }
  mMcmc.reportSitewiseFrequencyBoundaries (fout);
  fout.close();

  // Prints out site-wise frequency boundaries in file prefix.[rank].swe
  cfn = mFixed->prefixFilename (r) + "swe";
  fout.open(cfn.c_str());
  if (fout.is_open() == false)
    {
      ss << "Error: Could not open file ``" 
         << cfn
         << "'' for MCMC output!"; 
      strLog = ss.str(); 
      EZLOGGERSTREAM << strLog << endl;
      return;
    }
  mMcmc.reportSitewiseExpression (fout);
  fout.close();

  return;
}
void 
Manager::printRemainingTime (stringstream& ss,
                             unsigned int total, 
                             unsigned int step, 
                             unsigned int taken)
{
  unsigned int remainingStep = (total - step) / taken;
  time_t c;
  time(&c);
  double d = difftime(c,mPrevTime) * static_cast<double>(remainingStep);

  char prev = cout.fill('-'); 
  ss << static_cast<int>(floor(d/3600.0)) << ":" 
     << setw(2) << static_cast<int>(floor(fmod(d,3600.0)/60.0)) << ":"
     << setw(2) << static_cast<int>(fmod(d,60.0));
  cout.fill(prev);
  mPrevTime = c;
}
void 
Manager::summarize()
{
  // Parse using one or more chain files.
  // Compute the mean estimate of the boundaries.
  Summarizer s (mFixed,mReads);
  s.execute ();
  return;
}
void 
Manager::save()
{
  return;
}
void 
Manager::load()
{
  return;
}
void 
Manager::help()
{
  return;
}
}
@

\subsection{Mcmc}
<<tuxMcmc.h>>=
<<tux gnu copyright>>
#ifndef _TUXMCMC_H_
#define _TUXMCMC_H_
#include <vector>
#include "tuxChainManager.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class Mcmc {
public:
  unsigned int mRank; 
  Fixed* mFixed;
  vector<Reads*> mReads;
  ChainManager mChainManager;
  vector<unsigned int> mChainid;
  vector<double> mLogLikelihoodPrior;
  vector<vector<unsigned int> > mSwapCount;
  vector<vector<unsigned int> > mSwapTryCount;

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return current++;}
  } uniqueNumber;

  struct c_msg1 {
    unsigned int processid;
    unsigned int chainid;
    double likelihoodPrior;
    void set (unsigned int x, unsigned int y, double z) {
      processid = x; chainid = y; likelihoodPrior = z;
    }
  } mMessage;

private:
  Mcmc ();
public:
  int swapChains ();
  Mcmc (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank);
  virtual ~Mcmc () {}
  int step (unsigned int n, unsigned int s);
  virtual int swap () = 0;
  int save ();
  int load ();
  void reportSitewiseExpression (ostream& out);
  void reportSitewiseFrequencyBoundaries (ostream& out);
  void reportMC3 (ostream &out);
  void report (ostream &out);
  friend ostream& operator<< (ostream &out, const Mcmc &t);
};
}
#endif // _TUXMCMC_H_

<<tuxMcmc.cpp>>=
<<tux gnu copyright>>
#include <iomanip>
#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include <numeric>    // partial_sum
#include <functional>
#include <algorithm>  // swap
#include <cassert>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxChainManager.h"
#include "tuxFixed.h"
#include "tuxGslRng.h"
#include "tuxMcmc.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
Mcmc::Mcmc (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank)
  : mRank(rank), mFixed(m), mReads(shortRead), mChainManager(m,shortRead,rank)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  mLogLikelihoodPrior.resize (mFixed->mNumberChain);
  mChainid.resize(mFixed->mNumberChain);

  // Each chain has a unique ID.
  uniqueNumber.current = 0;
  generate (mChainid.begin(),mChainid.end(),uniqueNumber);                 

  // Sets the temperature values
  if (mFixed->mNumberChain > 1)
    { 
      // Swap counts. 
      mSwapCount.resize(mFixed->mNumberChain);
      mSwapTryCount.resize(mFixed->mNumberChain);
      for (unsigned int i = 0; i < mFixed->mNumberChain; i++)
        {
          mSwapCount.at(i).resize(mFixed->mNumberChain,0);
          mSwapTryCount.at(i).resize(mFixed->mNumberChain,0);
        }
    }

  // This needs to be called at the end of the constructor, partly because
  // we need to know temperature values.
  // This is done in setChainid.
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) 
    << "Process rank - " << rank << endl;
  stringstream ss;
  string strLog;
  ss << "mNumberChainPerProcess -";
  for (unsigned int i = 0; i < mFixed->mNumberChainPerProcess.size(); i++)
    {
      ss << " " << mFixed->mNumberChainPerProcess.at(i);
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog << endl;
  ss.str(string());
  ss << "mAccumulateNumberChain -";
  for (unsigned int i = 0; i < mFixed->mAccumulateNumberChain.size(); i++)
    {
      ss << " " << mFixed->mAccumulateNumberChain.at(i);
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog << endl;
  ss.str(string());
  ss << "mChainid -";
  for (unsigned int i = 0; i < mChainid.size(); i++)
    {
      ss << " " << mChainid.at(i);
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
}
int
Mcmc::step (unsigned int n, unsigned int s)
{
#ifdef _DEBUG
  stringstream ss;
  ss << "Mover::step " << n;
  string strLog(ss.str());
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
#endif // _DEBUG
  mChainManager.step (n, s);
  return 0;
}
int
Mcmc::save ()
{
  return 0;
}
int
Mcmc::load ()
{
  return 0;
}
int
Mcmc::swapChains ()
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  vector<unsigned int> chainIndex(mChainid.size());
  for (unsigned int i = 0; i < mChainid.size(); i++)
    chainIndex.at(mChainid.at(i)) = i;

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  ss.str(string());
  ss << "  A-chainIndex" << mRank << ": ";
  for (unsigned int i = 0; i < chainIndex.size(); i++)
    {
      ss << " " << chainIndex.at(i);
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

  for (unsigned int i = 0; i < mFixed->mNumberSwapTry; i++)
    {
      unsigned int ci, cj;
      ci = static_cast<unsigned int>(
             gsl_rng_uniform_int(gGslRng,
               static_cast<unsigned long int>(mFixed->mNumberChain))
             );
      // We choose cj using a specified step.
      unsigned int l; // left-side positions available
      unsigned int r; // right-side available
      unsigned int b; // 0-th position in the 2*mFixed->mSwapDistance window
      if (ci < mFixed->mSwapDistance)
        l = ci;
      else
        l = mFixed->mSwapDistance;
      b = ci - l;
      if (mFixed->mNumberChain - ci - 1 < mFixed->mSwapDistance)
        r = mFixed->mNumberChain - ci - 1;
      else
        r = mFixed->mSwapDistance;
      cj = ci;
      while (cj == ci)
        {
          // [1, l + 1 + r] is the range from fGslRanMirror.
          // So, we subtract 1 from fGslRanMirror.
          cj = fGslRanMirror (l, r, mFixed->mSwapDistance) - 1 + b;
        }
      
      // Now, we need to know which elements are ci and cj
      // because chain IDs are not consecutive.
      unsigned pi = chainIndex.at(ci);
      unsigned pj = chainIndex.at(cj);
      double sumi = mLogLikelihoodPrior.at(pi);
      double sumj = mLogLikelihoodPrior.at(pj);
      double ti = mFixed->mTemperature.at(ci);
      double tj = mFixed->mTemperature.at(cj);
      double logAlpha = (ti - tj) * (sumj - sumi);

      double logAlphaUniform = log(gsl_rng_uniform (gGslRng));
      mSwapTryCount[ci][cj]++; // Later, we will fold the matrix diagonally.
      if (logAlpha < logAlphaUniform)
        {
          // Reject it.
        }
      else
        {
          // Accept it.
          mSwapCount[ci][cj]++;
          std::swap(chainIndex.at(ci),chainIndex.at(cj));
        }
    }

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  ss.str(string());
  ss << "  B-chainIndex" << mRank << ": ";
  for (unsigned int i = 0; i < chainIndex.size(); i++)
    {
      ss << " " << chainIndex.at(i);
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

  for (unsigned int i = 0; i < mChainid.size(); i++)
    mChainid.at(chainIndex.at(i)) = i;

  return 0;
}
void
Mcmc::reportSitewiseExpression (ostream& out)
{
  mChainManager.reportSitewiseExpression (out);
  return;
}
void
Mcmc::reportSitewiseFrequencyBoundaries (ostream& out)
{
  mChainManager.reportSitewiseFrequencyBoundaries (out);
  return;
}
void 
Mcmc::reportMC3 (ostream &out)
{
  stringstream ss;
  string strLog;

  // Fold the swap matrix diagonally.
  char prev = out.fill('-');
  out << setw(80) << "-" << endl;
  out << "Lower triangular matrix of chains swap rate:" << endl;
  out << setw(80) << "-" << endl;
  out.fill(prev);
  out << setw(5) << setprecision(3);
  unsigned int n = mChainid.size();
  if (n > 1)
    {
      for (unsigned int i = 1; i < n; i++)
        {
          for (unsigned int j = 0; j < i; j++)
            {
              mSwapCount[i][j] += mSwapCount[j][i];
              mSwapTryCount[i][j] += mSwapTryCount[j][i];
            }
        }

      for (unsigned int i = 1; i < n; i++)
        {
          ss.str(string());

          out << std::fixed
              << setw(6) << setprecision(3) << mFixed->mTemperature.at(i);
          ss << "c" << i;
          strLog = ss.str();
          out << setw(5) << strLog;
          for (unsigned int j = 0; j < i; j++)
            {
              double v = .0;
              if (mSwapTryCount[i][j] > 0)
                {
                  v = static_cast<double>(mSwapCount[i][j]) 
                      / static_cast<double>(mSwapTryCount[i][j])
                      * 100.0;
                }
              out << setw(5) << setprecision(1) << v;
            }
          out << endl;
        }

      out << setw(6) << "";
      for (unsigned int i = 0; i < n - 1; i++)
        {
          ss.str(string());
          ss << "c" << i;
          strLog = ss.str();
          out << setw(5) << strLog;
        }
      out << endl;
    }
  return;
}
void 
Mcmc::report (ostream &out)
{
  mChainManager.report (out);
  return;
}
ostream& 
operator<< (ostream &out, const Mcmc &t)
{
  out << t.mChainManager;
  return out;
}
}

<<tuxMcmcSingle.h>>=
<<tux gnu copyright>>
#ifndef _TUXMCMCSINGLE_H_
#define _TUXMCMCSINGLE_H_
#include <vector>
#include "tuxMcmc.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class McmcSingle: public Mcmc {
private:
  McmcSingle ();
public:
  McmcSingle (Fixed* m, const vector<Reads*>& shortRead);
  int swap ();
};
}
#endif // _TUXMCMCSINGLE_H_

<<tuxMcmcSingle.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <sstream>
#include <vector>
#include <numeric>    // partial_sum
#include <functional>
#include <algorithm>  // swap
#include <cassert>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGslRng.h"
#include "ezlogger_headers.hpp"
#include "tuxChainManager.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxMcmc.h"
#include "tuxMcmcSingle.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
McmcSingle::McmcSingle (Fixed* m, const vector<Reads*>& shortRead)
  : Mcmc(m,shortRead,0)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  assert (mFixed->mNumberProcess == 1);
}
int
McmcSingle::swap ()
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

  // Get chain IDs and likelihood+prior sum values from each of ChainManagers.
  vector<unsigned int> v1;
  vector<double> v2;
  mChainManager.chainid (v1);
  mChainManager.likelihoodPrior (v2);

  assert (mRank == 0);
  assert (mFixed->mNumberProcess == 1);
  if (mRank==0) 
    {
      for (unsigned int workerIdx = 0; 
           workerIdx < mFixed->mNumberProcess; 
           workerIdx++) 
        {
          for (unsigned int i = mFixed->mAccumulateNumberChain.at(workerIdx), j = 0;
               i < mFixed->mAccumulateNumberChain.at(workerIdx+1);
               i++, j++)
            {
              if (mRank == workerIdx)
                {
                  // Process ID, Chain ID, and likelihood/prior value.
                  mMessage.set (i, v1.at(j), v2.at(j)); 
                }
              else
                {
                  assert(0);
                }
              mChainid.at(mMessage.processid) = mMessage.chainid;
              mLogLikelihoodPrior.at(mMessage.processid) = mMessage.likelihoodPrior;
            }
        }

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  ss.str(string());
  ss << "A-Rank " << mRank << ": ";
  for (unsigned int i = 0; i < mChainid.size(); i++)
    {
      ss << " " << mChainid.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

      // Swap chains.
      swapChains ();

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  ss.str(string());
  ss << "B-Rank " << mRank << ": ";
  for (unsigned int i = 0; i < mChainid.size(); i++)
    {
      ss << " " << mChainid.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

      v1.clear();
      v1.resize(mFixed->mNumberChainPerProcess.at(mRank));
      for (unsigned int workerIdx = 0; 
           workerIdx < mFixed->mNumberProcess; 
           workerIdx++) 
        {
          for (unsigned int i = mFixed->mAccumulateNumberChain[workerIdx], j = 0;
               i < mFixed->mAccumulateNumberChain[workerIdx+1];
               i++, j++)
            {
              unsigned int pid = mFixed->mAccumulateNumberChain[workerIdx] + j;
              assert (pid == i);
              mMessage.set (i, mChainid.at(i), .0); 
              if (mRank == workerIdx)
                {
                  v1.at(j) = mMessage.chainid;
                }
              else
                {
                  assert (0);
                }
            }
        }
    }

  mChainManager.setChainid (v1);

  return 0;
}
}


<<tuxMcmcMpi.h>>=
<<tux gnu copyright>>
#ifndef _TUXMCMCMPI_H_
#define _TUXMCMCMPI_H_
#include <vector>
#include "tuxMcmc.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class McmcMpi: public Mcmc {
private:
  McmcMpi ();
public:
  McmcMpi (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank);
  int swap ();
};
}
#endif // _TUXMCMCMPI_H_

<<tuxMcmcMpi.cpp>>=
<<tux gnu copyright>>
#include <mpi.h>
#include <iostream>
#include <sstream>
#include <vector>
#include <numeric>    // partial_sum
#include <functional>
#include <algorithm>  // swap
#include <cassert>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxChainManager.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxMcmc.h"
#include "tuxMcmcMpi.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
McmcMpi::McmcMpi (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank)
  : Mcmc(m,shortRead,rank)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
}
int
McmcMpi::swap ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  MPI_Status status;

  // Get chain IDs and likelihood prior sum values from each of ChainManagers.
  vector<unsigned int> v1;
  mChainManager.chainid (v1);
  vector<double> v2;
  mChainManager.likelihoodPrior (v2);

  if (mRank==0) 
    {
      // We are at the main process or rank 0 process.
      // Receive messages to fill chain IDs and sums of likelihood and prior.
      for (unsigned int workerIdx = 0; 
           workerIdx < mFixed->mNumberProcess; 
           workerIdx++) 
        {
          for (unsigned int i = mFixed->mAccumulateNumberChain.at(workerIdx), j = 0;
               i < mFixed->mAccumulateNumberChain.at(workerIdx+1);
               i++, j++)
            {
              if (mRank == workerIdx)
                {
                  // Process ID, Chain ID, and likelihood/prior value.
                  mMessage.set (i, v1.at(j), v2.at(j)); 
                }
              else
                {
                  MPI_Recv(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 
                           workerIdx, 999, MPI_COMM_WORLD, &status);
                }
              mChainid.at(mMessage.processid) = mMessage.chainid;
              mLogLikelihoodPrior.at(mMessage.processid) = mMessage.likelihoodPrior;
            }
        }
     
      swapChains ();

      // Send messages
      v1.clear();
      v1.resize(mFixed->mNumberChainPerProcess.at(mRank));
      for (unsigned int workerIdx = 0; 
           workerIdx < mFixed->mNumberProcess; 
           workerIdx++) 
        {
          for (unsigned int i = mFixed->mAccumulateNumberChain[workerIdx], j = 0;
               i < mFixed->mAccumulateNumberChain[workerIdx+1];
               i++, j++)
            {
              unsigned int pid = mFixed->mAccumulateNumberChain[workerIdx] + j;
              assert (pid == i);
              mMessage.set (j, mChainid.at(i), .0); 
              if (mRank == workerIdx)
                {
                  v1.at(mMessage.processid) = mMessage.chainid;
                }
              else
                {
                  MPI_Send(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 
                           workerIdx, 999, MPI_COMM_WORLD);
                }
            }
        }
    }
  else 
    {
      // Send messages to rank 0 process
      for (unsigned int i = mFixed->mAccumulateNumberChain[mRank], j = 0;
           i < mFixed->mAccumulateNumberChain[mRank+1];
           i++, j++)
        {
          mMessage.set (i, v1.at(j), v2.at(j)); 
          MPI_Send(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 
                   0, 999, MPI_COMM_WORLD);
        }

      // Wait for the decision of the rank 0 process.
      v1.clear();
      v1.resize(mFixed->mNumberChainPerProcess.at(mRank));
      for (unsigned int i = mFixed->mAccumulateNumberChain[mRank], j = 0;
           i < mFixed->mAccumulateNumberChain[mRank+1];
           i++, j++)
        {
          MPI_Recv(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 
                   0, 999, MPI_COMM_WORLD, &status);
          assert(mMessage.processid < v1.size());
          v1.at(mMessage.processid) = mMessage.chainid;
        }
    }
  mChainManager.setChainid (v1);
  return 0;
}
}
@

\subsection{ChainManager}
<<tuxChainManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXCHAINMANAGER_H_
#define _TUXCHAINMANAGER_H_
#include <iostream>
#include <vector>
using namespace std;
namespace tux {
class Fixed;
class Reads;
class Summary;
class Chain;
class ChainManager {
private:
  ChainManager ();
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  vector<Chain*> mChain;
  Summary* mSummary;
  vector<unsigned int> mSitewiseFrequencyBoundaries;
  vector<double> mSitewiseExpression;
public:
  ChainManager (Fixed* m, const vector<Reads*>& shortRead,
                unsigned int r);
  ~ChainManager ();
  void step (unsigned int, unsigned int s);
  void setChainid (unsigned int, unsigned int);
  void setChainid (vector<unsigned int>& v);
  void chainid (vector<unsigned int>&);
  void likelihoodPrior (vector<double>&);
  void reportSitewiseExpression (ostream& out);
  void reportSitewiseFrequencyBoundaries (ostream& out);
  void report (ostream &out);
  friend ostream& operator<< (ostream &out, const ChainManager &t);
};
}
#endif // _TUXCHAINMANAGER_H_

<<tuxChainManager.cpp>>=
<<tux gnu copyright>>
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <algorithm>     // for_each
#include <vector>
#include <cassert>
#include <functional>    // bind2nd, mem_fun
#include <iomanip>
#include "ezlogger_headers.hpp"
#include "yaml-cpp/yaml.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxSummary.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
using namespace std;
namespace tux {
template <typename T>
void delete_pointed_to (T* p)
{
  delete p;
}
ChainManager::ChainManager (Fixed* m,
                            const vector<Reads*>& shortRead,
                            unsigned int r)
  : mFixed(m), mReads(shortRead)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  mSitewiseFrequencyBoundaries.resize(mFixed->L(),0);
  mSitewiseExpression.resize(mFixed->L(),.0);
  mSummary = new Summary;

  // Create chains for a chain manager.
  unsigned int n = mFixed->mNumberChainPerProcess.at(r);
  for (unsigned int i = 0; i < n; i++)
    {
      Chain* c = new Chain (mFixed, mReads, mSummary);
      mChain.push_back(c);
    }
  setChainid (mFixed->mAccumulateNumberChain[r],
              mFixed->mAccumulateNumberChain[r+1]-1);

}
ChainManager::~ChainManager ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  for_each(mChain.begin(),mChain.end(),delete_pointed_to<Chain>);
  delete mSummary;
}
void 
ChainManager::step (unsigned int n, unsigned int s)
{
#ifdef _DEBUG
  stringstream ss;
  ss << "ChainManager::step " << n; 
  string strLog(ss.str());
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
#endif // _DEBUG
  for (vector<Chain*>::iterator i = mChain.begin(); i != mChain.end(); i++)
    {
      bool isColdChain = false;
      if ((*i)->mID == 0) isColdChain = true;
      for (unsigned int j = 0; j < n; j++)
        {
          (*i)->step ();
          if (isColdChain == true && mFixed->mMcmcBurnin < s)
            {
              // Gets chain information.
              (*i)->updateSitewiseFrequencyBoundaries (
                  mSitewiseFrequencyBoundaries
                );
              (*i)->updateSitewiseExpression (
                  mSitewiseExpression
                );
            }
        }
    }
  return;
}
void 
ChainManager::setChainid (unsigned int s, unsigned int e)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  assert (e - s + 1 == mChain.size());
  vector<Chain*>::iterator iter1;
  unsigned int i = 0;
  for (iter1 = mChain.begin(); iter1 != mChain.end(); iter1++)
    {
      (*iter1)->chainid (s + i);
      i++;
    }
}
void 
ChainManager::setChainid (vector<unsigned int>& v)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  assert (v.size() == mChain.size());
  vector<Chain*>::iterator iter1;
  vector<unsigned int>::iterator iter2;
  for (iter1 = mChain.begin(), iter2 = v.begin();
       iter1 != mChain.end();
       iter1++, iter2++)
    {
      (*iter1)->chainid (*iter2);
    }
}
void 
ChainManager::chainid (vector<unsigned int>& v)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  v.clear();
  vector<Chain*>::iterator iter1;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      v.push_back((*iter1)->mID);
    }
}
void 
ChainManager::likelihoodPrior (vector<double>& v)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  v.clear();
  vector<Chain*>::iterator iter1;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      double w = (*iter1)->likelihoodPrior ();
      v.push_back(w);
    }
}
void
ChainManager::reportSitewiseFrequencyBoundaries (ostream& out)
{
  out << mSitewiseFrequencyBoundaries.front();
  for (unsigned int i = 1; i < mFixed->L(); i++)
    {
      out << " " << mSitewiseFrequencyBoundaries.at(i);
    }
  out << endl;
  return;
}
void
ChainManager::reportSitewiseExpression (ostream& out)
{
  out << setprecision(7);
  out << mSitewiseExpression.front();
  for (unsigned int i = 1; i < mFixed->L(); i++)
    {
      out << " " << mSitewiseExpression.at(i);
    }
  out << endl;
  return;
}
void 
ChainManager::report (ostream &out)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  for (vector<Chain*>::iterator i = mChain.begin();
       i != mChain.end();
       i++)
    {
      (*i)->report (out);
    }
  return;
}
ostream& 
operator<< (ostream &out, const ChainManager &t)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  for (vector<Chain*>::const_iterator i = t.mChain.begin();
       i != t.mChain.end();
       i++)
    {
    //  if ((*i)->mID == 0)
      out << **i;
    }
  return out;
}
}
@

\subsection{Chain}
<<tuxChain.h>>=
<<tux gnu copyright>>
#ifndef _TUXCHAIN_H_
#define _TUXCHAIN_H_
#include <iostream>
#include <vector>
#include "tuxMoverManager.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class Summary;
class TxBoundaries;
class TxExpression;
class TxParameter;
class Chain {
private:
  Chain ();
public:
  unsigned int mID;
  unsigned int mStep;
  Fixed* mFixed;
  vector<Reads*> mReads;
  Summary* mSummary;
  MoverManager mMoverManager;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
  vector<unsigned int> mTallyChainid;
public:
  Chain (Fixed* m, const vector<Reads*>& shortRead, Summary* s);
  ~Chain ();
  void chainid (unsigned int id);
  double likelihoodPrior ();
  void updateSitewiseFrequencyBoundaries (vector<unsigned int>& b);
  void updateSitewiseExpression (vector<double>& e);
  void TxFixed (Fixed* m) {mFixed=m;}
  void TxReads (const vector<Reads*>& shortRead) {mReads=shortRead;}
  void step (unsigned int n = 1);
  void report (ostream &out);
  friend ostream& operator<< (ostream &out, const Chain &t);

  struct c_addv {
    double v;
    double operator()(double d) {
      return d + v;
    }
  } mAddV;
};
}
#endif // _TUXCHAIN_H_

<<tuxChain.cpp>>=
<<tux gnu copyright>>
#include <iomanip>
#include <string>
#include <sstream>
#include <iostream>
#include <numeric>          // accumulate
#include <cassert>
#include <vector>
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxMoverTxBSingle.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxMoverManager.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxSummary.h"
#include "tuxProbTxBoundaries.h" 
#include "tuxProbTxExpression.h" 
#include "tuxLikelihood.h" 
#include "tuxChain.h"
#include "ezlogger_headers.hpp"

using namespace std;
namespace tux {
Chain::Chain (Fixed* m, const vector<Reads*>& shortRead,
              Summary* s)
  : mID(0), mStep(0),
    mFixed(m), mReads(shortRead), mSummary(s)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  Reads* r = mReads.front();
  ProbTxBoundaries factoryTxBoundaries (r->size(),mFixed->K());
  mTxBoundaries = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  ProbTxExpression factoryTxExpression (mFixed->K());
  mTxExpression = static_cast<TxExpression*>(factoryTxExpression.r());
  mTxParameter = new TxParameter;

  // Boundaries mover
  MoverTxBoundaries* d1 = new MoverTxBoundaries (mFixed, 
                                                 mReads, 
                                                 mTxBoundaries, 
                                                 mTxExpression,
                                                 mTxParameter,
						 mSummary);
  mMoverManager.add (d1, 1U, mFixed->mMoverTxBWeight);
  // Expression mover
  MoverTxExpression* d2 = new MoverTxExpression (mFixed, 
                                                 mReads, 

                                                 mTxBoundaries, 
                                                 mTxExpression,
                                                 mTxParameter,
						 mSummary);
  mMoverManager.add (d2, 2U, mFixed->mMoverTxEWeight);
  // Boundaries single mover
  MoverTxBSingle* d3 = new MoverTxBSingle (mFixed, 
                                           mReads, 
                                           mTxBoundaries, 
                                           mTxExpression,
                                           mTxParameter,
					   mSummary);
  mMoverManager.add (d3, 3U, mFixed->mMoverTxBSingleWeight);

  // Compute the total likelihood.
  mTxParameter->mLoglikelihood = .0;
  if (mFixed->mIsData == true)
    {
      Likelihood factoryLikelihood (mFixed, mTxBoundaries, mTxExpression);
      for (vector<Reads*>::iterator i = mReads.begin(); 
           i != mReads.end(); 
           i++)
        {
          // We need mCount and mN to compute the total likelihood.
          factoryLikelihood.mCount =  (*i)->mCount;
          factoryLikelihood.mN =  (*i)->mN;
          mTxParameter->mLoglikelihood += factoryLikelihood.d ();
        }
    }
  mTallyChainid.resize(mFixed->mNumberChain,0);
}
Chain::~Chain ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  delete mTxBoundaries;
  delete mTxExpression;
  delete mTxParameter;
}
void 
Chain::chainid (unsigned int id)
{
  mID = id;
  mTxParameter->mBeta = mFixed->mTemperature.at(id);
}
double 
Chain::likelihoodPrior ()
{
  return mTxParameter->mLoglikelihood + mTxParameter->mLogprior;
}
void 
Chain::updateSitewiseFrequencyBoundaries (vector<unsigned int>& b)
{
  for (vector<unsigned int>::iterator i = mTxBoundaries->mC.begin();
       i != mTxBoundaries->mC.end();
       i++)
    {
      b.at(*i - 1)++;
    }
}
void
Chain::updateSitewiseExpression (vector<double>& e)
{
  for (unsigned int i = 0; i < mTxBoundaries->mC.size(); i++)
    {
      unsigned int right = mTxBoundaries->mC.at(i);
      unsigned int left;
      if (i > 0)
        left = mTxBoundaries->mC.at(i-1);
      else
        left = 0;
      unsigned int l = right - left;
      double v = mTxExpression->mDelta.at(i) 
                 * mFixed->mM / static_cast<double>(l);
      mAddV.v = v;
      transform(e.begin()+left,e.begin()+right,e.begin()+left,mAddV);
    }
  return;
}
void 
Chain::step (unsigned int n)
{
  for (unsigned int i = 0; i < n; i++, mStep++)
    {
      EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
        << "Step " << mStep << endl;
      Mover* m = mMoverManager.choose ();
      m->step ();
    }
  mTallyChainid.at(mID) += n;
  return;
}
void 
Chain::report (ostream &out)
{
  stringstream ss; 
  string strLog;

  out << mMoverManager << endl;
  unsigned int n;
  n = accumulate(mTallyChainid.begin(),mTallyChainid.end(),0);
  out << setprecision(3);
  for (unsigned int i = 0; i < mTallyChainid.size(); i++)
    {
      double v = static_cast<double>(mTallyChainid.at(i))
                 /static_cast<double>(n) * 100.0;
      ss.str(string());
      ss << "c" << i;
      strLog = ss.str();
      out << setw(5) << strLog << setw(7) << v << " ";
    }
  out << endl;
  return;
}
ostream& 
operator<< (ostream &out, const Chain &t)
{
  out << "-" << endl
      << "  - [" << t.mID << ", " << t.mStep << "]" << endl
      << "  - [" << t.mTxParameter->mBeta << ", " << t.mTxParameter->mLoglikelihood 
      << "]" << endl
      << *(t.mTxBoundaries)
      << *(t.mTxExpression);
  return out;
}
}
@

\subsection{RandomVariable}
<<tuxRandomVariable.h>>=
<<tux gnu copyright>>
#ifndef _TUXRANDOMVARIABLE_H_
#define _TUXRANDOMVARIABLE_H_
namespace tux {
class RandomVariable {
public:
  unsigned int id; // Nothing.
};
}
#endif // _TUXRANDOMVARIABLE_H_
@

\subsection{Parameter}
<<tuxParameter.h>>=
<<tux gnu copyright>>
#ifndef _TUXPARAMETER_H_
#define _TUXPARAMETER_H_
#include "tuxRandomVariable.h"
namespace tux {
class Parameter: public RandomVariable {
};
}
#endif // _TUXPARAMETER_H_
@

\subsection{TxBoundaries}
<<tuxTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXBOUNDARIES_H_
#define _TUXTXBOUNDARIES_H_
#include <iostream>
#include <vector>
#include "yaml-cpp/yaml.h"
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxBoundaries: public Parameter {
public:
  vector<unsigned int> mC;
public:
  TxBoundaries ();
  bool check ();
  unsigned int size () {return mC.size();}
  unsigned int L () {return mC.back();}
  friend YAML::Emitter& operator<< (YAML::Emitter &out, 
                                    const TxBoundaries &tx);
  friend ostream& operator<< (ostream &out, const TxBoundaries &t);
};
}
#endif // _TUXTXBOUNDARIES_H_

<<tuxTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>  // generate, upper_bound
#include <cassert>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxTxBoundaries.h"
using namespace std;
namespace tux {
TxBoundaries::TxBoundaries () 
{
}
bool 
TxBoundaries::check ()
{
  bool v = true;
  unsigned int leftC = mC.front();
  unsigned int rightC;
  for (unsigned int i = 1; i < mC.size(); i++)
    {
      rightC = mC.at(i); 
      if (!(leftC < rightC))
        {
          v = false;
          break;
        }
      leftC = rightC;
    }
  return v;
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const TxBoundaries &tx)
{
  out << YAML::BeginMap;
  out << YAML::Key << "TxBoundaries";
  out << YAML::Value << YAML::BeginSeq << YAML::Flow << tx.mC << YAML::EndSeq;
  out << YAML::EndMap;
  return out;
}
ostream& 
operator<< (ostream &out, const TxBoundaries &t)
{
  out << "  - [";
  copy(t.mC.begin(), t.mC.end() - 1, 
       ostream_iterator<unsigned int>(out, ", ") );
  out << t.mC.back() << "]" << endl;
  return out;
}
}
@

\subsection{TxExpression}
<<tuxTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXEXPRESSION_H_
#define _TUXTXEXPRESSION_H_
#include <cassert>
#include <vector>
#include "yaml-cpp/yaml.h"
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxExpression: public Parameter {
public:
  vector<double> mDelta;
public:
  TxExpression ();
  friend YAML::Emitter& operator<< (YAML::Emitter &out, 
                                    const TxExpression &tx);
  friend ostream& operator<< (ostream &out, const TxExpression &t);
};
}
#endif // _TUXTXEXPRESSION_H_

<<tuxTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <iterator>
#include "yaml-cpp/yaml.h"
#include "tuxTxExpression.h"
using namespace std;
namespace tux {
TxExpression::TxExpression ()
{
 
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const TxExpression &tx)
{
  out << YAML::BeginMap;
  out << YAML::Key << "TxExpression";
  out << YAML::Value << YAML::BeginSeq;
  out << YAML::Flow << tx.mDelta << YAML::EndSeq;
  out << YAML::EndMap;
  return out;
}
ostream& 
operator<< (ostream &out, const TxExpression &t)
{
  out << "  - [";
  copy(t.mDelta.begin(), t.mDelta.end() - 1, 
       ostream_iterator<double>(out, ", ") );
  out << t.mDelta.back() << "]" << endl;
  return out;
}
}
@

\subsection{TxParameter}
<<tuxTxParameter.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXPARAMETER_H_
#define _TUXTXPARAMETER_H_
#include <cassert>
#include <vector>
#include "yaml-cpp/yaml.h"
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxParameter: public Parameter {
public:
  double mLoglikelihood;
  double mLogprior;
  double mBeta;
public:
  TxParameter ();
  friend YAML::Emitter& operator<< (YAML::Emitter &out, 
                                    const TxParameter &tx);
  friend ostream& operator<< (ostream &out, const TxParameter &t);
};
}
#endif // _TUXTXPARAMETER_H_

<<tuxTxParameter.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <iterator>
#include "yaml-cpp/yaml.h"
#include "tuxTxParameter.h"
using namespace std;
namespace tux {
TxParameter::TxParameter ()
  : mLoglikelihood(.0), mLogprior(.0), mBeta(.0)
{
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const TxParameter &tx)
{
  out << YAML::BeginMap;
  out << YAML::Key << "TxParameter";
  out << YAML::Value << YAML::BeginSeq;
  out << YAML::Flow << tx.mLoglikelihood
                    << tx.mLogprior
		    << tx.mBeta
		    << YAML::EndSeq;
  out << YAML::EndMap;
  return out;
}
ostream& 
operator<< (ostream &out, const TxParameter &t)
{
  out << "  - ["
      << t.mLoglikelihood
      << ", "
      << t.mLogprior
      << ", "
      << t.mBeta;
  out << "]" << endl;
  return out;
}
}
@

\subsection{Data}
<<tuxData.h>>=
<<tux gnu copyright>>
#ifndef _TUXDATA_H_
#define _TUXDATA_H_
#include "tuxRandomVariable.h"
namespace tux {
class Data: public RandomVariable {
};
}
#endif // _TUXDATA_H_
@

\subsection{Reads}
<<tuxReads.h>>=
<<tux gnu copyright>>
#ifndef _TUXREADS_H_
#define _TUXREADS_H_
#include <iostream>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxGslRng.h"
#include "tuxData.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
class Reads: public Data {
public:
  vector<unsigned int> mCount;
  unsigned int mN;
  unsigned int mJ;
public:
  Reads (unsigned int j = 0);
  unsigned int size () {return mCount.size();}
  void sample (unsigned int l, unsigned int ul = 10);
//  friend YAML::Emitter& operator<< (YAML::Emitter &out, const Reads &tx);
//  friend void operator>> (const YAML::Node& node, Reads& t);
  friend ostream& operator<< (ostream &out, const Reads &t);
  friend istream& operator>> (istream &in, Reads &t);
  void summary (ostream &out);
  void cut (const unsigned int b, const unsigned int e);

  struct c_uniformInt {
    unsigned int l;
    c_uniformInt () {l=1000;}
    unsigned int operator()() {
      return static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
    }
  } mUniformInt;
};
}
#endif // _TUXREADS_H_
@

<<tuxReads.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <algorithm>        // generate
#include <numeric>          // accumulate
#include <iterator>         // ostream_iterator
#include <cassert>
#include "yaml-cpp/yaml.h"
#include "ezlogger_headers.hpp"
#include "tuxGslRng.h"
#include "tuxReads.h"
<<extern tuxGslRng>>
<<extern tuxlf>>
using namespace std;
namespace tux {
Reads::Reads (unsigned int j)
{
  mN = 0;
  mJ = j; 
}
void
Reads::sample (unsigned int l, unsigned int ul)
{
  mUniformInt.l = ul;
  mCount.resize(l);
  generate(mCount.begin(),mCount.end(),mUniformInt);
  mN = accumulate(mCount.begin(),mCount.end(),0);
}
ostream& 
operator<< (ostream &out, const Reads &t)
{
  copy(t.mCount.begin(), t.mCount.end() - 1, 
       ostream_iterator<unsigned int>(out, " ") );
  out << t.mCount.back();
  return out;
}
istream& operator>> (istream &fin, Reads &t)
{
  vector<unsigned int> a;
  string input;
  unsigned int nC = 0;
  while (!fin.eof()) 
    {
      char c = fin.peek();
      while (c == ' ')
        {
          c = fin.peek();
          if (c == ' ')
            c = fin.get();
          else
            break;
        }
      input.clear();
      if (isdigit(c))
        {
          c = fin.get();
          while (isdigit(c))
            {
              input += c;
              c = fin.get();
            }
          a.push_back(static_cast<unsigned int>
                      (strtoul(input.c_str(),NULL,0)));
          nC++;
          while (c == ' ')
            {
              c = fin.peek();
              if (c == ' ')
                {
                  c = fin.get();
                }
              else
                {
                  if (c == '\n')
                    c = fin.get();
                  else
                    c = ' ';
                  break;
                }
            }
          if (c != ' ')
            {
              EZLOGGERVLSTREAM2(axter::log_regularly,lf) 
                << "A new line in data section." << std::endl;
              t.mCount = a;
              a.clear();
              EZLOGGERVLSTREAM2(axter::log_regularly,lf) 
                << "Data " 
                << t.mJ
                << " - nC is " << nC << std::endl;
              c = fin.get();
              if (!fin.eof())
                fin.unget();
              break;
            }
        }
      else
        {
          if (!fin.eof()) 
            {
              nC++;
              EZLOGGERSTREAM2(lf) << "Fatal: counts must be numbers. "
                                  << "Character " << c << " is found at "
                                  << nC << "th from the start of the data."
                                  << std::endl;
              break;
            }
        }
    } 
  t.mN = accumulate(t.mCount.begin(),t.mCount.end(),0);

  stringstream ss; 
  ss << "Total number of reads is " << t.mN 
     << " from " << t.mCount.size() << " sites.";
  string strLog(ss.str());
  EZLOGGERSTREAM2(lf) << strLog << endl; 
  return fin;
}
void 
Reads::cut (const unsigned int b, const unsigned int e)
{
  assert (b < e);
  if (e - b + 1 < mCount.size())
    {
      vector<unsigned int> c(mCount.begin() + b - 1,mCount.begin() + e);
      mCount = c;
      assert(mCount.size() == e - b + 1);
      mN = accumulate(mCount.begin(),mCount.end(),0);
    }
  return;
}

//YAML::Emitter& 
//operator<< (YAML::Emitter &out, const Reads &t)
//{
//  out << YAML::BeginMap 
//      << YAML::Key << "Reads" 
//      << YAML::Value << YAML::BeginSeq << YAML::Flow << t.mCount << YAML::EndSeq
//      << YAML::EndMap;
//  return out;
//}
//void 
//operator>> (const YAML::Node& node, Reads& t)
//{
//  node[t.mJ] >> t.mCount;
//  t.mN = accumulate(t.mCount.begin(),t.mCount.end(),0);
//  return;
//}
void 
Reads::summary (ostream &out)
{
  out << "Reads #" << mJ << " - " << mN << endl;
  return;
}
}
@

\subsection{Fixed}
We use the following order of option setup: \Cclass{Default}, \Cclass{Fixed},
and the command line options in the \program{tux}.

f1 <- function(i,n,x,y) { 1 - (1-y)*i*(x^(n-1-i))/(n-1) }
v <- c(); for (i in 1:n) { v <- c(v,f1(i,n,0.95,0.3)) }; plot(1:n,v)

<<tuxFixed.h>>=
<<tux gnu copyright>>
#ifndef _TUXFIXED_H_
#define _TUXFIXED_H_
#include <iostream>
#include <utility>
#include <cmath>
#include <string>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxData.h"
#include "tuxGslRng.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
class Fixed: public Data {
public:
  double mMoverTxBSingleWeight;
  double mMoverTxBWeight;
  double mMoverTxEWeight;
  unsigned int mLogVerbosity;
  unsigned long int mSeed;
  unsigned int mL;
  unsigned int mK;
  double mM;
  vector<double> mZ;
  double mA0;
  double mA1;
  double mAlphaQExpression;
  double mAlphaQBoundaries;
  unsigned int mLengthSampleSegmentA;
  unsigned int mLengthSampleSegmentB;
  double mAlphaPriorExpression;
  unsigned int mMcmcLength;
  unsigned int mMcmcBurnin;
  unsigned int mMcmcThin;
  unsigned int mNumberProcess;
  unsigned int mNumberChain;
  unsigned int mNumberSwap;
  unsigned int mNumberSwapTry;
  unsigned int mSwapDistance;
  double mHAlpha;
  double mHBeta;
  string mPrefix;
  string mOutDirectory;
  string mChainDirectory;
  string mLogDirectory;
  string mLogfile;
  string mDatafile;
  bool mIsData;
  bool mSitewiseExpression;
  bool mSitewiseBoundaries; 
  bool mListlikelihood;
  pair<unsigned int,unsigned int> mPosition;
public:
  vector<double> mTemperature;
  vector<unsigned long int> mProcessSeed;
  vector<unsigned int> mNumberChainPerProcess;
  vector<unsigned int> mAccumulateNumberChain;
public:
  Fixed ();
  ~Fixed ();
  void init ();
  bool check ();
  unsigned int K () {return mK;}
  unsigned int L () {return (mPosition.second - mPosition.first + 1);}
  unsigned int numberProcess () {return mNumberProcess;}
  unsigned int mcmcLength () {return mMcmcLength;}
  friend YAML::Emitter& operator<< (YAML::Emitter &out, const Fixed &t);
  friend void operator>> (const YAML::Node& node, Fixed& t);
  friend ostream& operator<< (ostream &out, const Fixed& t);
  string chainFilename (unsigned int i);
  string outFilename (unsigned int i);
  string logFilename (unsigned int i);
  string pFilename (int i = -1);
  string prefixFilename (int i = -1);
  void temperature ();
  int numberChainPerProcess ();
  void reportTemperature (ostream& out);

  struct c_hgeometric {
    unsigned int numChain;
    double halpha, hbeta;
    unsigned int i;
    c_hgeometric () {i=0; numChain = 10; halpha=0.95; hbeta=0.2;}
    double operator()() {
      double v = 1 
                 - (1 - hbeta) * i 
                 * pow (halpha, (double) (numChain - 1 - i)) 
                 / (double) (numChain - 1);
      i++;
      return v; 
    }
  } hgeometricNumber;

  struct c_hlinear {
    double halpha;
    unsigned int i;
    c_hlinear () {i=0; halpha=0.5;}
    double operator()() {
      double v = 1.0 / (1.0 + halpha * i);
      i++; 
      return v;
    }
  } hlinearNumber;

  struct c_setNumberChainPerProcess {
    unsigned int current;
    unsigned int numberChainPerProcess;
    unsigned int numberRemainingChain;
    c_setNumberChainPerProcess () {current=0;}
    unsigned int operator() () { 
      if (current++ < numberRemainingChain)
        return numberChainPerProcess + 1;
      else
        return numberChainPerProcess;
    }
  } setNumberChainPerProcess;

  struct c_gslrnginteger {
    unsigned long int operator()() {
      return gsl_rng_get (gGslRng);
    }
  } mGslRngInteger;
};
}
#endif // _TUXFIXED_H_
@

<<tuxFixed.cpp>>=
<<tux gnu copyright>>
#include <cstdlib>
#include <iomanip>
#include <cassert>
#include <sstream>
#include <iostream>
#include <numeric>         // partial_sum
#include <algorithm>       // generate
#include "yaml-cpp/yaml.h"
#include "ezlogger_headers.hpp"
#include "tuxString.h"
#include "tuxDefault.h"
#include "tuxFixed.h"
<<extern tuxlf>>
using namespace std;
namespace tux {
Fixed::Fixed ()
  : 
    mMoverTxBSingleWeight(Default::mMoverTxBSingleWeight),
    mMoverTxBWeight(Default::mMoverTxBWeight),
    mMoverTxEWeight(Default::mMoverTxEWeight),
    mLogVerbosity(Default::mLogVerbosity),
    mSeed(Default::mSeed),

    mAlphaQExpression(100.0), mAlphaQBoundaries(100.0),
    mLengthSampleSegmentA(5000U),
    mLengthSampleSegmentB(15000U),
    mMcmcLength(1000000U), mMcmcBurnin(500000U), mMcmcThin(5000U),
    mNumberProcess(1U), mNumberChain(1U), mNumberSwap(0U), mNumberSwapTry(0U),
    mSwapDistance(7),
    mHAlpha(0.98), mHBeta(.9), 
    mIsData(Default::mIsData)
{
  //cout << Default::mDatafile << endl; // Not constructed
}
Fixed::~Fixed ()
{
  
}
void
Fixed::init ()
{
  mMoverTxBSingleWeight = Default::mMoverTxBSingleWeight;
  mMoverTxBWeight       = Default::mMoverTxBWeight;
  mMoverTxEWeight       = Default::mMoverTxEWeight;
  mLogVerbosity         = Default::mLogVerbosity;
  mSeed                 = Default::mSeed;
  mL                    = Default::mL;
  mK                    = Default::mK;
  mM                    = Default::mM;
  //vector<double> mZ;
  mA0                   = Default::mA0;
  mA1                   = Default::mA1;
  mAlphaQExpression     = Default::mAlphaQExpression;
  mAlphaQBoundaries     = Default::mAlphaQBoundaries;
  mLengthSampleSegmentA = Default::mLengthSampleSegmentA;
  mLengthSampleSegmentB = Default::mLengthSampleSegmentB;
  //double mAlphaPriorExpression;
  mMcmcLength           = Default::mMcmcLength;
  mMcmcBurnin           = Default::mMcmcBurnin;
  mMcmcThin             = Default::mMcmcThin;
  mNumberProcess        = Default::mNumberProcess;
  mNumberChain          = Default::mNumberChain;
  mNumberSwap           = Default::mNumberSwap;
  mNumberSwapTry        = Default::mNumberSwapTry;
  mSwapDistance         = Default::mSwapDistance;
  mHAlpha               = Default::mHAlpha;
  mHBeta                = Default::mHBeta;
  mPrefix               = Default::mPrefix;
  mOutDirectory         = Default::mOutDirectory;
  mChainDirectory       = Default::mChainDirectory;
  mLogDirectory         = Default::mLogDirectory;
  //mLogfile              = Default::mLogfile;
  mDatafile             = Default::mDatafile;
  mIsData               = Default::mIsData;
  mSitewiseExpression   = Default::mSitewiseExpression;
  mSitewiseBoundaries   = Default::mSitewiseBoundaries;
  mListlikelihood       = Default::mListlikelihood;
  mPosition.first       = Default::mPosition;
  mPosition.second      = Default::mL;
  return;
}
bool 
Fixed::check ()
{
  bool v = true;
  if (!(1 <= mLogVerbosity && mLogVerbosity <= 5))
    {
      mLogVerbosity = Default::mLogVerbosity;
    }
  if (mNumberProcess > 1)
    {
      mProcessSeed.resize(mNumberProcess);
      generate (mProcessSeed.begin(), 
                mProcessSeed.end(), 
                mGslRngInteger);
    }
  temperature ();
  numberChainPerProcess ();
  return v;
}
int 
Fixed::numberChainPerProcess ()
{
  // Allocate chains among processes e.g., (3,3,2).
  setNumberChainPerProcess.current = 0;
  setNumberChainPerProcess.numberChainPerProcess 
    = mNumberChain / mNumberProcess; 
  setNumberChainPerProcess.numberRemainingChain
    = mNumberChain % mNumberProcess;
  mNumberChainPerProcess.resize (mNumberProcess); 
  generate (mNumberChainPerProcess.begin(), 
            mNumberChainPerProcess.end(), 
            setNumberChainPerProcess);
  unsigned int n;
  n = accumulate(mNumberChainPerProcess.begin(),
                 mNumberChainPerProcess.end(),0);
  assert (n == mNumberChain);

  // Construct a vector of partial sum. e.g., (0,3,6,8).
  mAccumulateNumberChain.resize(mNumberChainPerProcess.size());
  partial_sum(mNumberChainPerProcess.begin(),
              mNumberChainPerProcess.end(),
              mAccumulateNumberChain.begin());
  mAccumulateNumberChain.insert(mAccumulateNumberChain.begin(),0);
  return 0;
}
ostream&
operator<< (ostream &out, const Fixed &t)
{
  out << "Fixed: " << endl
      << "  " << "mMoverTxBSingleWeight"
      << ": " << t.mMoverTxBSingleWeight << endl
      << "  " << "mMoverTxBWeight"
      << ": " << t.mMoverTxBWeight << endl
      << "  " << "mMoverTxEWeight"
      << ": " << t.mMoverTxEWeight << endl
      << "  " << "mLogVerbosity"
      << ": " << t.mLogVerbosity << endl
      << "  " << "mSeed"
      << ": " << t.mSeed << endl
      << "  " << "mL"
      << ": " << t.mL << endl
      << "  " << "mK"
      << ": " << t.mK << endl
      << "  " << "mM"
      << ": " << t.mM << endl
      << "  " << "mZ"
      << ": " << endl;
  for (vector<double>::const_iterator i = t.mZ.begin(); i != t.mZ.end(); i++)
    {
      out << "    - " << *i << endl;
    }
  out << "  " << "mA0"
      << ": " << t.mA0 << endl
      << "  " << "mA1"
      << ": " << t.mA1 << endl
      << "  " << "mAlphaQExpression"
      << ": " << t.mAlphaQExpression << endl
      << "  " << "mAlphaQBoundaries"
      << ": " << t.mAlphaQBoundaries << endl
      << "  " << "mLengthSampleSegmentA"
      << ": " << t.mLengthSampleSegmentA << endl
      << "  " << "mLengthSampleSegmentB"
      << ": " << t.mLengthSampleSegmentB << endl
      << "  " << "mAlphaPriorExpression"
      << ": " << t.mAlphaPriorExpression << endl
      << "  " << "mMcmcLength"
      << ": " << t.mMcmcLength << endl
      << "  " << "mMcmcBurnin"
      << ": " << t.mMcmcBurnin << endl
      << "  " << "mMcmcThin"
      << ": " << t.mMcmcThin << endl
      << "  " << "mNumberProcess"
      << ": " << t.mNumberProcess << endl
      << "  " << "mNumberChain"
      << ": " << t.mNumberChain << endl
      << "  " << "mNumberSwap"
      << ": " << t.mNumberSwap << endl
      << "  " << "mNumberSwapTry"
      << ": " << t.mNumberSwapTry << endl
      << "  " << "mSwapDistance"
      << ": " << t.mSwapDistance << endl
      << "  " << "mHAlpha"
      << ": " << t.mHAlpha << endl
      << "  " << "mHBeta"
      << ": " << t.mHBeta << endl
      << "  " << "mPrefix"
      << ": " << t.mPrefix << endl
      << "  " << "mOutDirectory"
      << ": " << t.mOutDirectory << endl
      << "  " << "mChainDirectory"
      << ": " << t.mChainDirectory << endl
      << "  " << "mLogDirectory"
      << ": " << t.mLogDirectory << endl
      << "  " << "mDatafile"
      << ": " << t.mDatafile << endl
      << "  " << "mPosition"
      << ": " << t.mPosition.first << "-" << t.mPosition.second << endl;
  if (t.mIsData == true) 
    out << "  mIsData: true" << endl;
  else
    out << "  mIsData: false" << endl;
  if (t.mSitewiseExpression == true) 
    out << "  mSitewiseExpression: true" << endl;
  else
    out << "  mSitewiseExpression: false" << endl;
  if (t.mSitewiseBoundaries == true) 
    out << "  mSitewiseBoundaries: true" << endl;
  else
    out << "  mSitewiseBoundaries: false" << endl;
  if (t.mListlikelihood == true) 
    out << "  mListlikelihood: true" << endl;
  else
    out << "  mListlikelihood: false" << endl;
  out << "---" << endl;
  return out;
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const Fixed &t)
{
  stringstream ss;
  ss << t.mPosition.first << "-" << t.mPosition.second;
  string strPosition(ss.str());
  
  out << YAML::BeginMap << YAML::Key << "Fixed" << YAML::Value;
  out << YAML::BeginMap
      << YAML::Key << "mMoverTxBSingleWeight"
      << YAML::Value << t.mMoverTxBSingleWeight
      << YAML::Key << "mMoverTxBWeight"
      << YAML::Value << t.mMoverTxBWeight
      << YAML::Key << "mMoverTxEWeight"
      << YAML::Value << t.mMoverTxEWeight
      << YAML::Key << "mLogVerbosity"
      << YAML::Value << t.mLogVerbosity
      << YAML::Key << "mSeed"
      << YAML::Value << t.mSeed
      << YAML::Key << "mL"
      << YAML::Value << t.mL
      << YAML::Key << "mK"
      << YAML::Value << t.mK
      << YAML::Key << "mM"
      << YAML::Value << t.mM
      << YAML::Key << "mZ"
      << YAML::Value << t.mZ
      << YAML::Key << "mA0"
      << YAML::Value << t.mA0
      << YAML::Key << "mA1"
      << YAML::Value << t.mA1
      << YAML::Key << "mAlphaQExpression"
      << YAML::Value << t.mAlphaQExpression
      << YAML::Key << "mAlphaQBoundaries"
      << YAML::Value << t.mAlphaQBoundaries
      << YAML::Key << "mLengthSampleSegmentA"
      << YAML::Value << t.mLengthSampleSegmentA
      << YAML::Key << "mLengthSampleSegmentB"
      << YAML::Value << t.mLengthSampleSegmentB
      << YAML::Key << "mAlphaPriorExpression"
      << YAML::Value << t.mAlphaPriorExpression
      << YAML::Key << "mMcmcLength"
      << YAML::Value << t.mMcmcLength
      << YAML::Key << "mMcmcBurnin"
      << YAML::Value << t.mMcmcBurnin
      << YAML::Key << "mMcmcThin"
      << YAML::Value << t.mMcmcThin
      << YAML::Key << "mNumberProcess"
      << YAML::Value << t.mNumberProcess
      << YAML::Key << "mNumberChain"
      << YAML::Value << t.mNumberChain
      << YAML::Key << "mNumberSwap"
      << YAML::Value << t.mNumberSwap
      << YAML::Key << "mNumberSwapTry"
      << YAML::Value << t.mNumberSwapTry
      << YAML::Key << "mSwapDistance"
      << YAML::Value << t.mSwapDistance
      << YAML::Key << "mHAlpha"
      << YAML::Value << t.mHAlpha
      << YAML::Key << "mHBeta"
      << YAML::Value << t.mHBeta
      << YAML::Key << "mPrefix"
      << YAML::Value << t.mPrefix
      << YAML::Key << "mOutDirectory"
      << YAML::Value << t.mOutDirectory
      << YAML::Key << "mChainDirectory"
      << YAML::Value << t.mChainDirectory
      << YAML::Key << "mLogDirectory"
      << YAML::Value << t.mLogDirectory
      << YAML::Key << "mDatafile"
      << YAML::Value << t.mDatafile
      << YAML::Key << "mIsData"
      << YAML::Value << t.mIsData
      << YAML::Key << "mSitewiseExpression"
      << YAML::Value << t.mSitewiseExpression
      << YAML::Key << "mSitewiseBoundaries"
      << YAML::Value << t.mSitewiseBoundaries
      << YAML::Key << "mListlikelihood"
      << YAML::Value << t.mListlikelihood
      << YAML::Key << "mPosition"
      << YAML::Value << strPosition
      << YAML::EndMap;
  out << YAML::EndMap;
  return out;
}
void 
operator>> (const YAML::Node& node, Fixed& t) 
{
  string strPosition;
  // See yaml-cpp/include/yaml-cpp/exceptions.h
  // for exception handlers
  try 
    {
      node["mMoverTxBSingleWeight"] >> t.mMoverTxBSingleWeight;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mMoverTxBSingleWeight = Default::mMoverTxBSingleWeight;
    }
  try 
    {
      node["mMoverTxBWeight"] >> t.mMoverTxBWeight;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mMoverTxBWeight = Default::mMoverTxBWeight;
    }
  try 
    {
      node["mMoverTxEWeight"] >> t.mMoverTxEWeight;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mMoverTxEWeight = Default::mMoverTxEWeight;
    }
  try 
    {
      node["mLogVerbosity"] >> t.mLogVerbosity;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mLogVerbosity = Default::mLogVerbosity;
    }
  try 
    {
      node["mSeed"] >> t.mSeed;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mSeed = Default::mSeed;
    }
  try 
    {
      node["mL"] >> t.mL;
    }
  catch(YAML::KeyNotFound& e) 
    {
      t.mL = Default::mL;
    }
  try 
    {
      node["mK"] >> t.mK;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mK = Default::mK;
    }

  node["mM"] >> t.mM;
  node["mZ"] >> t.mZ;
  node["mA0"] >> t.mA0;
  node["mA1"] >> t.mA1;
  node["mAlphaQExpression"] >> t.mAlphaQExpression;
  node["mAlphaQBoundaries"] >> t.mAlphaQBoundaries;
  node["mLengthSampleSegmentA"] >> t.mLengthSampleSegmentA;
  node["mLengthSampleSegmentB"] >> t.mLengthSampleSegmentB;
  node["mAlphaPriorExpression"] >> t.mAlphaPriorExpression;
  node["mMcmcLength"] >> t.mMcmcLength;
  node["mMcmcBurnin"] >> t.mMcmcBurnin;
  node["mMcmcThin"] >> t.mMcmcThin;
  node["mNumberProcess"] >> t.mNumberProcess;
  node["mNumberChain"] >> t.mNumberChain;
  node["mNumberSwap"] >> t.mNumberSwap;
  node["mNumberSwapTry"] >> t.mNumberSwapTry;
  node["mSwapDistance"] >> t.mSwapDistance;
  node["mHAlpha"] >> t.mHAlpha;
  node["mHBeta"] >> t.mHBeta;
  node["mPrefix"] >> t.mPrefix;
  node["mOutDirectory"] >> t.mOutDirectory;
  node["mChainDirectory"] >> t.mChainDirectory;
  node["mLogDirectory"] >> t.mLogDirectory;
  node["mDatafile"] >> t.mDatafile;
  try 
    {
      node["mIsData"] >> t.mIsData;
    }
  catch(YAML::KeyNotFound& e) 
    {
      t.mIsData = Default::mIsData;
    }
  try 
    {
      node["mSitewiseExpression"] >> t.mSitewiseExpression;
    }
  catch(YAML::KeyNotFound& e) 
    {
      t.mSitewiseExpression = Default::mSitewiseExpression;
    }
  try 
    {
      node["mSitewiseBoundaries"] >> t.mSitewiseBoundaries;
    }
  catch(YAML::KeyNotFound& e) 
    {
      t.mSitewiseBoundaries = Default::mSitewiseBoundaries;
    }
  try 
    {
      node["mListlikelihood"] >> t.mListlikelihood;
    }
  catch(YAML::KeyNotFound& e) 
    {
      t.mListlikelihood = Default::mListlikelihood;
    }
  try 
    {
      node["mPosition"] >> strPosition;
      vector <string> fields;
      split (fields, strPosition, "-" );
      if (fields.size() == 2)
        {
          t.mPosition.first = strtoul(fields.front().c_str(),NULL,0);
          t.mPosition.second = strtoul(fields.back().c_str(),NULL,0);
        }
      else
        {
          t.mPosition.first = Default::mPosition;
          t.mPosition.second = t.mL;
        }
    }
  catch(YAML::KeyNotFound& e) 
    {
      t.mPosition.first = Default::mPosition;
      t.mPosition.second = t.mL;
    }
  return;
}
string 
Fixed::chainFilename (unsigned int i)
{
  string v(mChainDirectory);
  v += mPrefix;
  v += ".";
  string sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
  v += sID;
  v += ".chain";
  return v;
}
string 
Fixed::outFilename (unsigned int i)
{
  string v(mOutDirectory);
  v += mPrefix;
  v += ".";
  string sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
  v += sID;
  v += ".out";
  return v;
}
string 
Fixed::pFilename (int i)
{
  string v(mOutDirectory);
  v += mPrefix;
  v += ".";
  if (!(i < 0))
    {
      string sID;
      sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
      v += sID;
      v += ".";
    }
  v += "p";
  return v;
}
string 
Fixed::logFilename (unsigned int i)
{
  string v(mLogDirectory);
  v += mPrefix;
  v += ".";
  string sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
  v += sID;
  v += ".log";
  return v;
}
string 
Fixed::prefixFilename (int i)
{
  string v(mOutDirectory);
  v += mPrefix;
  v += ".";
  if (!(i < 0))
    {
      string sID;
      sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
      v += sID;
      v += ".";
    }
  return v;
}
void
Fixed::temperature ()
{
  // Sets the temperature values
  mTemperature.resize(mNumberChain,1.0);
  if (mNumberChain > 1)
    {
      hgeometricNumber.numChain = mNumberChain;
      hgeometricNumber.halpha = mHAlpha;
      hgeometricNumber.hbeta = mHBeta;
      generate (mTemperature.begin(),mTemperature.end(),hgeometricNumber);        
    }
  return;
}
void
Fixed::reportTemperature (ostream& out)
{
  for (vector<double>::iterator i = mTemperature.begin();
       i != mTemperature.end();
       i++)
    {
      out << setprecision(3) << setw(6) << *i;
    } 
  out << endl;
  return;
}
}
@

\subsection{Probability}
<<tuxProbability.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBABILITY_H_
#define _TUXPROBABILITY_H_
#include <vector>
using namespace std;
namespace tux {
class RandomVariable;
class Probability {
public:
  virtual ~Probability () {}
  virtual double d () = 0;
  virtual RandomVariable* r () = 0;
};
}
#endif // _TUXPROBABILITY_H_
@

\subsection{ProbTxBoundaries}
<<tuxProbTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBTXBOUNDARIES_H_
#define _TUXPROBTXBOUNDARIES_H_
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"
using namespace std;
namespace tux {
class ProbTxBoundaries: public Probability {
private:
  ProbTxBoundaries ();
public:
  unsigned int mL;
  unsigned int mK;
public:
  ProbTxBoundaries (unsigned int, unsigned int);
  virtual ~ProbTxBoundaries () {}
  double d ();
  RandomVariable* r (); 

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return ++current;}
  } mUniqueNumber;
};
}
#endif // _TUXPROBTXBOUNDARIES_H_

<<tuxProbTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_sf_gamma.h>
#include "ezlogger_headers.hpp"
#include "tuxGslRng.h"
#include "tuxTxBoundaries.h"
#include "tuxProbTxBoundaries.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
ProbTxBoundaries::ProbTxBoundaries (unsigned int l, unsigned int k)
  : mL(l), mK(k)
{
}
double
ProbTxBoundaries::d ()
{
  return -gsl_sf_lnchoose(mL-1,mK-1);
}
RandomVariable* 
ProbTxBoundaries::r ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  vector<unsigned int> a(mK-1);
  vector<unsigned int> b(mL-1);
  generate (b.begin(),b.end(),mUniqueNumber);
  gsl_ran_choose (gGslRng, &a[0], mK-1, &b[0], mL-1, sizeof(unsigned int));
  a.push_back(mL);
  TxBoundaries* v = new TxBoundaries;
  v->mC = a;
  return v;
}
}
@

\subsection{ProbTxExpression}
<<tuxProbTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBTXEXPRESSION_H_
#define _TUXPROBTXEXPRESSION_H_
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGslRng.h"
#include "tuxProbability.h"
<<extern tuxGslRng>>
namespace tux {
class ProbTxExpression: public Probability {
public:
  vector<double> mAlpha;
  vector<double> mDelta;
public:
  ProbTxExpression (const unsigned int k, const double a = 1.L);
  virtual ~ProbTxExpression () {}
  double d ();
  RandomVariable* r (); 
  void theta (vector<double>& t) {mDelta = t;}
  vector<double>& theta () {return mDelta;}
};
}
#endif // _TUXPROBTXEXPRESSION_H_

<<tuxProbTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_block.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxTxExpression.h"
#include "tuxProbTxExpression.h"
using namespace std;
namespace tux {
ProbTxExpression::ProbTxExpression (const unsigned int k, const double a)
{
  mAlpha.resize(k,a);
}
double
ProbTxExpression::d ()
{
  size_t k = static_cast<size_t>(mAlpha.size());
  return gsl_ran_dirichlet_lnpdf(k,&mAlpha[0],&mDelta[0]);
}
RandomVariable* 
ProbTxExpression::r ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  size_t k = static_cast<size_t>(mAlpha.size());
  mDelta.resize(k); 
  gsl_ran_dirichlet(gGslRng,k,&mAlpha[0],&mDelta[0]);
  TxExpression* v = new TxExpression;
  v->mDelta = mDelta;
  return v;
}
}
@

\subsection{Likelihood}
<<tuxLikelihood.h>>=
<<tux gnu copyright>>
#ifndef _TUXLIKELIHOOD_H_
#define _TUXLIKELIHOOD_H_
#include <vector>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
class Fixed;
class Data;
class TxBoundaries;
class TxExpression;
class Likelihood: public Probability {
public:
  Fixed* mFixed;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  unsigned int mJ;

  // Data members are set by the above RandomVariable objects
  double mA0; // given a_0
  double mA1; // given a_1
  unsigned int mL; // a given chromosome length
  unsigned int mK; // a given segments length
  double mM;       // a given average total counts
  double mSizeFactor; // a given size factor
  vector<double> mDelta;   // sample from a uniform Dirichlet distribution
  vector<unsigned int> mC; // sample from a uniform Dirichlet distribution

  // Note that the following is one instance of multiple data
  vector<unsigned int> mCount;
  unsigned int mN;
public:
  Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te);
  virtual ~Likelihood () {}
  //Likelihood (unsigned int, unsigned int, double);
  double d ();
  RandomVariable* r (); 
  void J (unsigned int j);
  double sizeFactor () const {return mSizeFactor;}
  void sizeFactor (const double s) {mSizeFactor=s;}
  void alpha (const double a0, const double a1) {mA0=a0; mA1=a1;}

  struct c_nb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    unsigned int operator()(double i) {
      double mu = mSizeFactor * mM * i;
      double n = 1/(a0+a1/mu); // multiplied by mu?
      double p = n/(n+mu);
      unsigned int k = gsl_ran_negative_binomial(gGslRng, p, n);
      return k; 
    }
  } gslrngNb;
};
}
#endif // _TUXLIKELIHOOD_H_

<<tuxLikelihood.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <string>
#include <iostream>
#include <functional>       // minus
#include <vector>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
using namespace std;
namespace tux {
Likelihood::Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te)
{
  // Check the three variables are valid. 
  mFixed = f;
  mL = tb->L();
  mK = f->mK;
  mM = f->mM;
  mSizeFactor = f->mZ[0];
  mA0 = f->mA0;
  mA1 = f->mA1;
  mC = tb->mC;
  mDelta = te->mDelta;
}
//
//Likelihood::Likelihood (unsigned int l, unsigned int k, double m)
//{
//  mL = l;
//  mK = k;
//  mM = m;
//  // TxBoundaries is created. Likelihood owns it.
//  ProbTxBoundaries priorTxBoundaries (mL, mK);
//  priorTxBoundaries.mL = mL;
//  priorTxBoundaries.mK = mK;
//  TxBoundaries* vTxBoundaries = 
//    static_cast<TxBoundaries*>(priorTxBoundaries.r());
//  mC = vTxBoundaries->mC;
//  delete vTxBoundaries;
//
//  // TxExpression is created. Likelihood owns it.
//  ProbTxExpression priorTxExpression (mK,1.L);
//  TxExpression* vTxExpression = 
//    static_cast<TxExpression*>(priorTxExpression.r());
//  mDelta = vTxExpression->mDelta;
//  delete vTxExpression;
//}
void 
Likelihood::J (unsigned int j) 
{
  mJ=j;
  mSizeFactor = mFixed->mZ.at(mJ);
}
double
Likelihood::d ()
{
  // Find lengths lk using ck.
  vector<unsigned int> lk(mC);
  vector<unsigned int> lkLeft(mC);
  lkLeft.pop_back();
  lkLeft.insert(lkLeft.begin(),0);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<unsigned int>());

  // Count reads in ck.
  vector<unsigned int> c;
  unsigned int pos = lkLeft.front();
  for (vector<unsigned int>::iterator i = lk.begin(); 
       i != lk.end(); 
       i++)
    {
      unsigned int sumCk = accumulate(mCount.begin() + pos,
                                      mCount.begin() + pos + *i,
                                      0);
      pos += *i;
      c.push_back(sumCk);
   }

  // Compute the probability. 
  vector<double> logNb;
  for (unsigned int k = 0; k < mDelta.size(); k++)
    {
      unsigned int xk = c.at(k);
      double mu = mN * mDelta.at(k);
      double n = 1.0/(mFixed->mA0 + mFixed->mA1/mu);
      double p = n/(n+mu);
      double v = gsl_ran_negative_binomial_lnpdf (xk, p, n);
      logNb.push_back(v);
    }
  double vTotal = accumulate(logNb.begin(),logNb.end(),.0);

#ifdef _DEBUG
  stringstream ss;
  ss << "Likelihood::d returns " << vTotal;
  string strLog(ss.str());
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
#endif // _DEBUG

  return vTotal;
}
RandomVariable*
Likelihood::r ()
{
  // For each i-th segment, sample j.
  // Use TxBoundaries and TxExpression to generate a set of Data.
  gslrngNb.a0 = mA0;
  gslrngNb.a1 = mA1;
  gslrngNb.mM = mM;
  gslrngNb.mSizeFactor = mFixed->mZ.at(mJ);
  vector<unsigned int> nk(mDelta.size());
  transform(mDelta.begin(),mDelta.end(),nk.begin(),gslrngNb);
   
  // Lengths of segments
  vector<unsigned int> lk(mC);
  lk.pop_back();
  lk.insert(lk.begin(),0);
  transform(mC.begin(),mC.end(),lk.begin(),lk.begin(),minus<unsigned int>());

  // Place counts on mRead of gslrngRead.
  vector<unsigned int> reads(mL,0);
  unsigned int s; 
  unsigned int p = 0;
  for (unsigned int i = 0; i < nk.size(); i++)
    {
      unsigned int n = nk.at(i);
      unsigned int l = lk.at(i);
      for (unsigned int j = 0; j < n; j++)
        {
          s = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
          reads.at(p + s)++;
        }
      p += l;
    }

  // Data
  Reads* v = new Reads;
  v->mCount = reads;
  return v;
}
}
@

\subsection{TotalLikelihood}

<<tuxTotalLikelihood.h>>=
<<tux gnu copyright>>
#ifndef _TUXTOTALLIKELIHOOD_H_
#define _TUXTOTALLIKELIHOOD_H_
#include <vector>
#include "tuxProbability.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class TxBoundaries;
class TxExpression;
class TotalLikelihood: public Probability {
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
public:
  TotalLikelihood (Fixed* fixed, vector<Reads*>& reads, 
                   TxBoundaries* txb, TxExpression* txe, TxParameter* txp);
  virtual ~TotalLikelihood () {}
  double d ();
  RandomVariable* r (); 
};
}
#endif // _TUXTOTALLIKELIHOOD_H_

<<tuxTotalLikelihood.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <string>
#include <iostream>
#include <functional>
#include <algorithm>  // transform, copy
#include <numeric>    // accumulate
#include <vector>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxTotalLikelihood.h"
using namespace std;
namespace tux {
TotalLikelihood::TotalLikelihood (Fixed* fixed, 
                                  vector<Reads*>& reads, 
                                  TxBoundaries* txb, 
                                  TxExpression* txe,
                                  TxParameter* txp)
  : mFixed(fixed), mReads(reads), 
    mTxBoundaries(txb), mTxExpression(txe), mTxParameter(txp)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
}
double
TotalLikelihood::d ()
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  vector<unsigned int> ck(mTxBoundaries->mC);
  vector<double> dk(mTxExpression->mDelta);
  vector<unsigned int> lk(ck);
  vector<unsigned int> lkLeft;
  lkLeft.push_back(0);
  lkLeft.insert(lkLeft.end(),lk.begin(),lk.end()-1);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<unsigned int>());

  vector<double> logNb;
  vector<unsigned int> c;
  for (unsigned int j = 0; j < mReads.size(); j++)
    {
      Reads* ds = mReads.at(j);
      c.clear();
      unsigned int pos = lkLeft.front();
      for (vector<unsigned int>::iterator i = lk.begin(); 
           i != lk.end(); 
           i++)
        {
          unsigned int sumCk = accumulate(ds->mCount.begin() + pos,
                                          ds->mCount.begin() + pos + *i,
                                          0);
          pos += *i;
          c.push_back(sumCk);
       }

      // Compute the probability of observing the counts using a and b.
      for (unsigned int k = 0; k < dk.size(); k++)
        {
          unsigned int xk = c.at(k);
          double mu = ds->mN * dk.at(k);
          double n = 1.0/(mFixed->mA0 + mFixed->mA1/mu);
          double p = n/(n+mu);
          double v = gsl_ran_negative_binomial_lnpdf (xk, p, n);
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
              ss.str(string()); 
              ss << "j k v mu xk p n " 
                 << j << " " << k << " " << v << " " << mu << " " 
                 << xk << " " << p << " " << n;
              strLog = ss.str(); 
              EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

          logNb.push_back(v);
        }
    }
  double vTotal = accumulate(logNb.begin(),logNb.end(),.0);
  return vTotal;
}
RandomVariable*
TotalLikelihood::r ()
{
  RandomVariable* v = NULL;
  return v;
}
}
@

\subsection{MoverManager}
<<tuxMoverManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERMANAGER_H_
#define _TUXMOVERMANAGER_H_
#include <iostream>
#include <vector>
#include <gsl/gsl_randist.h>
using namespace std;
namespace tux {
class Mover;
class MoverManager {
public:
  vector<Mover*> mMover;
  vector<unsigned int> mId;
  vector<double> mWeight;
  gsl_ran_discrete_t* mGslRanDiscrete;
public:
  MoverManager ();
  ~MoverManager ();
  void add (Mover*, const unsigned int, const double);
  Mover* choose ();
  friend ostream& operator<< (ostream &out, const MoverManager &t);

  template <class T> struct c_delete {
    void operator() (T i) {delete i;}
  };
};
}
#endif // _TUXMOVERMANAGER_H_

<<tuxMoverManager.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <string>
#include <iostream>
#include <algorithm>  // for_each
#include <cassert>
#include <gsl/gsl_block.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxGslRng.h"
#include "tuxMover.h"
#include "tuxMoverManager.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
MoverManager::MoverManager ()
{
  mGslRanDiscrete = NULL;
}
MoverManager::~MoverManager ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  c_delete<Mover*> deleteMover;
  for_each (mMover.begin(), mMover.end(), deleteMover);           
  if (mGslRanDiscrete != NULL) 
    {
      gsl_ran_discrete_free(mGslRanDiscrete);
      mGslRanDiscrete = NULL;
    }
}
void
MoverManager::add (Mover* m, const unsigned int id, const double weight)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
    << "Mover " << id << " added with weight of " << weight << endl;

  mId.push_back(id); 
  mWeight.push_back(weight);
  mMover.push_back(m);

  size_t k = mMover.size();
  if (k > 1)
    {
      if (mGslRanDiscrete != NULL) 
        {
          gsl_ran_discrete_free(mGslRanDiscrete);
          mGslRanDiscrete = NULL;
        }
      mGslRanDiscrete = gsl_ran_discrete_preproc (k,&mWeight[0]); 
    }
}
Mover*
MoverManager::choose()
{
  size_t k;
  if (mMover.size() > 1)
    k = gsl_ran_discrete(gGslRng,mGslRanDiscrete);
  else
    k = 0;
#ifdef _DEBUG
  stringstream ss;
  ss << "MoverManager::choose " << k;
  string strLog(ss.str());
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
#endif // _DEBUG
  return mMover.at(k);
}
ostream& 
operator<< (ostream &out, const MoverManager &t)
{
  out << "Acceptance Ratio: ";
  for (unsigned int i = 0; i < t.mMover.size(); i++)
    {
      Mover* m = t.mMover.at(i);
      out << t.mId.at(i) << " (" << (*m) << ") ";
    }
  return out;
}
}
@

\subsection{Mover}
<<tuxMover.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVER_H_
#define _TUXMOVER_H_
#include <iostream>
using namespace std;
namespace tux {
class Mover {
public:
  unsigned int mTry;
  unsigned int mAccepted;
  bool mIsData;
  unsigned int mID;
  double mWeight;
public:
  Mover (bool d = true) : mTry(0), mAccepted(0), mIsData(d) {}
  virtual ~Mover () {}
  virtual int step () = 0;
  double acceptanceRatio () const; 
  friend ostream& operator<< (ostream &out, const Mover &t);
};
}
#endif // _TUXMOVER_H_

<<tuxMover.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxMover.h"
using namespace std;
namespace tux {
double
Mover::acceptanceRatio () const 
{
  double v;
  if (mTry > 0)
    v = double(mAccepted)/double(mTry)*100.0;
  else
    v = .0;
  return v;
}
ostream& 
operator<< (ostream &out, const Mover &t)
{
  out << t.mAccepted << "/" << t.mTry << " " << t.acceptanceRatio ();
  return out;
}
}
@

\subsection{MoverTxBoundaries}
<<tuxMoverTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXBOUNDARIES_H_
#define _TUXMOVERTXBOUNDARIES_H_
#include <vector>
#include <cmath>
#include <functional> // unary_function
#include <numeric>    // accumulate
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGslRng.h"
#include "tuxMover.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
class TxBoundaries;
class TxExpression;
class TxParameter;
class Reads;
class Fixed;
class Summary;
class MoverTxBoundaries: public Mover {
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
  Summary* mSummary;
  vector<unsigned int> mK;
public:
  MoverTxBoundaries ();
  MoverTxBoundaries (Fixed* f, vector<Reads*>& r, 
                     TxBoundaries* txb, TxExpression* txe, TxParameter* txp,
		     Summary* s);
  int step ();
  int step (unsigned int left, unsigned int right);

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return current++;}
  } uniqueNumber;

  // Duplicate
  struct c_probNb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    double operator()(double d,unsigned int k) {
      double mu = d * mM * mSizeFactor; 
      double n = mu/(a0+a1/mu);
      double p = n/(n+mu);
      return log(gsl_ran_negative_binomial_pdf(k,p,n));
    }
  } probNb;

  struct c_round {
    unsigned int operator()(double i) {
      return static_cast<unsigned int>(i + 0.5L);
    }
  } mRound;
};
}
#endif // _TUXMOVERTXBOUNDARIES_H_

<<tuxMoverTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <cassert>
#include <cmath>
#include <iostream>
#include <sstream>
#include <numeric>         // partial_sum
#include <algorithm>       // generate
#include <functional>      // plus
#include <vector>
#include <gsl/gsl_math.h>  // gsl_fcmp
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxTotalLikelihood.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxSummary.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxMoverTxBoundaries.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
MoverTxBoundaries::MoverTxBoundaries ()
{
}
MoverTxBoundaries::MoverTxBoundaries (Fixed* f, vector<Reads*>& r, 
                                      TxBoundaries* txb, 
                                      TxExpression* txe,
                                      TxParameter* txp,
                                      Summary* s)
  : Mover(f->mIsData), mFixed(f), mReads(r), 
    mTxBoundaries(txb), mTxExpression(txe), mTxParameter(txp),
    mSummary(s)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  // Create a sequence of non-negative integers from 0 to K-1.
  gUniqueNumberFromZero.current = 0;
  mK.resize(mFixed->mK-1);
  generate(mK.begin(),mK.end(),gUniqueNumberFromZero);                 
}
int 
MoverTxBoundaries::step ()
{
  unsigned int left = 0;
  unsigned int right = 0;
  gsl_ran_shuffle (gGslRng,&mK[0],mK.size(),sizeof(unsigned int)); 
  for (vector<unsigned int>::iterator i = mK.begin(); i != mK.end(); i++)
    {
      if (mFixed->mLengthSampleSegmentA < *i)
        {
          left = *i - mFixed->mLengthSampleSegmentA;
        }
      else
        {
          left = 0;
        }
      if (mFixed->mLengthSampleSegmentA < mK.size() - 1 - *i)
        {
          right = *i + mFixed->mLengthSampleSegmentA;
        }
      else
        {
          right = mK.size() - 1;
        }
      assert(left < right);
      step (left, right);
    }
  return 0;
}
int 
MoverTxBoundaries::step (unsigned int left, unsigned int right)
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  int status;
  // Find the left and right.
  vector<unsigned int> ck(mTxBoundaries->mC.begin() + left,
                          mTxBoundaries->mC.begin() + right + 1);
  vector<unsigned int> ckA(ck);
  vector<double> deltaK(mTxExpression->mDelta.begin() + left,
                        mTxExpression->mDelta.begin() + right + 1);
  // Compute lk
  vector<unsigned int> lk(ck);
  vector<unsigned int> lkLeft;
  if (left == 0)
    lkLeft.push_back(0);
  else
    lkLeft.push_back(mTxBoundaries->mC.at(left - 1));
  lkLeft.insert(lkLeft.end(),lk.begin(),lk.end()-1);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<unsigned int>());
  
  // Propose new boundaries
  unsigned int sumLk = accumulate(lk.begin(),lk.end(),0);
  unsigned int kappa = lk.size();
  unsigned int sumLkStar = sumLk - kappa;
  vector<double> b(lk.size());
  transform(lk.begin(), lk.end(), b.begin(), 
            bind2nd(divides<double>(),static_cast<double>(sumLk)));
  vector<double> a(lk.size());
  vector<double> aAlpha(lk.size());
  vector<double> bAlpha(lk.size());
  transform(b.begin(), b.end(), bAlpha.begin(), 
            bind2nd(multiplies<double>(),mFixed->mAlphaQBoundaries));
  // Get a and aAlpha using bAlpha.
  // FIXME: check for the numerical stability?
  status = fGslRanDirichletCheck (b,bAlpha,a,aAlpha,mFixed->mAlphaQBoundaries);
  if (status != GSL_SUCCESS)
    {
      mTry++;
      return 0;
    }

  // Compute the new set, ckA, of boundaries using the new lambda, or a.
  vector<double> aPartialSum(a.size());
  partial_sum(a.begin(),a.end(),aPartialSum.begin());
  vector<double> ckADouble(a.size());
  transform(aPartialSum.begin(), aPartialSum.end(), ckADouble.begin(), 
            bind2nd(multiplies<double>(),static_cast<double>(sumLkStar)));
  transform (ckADouble.begin(),ckADouble.end(),ckA.begin(),mRound);
  ckA.back() = sumLkStar;
  // Now, we have ending positions. We will use the first kappa-1 elements.
  vector<unsigned int> s1(a.size());
  uniqueNumber.current = lkLeft.front() + 1;
  generate(s1.begin(),s1.end(),uniqueNumber);                  
  transform(ckA.begin(),ckA.end(),s1.begin(),ckA.begin(),plus<unsigned int>());

  // Now, we have ckA.
  assert(ckA.back()==ck.back());

  // Compute lkA
  vector<unsigned int> lkA(ckA);
  vector<unsigned int> lkALeft;
  if (left == 0)
    lkALeft.push_back(0);
  else
    lkALeft.push_back(mTxBoundaries->mC.at(left - 1));
  lkALeft.insert(lkALeft.end(),lkA.begin(),lkA.end()-1);
  transform(lkA.begin(),lkA.end(),lkALeft.begin(),lkA.begin(),
            minus<unsigned int>());

  // No prior ratio because of uniform prior on TxBoundaries
  double prExpression = 0;
  // MH ratio.
  double mhAtoB = gsl_ran_dirichlet_lnpdf(kappa,&aAlpha[0],&b[0]);
  double mhBtoA = gsl_ran_dirichlet_lnpdf(kappa,&bAlpha[0],&a[0]);
  double mhExpression = mhAtoB - mhBtoA;
  // Likelihood ratio.
  double likelihoodExpression; 
  if (mIsData == true)
    {
      // We count reads on the segments.
      vector<double> logNb;
      vector<unsigned int> cA;
      vector<unsigned int> cB;
      for (unsigned int j = 0; j < mReads.size(); j++)
        {
          Reads* d = mReads.at(j);
          cA.clear();
          unsigned int posA = lkLeft.front();
          for (vector<unsigned int>::iterator i = lkA.begin(); 
               i != lkA.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posA,
                                              d->mCount.begin() + posA + *i,
                                              0);
              posA += *i;
              cA.push_back(sumCk);
           }

          cB.clear();
          unsigned int posB = lkLeft.front();
          for (vector<unsigned int>::iterator i = lk.begin(); 
               i != lk.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posB,
                                              d->mCount.begin() + posB + *i,
                                              0);
              posB += *i;
              cB.push_back(sumCk);
           }

          // Compute the probability of observing the counts using a and b.
          for (unsigned int k = 0; k < deltaK.size(); k++)
            {
              unsigned int xkA = cA.at(k);
              double muA = d->mN * deltaK.at(k);
              double nA = 1.0/(mFixed->mA0 + mFixed->mA1/muA);
              double pA = nA/(nA+muA);
              double vA = gsl_ran_negative_binomial_lnpdf (xkA, pA, nA);

              unsigned int xkB = cB.at(k);
              double muB = d->mN * deltaK.at(k);
              double nB = 1.0/(mFixed->mA0 + mFixed->mA1/muB);
              double pB = nB/(nB+muB);
              double vB = gsl_ran_negative_binomial_lnpdf (xkB, pB, nB);
              logNb.push_back(vA - vB);
            }
        }
      likelihoodExpression = accumulate(logNb.begin(),logNb.end(),.0);
    }
  else
    {
      likelihoodExpression = .0;
    }
  double logAlpha = mTxParameter->mBeta * (likelihoodExpression + prExpression)
                    + mhExpression;
  double logAlphaUniform = log(gsl_rng_uniform(gGslRng));
  mTry++;
  bool isAccepted = true;
  if (logAlpha < logAlphaUniform)
    {
      // Reject it.
      isAccepted = false;
    }
  else
    {
      // Accept it.
      mAccepted++;

#ifdef _DEBUG
      // Compute the total likelihood before the change to the boundaries.
      TotalLikelihood tl(mFixed,mReads,mTxBoundaries,mTxExpression,mTxParameter);
      double prevLoglikelihood = tl.d();
#endif // _DEBUG

      for (unsigned int i = 0; i < ckA.size() - 1; i++)
        {
          mTxBoundaries->mC.at(i + left) = ckA.at(i);
        }

#ifdef _DEBUG
      // Compute the total likelihood after the change to the boundaries.
      double currLoglikelihood = tl.d();
      // Compare the difference and likelihoodExpression.
      int diffV = gsl_fcmp(currLoglikelihood - prevLoglikelihood,
                           likelihoodExpression, 1e-6);
      if (diffV != 0)
        {
          ss.str(string()); 
          ss << "Error: currLoglikelihood " << currLoglikelihood
             << " - "
             << "prevLoglikelihood " << prevLoglikelihood
             << " = likelihoodExpression " << likelihoodExpression;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog << endl;
          assert(0);
        }
#endif // _DEBUG

      mTxParameter->mLoglikelihood += likelihoodExpression; 
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
      if (mTxBoundaries->check() == false)
        {
          ss.str(string()); 
          ss << "    ";
          ss << "TxB(old) start at " << lkLeft.front() << " k (lk-ck) ";
          for (unsigned int i = 0; i < ck.size(); i++)
            {
              unsigned int k = left + i;
              ss << " " << k << " (" << lk.at(i) << " - " << ck.at(i) << ")";
            }
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog << endl;
          ss.str(string());
          ss << "    ";
          ss << "TxB(new) start at " << lkLeft.front() << " k (lk-ck)";
          for (unsigned int i = 0; i < ckA.size(); i++)
            {
              unsigned int k = left + i;
              ss << " " << k << " (" << lkA.at(i) << " - " << ckA.at(i) << ")";
            }
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog << endl;
          assert (0);
        }
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

    }
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
    << "  TxB Move Left - Right: " << left << " - " << right << endl;
  ss << "    ";
  ss << "Total likelihood: (" 
     << mTxParameter->mLoglikelihood 
     << ") AlphaUnif: " << logAlphaUniform;
  if (isAccepted == true)
    ss << " < ";
  else
    ss << " > ";
  ss << "Alpha: " << logAlpha << " = "
     << likelihoodExpression << " + " << prExpression << " + " << mhExpression;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB(old) start at " << lkLeft.front() << " k (lk-ck) ";
  for (unsigned int i = 0; i < ck.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << lk.at(i) << " - " << ck.at(i) << ")";
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
  ss.str(string());
  ss << "    ";
  ss << "TxB(new) start at " << lkLeft.front() << " k (lk-ck)";
  for (unsigned int i = 0; i < ckA.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << lkA.at(i) << " - " << ckA.at(i) << ")";
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string());
  ss << "    ";
  ss << "TxB(b) ";
  for (unsigned int i = 0; i < a.size(); i++) ss << " " << b.at(i); 
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string());
  ss << "    ";
  ss << "TxB(a) ";
  for (unsigned int i = 0; i < a.size(); i++) ss << " " << a.at(i); 
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB Acceptance: " << mAccepted << " / " << mTry << " = " 
     <<  acceptanceRatio (); 
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  return 0;
}
}
@

\subsection{MoverTxBSingle}
<<tuxMoverTxBSingle.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXBSINGLE_H_
#define _TUXMOVERTXBSINGLE_H_
#include <vector>
#include "tuxMover.h"
using namespace std;
namespace tux {
class TxBoundaries;
class TxExpression;
class TxParameter;
class Reads;
class Fixed;
class Summary;
class MoverTxBSingle: public Mover {
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
  Summary* mSummary;
  vector<unsigned int> mK;
public:
  MoverTxBSingle ();
  MoverTxBSingle (Fixed* f, vector<Reads*>& r, 
                  TxBoundaries* txb, TxExpression* txe, TxParameter* txp,
		  Summary* s);
  int step ();
  int step (unsigned int pos);
};
}
#endif // _TUXMOVERTXBSINGLE_H_

<<tuxMoverTxBSingle.cpp>>=
<<tux gnu copyright>>
#include <cassert>
#include <cmath>
#include <iostream>
#include <sstream>
#include <numeric>    // partial_sum
#include <algorithm>  // generate
#include <functional> // plus
#include <vector>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxTotalLikelihood.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxSummary.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxMoverTxBSingle.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
MoverTxBSingle::MoverTxBSingle ()
{
}
MoverTxBSingle::MoverTxBSingle (Fixed* f, vector<Reads*>& r, 
                                TxBoundaries* txb, 
                                TxExpression* txe,
                                TxParameter* txp,
				Summary* s)
  : Mover(f->mIsData), mFixed(f), mReads(r), 
    mTxBoundaries(txb), mTxExpression(txe), mTxParameter(txp),
    mSummary(s)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);

  // Create a sequence of non-negative integers from 0 to K-1.
  gUniqueNumberFromZero.current = 0;
  mK.resize(mFixed->mK-1);
  generate(mK.begin(),mK.end(),gUniqueNumberFromZero);                 
}
int 
MoverTxBSingle::step ()
{
  gsl_ran_shuffle (gGslRng,&mK[0],mK.size(),sizeof(unsigned int)); 
  for (vector<unsigned int>::iterator i = mK.begin(); i != mK.end(); i++)
    step (*i);
  return 0;
}
int 
MoverTxBSingle::step (unsigned int pos)
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
  ss.str(string()); 
  ss << "MoverTxBSingle::step (" << pos << ")";
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  // Find the deltaK of the two segments.
  unsigned int ck = mTxBoundaries->mC.at(pos);
  vector<double> deltaK(mTxExpression->mDelta.begin() + pos,
                        mTxExpression->mDelta.begin() + pos + 2);

  // Find the left side distance.
  unsigned int leftDistance;
  unsigned int rightDistance;
  unsigned int basePosition;
  if (pos == 0)
    {
      basePosition = 0;
    }
  else
    {
      basePosition = mTxBoundaries->mC.at(pos-1);
    }
  assert(pos < mTxBoundaries->mC.size() - 1);
  leftDistance = mTxBoundaries->mC.at(pos) - basePosition;
  rightDistance = mTxBoundaries->mC.at(pos+1) - mTxBoundaries->mC.at(pos) - 1;
  vector<unsigned int> lk(2);
  lk.at(0) = leftDistance;
  lk.at(1) = rightDistance + 1;
  // Find the number of positions that ck can be placed.
  unsigned int lengthWindow = leftDistance + rightDistance;
  if (lengthWindow == 0)
    {
      mTry++;
      return 0;
    }

  // Choose one of lengthWindow.
  // We could use the mirror jump for moderate update.
  unsigned int ckA = gsl_rng_uniform_int(gGslRng, lengthWindow) 
                     + basePosition + 1;
  vector<unsigned int> lkA(2);
  lkA.at(0) = ckA - basePosition;
  lkA.at(1) = mTxBoundaries->mC.at(pos+1) - ckA;

  // Prior ratio.
  double prExpression = 0;
  // MH ratio.
  double mhExpression = 0;
  // Likelihood ratio.
  double likelihoodExpression; 
  if (mIsData == true)
    {
      // We count reads on the segments.
      vector<double> logNb;
      vector<unsigned int> cA;
      vector<unsigned int> cB;
      for (unsigned int j = 0; j < mReads.size(); j++)
        {
          Reads* d = mReads.at(j);
          cA.clear();
          unsigned int posA = basePosition;
          for (vector<unsigned int>::iterator i = lkA.begin(); 
               i != lkA.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posA,
                                              d->mCount.begin() + posA + *i,
                                              0);
              posA += *i;
              cA.push_back(sumCk);
           }

          cB.clear();
          unsigned int posB = basePosition;
          for (vector<unsigned int>::iterator i = lk.begin(); 
               i != lk.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posB,
                                              d->mCount.begin() + posB + *i,
                                              0);
              posB += *i;
              cB.push_back(sumCk);
           }

          // Compute the probability of observing the counts using a and b.
          for (unsigned int k = 0; k < deltaK.size(); k++)
            {
              unsigned int xkA = cA.at(k);
              double muA = d->mN * deltaK.at(k);
              double nA = 1.0/(mFixed->mA0 + mFixed->mA1/muA);
              double pA = nA/(nA+muA);
              double vA = gsl_ran_negative_binomial_lnpdf (xkA, pA, nA);
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
              ss.str(string()); 
              ss << "j k vA muA xkA pA nA " 
                 << j << " " << k << " " << vA << " " << muA << " " 
                 << xkA << " " << pA << " " << nA;
              strLog = ss.str(); 
              EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

              unsigned int xkB = cB.at(k);
              double muB = d->mN * deltaK.at(k);
              double nB = 1.0/(mFixed->mA0 + mFixed->mA1/muB);
              double pB = nB/(nB+muB);
              double vB = gsl_ran_negative_binomial_lnpdf (xkB, pB, nB);
              logNb.push_back(vA - vB);

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
              ss.str(string()); 
              ss << "j k vB muB xkB pB nB " 
                 << j << " " << k << " " << vB << " " << muB << " " 
                 << xkB << " " << pB << " " << nB; 
              strLog = ss.str(); 
              EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
            }
        }
      likelihoodExpression = accumulate(logNb.begin(),logNb.end(),.0);
    }
  else
    {
      likelihoodExpression = .0;
    }
  double logAlpha = mTxParameter->mBeta * (likelihoodExpression + prExpression)
                    + mhExpression;
  double logAlphaUniform = log(gsl_rng_uniform(gGslRng));
  mTry++;
  bool isAccepted = true;
  if (logAlpha < logAlphaUniform)
    {
      // Reject it.
      isAccepted = false;
    }
  else
    {
      // Accept it.
      mAccepted++;

#ifdef _DEBUG
      // Compute the total likelihood before the change to the boundaries.
      TotalLikelihood tl(mFixed,mReads,mTxBoundaries,mTxExpression,mTxParameter);
      double prevLoglikelihood = tl.d();
#endif // _DEBUG

      mTxBoundaries->mC.at(pos) = ckA;

#ifdef _DEBUG
      // Compute the total likelihood after the change to the boundaries.
      double currLoglikelihood = tl.d();
      // Compare the difference and likelihoodExpression.
      int diffV = gsl_fcmp(currLoglikelihood - prevLoglikelihood,
                           likelihoodExpression, 1e-6);
      if (diffV != 0)
        {
          ss.str(string()); 
          ss << "Error: currLoglikelihood " << currLoglikelihood
             << " - "
             << "prevLoglikelihood " << prevLoglikelihood
             << " = likelihoodExpression " << likelihoodExpression;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog << endl;
          assert(0);
        }
#endif // _DEBUG

      mTxParameter->mLoglikelihood += likelihoodExpression; 
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
      if (mTxBoundaries->check() == false)
        {
          ss.str(string()); 
          ss << "    ";
          ss << "TxB3(old) " << ck;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog << endl;
          ss.str(string());
          ss << "    ";
          ss << "TxB3(new) " << ckA; 
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog << endl;
          assert (0);
        }
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
    }
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
    << "  TxBSingle Move pos: " << pos << endl;
  ss.str(string()); 
  ss << "    ";
  ss << "Total likelihood: (" 
     << mTxParameter->mLoglikelihood 
     << ") AlphaUnif: " << logAlphaUniform;
  if (isAccepted == true)
    ss << " < ";
  else
    ss << " > ";
  ss << "Alpha: " << logAlpha << " = "
     << likelihoodExpression << " + " << prExpression << " + " << mhExpression;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB3(old) " << ck;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
  ss.str(string());
  ss << "    ";
  ss << "TxB3(new) " << ckA; 
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB3 Acceptance: " << mAccepted << " / " << mTry << " = " 
     <<  acceptanceRatio (); 
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  return 0;
}
}
@

\subsection{MoverTxExpression}
<<tuxMoverTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXEXPRESSION_H_
#define _TUXMOVERTXEXPRESSION_H_
#include <vector>
#include <cmath>
#include <functional> // unary_function
#include "tuxMover.h"
using namespace std;
namespace tux {
class TxBoundaries;
class TxExpression;
class TxParameter;
class Reads;
class Fixed;
class Summary;
class MoverTxExpression: public Mover {
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
  Summary* mSummary;
  double mAverageTotalCount;
  vector<unsigned int> mK;
public:
  MoverTxExpression ();
  MoverTxExpression (Fixed* f, vector<Reads*>& r, 
                     TxBoundaries* txb, TxExpression* txe, TxParameter* txp,
		     Summary* s);
  int step ();
  int step (unsigned int left, unsigned int right);

  struct unaryLog: public unary_function<double,double> {
    double operator() (double number) {return log(number);}
  } mUnaryLog;

};
}
#endif // _TUXMOVERTXEXPRESSION_H_

<<tuxMoverTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <numeric>
#include <algorithm>
#include <functional>
#include <vector>
#include <cassert>
#include <cmath>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxSummary.h"
#include "tuxTotalLikelihood.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverTxExpression.h"
using namespace std;
<<extern tuxlf>>
namespace tux {
MoverTxExpression::MoverTxExpression () : Mover()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  mFixed = NULL;
  mTxBoundaries = NULL;
  mTxExpression = NULL;
  mTxParameter = NULL;
}
MoverTxExpression::MoverTxExpression (Fixed* f, vector<Reads*>& r, 
                                      TxBoundaries* txb, TxExpression* txe,
                                      TxParameter* txp,
                                      Summary* s)
  : Mover(f->mIsData), mFixed(f), mReads(r), 
    mTxBoundaries(txb), mTxExpression(txe), mTxParameter(txp),
    mSummary(s)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  mAverageTotalCount = .0; 
  for (vector<Reads*>::iterator it = r.begin(); it != r.end(); it++)
    {
      mAverageTotalCount += static_cast<double>((*it)->mN);
    }
  mAverageTotalCount /= static_cast<double>(r.size());

  EZLOGGERSTREAM 
    << "The average of the total number of reads is "
    << mAverageTotalCount << endl;

  // Create a sequence of non-negative integers from 0 to K-1.
  gUniqueNumberFromZero.current = 0;
  mK.resize(mFixed->mK-1);
  generate(mK.begin(),mK.end(),gUniqueNumberFromZero);
}
// This is the same copy of MoverTxBoundaries::step ().
int 
MoverTxExpression::step ()
{
  unsigned int left = 0;
  unsigned int right = 0;
  gsl_ran_shuffle (gGslRng,&mK[0],mK.size(),sizeof(unsigned int)); 
  for (vector<unsigned int>::iterator i = mK.begin(); i != mK.end(); i++)
    {
      if (mFixed->mLengthSampleSegmentA < *i)
        {
          left = *i - mFixed->mLengthSampleSegmentA;
        }
      else
        {
          left = 0;
        }
      if (mFixed->mLengthSampleSegmentA < mK.size() - 1 - *i)
        {
          right = *i + mFixed->mLengthSampleSegmentA;
        }
      else
        {
          right = mK.size() - 1;
        }
      assert(left < right);
      step (left, right);
    }
  return 0;
}
int 
MoverTxExpression::step (unsigned int left, unsigned int right)
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  int status;
  assert(left < right); 
  // Find the ck and lk for computing the likelihood.
  assert(right + 1 <= mTxBoundaries->mC.size());
  vector<unsigned int> ck(mTxBoundaries->mC.begin() + left,
                          mTxBoundaries->mC.begin() + right + 1);
 
  // Compute the lengths.
  vector<unsigned int> lk(ck);
  vector<unsigned int> lkLeft;
  if (left == 0)
    lkLeft.push_back(0);
  else
    lkLeft.push_back(mTxBoundaries->mC.at(left - 1));
  lkLeft.insert(lkLeft.end(),lk.begin(),lk.end()-1);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<unsigned int>());

  // Propose a new set of expression. 
  vector<double> dk(mTxExpression->mDelta.begin() + left,
                    mTxExpression->mDelta.begin() + right + 1);
  // Propose a new set of expression. 
  size_t kappa = static_cast<size_t>(dk.size());
  assert (kappa > 1);
  vector<double> dkA(dk);
  vector<double> a(kappa);
  vector<double> b(kappa);
  vector<double> aAlpha(kappa);
  vector<double> bAlpha(kappa);
  double sumDk = accumulate(dk.begin(),dk.end(),.0);
  transform(dk.begin(),dk.end(),b.begin(), 
            bind2nd(divides<double>(),sumDk));
  transform(b.begin(),b.end(),bAlpha.begin(), 
            bind2nd(multiplies<double>(),mFixed->mAlphaQExpression));
  status = fGslRanDirichletCheck (b,bAlpha,a,aAlpha,mFixed->mAlphaQExpression);
  if (status != GSL_SUCCESS)
    {
      mTry++;
      return 0;
    }
  transform(a.begin(), a.end(), dkA.begin(), 
            bind2nd(multiplies<double>(),sumDk));

  // Prior ratio.
  double prExpression = .0L;

  // MH ratio.
  double mhAtoB = gsl_ran_dirichlet_lnpdf(kappa,&aAlpha[0],&b[0]);
  double mhBtoA = gsl_ran_dirichlet_lnpdf(kappa,&bAlpha[0],&a[0]);
  double mhExpression = mhAtoB - mhBtoA;
  // Likelihood ratio.
  double likelihoodExpression; 
  if (mIsData == true)
    {
      // We count reads on the segments.
      vector<double> logNb;
      for (unsigned int j = 0; j < mReads.size(); j++)
        {
          Reads* d = mReads.at(j);
          vector<unsigned int> c;
          unsigned int pos = lkLeft.front();
          for (vector<unsigned int>::iterator i = lk.begin(); 
               i != lk.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + pos,
                                              d->mCount.begin() + pos + *i,
                                              0);
              pos += *i;
              c.push_back(sumCk);
           }
          // Compute the probability of observing the counts using a and b.
          for (unsigned int k = 0; k < ck.size(); k++)
            {
              unsigned int xk = c.at(k);

              double muA = d->mN * dkA.at(k);
              double nA = 1.0/(mFixed->mA0 + mFixed->mA1/muA);
              double pA = nA/(nA+muA);
              double vA = gsl_ran_negative_binomial_lnpdf (xk, pA, nA);

              double muB = d->mN * dk.at(k);
              double nB = 1.0/(mFixed->mA0 + mFixed->mA1/muB);
              double pB = nB/(nB+muB);
              double vB = gsl_ran_negative_binomial_lnpdf (xk, pB, nB);
              logNb.push_back(vA - vB);
            }
        }
      // Be careful in using accumulate with double. If the third argument is 0,
      // then the returned value would be 0.
      likelihoodExpression = accumulate(logNb.begin(),logNb.end(),.0);
    }
  else
    {
      likelihoodExpression = .0;
    }
  double logAlpha = mTxParameter->mBeta * (likelihoodExpression + prExpression)
                    + mhExpression;
  double logAlphaUniform = log(gsl_rng_uniform(gGslRng));
  mTry++;
  bool isAccepted = true;
  if (logAlpha < logAlphaUniform)
    {
      // Reject it.
      // Keep the value of TxExpression* mTxExpression;
      isAccepted = false;
    }
  else
    {
      // Accept it.
      mAccepted++;


#ifdef _DEBUG
      // Compute the total likelihood before the change to the boundaries.
      TotalLikelihood tl(mFixed,mReads,mTxBoundaries,mTxExpression,mTxParameter);
      double prevLoglikelihood = tl.d();
#endif // _DEBUG

      // Change the value of TxExpression* mTxExpression;
      for (unsigned int i = 0; i < dkA.size(); i++)
        {
          mTxExpression->mDelta.at(i + left) = dkA.at(i);
        }

#ifdef _DEBUG
      // Compute the total likelihood after the change to the boundaries.
      double currLoglikelihood = tl.d();
      // Compare the difference and likelihoodExpression.
      int diffV = gsl_fcmp(currLoglikelihood - prevLoglikelihood,
                           likelihoodExpression, 1e-6);
      if (diffV != 0)
        {
          ss.str(string()); 
          ss << "Error: currLoglikelihood " << currLoglikelihood
             << " - "
             << "prevLoglikelihood " << prevLoglikelihood
             << " = likelihoodExpression " << likelihoodExpression;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog << endl;
          assert(0);
        }
#endif // _DEBUG

      mTxParameter->mLoglikelihood += likelihoodExpression;
    }

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
    << "  TxE Move Left - Right: " << left << " - " << right << endl;
  ss << "    ";
  ss << "Total likelihood: ("
     << mTxParameter->mLoglikelihood
     << ") AlphaUnif: " << logAlphaUniform;
  if (isAccepted == true)
    ss << " < ";
  else
    ss << " > ";
  ss << "Alpha: " << logAlpha << " = "
     << likelihoodExpression << " + " << prExpression << " + " << mhExpression;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB(curr) start at " << lkLeft.front() << " k (lk-ck) ";
  for (unsigned int i = 0; i < ck.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << lk.at(i) << " - " << ck.at(i) << ")";
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
  ss.str(string()); 
  ss << "    ";
  ss << "TxE(old): k (dk)";
  for (unsigned int i = 0; i < dk.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << dk.at(i) << ")";
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
  ss.str(string()); 
  ss << "    ";
  ss << "TxE(new): k (dk)";
  for (unsigned int i = 0; i < dkA.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << dkA.at(i) << ")";
    }
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string());
  ss << "    ";
  ss << "TxE(b) ";
  for (unsigned int i = 0; i < a.size(); i++) ss << " " << b.at(i); 
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string());
  ss << "    ";
  ss << "TxE(a) ";
  for (unsigned int i = 0; i < a.size(); i++) ss << " " << a.at(i); 
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;

  ss.str(string()); 
  ss << "    ";
  ss << "TxE Acceptance: " << mAccepted << " / " << mTry << " = " 
     <<  acceptanceRatio (); 
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog << endl;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  return 0;
}
}
@

\subsection{Sample}
<<tuxSample.h>>=
<<tux gnu copyright>>
#ifndef _TUXSAMPLE_H_
#define _TUXSAMPLE_H_
#include <fstream>
namespace tux {
class Sample {
public:
  string mFilename;
  ofstream mOs;
public:
  void open (const char* filename);
  void close ();
  void write (); 
};
}
#endif // _TUXSAMPLE_H_

<<tuxSample.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSample.h"
using namespace std;
namespace tux {
void 
Sample::full ()
{
  return;
}
}
@

\subsection{Summarizer}
<<tuxSummarizer.h>>=
<<tux gnu copyright>>
#ifndef _TUXSUMMARIZER_H_
#define _TUXSUMMARIZER_H_
#include <iostream>
#include <vector>
#include <gsl/gsl_siman.h>
using namespace std;
namespace tux {
class Fixed;
class Reads;
class Summarizer {
private:
  vector<unsigned int> mTxb;
  vector<unsigned int> mBestTxb;
  bool mIsSuccess;
private:
  Summarizer();
  double EfInitialize();
  double boltzmann(double E, double new_E, double T);
  double Ef(double);
  void takeStep();
  bool fillStepIndex ();
  bool fillTxbs ();
public:
  Fixed* mFixed;
  vector<Reads*> mReads;

  map<unsigned int,unsigned int> mStepIndex;
  vector<vector<unsigned int> > mTxbs;

  gsl_siman_params_t params; //  = {N_TRIES, ITERS_FIXED_T, STEP_SIZE,
                             //  K, T_INITIAL, MU_T, T_MIN};

  unsigned int mLeftInterval; 
  unsigned int mRightInterval; 
  unsigned int mStepsize;    // Preset this.
  unsigned int mCk;          // the boundary site we propose a new value for
  unsigned int mNewX;        // a new value for the proposed boundary site
  unsigned int mX;           // the old value for the proposed boundary site 

public:
  Summarizer (Fixed* m, const vector<Reads*>& shortRead);
  void execute ();
  void findMeanBoundaries ();
  void listLoglikelihood ();
  void reportSitewiseFrequencyBoundaries ();
  void reportSitewiseExpression ();
  void computeFrequencyBoundaries ();
  friend ostream& operator<< (ostream &out, const Summarizer &t);
};
}
#endif // _TUXSUMMARIZER_H_


<<tuxSummarizer.cpp>>=
<<tux gnu copyright>>
#include <iomanip>
#include <map>
#include <fstream>
#include <iterator>
#include <algorithm>  // upper_bound
#include <gsl/gsl_math.h>
#include "yaml-cpp/yaml.h"
#include "ezlogger_headers.hpp"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxProgress.h"
#include "tuxSummarizer.h"
using namespace std;
namespace tux {
template <typename T>
void delete_pointed_to (T* p)
{
  delete p;
}
Summarizer::Summarizer (Fixed* m, const vector<Reads*>& shortRead)
  : mFixed(m), mReads(shortRead)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  mIsSuccess = fillStepIndex ();
  mIsSuccess = fillTxbs ();
}
void
Summarizer::execute ()
{
  if (mIsSuccess == true)
    {
      if (mFixed->mListlikelihood == true)
        listLoglikelihood ();
      if (mFixed->mSitewiseExpression == true)
        reportSitewiseExpression ();
      if (mFixed->mSitewiseBoundaries == true)
        reportSitewiseFrequencyBoundaries ();
      // computeFrequencyBoundaries ();
      // findMeanBoundaries ();
    }
  return;
}
void
Summarizer::reportSitewiseFrequencyBoundaries ()
{ 
  string cfn;
  vector<unsigned int> v(mFixed->L(),0);
  for (unsigned int i = 0; i < mFixed->numberProcess (); i++)
    {
      unsigned int c;
      cfn = mFixed->prefixFilename (i) + "sfb";
      ifstream fin(cfn.c_str());
      if (fin.is_open() == false)
        {
          cerr << "Error: Could not open file ``" 
               << cfn
               << "'' for summary!" << endl;
          return;
        }
      for (vector<unsigned int>::iterator j = v.begin(); j != v.end(); j++) 
        {
          fin >> c;
          if (fin.good())
            {
              *j += c;
            }
          else
            {
              cerr << "Error: Could not read " << mFixed->L()
                   << " numbers from ``" << cfn << ".''" << endl;
              fin.close();
              return; 
            }
        }
      fin.close();
    }

  // Prints out the summed values. 
  cfn = mFixed->prefixFilename () + "sfb";
  ofstream fout(cfn.c_str());
  if (fout.is_open() == false)
    {
      cerr << "Error: Could not open file ``" 
           << cfn
           << "'' for summary!" << endl;
      return;
    }
  double d;
  unsigned int l = mFixed->mcmcLength ();
  fout << setprecision(5);
  // fout << "fixedStep chrom=chr1 start=1 step=1" << endl;
  for (vector<unsigned int>::iterator j = v.begin(); j != v.end(); j++) 
    {
      d = static_cast<double>(*j)/static_cast<double>(l);
      fout << d << endl; 
    }
  fout.close();
  return;
}

void
Summarizer::reportSitewiseExpression ()
{ 
  string cfn;
  vector<double> v(mFixed->L(),.0);
  for (unsigned int i = 0; i < mFixed->numberProcess (); i++)
    {
      double c;
      cfn = mFixed->prefixFilename (i) + "swe";
      ifstream fin(cfn.c_str());
      if (fin.is_open() == false)
        {
          cerr << "Error: Could not open file ``" 
               << cfn
               << "'' for summary!" << endl;
          return;
        }
      for (vector<double>::iterator j = v.begin(); j != v.end(); j++) 
        {
          fin >> c;
          if (fin.good())
            {
              *j += c;
            }
          else
            {
              cerr << "Error: Could not read " << mFixed->L()
                   << " numbers from ``" << cfn << ".''" << endl;
              fin.close();
              return; 
            }
        }
      fin.close();
    }

  // Prints out the summed values. 
  cfn = mFixed->prefixFilename () + "swe";
  ofstream fout(cfn.c_str());
  if (fout.is_open() == false)
    {
      cerr << "Error: Could not open file ``" 
           << cfn
           << "'' for summary!" << endl;
      return;
    }
  double d;
  unsigned int l = mFixed->mcmcLength ();
  fout << setprecision(5);
  // fout << "fixedStep chrom=chr1 start=1 step=1" << endl;
  for (vector<double>::iterator j = v.begin(); j != v.end(); j++) 
    {
      d = *j / static_cast<double>(l);
      fout << d << endl; 
    }
  fout.close();
  return;
}
void 
Summarizer::listLoglikelihood ()
{
  // Now, we have stepIndex ready.
  unsigned int numberSample = mStepIndex.size();
  vector<vector<double> > pMatrix;
  pMatrix.resize(numberSample); 
  for (unsigned int i = 0; i < numberSample; i++)
    {
      pMatrix.at(i).resize(mFixed->mNumberChain+1,0);
    }

  // Now, we have pMatrix ready.
  Progress p;
  p.start ("List Likelihood", mFixed->mNumberProcess, cout);
  for (unsigned int i = 0; i < mFixed->mNumberProcess; i++)
    {
      string cfn = mFixed->chainFilename (i);
      ifstream fin(cfn.c_str()); 
      YAML::Parser parser2(fin);
      YAML::Node doc2;
      parser2.GetNextDocument(doc2);
      for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
        {
          unsigned int id, s;
          (*it)[0][0] >> id;
          (*it)[0][1] >> s;
          double beta, loglikelihood;
          (*it)[1][0] >> beta;
          (*it)[1][1] >> loglikelihood;

          unsigned int rowIndex = mStepIndex[s];
          pMatrix.at(rowIndex).at(id+1) = loglikelihood;
          pMatrix.at(rowIndex).at(0) = s;
        }
      fin.close();
      p.move (i, cout);
    }
  p.complete (cout);
  // Print the status.

  // Print the values in a .p file.
  string ofn = mFixed->pFilename ();
  ofstream fout(ofn.c_str()); 
  fout << "step"; 
  for (unsigned int i = 1; i < pMatrix.front().size(); i++)
    {
      fout << "\t" << i; 
    }
  fout << endl;
  for (unsigned int i = 0; i < pMatrix.size(); i++)
    {
      fout << static_cast<int>(pMatrix.at(i).front());
      for (unsigned int j = 1; j < pMatrix.at(i).size(); j++)
        {
          fout << "\t" << pMatrix.at(i).at(j);
        }
      fout << endl;
    }
  fout.close();
  return; 
}
bool
Summarizer::fillStepIndex ()
{
  mStepIndex.clear();

  // Find the size of the sample, and index the steps.
  string cfn = mFixed->chainFilename (0);
  ifstream fin(cfn.c_str()); 
  if (fin.is_open())
    {
      YAML::Parser parser2(fin);
      YAML::Node doc2;
      parser2.GetNextDocument(doc2);
      Progress p;
      p.start ("Index", doc2.size(), cout);
      unsigned int i = 0;
      for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
        {
          unsigned int id, s;
          (*it)[0][0] >> id;
          (*it)[0][1] >> s;
          mStepIndex[s] = 0;
          p.move (i++, cout);
        }
      fin.close();
      p.complete (cout);
    }
  else
    {
      cerr << "Error: Check if the file ``" << cfn 
           << "'' exists." << endl;
      return false;
    }

  unsigned int k = 0;
  for (map<unsigned int,unsigned int>::iterator it = mStepIndex.begin(); 
       it != mStepIndex.end(); 
       it++)
    {
      it->second = k++;
    }
  return true;
}

bool
Summarizer::fillTxbs ()
{
  if (mIsSuccess == false) return false;
  // Now, we have stepIndex ready.
  unsigned int numberSample = mStepIndex.size();
  mTxbs.resize(numberSample);
  vector<unsigned int> txb;

  // Now, we txbs ready.
  Progress p;
  p.start ("TxB", mFixed->mNumberProcess, cout);
  for (unsigned int i = 0; i < mFixed->mNumberProcess; i++)
    {
      string cfn = mFixed->chainFilename (i);
      ifstream fin(cfn.c_str()); 
      YAML::Parser parser2(fin);
      YAML::Node doc2;
      parser2.GetNextDocument(doc2);
      for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
        {
          unsigned int id, s;
          (*it)[0][0] >> id;
          (*it)[0][1] >> s;
          double beta, loglikelihood;
          (*it)[1][0] >> beta;
          (*it)[1][1] >> loglikelihood;

          // Many integers
          if (id == 0)
            {
              txb.clear();
              for (YAML::Iterator jt=(*it)[2].begin();jt!=(*it)[2].end();++jt) 
                {
                  unsigned int a; *jt >> a; 
                  // cout << a << " ";
                  txb.push_back(a);
                }
              unsigned int rowIndex = mStepIndex[s];
              mTxbs.at(rowIndex) = txb;
            }
        }
      fin.close();
      p.move (i, cout);
    }
  p.complete (cout);
  return true;
}
void 
Summarizer::computeFrequencyBoundaries ()
{
  vector<unsigned int> summaryTxB(mReads.front()->size(),0U);
  for (unsigned int i = 0; i < mTxbs.size(); i++)
    {
      for (unsigned int j = 0; j < mTxbs[i].size(); j++)
        {
          unsigned int ck = mTxbs[i][j];
          summaryTxB.at(ck-1)++;
        }
    }
  vector<double> fractionTxB(mReads.front()->size(),.0);
  for (unsigned int i = 0; i < summaryTxB.size(); i++)
    {
      fractionTxB.at(i) = static_cast<double>(summaryTxB.at(i)) 
                          / static_cast<double>(summaryTxB.size());
    }

  // Print the values in a .wig file.
  string ofn = mFixed->prefixFilename ();
  ofn += "wig";
  ofstream fout(ofn.c_str()); 
  for (unsigned int i = 0; i < summaryTxB.size(); i++)
    {
      unsigned int pos = i + 1;
      fout << pos << " " << fractionTxB.at(i) << endl;
    }
  fout.close();

  return;
}
double
Summarizer::boltzmann(double E, double new_E, double T)
{
  double x = -(new_E - E) / (params.k * T);
  /* avoid underflow errors for large uphill steps */
  return (x < GSL_LOG_DBL_MIN) ? 0.0 : exp(x);
}
void 
Summarizer::findMeanBoundaries ()
{
  double E, new_E, best_E;
  double T, T_factor;
  int n_evals = 1, n_iter = 0, n_accepts, n_rejects, n_eless;

  // Sets the mTxb and mBestTxb, and computes E.
  E = EfInitialize();
  best_E = E;

  cout << "E: " << E << endl;
 
  // int params.n_tries // The number of points to try for each step.

  params.iters_fixed_T = 1000; // The number of iterations at each temperature.

  //double params.step_size // The maximum step size in the random walk.

  params.k = 1.0;
  params.t_initial = 1e8;
  params.mu_t = 1.001;
  params.t_min = 10;
  //        The parameters of the Boltzmann distribution and cooling
  //        schedule.
  //
  //return;

  T = params.t_initial;
  T_factor = 1.0 / params.mu_t;

  while (1) 
    {
      n_accepts = 0;
      n_rejects = 0;
      n_eless = 0;

      for (int i = 0; i < params.iters_fixed_T; ++i) 
        {
          takeStep ();    // Sets mCk, mX and mNewX.
          new_E = Ef (E); // Computes a new energy based on E, mX and mNewX.

          if (new_E <= best_E) 
            {
              mBestTxb.at(mCk) = mNewX;
              best_E = new_E;
            }

          ++n_evals;     /* keep track of Ef() evaluations */
          /* now take the crucial step: see if the new point is accepted
             or not, as determined by the boltzmann probability */
          if (new_E < E) 
            {
              if (new_E < best_E) 
                {
                  mBestTxb.at(mCk) = mNewX;
                  best_E = new_E;
                }
              /* yay! take a step */
              mTxb.at(mCk) = mNewX;
              E = new_E;
              ++n_eless;
            } 
          else if (gsl_rng_uniform(gGslRng) < boltzmann(E, new_E, T)) 
            {
              /* yay! take a step */
	            //copy_state(new_x, x, element_size, copyfunc);
              mTxb.at(mCk) = mNewX;
              E = new_E;
              ++n_accepts;
            } 
          else 
            {
              ++n_rejects;
            }
        }

      if (true) 
        {
          /* see if we need to print stuff as we go */
          /*       printf("%5d %12g %5d %3d %3d %3d", n_iter, T, n_evals, */
          /*           100*n_eless/n_steps, 100*n_accepts/n_steps, */
          /*           100*n_rejects/n_steps); */
          printf ("%5d   %7d  %12g", n_iter, n_evals, T);
          //print_position (x);
          printf ("  %12g  %12g\n", E, best_E);
        }

      /* apply the cooling schedule to the temperature */
      /* FIXME: I should also introduce a cooling schedule for the iters */
      T *= T_factor;
      ++n_iter;
      if (T < params.t_min) break;
    }

  /* at the end, copy the result onto the initial point, so we pass it
     back to the caller */
  mTxb = mBestTxb;
  for (vector<unsigned int>::iterator i = mTxb.begin(); 
       i != mTxb.end(); 
       i++)
    {
      cout << setw(6) << *i;
    }
  cout << endl;
  return;
}
double
Summarizer::EfInitialize ()
{
  // Choose a TxB in TxBs.
  unsigned long int s = static_cast<unsigned long int>(mTxbs.size());
  s = gsl_rng_uniform_int (gGslRng,s);
  mTxb = mTxbs.at(s);
  mBestTxb = mTxb;

  // Compute the total distance between TxB and each of TxBs.
  double v = .0;
  for (unsigned int i = 0; i < mTxbs.size(); i++)
    {
      unsigned int d = fGslDistance (mTxb, mTxbs.at(i));
      v += static_cast<double>(d);
    }
  return v;
}
double
Summarizer::Ef (double E)
{
  vector<unsigned int>::iterator u;
  unsigned int leftDistance;
  unsigned int rightDistance;
  for (unsigned int i = 0; i < mTxbs.size(); i++)
    {
      vector<unsigned int>& b = mTxbs.at(i);
      u = upper_bound(b.begin(),b.end(),mNewX);
      assert (u != b.end());
      if (u == b.begin())
        {
          leftDistance = mNewX;
          rightDistance = *u - mNewX;
        }
      else
        {
          leftDistance = mNewX - *(u-1);
          rightDistance = *u - mNewX;
        }
      unsigned int d = GSL_MIN(leftDistance,rightDistance);
      E += static_cast<double>(d);

      assert (u != b.end());
      u = upper_bound(b.begin(),b.end(),mX);
      if (u == b.begin())
        {
          leftDistance = mX - 1;
          rightDistance = *u - mX;
        }
      else
        {
          leftDistance = mX - *(u-1);
          rightDistance = *u - mX;
        }
      d = GSL_MIN(leftDistance,rightDistance);
      E -= static_cast<double>(d);
    }
  return E;
}
void 
Summarizer::takeStep ()
{
  // Choose one boundary. 
  // Find its two neighboring boundaries.
  unsigned long int s = static_cast<unsigned long int>(mTxb.size());
  s = gsl_rng_uniform_int (gGslRng,s - 1);
  mX = mTxb.at(s); // Boundary site
  mCk = s; // Boundary site index
  if (s == 0)
    {
      mLeftInterval = mX - 1U;
    }
  else
    {
      mLeftInterval = mX - mTxb.at(s-1) - 1U;
    }
  mRightInterval = mTxb.at(s+1) - mX - 1U;
  mStepsize = 50;
  mNewX = fGslRanMirror (mLeftInterval,mRightInterval,mStepsize);
  if (s > 0)
    {
      mNewX += mTxb.at(s-1);
    }
  return;
}
ostream& 
operator<< (ostream &out, const Summarizer &t)
{
  out << t.mFixed->mK;
  return out;
}
}
@

\subsection{Summary}
<<tuxSummary.h>>=
<<tux gnu copyright>>
#ifndef _TUXSUMMARY_H_
#define _TUXSUMMARY_H_
#include "tuxRandomVariable.h"
#include <vector>
using namespace std;
namespace tux {
class Summary: public RandomVariable {
public:
  vector<unsigned int> mBoundary;
public:
  Summary ();
  ~Summary ();
};
}
#endif // _TUXSUMMARY_H_

<<tuxSummary.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSummary.h"
using namespace std;
namespace tux {
Summary::Summary ()
{
}
Summary::~Summary ()
{
}
}
@

\subsection{System}
<<tuxSystem.h>>=
<<tux gnu copyright>>
#ifndef _TUXSYSTEM_H_
#define _TUXSYSTEM_H_
namespace tux {
class System {
public:
  void full ();
};
}
#endif // _TUXSYSTEM_H_

<<tuxSystem.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSystem.h"
using namespace std;
namespace tux {
void 
System::full ()
{
  return;
}
}
@

\subsection{TUX GSL}
<<tuxGsl.h>>=
<<tux gnu copyright>>
#ifndef _TUXGSL_H_
#define _TUXGSL_H_
#include <vector>
using namespace std;
namespace tux {
double                                                                          
gsl_ran_negative_binomial_lnpdf (const unsigned int k, 
                                 const double p, 
                                 const double n);
unsigned int 
fGslDistance (const vector<unsigned int>& a, const vector<unsigned int>& b);
}
#endif // _TUXGSL_H_

<<tuxGsl.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <algorithm>  // upper_bound
#include <iterator>
#include <cmath>
#include <cassert>
#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGsl.h"
using namespace std;
namespace tux {
double                                                                          
gsl_ran_negative_binomial_lnpdf (const unsigned int k, 
                                 const double p, 
                                 const double n)
{ 
  double f = gsl_sf_lngamma (k + n);                                           
  double a = gsl_sf_lngamma (n);                                               
  double b = gsl_sf_lngamma (k + 1.0);                                         

  double P = (f-a-b) + n * log(p) + static_cast<double>(k) * log(1 - p); 
  return P;
}
unsigned int 
fGslDistance (const vector<unsigned int>& a, const vector<unsigned int>& b)
{
  unsigned int v = 0;
  vector<unsigned int>::const_iterator u;
  unsigned int leftDistance;
  unsigned int rightDistance;
  for (vector<unsigned int>::const_iterator i = a.begin(); i != a.end(); i++)
    {
      u = upper_bound(b.begin(),b.end(),*i);
      if (u == b.begin())
        {
          leftDistance = *i - 1;
          rightDistance = *u - *i;
        }
      else if (u == b.end())
        {
          leftDistance = 0;
          rightDistance = 0;
        }
      else
        {
          leftDistance = *i - *(u-1);
          rightDistance = *u - *i;
        }
      unsigned int d = GSL_MIN(leftDistance,rightDistance);
      v += d;
    }
  return v;
}
}
@

\subsection{GNU Scientific Library}

Use the following environment variables.
\begin{Verbatim}[frame=lines,framesep=5mm]
GSL_RNG_TYPE="taus" GSL_RNG_SEED=123
\end{Verbatim}

<<gsl.cpp>>=
#include <stdio.h>
#include <gsl/gsl_sf_bessel.h>
     
int main (void)
{
  double x = 5.0;
  double y = gsl_sf_bessel_J0 (x);
  printf ("J0(%g) = %.18e\n", x, y);
  return 0;
}
@

<<tuxGslRng.h>>=
<<tux gnu copyright>>
#ifndef _TUXGSLRNG_H_
#define _TUXGSLRNG_H_
#include <vector>
#include <gsl/gsl_sf_result.h>
using namespace std;
namespace tux {
void fGslRngAlloc ();
unsigned long fGslRngSeed(unsigned long seed = 0);
void fGslRngFree ();
void fGslRanDirichlet (const vector<double>& alpha, 
                       vector<double>& theta, double e);
int
fGslRanDirichletCheck (const vector<double>& bTheta, 
                       const vector<double>& bAlpha, 
                       vector<double>& aTheta, 
                       vector<double>& aAlpha, 
                       double sAlpha);
int
fGslRanDirichletLnpdf (const size_t K,
                       const double alpha[], const double theta[],
                       gsl_sf_result * result);
struct c_unique {
  unsigned int current;
  c_unique() {current=0;}
  unsigned int operator()() {return ++current;}
};
struct c_unique_from_zero {
  unsigned int current;
  c_unique_from_zero() {current=0;}
  unsigned int operator()() {return current++;}
};
vector<unsigned int>
fGslRanTxBoundaries (const unsigned int mL, const unsigned int mK);
unsigned int
fGslRanMirror (const unsigned int l, const unsigned int r, 
               const unsigned int s);
}
#endif /* _TUXGSLRNG_H_ */
@

<<tuxGslRng.cpp>>=
<<tux gnu copyright>>
#include <cstdio>
#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>         // find_if, transform
#include <functional>        // less
#include <cmath>
#include <gsl/gsl_sf_result.h>
#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGslRng.h"
using namespace std;
namespace tux {
gsl_rng* gGslRng;
c_unique gUniqueNumber;
c_unique_from_zero gUniqueNumberFromZero;
void 
fGslRngAlloc () 
{
  const gsl_rng_type* T;
  gsl_rng_env_setup();
  T = gsl_rng_default;
  gGslRng = gsl_rng_alloc(T);
}
unsigned long 
fGslRngSeed (unsigned long seed)                                       
{                                                                               
  unsigned long tseed;
  FILE *devrandom;
  if(seed==0)
    {
      if ((devrandom = fopen("/dev/random","r")) == NULL)                       
        {                                                                       
          tseed = (unsigned long) time(NULL);                                   
          // printf("Got seed %lu from time()\n",tseed);                           
        }                                                                       
      else                                                                      
        {                                                                       
          fread(&tseed,sizeof(tseed),1,devrandom);                              
          // printf("Got seed %lu from /dev/random\n",tseed);                      
          fclose(devrandom);                                                    
        }                                                                       
    }                                                                           
  else                                                                          
    {                                                                           
      tseed=seed;                                                               
      //printf("Using specified seed %lu\n",tseed);                               
    }                                                                           
  gsl_rng_set(gGslRng,tseed);                                                       
  return(tseed);                                                                
}    
void 
fGslRngFree ()
{
  gsl_rng_free (gGslRng);
}
void 
fGslRanDirichlet (const vector<double>& alpha, vector<double>& theta, double e)
{
  vector<double>::iterator it;
  size_t kappa = static_cast<size_t>(alpha.size());
  unsigned int s = 0;
  bool isS = false;
  do
    {
      s++;
      gsl_ran_dirichlet(gGslRng,kappa,&alpha[0],&theta[0]);
      it = find_if(theta.begin(),theta.end(),bind2nd(less<double>(),e));
      if (s % 100000 == 0) 
        {
          isS = true;
          cerr << "-";
        }
    }
  while (it != theta.end());
  if (isS) cerr << endl;
  return;
}
// Given bAlpha we sample aTheta. 
// We check if bTheta is a possible value with aAlpha, which is computed from a.
// We check whehter there are too small values in aTheta.
int
fGslRanDirichletCheck (const vector<double>& bTheta, 
                       const vector<double>& bAlpha, 
                       vector<double>& aTheta, 
                       vector<double>& aAlpha, 
                       double sAlpha)
{
  int status = GSL_SUCCESS;
  gsl_sf_result r;
  vector<double>::iterator it;
  unsigned int kappa = bTheta.size();
  unsigned int s = 0;
  double e = 1e-25;
  do
    {
      s++;
      gsl_ran_dirichlet(gGslRng,kappa,&bAlpha[0],&aTheta[0]);
      it = find_if(aTheta.begin(),aTheta.end(),bind2nd(less<double>(),e));
      if (it != aTheta.end()) 
        {
          status = GSL_EINVAL;
          continue;
        }
      transform(aTheta.begin(),aTheta.end(),aAlpha.begin(), 
                bind2nd(multiplies<double>(),sAlpha));

      status = fGslRanDirichletLnpdf (kappa,&aAlpha[0],&bTheta[0],&r);
      if (status != GSL_SUCCESS) continue;
      status = fGslRanDirichletLnpdf (kappa,&bAlpha[0],&aTheta[0],&r);
      if (status != GSL_SUCCESS) continue;
      // Use r.val to get the result of the value. double mhBtoA = r.val;
    }
  while (s < 100 && status != GSL_SUCCESS);
  return status;
}
int
fGslRanDirichletLnpdf (const size_t K,
                       const double alpha[], const double theta[],
                       gsl_sf_result * result)
{                                                                                  
  /*We calculate the log of the pdf to minimize the possibility of overflow */  
  size_t i;
  double log_p = 0.0;
  double sum_alpha = 0.0;
  gsl_sf_result r;
  int status = GSL_SUCCESS;

  for (i = 0; i < K; i++)
    {
      double logTheta = log (theta[i]);
      if (logTheta == HUGE_VAL)
        {
          status = GSL_ERANGE;
          return status;
        }
      log_p += (alpha[i] - 1.0) * logTheta;
    }

  for (i = 0; i < K; i++)
    {
      sum_alpha += alpha[i];
    }

  status = gsl_sf_lngamma_e(sum_alpha,&r);
  if (status != GSL_SUCCESS) return status;
  log_p += r.val;
                                                                                   
  for (i = 0; i < K; i++)
    {
      status = gsl_sf_lngamma_e(alpha[i],&r);
      if (status != GSL_SUCCESS) return status;
      log_p -= r.val;
    }
  result->val = log_p;
  return status;
}
vector<unsigned int>
fGslRanTxBoundaries (const unsigned int mL, const unsigned int mK)
{
  vector<unsigned int> a(mK-1);
  vector<unsigned int> b(mL-1);
  generate (b.begin(),b.end(),gUniqueNumber);
  gsl_ran_choose (gGslRng, &a[0], mK-1, &b[0], mL-1, sizeof(unsigned int));
  a.push_back(mL);
  return a;
}
// x: l + 1 + r
// x: v in [1,l+r+1]
unsigned int
fGslRanMirror (const unsigned int l, const unsigned int r, 
               const unsigned int s)
{
  unsigned int d, f;
  d = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,s+1));
  f = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,2UL));
  assert(f == 0 || f == 1U);
  if (f == 0)
    {
      d += l + 1;
    }
  else
    {
      if (d < l)
        d = l + 1 - d;
      else
        d = d - l;
    }
  unsigned int q;
  //q = d / (l+r+2);
  q = d / (l+r+1);
  unsigned int remainder;
  // remainder = d % (l+r+2);
  remainder = d % (l+r+1);
  unsigned int v;
  if (q % 2 == 0)
    {
      if (remainder == 0)
        {
          v = 1;
        }
      else
        {
          v = remainder;
        }
    }
  else
    {
      if (remainder == 0)
        {
          v = l + r + 1;
        }
      else
        {
          v = l + r + 2 - remainder;
        }
    }
//  if (q % 2 == 0)
//    {
//      if (remainder == 0)
//        {
//          v = 1;
//        }
//      else
//        {
//          v = remainder;
//        }
//    }
//  else
//    {
//      if (remainder == 0)
//        {
//          v = l + r + 1;
//        }
//      else
//        {
//          v = l + r + 2 - remainder;
//        }
//    }
  return v;
}
}
@

<<extern tuxGslRng>>=
namespace tux {
extern gsl_rng* gGslRng;
extern c_unique_from_zero gUniqueNumberFromZero;
}
@

\subsection{Error codes}
<<tuxError.h>>=
<<tux gnu copyright>>
#ifndef _TUXERROR_H_
#define _TUXERROR_H_
namespace tux {
enum { 
  ERR_OK,
  ERR_FILE,
  ERR_RT_OUT_OF_MEMORY
};
char* err2msg(int code);
}
#endif // _TUXERROR_H_

<<tuxError.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxError.h"
using namespace std;
namespace tux {
struct Error {
  int value;
  char* name;
} error_codes[] = {
  { ERR_OK, "ERR_OK" },
  { ERR_FILE, "File not found" },
  { ERR_RT_OUT_OF_MEMORY, "ERR_RT_OUT_OF_MEMORY" },
  { 0, 0 }
};
char* err2msg(int code)
{
  for (int i = 0; error_codes[i].name; ++i)
    if (error_codes[i].value == code)
      return error_codes[i].name;
  return "unknown";
}
}
@


\subsection{Signal}

\begin{Verbatim}[frame=lines,framesep=5mm]
#include <signal.h>
\end{Verbatim}

<<register signal>>=
signal(SIGUSR1, sig_handler);
<<tuxSignal.h>>=
<<tux gnu copyright>>
#ifndef _TUXSIGNAL_H_
#define _TUXSIGNAL_H_
#include <signal.h>
namespace tux {
void sig_handler(int signum);
}
#endif // _TUXSIGNAL_H_

<<tuxSignal.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <signal.h>
#include "tuxSignal.h"
using namespace std;
namespace tux {
void sig_handler(int signum)
{
  cout << "Received signal " << signum << endl;
}
}
@

\subsection{Default}
<<tuxDefault.h>>=
<<tux gnu copyright>>
#ifndef _TUXDEFAULT_H_
#define _TUXDEFAULT_H_
#include <vector>
#include <string>
using namespace std;
namespace tux {
class Default {
public:
  static string mInfilename;
  static string mLogfilename;

  // From Fixed
  static double mMoverTxBSingleWeight;
  static double mMoverTxBWeight;
  static double mMoverTxEWeight;
  static unsigned int mLogVerbosity;
  static unsigned long int mSeed;
  static unsigned int mL;
  static unsigned int mK;
  static double mM;
  static vector<double> mZ;
  static double mA0;
  static double mA1;
  static double mAlphaQExpression;
  static double mAlphaQBoundaries;
  static unsigned int mLengthSampleSegmentA;
  static unsigned int mLengthSampleSegmentB;
  static double mAlphaPriorExpression;
  static unsigned int mMcmcLength;
  static unsigned int mMcmcBurnin;
  static unsigned int mMcmcThin;
  static unsigned int mNumberProcess;
  static unsigned int mNumberChain;
  static unsigned int mNumberSwap;
  static unsigned int mNumberSwapTry;
  static unsigned int mSwapDistance;
  static double mHAlpha;
  static double mHBeta;
  static string mPrefix;
  static string mOutDirectory;
  static string mChainDirectory;
  static string mLogDirectory;
  static string mDatafile;
  static bool mIsData;
  static bool mSitewiseExpression;
  static bool mSitewiseBoundaries;
  static bool mListlikelihood;
  static unsigned int mPosition;
};
}
#endif // _TUXDEFAULT_H_

<<tuxDefault.cpp>>=
<<tux gnu copyright>>
#include <string>
#include "tuxDefault.h"
using namespace std;
namespace tux {
string Default::mInfilename("in.tux");  
string Default::mLogfilename("in.log");  

// From Fixed.
double Default::mMoverTxBSingleWeight(1.0);
double Default::mMoverTxBWeight(1.0);
double Default::mMoverTxEWeight(1.0);
unsigned int Default::mLogVerbosity(1);
unsigned long Default::mSeed(0);
unsigned int Default::mL(10000U);
unsigned int Default::mK(10U);
double Default::mM(100000.0);
  //vector<double> mZ;
double Default::mA0(.05);
double Default::mA1(5.0);
double Default::mAlphaQExpression(100.0);
double Default::mAlphaQBoundaries(100.0);
unsigned int Default::mLengthSampleSegmentA(3000U);
unsigned int Default::mLengthSampleSegmentB(7000U);
  //double mAlphaPriorExpression;
unsigned int Default::mMcmcLength(1000000U);
unsigned int Default::mMcmcBurnin(500000U);
unsigned int Default::mMcmcThin(10000U);
unsigned int Default::mNumberProcess(1U);
unsigned int Default::mNumberChain(1U);
unsigned int Default::mNumberSwap(100U);
unsigned int Default::mNumberSwapTry(10U);
unsigned int Default::mSwapDistance(1U);
double Default::mHAlpha(0.99);
double Default::mHBeta(0.77);
string Default::mPrefix("tux.out");
string Default::mOutDirectory("./");
string Default::mChainDirectory("./");
string Default::mLogDirectory("./");
string Default::mDatafile("in.dat");
bool Default::mIsData(true);
bool Default::mSitewiseExpression(true);
bool Default::mSitewiseBoundaries(true);
bool Default::mListlikelihood(true);
unsigned int Default::mPosition(0);
}
@

\subsection{Progress}
<<tuxProgress.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROGRESS_H_
#define _TUXPROGRESS_H_
#include <ctime>
#include <string>
using namespace std;
namespace tux {
class Progress {
private:
  string mName; 
  unsigned int mTotal;
  time_t mPrevTime;
public:
  Progress () {}
  Progress (char* n, unsigned int);
  void start (char* n, unsigned int, ostream& out);
  void move (unsigned int, ostream& out);
  void complete (ostream& out);
};
}
#endif // _TUXPROGRESS_H_

<<tuxProgress.cpp>>=
<<tux gnu copyright>>
#include <iomanip>
#include <iostream>
#include <ctime>
#include <string>
#include "tuxProgress.h"
using namespace std;
namespace tux {
Progress::Progress (char* n, unsigned int t)
  : mName(n), mTotal(t)
{
}
void
Progress::start (char* n, unsigned int l, ostream& out)
{
  mName = n;
  mTotal = l;
  out << mName << ": 0% ("
      << "0/" << mTotal << ")\r" << flush;
  return;
}
void
Progress::move (unsigned int s, ostream& out)
{
  double p = static_cast<double>(s) / static_cast<double>(mTotal) * 100.0;
  out << mName << ": " << setprecision(1) << fixed << p << "% ("
      << s << "/" << mTotal << ")\r" << flush;
  return;
}
void
Progress::complete (ostream& out)
{
  out << mName << ": 100% ("
      << mTotal << "/" << mTotal << "), done\n";
  return;
}

}
@

\subsection{Xyz}
<<tuxXyz.h>>=
<<tux gnu copyright>>
#ifndef _TUXXYZ_H_
#define _TUXXYZ_H_
namespace tux {
class Xyz {
public:
  void full ();
};
}
#endif // _TUXXYZ_H_

<<tuxXyz.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxXyz.h"
using namespace std;
namespace tux {
void 
Xyz::full ()
{
  return;
}
}
@

\subsection{GNU Readline Library}
<<xmalloc decl>>=
#include <cstdlib>
void * xmalloc (size_t size);
<<xmalloc defn>>=
void *
xmalloc (size_t size)
{
   register void *value = (void*)malloc(size);
   if (value == 0)
      fprintf(stderr, "virtual memory exhausted");
   return value;
}
<<config.h.in>>=
#ifndef _CONFIG_H_
#define _CONFIG_H_

#undef __BEGIN_DECLS
#undef __END_DECLS
#ifdef __cplusplus
# define __BEGIN_DECLS extern "C" {
# define __END_DECLS }
#else
# define __BEGIN_DECLS /* empty */
# define __END_DECLS /* empty */
#endif

#define tux_VERSION_MAJOR @tux_VERSION_MAJOR@
#define tux_VERSION_MINOR @tux_VERSION_MINOR@

#cmakedefine USE_MYMATH

#cmakedefine HAVE_LOG
#cmakedefine HAVE_EXP

#cmakedefine HAVE_MALLOC_H 1
#cmakedefine HAVE_SYS_FILE_H
#cmakedefine HAVE_UNISTD_H
#cmakedefine HAVE_STRING_H
#cmakedefine HAVE_STDLIB_H

#endif /* _CONFIG_H_ */

<<fileman.cpp>>=
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif 

// #include "rlstdc.h"

#include <sys/types.h>
#ifdef HAVE_SYS_FILE_H
#  include <sys/file.h>
#endif
#include <sys/stat.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include <fcntl.h>
#include <stdio.h>
#include <errno.h>

#if defined (HAVE_STRING_H)
#  include <string.h>
#else /* !HAVE_STRING_H */
#  include <strings.h>
#endif /* !HAVE_STRING_H */

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#endif

#include <time.h>

// #include "xmalloc.h"

#include <readline/readline.h>
#include <readline/history.h>

<<xmalloc decl>>
<<xmalloc defn>>

// extern char *xmalloc PARAMS((size_t));

/* The names of functions that actually do the manipulation. */
int com_list PARAMS((char *));
int com_view PARAMS((char *));
int com_rename PARAMS((char *));
int com_stat PARAMS((char *));
int com_pwd PARAMS((char *));
int com_delete PARAMS((char *));
int com_help PARAMS((char *));
int com_cd PARAMS((char *));
int com_quit PARAMS((char *));

/* A structure which contains information on the commands this program
   can understand. */

typedef struct {
  char *name;/* User printable name of the function. */
  rl_icpfunc_t *func;/* Function to call to do the job. */
  char *doc;/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "cd", com_cd, "Change to directory DIR" },
  { "delete", com_delete, "Delete FILE" },
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "list", com_list, "List files in DIR" },
  { "ls", com_list, "Synonym for `list'" },
  { "pwd", com_pwd, "Print the current working directory" },
  { "quit", com_quit, "Quit using Fileman" },
  { "rename", com_rename, "Rename FILE to NEWNAME" },
  { "stat", com_stat, "Print out statistics on FILE" },
  { "view", com_view, "View the contents of FILE" },
  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite (char *string);
COMMAND* find_command (char *name);
void too_dangerous (char *caller);
void initialize_readline ();
int execute_line (char *line);
int valid_argument (char *caller, char *arg);

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (char *s)
{
  char *r;

  r = (char *) xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

int
main (int argc, char **argv)
{
  char *line, *s;

  progname = argv[0];
  if (argc == 1) { }

  initialize_readline ();/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}

/* Execute a command line. */
int
execute_line (char *line)
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (char *name)
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (char *string)
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator PARAMS((const char *, int));
char **fileman_completion PARAMS((const char *, int, int));

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
void
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END bound the
   region of rl_line_buffer that contains the word to complete.  TEXT is
   the word to complete.  We can use the entire contents of rl_line_buffer
   in case we want to do some simple parsing.  Return the array of matches,
   or NULL if there aren't any. */
char **
fileman_completion (const char *text, int start, int end)
{
  char **matches;

  if (end == 0) {}

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);

  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (const char *text, int state)
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  name = commands[list_index].name;
  while (name) 
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
      name = commands[list_index].name;
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                       FileMan Commands                           */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* List the file(s) named in arg. */
int
com_list (char *arg)
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}

int 
com_view (char *arg)
{
  if (!valid_argument ("view", arg))
    return 1;

#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "less %s", arg);
#else
  sprintf (syscom, "more %s", arg);
#endif
  return (system (syscom));
}

int
com_rename (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "rename %s", arg);
#else
  sprintf (syscom, "rename %s", arg);
#endif
  too_dangerous (syscom);
  return (1);
}

int
com_stat (char *arg)
{
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %d byte%s in length.\n",
  arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          (int) finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}

int
com_delete (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "delete %s", arg);
#else
  sprintf (syscom, "delete %s", arg);
#endif
  too_dangerous (syscom);
  return (1);
}

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
int
com_help (char *arg)
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

/* Change to the directory ARG. */
int
com_cd (char *arg)
{
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}

/* Print out the current working directory. */
int
com_pwd (char *ignore)
{
  char dir[1024], *s;

  s = getcwd (dir, sizeof(dir) - 1);
  if (s == 0)
    {
      printf ("Error getting pwd: %s %s\n", dir, ignore);
      return 1;
    }

  printf ("Current directory is %s %s\n", dir, ignore);
  return 0;
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
int
com_quit (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "quit %s", arg);
#else
  sprintf (syscom, "quit %s", arg);
#endif
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
void
too_dangerous (char *caller)
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (char *caller, char *arg)
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}
@

\subsection{Logarithm of sum}
We use a head file log-double.H of BAli-Phy.
<<benLogDouble.h>>=
// The following is a header file of BAli-Phy authored by Ben.

/*
   Copyright (C) 2004-2005 Benjamin Redelings

This file is part of BAli-Phy.

BAli-Phy is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

BAli-Phy is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with BAli-Phy; see the file COPYING.  If not see
<http://www.gnu.org/licenses/>.  */

#ifndef LOG_DOUBLE_H
#define LOG_DOUBLE_H

#include <cassert>
#include "logsum.H"

/// A class for handling positive real number in terms of their natural log.
class log_double_t {
  /// Natural log of the number.
  double value;
public:

  /// Access the log of the number.
  double  log() const {return value;}
  /// Access the log of the number.
  double& log()       {return value;}

  log_double_t& operator +=(const log_double_t& y) {loginc(value,y.log()); return *this;}
  log_double_t& operator -=(const log_double_t& y) {value = logdiff(log(),y.log()); return *this;}
  log_double_t& operator *=(const log_double_t& y) {value += y.log(); return *this;}
  log_double_t& operator /=(const log_double_t& y) {value -= y.log(); return *this;}

  operator double() const {return exp(value);}

  log_double_t& operator=(double y) {
    assert(y >= 0);
    if (y == 0)
      value = log_0;
    else if (y == 1)
      value = 0;
    else
      value = ::log(y);
    return *this;
  }


  log_double_t():value(log_0) {}

  log_double_t(double x) {
    operator=(x);
  }
};

inline double log(log_double_t x) {
  return x.log();
}

#define decl_double(rtype,op)  \
inline rtype operator op (double x,log_double_t y) { \
  return log_double_t(x) op y; \
} \
\
inline rtype operator op (log_double_t x,double y) {\
  return x op log_double_t(y);\
}

inline log_double_t operator+(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z += y;
  return z;
}

inline log_double_t operator-(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z -= y;
  return z;
}

inline log_double_t operator*(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z *= y;
  return z;
}

inline log_double_t operator/(log_double_t x,log_double_t y) {
  log_double_t z=x;
  z /= y;
  return z;
}

decl_double(log_double_t,+)
decl_double(log_double_t,-)
decl_double(log_double_t,*)
decl_double(log_double_t,/)

inline bool operator< (log_double_t x,log_double_t y) {
  return log(x)<log(y);
}

decl_double(bool,<)

inline bool operator<=(log_double_t x,log_double_t y) {
  return log(x)<=log(y);
}

decl_double(bool,<=)

inline bool operator> (log_double_t x,log_double_t y) {
  return log(x)>log(y);
}

inline bool operator>(log_double_t x,double y) {
  if (y==0)
    return log(x) > log_limit;
  else
    return x > log_double_t(y);
}

inline bool operator>(double  x,log_double_t y) {
  return log_double_t(x) > y;
}

inline bool operator>=(log_double_t x,log_double_t y) {
  return log(x)>=log(y);
}

decl_double(bool,>=)


inline bool operator==(log_double_t x,log_double_t y) {
  return log(x)==log(y);
}

inline bool operator==(log_double_t x,double y) {
  if (y==0.0)
    return log(x) <= log_limit;
  else if (y==1)
    return log(x) == 0.0;
  else
    return double(x) == y;
}

/*
inline bool operator==(log_double_t x,double y) {
  if (y==0)
    return (x==log_0);
  else if (y==1)
    return (x==0);
  else
    return (x==log(y));
}
*/

inline bool operator!=(log_double_t x,log_double_t y) {
  return log(x)!=log(y);
}

inline bool operator!=(log_double_t x,double y) {
  if (y==0.0)
    return log(x) > log_limit;
  else if (y==1)
    return log(x) != 0.0;
  else
    return double(x) != y;
}

#undef decl_double

inline log_double_t pow(log_double_t x,double p) 
{
  x.log() *= p;
  return x;
}

inline bool different(log_double_t x,log_double_t y,double tol=1.0e-9)
{
  double diff = log(x) - log(y);

  if (std::abs(diff)<tol) return false;

  if (x == y) return false;

  return true;
}

template<class T> T exp(double);

template<> inline log_double_t exp<log_double_t>(double x) {
  log_double_t y;
  y.log() = x;
  return y;
}

// Don't do pow<log_double_t>(x,y): do pow(log_double_t(x),y), instead.
//
// template<class T> T pow(double,double);
// 
// template<> inline log_double_t pow<log_double_t>(double x,double p) {
//   log_double_t y;
//   y.log() = p * ::log(x);
//   return y;
// }

#endif
@

\section{Tests}

\subsection{Generation of data}
Data generation requires procedures. The \Cclass{RandomVariable} and its two
other subclasses of \Cclass{Parameter} and \Cclass{Data} are abstract. The
\Cclass{TxBoundaries}, \Cclass{TxExpression}, and \Cclass{Reads} are concrete.  

\subsection{Test of Main}
<<tux-v1.cpp>>=
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include "config.h"

#ifdef USE_MYMATH
#include "MathFunctions.h"
#endif

int main (int argc, char *argv[])
{
  if (argc < 2)
    {
      fprintf(stdout,"%s Version %d.%d\n",
      argv[0],
      tux_VERSION_MAJOR,
      tux_VERSION_MINOR);
      fprintf(stdout,"Usage: %s number\n",argv[0]);
      return 1;
    }

  double inputValue = atof(argv[1]);

#ifdef USE_MYMATH
  double outputValue = mysqrt(inputValue);
#else
  double outputValue = sqrt(inputValue);
#endif

  fprintf(stdout,"The square root of %g is %g\n",
          inputValue, outputValue);
  return 0;
}
@

<<MathFunctions/mysqrt.cpp>>=
#include <cstdio>
#include "MathFunctions.h"
#include "TutorialConfig.h"

// include the generated table
#include "Table.h"

#include <math.h>

// a hack square root calculation using simple operations
double mysqrt(double x)
{
  if (x <= 0)
    {
    return 0;
    }
  
  double result;

  // if we have both log and exp then use them
  double delta;  

  // use the table to help find an initial value
  result = x;
  if (x >= 1 && x < 10)
    {
    result = sqrtTable[static_cast<int>(x)];
    }

  // do ten iterations
  int i;
  for (i = 0; i < 10; ++i)
    {
    if (result <= 0)
      {
      result = 0.1;
      }
    delta = x - (result*result);
    result = result + 0.5*delta/result;
    fprintf(stdout,"Computing sqrt of %g to be %g\n",x,result);
    }

  return result;
}
@

<<MathFunctions/MakeTable.cpp>>=
// A simple program that builds a sqrt table 
#include <stdio.h>
#include <math.h>

int main (int argc, char *argv[])
{
  int i;
  double result;

  // make sure we have enough arguments
  if (argc < 2)
    {
    return 1;
    }
  
  // open the output file
  FILE *fout = fopen(argv[1],"w");
  if (!fout)
    {
    return 1;
    }
  
  // create a source file with a table of square roots
  fprintf(fout,"double sqrtTable[] = {\n");
  for (i = 0; i < 10; ++i)
    {
    result = sqrt(static_cast<double>(i));
    fprintf(fout,"%g,\n",result);
    }

  // close the table with a zero
  fprintf(fout,"0};\n");
  fclose(fout);
  return 0;
}
@

\subsection{GSL}
<<tux-gsl.cpp>>=
#include <cassert>
#include <fstream>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
<<extern tuxGslRng>>
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  fGslRngSeed (100);
  unsigned long int s = gsl_rng_uniform_int(gGslRng,100);

  std::fstream f;
  f.open (argv[1], std::fstream::out);
  f << s << std::endl;

  // Test of Dirichlet and vectors
  std::vector<double> a(3,1.L);
  std::vector<double> b;
  b.resize(3);
  gsl_ran_dirichlet(gGslRng,3,&a[0],&b[0]);
  for (std::vector<double>::iterator i = b.begin(); i != b.end(); i++) {
    f << *i << "\t";
  }
  f << std::endl;

  vector<unsigned int> ui1Count(15,0);
  for (unsigned int i = 0; i < 100000; i++)
    {
      // unsigned int ui1 = fGslRanMirror (5, 9, 7);
      // unsigned int ui1 = fGslRanMirror (1, 13, 7);
      unsigned int ui1 = fGslRanMirror (6, 8, 7);
      ui1Count.at(ui1-1)++;
      // assert (1 <= ui1 && ui1 <= 15);
    }
  for (unsigned int i = 0; i < ui1Count.size(); i++)
    {
      f << ui1Count.at(i) << " ";
    }
  f << std::endl;

  f.close();
  fGslRngFree ();
  return 0;
}
@


\subsection{STL}
<<stl-transform.cpp>>=
#include <iomanip>
#include <iostream>
#include <string>
#include <algorithm>  // transform, copy
#include <vector>
#include <functional> // bind2nd, unary_function
#include <numeric>    // accumulate
#include <iterator>   // ostream_iterator
#include <cmath>
using namespace std;
struct myclass {
  void operator() (double i) {cout << " " << i;}
} myobject;

struct unaryLog : public unary_function<double,double> {
  double operator() (double number) {return log(number);}
};

int
main ()
{
  static const double a[] = {1,2,3};
  static const double b[] = {1,2,3};
  vector<double> v (a, a + sizeof(a) / sizeof(a[0]) );
  vector<double> vb (b, b + sizeof(b) / sizeof(a[0]) );
  // Sum of a.
  double s = accumulate(v.begin(),v.end(),0);
  // Divide a by the sum.
  transform(v.begin(),v.end(),v.begin(),bind2nd(divides<double>(),s));
  // Print the a/sum.
  for_each(v.begin(),v.end(),myobject);
  cout << endl;

  // Log of a.
  unaryLog unaryLogObject;
  transform(v.begin(),v.end(),v.begin(),unaryLogObject);
  for_each(v.begin(),v.end(),myobject);
  cout << endl;

  // vector A minus vector B = vector C.
  vector<double> vc(v.size());
  transform(v.begin(),v.end(),vb.begin(),vc.begin(),minus<double>());
  for_each(vc.begin(),vc.end(),myobject);
  cout << endl;

  // unsigned int / double
  cout << std::scientific;
  cout << std::setprecision(std::numeric_limits<double>::digits);
  unsigned int ui = 25;
  static const unsigned int scui[] = {1,2,3,4,5};
  vector<unsigned int> scuiA (scui, scui + sizeof(scui) / sizeof(scui[0]) );
  vector<double> scuiB (scuiA.size());
  transform(scuiA.begin(), scuiA.end(), scuiB.begin(), 
            bind2nd(divides<double>(),static_cast<double>(ui)));
  for_each(scuiB.begin(),scuiB.end(),myobject);
  cout << endl;

  double d = 10.0;
  static const double scd[] = {1.0, 2.0, 3.0, 4.0, 5.0};
  cout << scd[0] << endl;
  cout << scd[4] << endl;
  cout << d << endl;
  double dv = scd[0]/d;
  cout << "1/10 = " << dv << endl;
  vector<unsigned int> scdA (scd, scd + sizeof(scd) / sizeof(scd[0]) );
  vector<double> scdB (scdA.size());
  transform(scdA.begin(), scdA.end(), scdB.begin(), 
            bind2nd(divides<double>(),static_cast<double>(d)));
  for_each(scdB.begin(),scdB.end(),myobject);
  cout << endl;

  return 0;
}
@

\subsection{Test-Fixed and YAML}

<<simpleopt>>=
enum { OPT_HELP, OPT_FLAG, OPT_ARG };
CSimpleOpt::SOption g_rgOptions[] = {
  { OPT_FLAG, "-a",     SO_NONE    }, // "-a"
  { OPT_FLAG, "-b",     SO_NONE    }, // "-b"
  { OPT_ARG,  "-f",     SO_REQ_SEP }, // "-f ARG"
  { OPT_HELP, "-?",     SO_NONE    }, // "-?"
  { OPT_HELP, "--help", SO_NONE    }, // "--help"
  SO_END_OF_OPTIONS                       // END
};
void ShowUsage() {
  std::cout << "Usage: tux [-?] [--help] tux.yaml tux.out tux.log\n";
}
<<tux-fixed.cpp>>=
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxFixed.h"
#include "tuxReads.h"
using namespace tux;
<<extern tuxGslRng>>
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    std::cout << "Error while reading two files" << std::endl;
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);

  std::fstream f;
  f.open(glob.File(1), std::fstream::out);
  f << std::scientific;// << std::fixed;
  f << std::setprecision(std::numeric_limits<double>::digits);
  //f << std::setprecision(std::numeric_limits<int>::max());

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  vector<unsigned int> a;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
  }
  // The data consists of just numbers and spaces.
  unsigned int nC = 0;
  while (!fin.eof()) 
    {
      unsigned int i;
      char c = fin.peek();
      while (c == ' ')
        {
          c = fin.peek();
          if (c == ' ')
            c = fin.get();
          else
            break;
        }
      input.clear();
      if (isdigit(c))
        {
          c = fin.get();
          while (isdigit(c))
            {
              input += c;
              c = fin.get();
            }
          a.push_back(static_cast<unsigned int>
                      (strtoul(input.c_str(),NULL,0)));
          nC++;
          while (c == ' ')
            {
              c = fin.peek();
              if (c == ' ')
                {
                  c = fin.get();
                }
              else
                {
                  if (c == '\n')
                    c = fin.get();
                  else
                    c = ' ';
                  break;
                }
            }
          if (c != ' ')
            {
              EZLOGGERSTREAM2(lf) << "A new line in data section." << std::endl;
              r = new Reads(static_cast<unsigned int>(shortRead.size()));
              r->mCount = a;
              shortRead.push_back(r);
              a.clear();
              i = static_cast<unsigned int>(shortRead.size()); 
              EZLOGGERSTREAM2(lf) << "Data " 
                                  << i
                                  << " - nC is " << nC << std::endl;
            }
        }
      else
        {
          if (!fin.eof()) 
            {
              nC++;
              EZLOGGERSTREAM2(lf) << "Fatal: counts must be numbers. "
                                  << "Character " << c << " is found at "
                                  << nC << "th from the start of the data."
                                  << std::endl;
              break;
            }
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator i = shortRead.begin(); 
       i != shortRead.end(); 
       i++)
    {
      f << **i;
      delete *i;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  f.close();

  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{TxBoundaries, TxExpression, and Reads}
<<tux-tx.cpp>>=
#include <cassert>
#include <iomanip>
#include <string>
#include <sstream>
#include <fstream>
#include <iterator>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Create TxBoundaries, TxExpression, and Reads
  //////////////////////////////////////////////////////////////////////////////
  // TxBoundaries
  TxBoundaries txb;
  static const unsigned int s[] = {10,40,80,120,150,500,1500};
  vector<unsigned int> sv(s, s + sizeof(s)/sizeof(s[0]));
  txb.mC = sv;
//  txb.mLengthSampleSegmentA = 30;
//  txb.mLengthSampleSegmentB = 60;
  vector<unsigned int> segmentKappa;
  assert (0); // Implement sampling of segments. We do not use sampleSegment.
//  txb.sampleSegment (segmentKappa);
  stringstream result;
  copy(segmentKappa.begin(), segmentKappa.end(), 
       ostream_iterator<unsigned int>(result, " "));
  cout << result.str().c_str() << endl;
//  txb.seq (2,r.size(),2); 
//  out << txb;

  // Sample two points
//  out << YAML::BeginMap << YAML::Key << "SegmentSubset";
//  out << YAML::Value << YAML::BeginSeq;
//  unsigned int l1,l2;
//  for (unsigned int i = 0; i < 3; i++)
//    {
//      txb.mLengthSampleSegment = 200;
//      txb.sampleSegment (l1,l2);
//      out << l1 << l2;
//    }
//  out << YAML::EndSeq << YAML::EndMap;

  // TxExpression
//  TxExpression txe;
//  txe.seq (txb.size());
//  out << txe;

  // Reads
//  Reads shortReads;
//  shortReads.sample (txb.L());
//  std::cout << shortReads;
////////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;


}
@

\subsection{tux-probtx}

Run the following command.
\begin{Verbatim}[frame=lines,framesep=5mm]
./tux-probtx s1.tux s1.out s1.log
\end{Verbatim}

The \program{tux-probtx} creates boundaries and expression parameters written in
\Cfile{s1.out}. 
<<tux-probtx.cpp>>=
#define EZLOGGER_REPLACE_EXISTING_LOGFILE_
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxFixed.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>

<<tux logfilename>>

int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Set the random Seed.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngSeed (m.mSeed);
  
  //////////////////////////////////////////////////////////////////////////////
  // Generate data.
  //////////////////////////////////////////////////////////////////////////////
  std::ofstream dataof;
  dataof.open(m.mDatafile.c_str());
  if (!dataof) 
    {
      std::cerr << "Unable to open file " << m.mDatafile << std::endl;
      EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                          << m.mDatafile << std::endl;
      fGslRngFree ();
      return 1;
    }
  of << "-" << endl;
  ProbTxBoundaries priorTxBoundaries (m.L(), m.K());
  TxBoundaries* txb = static_cast<TxBoundaries*>(priorTxBoundaries.r());
  of << *txb;
  ProbTxExpression priorTxExpression (m.K(),1.0);
  TxExpression* txe = static_cast<TxExpression*>(priorTxExpression.r());
  of << *txe;

  // Log only
  int iii = 123;
  std::string somedata = "Hello World";
  axter::ezlogger_output_policy::mEzloggerOutputFilename = "another.log";
  EZLOGGERSTREAM << somedata << " " << iii << std::endl;

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  delete txb;
  delete txe;

  //////////////////////////////////////////////////////////////////////////////
  // Close the output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{tux-prob}

<<tux-prob.cpp>>=
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);

  // Add your source codes.
  YAML::Emitter out;
  
  // Read in a YAML file.
  Fixed m;
  Reads r;
  // Read in a file: the same code as tux-fixed.cpp.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; out << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  r.mJ = 0; doc["Reads"] >> r; out << r;
  fin.close();

  ProbTxBoundaries factoryTxBoundaries (r.size(),m.K());
  out << YAML::BeginMap;
  out << YAML::Key << "ProbTxBoundaries";
  out << YAML::Value << factoryTxBoundaries.d (); 
  out << YAML::EndMap;
  TxBoundaries* txb = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  out << *txb; 

  ProbTxExpression factoryTxExpression (m.K());
  TxExpression* txe = static_cast<TxExpression*>(factoryTxExpression.r());
  out << *txe;

  // L: 1000, K:10, M:10000 
  //static const double sf[] = {0.8700484, 1.0158870, 1.1285131};
  //vector<double> sizeFactor(sf, sf + sizeof(sf)/sizeof(sf[0]));
  Likelihood factoryData (&m,txb,txe);
  for (unsigned int i = 0; i < m.mZ.size(); i++)
    {
      factoryData.J(i);
      Reads* shortRead = static_cast<Reads*>(factoryData.r());
      out << *shortRead;
      delete shortRead;
    }

  delete txb;
  delete txe;

  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{Movers}
<<tux-move.cpp>>=
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);
  YAML::Emitter out;

  // Add your source codes.
  // Read in a YAML file.
  Fixed m;
  // Read in a file: the same code as tux-fixed.cpp.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; out << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  const YAML::Node& node = doc["Reads"];
  vector<Reads*> shortRead;
  Reads* r;
  for (unsigned int i = 0; i < node.size(); i++)
    {
      r = new Reads(i);
      doc["Reads"] >> *r;
      shortRead.push_back(r);
    }
  fin.close();
//  for (vector<Reads*>::iterator i = shortRead.begin(); 
//       i != shortRead.end(); 
//       i++)
//    {
//      std::cout << **i;
//    }
  // Initial values;
  r = shortRead.front();
  ProbTxBoundaries factoryTxBoundaries (r->size(),m.K());
  TxBoundaries* txb = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  out << *txb; 
  ProbTxExpression factoryTxExpression (m.K());
  TxExpression* txe = static_cast<TxExpression*>(factoryTxExpression.r());
  out << *txe; 

  // MCMC
  MoverManager mMoverManager;
  MoverTxBoundaries* d1;
  MoverTxExpression* d2;
  // Boundaries Mover
  d1 = new MoverTxBoundaries (&m, shortRead, txb, txe);
  mMoverManager.add (d1, 1, 1);
  // Expression Mover
  d2 = new MoverTxExpression (&m, shortRead, txb, txe);
  mMoverManager.add (d2, 2, 1);

  for (unsigned int i = 0; i < m.mMcmcLength; i++)
    {
      Mover* mover = mMoverManager.choose ();
      mover->step ();
      // Other information for steps.
      out << *txb;
      out << *txe;
    }
  // Movers are deleted by MoverManager.
  // RandomVariables must be removed.
  delete txb;
  delete txe;
  for (vector<Reads*>::iterator i = shortRead.begin(); 
       i != shortRead.end(); 
       i++)
    {
      delete *i;
    }

  // END of TEST
  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{Chains and chain manager}

<<extern tuxlf>>=
namespace tux {
extern std::ofstream lf; // log file
}
<<main tuxlf>>=
namespace tux {
  std::ofstream lf; // log file
}
<<tux-chain.cpp>>=
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Create a chain.
  //////////////////////////////////////////////////////////////////////////////
  Chain mChain (&m, shortRead);
  unsigned int s = 0;
  while (s < m.mMcmcLength) 
    {
      mChain.step (m.mMcmcThin);
      std::cerr << "Step: " << s << "\r";
      s += m.mMcmcThin;
      if (m.mMcmcBurnin < s)
        {
          of << mChain;
        }
    }
  mChain.report (of);

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

<<tux-cm.cpp>>=
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Create a chain manager.
  //////////////////////////////////////////////////////////////////////////////
  ChainManager mChainManager (&m, shortRead, 0);
//  mChainManager.createChain (m.mNumberChain);
  mChainManager.setChainid (0,m.mNumberChain-1);
  unsigned int s = 0;
  while (s < m.mMcmcLength) 
    {
      mChainManager.step (m.mMcmcThin);
      std::cerr << "Step: " << s << "\r";
      s += m.mMcmcThin;
      if (m.mMcmcBurnin < s)
        {
          of << mChainManager;
        }
    }
  mChainManager.report (of);

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{MCMC and MPI}
<<tux-mcmc.cpp>>=
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <mpi.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
#include "tuxMcmcMpi.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
<<main gslrngrandomnumber>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // MPI Init
  //////////////////////////////////////////////////////////////////////////////
  fGslRngSeed (m.mSeed);
  vector<unsigned long int> mProcessSeed;
  mProcessSeed.resize(m.mNumberProcess); 
  generate (mProcessSeed.begin(),mProcessSeed.end(),gslrngRandomNumber);

  int size,rank;
  int length;
  char name[80];

  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD,&rank);
  MPI_Comm_size(MPI_COMM_WORLD,&size);
  MPI_Get_processor_name(name,&length);

  // Now we are in one of the processes.
  // Reset the gGslRng.
  fGslRngSeed (mProcessSeed.at(rank));
  
  //////////////////////////////////////////////////////////////////////////////
  // Create an MCMC.
  //////////////////////////////////////////////////////////////////////////////
  assert (m.mNumberSwap < m.mMcmcThin);
  McmcMpi mMcmc (&m, shortRead, rank);
  unsigned int s = 0;
  unsigned int sThin = 0;
  while (s < m.mMcmcLength) 
    {
      std::cerr << "Step: " << s << "\r";
      mMcmc.step (m.mNumberSwap);
      s += m.mNumberSwap; sThin += m.mNumberSwap;
      mMcmc.swap ();
      if (m.mMcmcBurnin < s)
        {
          if (m.mMcmcThin < sThin)
            {
              sThin -= m.mMcmcThin;
              of << mMcmc;
            }
        }
    }
  mMcmc.report (of);

  //////////////////////////////////////////////////////////////////////////////
  // MPI Final
  //////////////////////////////////////////////////////////////////////////////
  MPI_Finalize(); 

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}

<<tux-single.cpp>>=
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
#include "tuxMcmcSingle.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
<<main gslrngrandomnumber>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Set the random Seed.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngSeed (m.mSeed);
  
  //////////////////////////////////////////////////////////////////////////////
  // Create an MCMC.
  //////////////////////////////////////////////////////////////////////////////
  assert (m.mNumberSwap < m.mMcmcThin);
  McmcSingle mMcmc (&m, shortRead);
  unsigned int s = 0;
  unsigned int sThin = 0;
  while (s < m.mMcmcLength) 
    {
      std::cerr << "Step: " << s << "\r";
      mMcmc.step (m.mNumberSwap);
      s += m.mNumberSwap; sThin += m.mNumberSwap;
      mMcmc.swap ();
      if (m.mMcmcBurnin < s)
        {
          if (m.mMcmcThin < sThin)
            {
              sThin -= m.mMcmcThin;
              of << mMcmc;
            }
        }
    }
  mMcmc.report (of);

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{Summary}
<<tux-sum.cpp>>=
#include <limits>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "ezlogger_headers.hpp"
#include "yaml-cpp/yaml.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxSummarizer.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Create a summarizer.
  //////////////////////////////////////////////////////////////////////////////
  vector<vector<unsigned int> > txbs;
  vector<unsigned int> txb;

  cout << std::scientific;// << std::fixed;
  cout << std::setprecision(std::numeric_limits<double>::digits);
  fin.open("tux.sum");
  YAML::Parser parser2(fin);
  YAML::Node doc2;
  parser2.GetNextDocument(doc2);
  for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
    {
      // Two integers
      for (YAML::Iterator jt=(*it)[0].begin();jt!=(*it)[0].end();++jt) 
        {
          // unsigned int a; *jt >> a; cout << a << " ";
        }
      // Two doubles
      for (YAML::Iterator jt=(*it)[1].begin();jt!=(*it)[1].end();++jt) 
        {
          // string a; *jt >> a; double b = strtod(a.c_str(),NULL);
          // cout << b << " ";
        }
      // Many integers
      txb.clear();
      for (YAML::Iterator jt=(*it)[2].begin();jt!=(*it)[2].end();++jt) 
        {
          unsigned int a; *jt >> a; 
          // cout << a << " ";
          txb.push_back(a);
        }
      txbs.push_back(txb);
      // Many doubles
      for (YAML::Iterator jt=(*it)[3].begin();jt!=(*it)[3].end();++jt) 
        {
          string a; *jt >> a; double b = strtod(a.c_str(),NULL);
          // cout << b << " ";
        }
    }
  fin.close();

  // A random sample of TxB.
  txb = fGslRanTxBoundaries (shortRead.front()->size(),m.mK);
  // Compute this txb and each of txbs.
  for (unsigned int i = 0; i < txbs.size(); i++)
    {
      unsigned int d = fGslDistance (txb, txbs.at(i));
      cout << d << endl;
    }

  ////////////////////////////////////////////////////////////////////////////// 
  // Find a mean boundaries and count boundaries.
  ////////////////////////////////////////////////////////////////////////////// 
  // We can start with a random boundaries or one of the boundaries.
  // How can we step between two sets of boundaries? Randomly choose a finite
  // number of boundary sites, and increase or decrease the number by
  // considering its neighboring boundary sites. We need to choose how many
  // sites we move, and how many sites to increase or decrease. We use a uniform
  // distribution for the choice.
  //
  // Another summary is simpler. We count the number of posterior samples where
  // a site is a boundary site for each site. I am not clear about boundaries.
  // What is a boundary?
  vector<unsigned int> summaryTxB(shortRead.front()->size(),0U);
  for (unsigned int i = 0; i < txbs.size(); i++)
    {
      for (unsigned int j = 0; j < txbs[i].size(); j++)
        {
          unsigned int ck = txbs[i][j];
          summaryTxB.at(ck-1)++;
        }
    }
  vector<double> fractionTxB(shortRead.front()->size(),.0);
  for (unsigned int i = 0; i < summaryTxB.size(); i++)
    {
      fractionTxB.at(i) = static_cast<double>(summaryTxB.at(i)) 
                          / static_cast<double>(summaryTxB.size());
    }
  // Now, print fractionTxB.
  ////////////////////////////////////////////////////////////////////////////// 
  // Find a mean set of boundaries.
  ////////////////////////////////////////////////////////////////////////////// 
  Summarizer mSummarizer (&m,shortRead);
  mSummarizer.mTxbs = txbs;
  mSummarizer.params.n_tries = 0;            // Not used.
  mSummarizer.params.iters_fixed_T = m.mK;
  mSummarizer.params.step_size = 10.0;
  mSummarizer.params.k = 1.0;
  mSummarizer.params.t_initial = 1e10;
  mSummarizer.params.mu_t = 1.00001;
  mSummarizer.params.t_min = 1e-1;

  // Execute the summarizer and print it out.
  mSummarizer.execute ();
  of << mSummarizer;

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{tux-likelihood}
First, create a file called \Cfile{s1.tux} with the following content.
\begin{Verbatim}[frame=lines,framesep=5mm]
Fixed:
  mSeed: 12345
  mL: 10000
  mK: 10
  mM: 100000
  mZ:
    - 0.8699429
    - 1.0158870
    - 1.1287902
  mA0: 0.027
  mA1: 6.131
  mAlphaQExpression: 10
  mAlphaQBoundaries: 10
  mLengthSampleSegmentA: 4000
  mLengthSampleSegmentB: 6000
  mAlphaPriorExpression: 1
  mMcmcLength: 30
  mMcmcBurnin: 15
  mMcmcThin: 5
  mNumberProcess: 1
  mNumberChain: 3
  mNumberSwap: 2
  mNumberSwapTry: 2
  mSwapDistance: 7
  mHAlpha: 0.98
  mHBeta: 0.7
  mPrefix: s1.out
  mOutDirectory: ./
  mChainDirectory: ./
  mLogDirectory: ./
  mDatafile: s1.in
  mIsData: true
\end{Verbatim}

Run the following command.
\begin{Verbatim}[frame=lines,framesep=5mm]
./tux-probtx s1.tux s1.txb s1.log
./tux-likelihood s1.tux s1.out s1.log s1.txb
\end{Verbatim}

The \program{tux-probtx} creates two parameters in \Cfile{s1.txb}.
The \program{tux-likelihood} creates data in a data \Cfile{s1.in}.
<<tux-likelihood.cpp>>=
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
#include "tuxMcmcSingle.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
<<main gslrngrandomnumber>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 4) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Set the random Seed.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngSeed (m.mSeed);
  
  //////////////////////////////////////////////////////////////////////////////
  // Generate data.
  //////////////////////////////////////////////////////////////////////////////
  std::ofstream dataof;
  dataof.open(m.mDatafile.c_str());
  if (!dataof) 
    {
      std::cerr << "Unable to open file " << m.mDatafile << std::endl;
      EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                          << m.mDatafile << std::endl;
      fGslRngFree ();
      return 1;
    }

//  ProbTxBoundaries priorTxBoundaries (m.L(), m.K());
//  TxBoundaries* txb = static_cast<TxBoundaries*>(priorTxBoundaries.r());
//  of << *txb;
//  ProbTxExpression priorTxExpression (m.K(),1.L);
//  TxExpression* txe = static_cast<TxExpression*>(priorTxExpression.r());
//  of << *txe;

  vector<unsigned int> txb;
  vector<double> txe;
  fin.open(glob.File(3));
  YAML::Parser parser2(fin);
  YAML::Node doc2;
  parser2.GetNextDocument(doc2);
  assert (doc2.size() == 1);
  for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
    {
      txb.clear();
      txe.clear();
      for (YAML::Iterator jt=(*it)[0].begin();jt!=(*it)[0].end();++jt) 
        {
          unsigned int a; *jt >> a; 
          txb.push_back(a);
        }
      // Many doubles
      for (YAML::Iterator jt=(*it)[1].begin();jt!=(*it)[1].end();++jt) 
        {
          string a; *jt >> a; double b = strtod(a.c_str(),NULL);
          txe.push_back(b);
        }
    }
  fin.close();
  TxBoundaries mTxB(txb);
  TxExpression mTxE(txe);

  Likelihood dataLikelihood (&m, &mTxB, &mTxE);
  vector<Reads*> shortRead;
  Reads* r;
  for (unsigned int j = 0; j < m.mZ.size(); j++)
    {
      r = static_cast<Reads*>(dataLikelihood.r());
      shortRead.push_back(r);
      dataof << *r << endl;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@


\subsection{Log}

Edit ezlogger\_format\_policy.hpp to change the log output.

Define the following definition to change the log file.
\begin{Verbatim}[frame=lines,framesep=5mm]
Check ezlogger_output_policy.hpp
#define EZLOGGER_OUTPUT_FILENAME "tux-log.out"
\end{Verbatim}

<<tux logfilename>>=
std::string axter::ezlogger_output_policy::mEzloggerOutputFilename = "log.txt";
<<tux-log.cpp>>=
#include <iomanip>
#include <fstream>
#include <cassert>
#include <vector>
#include "config.h"
#define EZLOGGER_OUTPUT_FILENAME "tux-log.out"
#include "ezlogger_headers.hpp"
void FunctFoo()
{
EZLOGGERFUNCTRACKER;
EZLOGGERDISPLAY_STACK;
//Function Foo code here....
}
int 
main (int argc, char *argv[])
{
  EZLOGGERFUNCTRACKER;
  EZLOGGERDISPLAY_STACK;
  EZLOGGER_PRG_MAIN_ARG(argc, argv);
  int i = 123;
  std::string somedata = "Hello World";
  std::string somedataOften = "Often, Hello World";
  std::ofstream f("tux-log.out2");
  bool b = true;
  static const unsigned int a[] = {16,2,77,29,5,2,3,3,2,3};
  std::vector<unsigned int> v(a,a+sizeof(a)/sizeof(a[0]));

  // log_always = 1, log_often, log_regularly, log_rarely, log_very_rarely
  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);

  EZLOGGER << "Start of ezlogger" << std::endl;
  EZLOGGER("ezlogger", 1, 0.77898);
  EZLOGGERVAR(b);
  //EZLOGGERVAR(v);
  EZLOGGERMARKER;
  FunctFoo();

  //Simple usage with standard verbosity level
  EZLOGGERSTREAM << somedata << " " << i << std::endl;

  //Can use alternate stream
  EZLOGGERSTREAM2(std::cerr) << somedata << " next line " << i << std::endl;
  EZLOGGERSTREAM2(f) << somedata << " next line " << i << std::endl;
  EZLOGGERVARIFY(b == false);
  //assert(b == false);

  //Verbosity level logging example
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);
  EZLOGGERSTREAM << somedata << " " << i << std::endl;
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_regularly);
  EZLOGGERSTREAM << somedata << " " << i << std::endl;
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_often);
  EZLOGGERSTREAM << somedata << " " << i << std::endl;
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_always);
  EZLOGGERSTREAM << somedata << " " << i << std::endl;
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  f.close();
  return 0;
}
@

\subsection{MPI}

\begin{Verbatim}[frame=lines,framesep=5mm]
bash plotTemperature.sh s1.out.mc3; open 1.pdf
\end{Verbatim}

<<runtux>>=
#!/bin/bash
nsub tuxbatch.sh
<<tuxbatch.sh>>=
#!/bin/sh
#PBS -A acs4_0001
#PBS -l walltime=15:00,nodes=2
#PBS -N tux
#PBS -j oe
#PBS -q v4
#PBS -m e
##PBS -M goshng@gmail.com

# Change to the working directory.
cd $PBS_O_WORKDIR
# Count the number of processes.
CPUPERNODE=`grep processor /proc/cpuinfo|wc -l`
NODECNT=$(wc -l < $PBS_NODEFILE)
PROCESSCNT=$((CPUPERNODE * NODECNT))
# Boot mpi on the nodes
PATH=/usr/bin:/bin:/opt/intel/impi/3.1/bin64/ mpdboot -n $NODECNT --verbose -r /usr/bin/ssh -f $PBS_NODEFILE
# Now execute PROCESSCNT process on the nodes.
mpiexec -ppn $CPUPERNODE -np $PROCESSCNT $PBS_O_WORKDIR/tux \
  mcmc -i in.tux
# Exit the MPI.
mpdallexit
<<plotTemperature.sh>>=
#!/bin/bash
echo bash plotTemperature.sh [prefix.mc3]
head -n 1 $1 > 1
Rscript plotTemperature.R
<<plotTemperature.R>>=
x <- scan("1")
pdf("1.pdf")
plot(seq(length(x)),x)
dev.off()
@


\end{document}
