\documentclass[12pt]{article}
\usepackage[T1]{fontenc}                                                        
\usepackage[latin9]{inputenc}                                                   
\usepackage{mdwlist}           % less spaces between items
\usepackage{bm}                % bold math letters
\usepackage{noweb}
\usepackage{fancyvrb}
\usepackage[letterpaper]{geometry}
% \geometry{verbose,tmargin=1in,bmargin=1in}
\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\parskip}{1ex}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=2,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

% Text layout
\oddsidemargin -.5in
\evensidemargin 0in
\topmargin -.5in
\textwidth 7.5in
\textheight 9in

\newcommand{\Ccommand}[1]{command \textbf{#1}}
\newcommand{\Coption}[1]{option \texttt{#1}}
\newcommand{\Cclass}[1]{class \textit{#1}}
\newcommand{\Cmember}[1]{member \texttt{#1}}
\newcommand{\Cmethod}[1]{method \texttt{#1}}
\newcommand{\Cglobal}[1]{\texttt{#1}}
\newcommand{\Cfunction}[1]{function \texttt{#1}}
\newcommand{\Cpackage}[1]{package \textit{#1}}
\newcommand{\program}[1]{program \texttt{#1}}
\newcommand{\library}[1]{\texttt{#1}}
\newcommand{\Cfile}[1]{file \texttt{#1}}

\begin{document}
\raggedright

\title{Inferring transcript boundaries and expression levels using RNA-seq}
\author{Sang Chul Choi\\
Department of Biological Statistics and Computational Biology, \\
Cornell University,\\
Ithaca, NY 14850}

\maketitle

\tableofcontents

\newpage
\section{Introduction}
We have two versions of \program{tux}. The first version uses
\Cclass{McmcSingle}, and the latter \Cclass{McmcMpi}. When the openmpi is not
available, use \Cclass{McmcSingle}.  Read more documentation in the lyx 
\Cfile{Peach/notes/researches/siepel-transcript.lyx}.

\subsection{Tux}
We describe \Cfile{tux.cpp}. The file is one of the two versions of
\program{tux} with compiler definition of \texttt{\_MPI}. It uses several
libraries including \library{readline}, \library{yaml-cpp}, \library{SimpleOpt},
\library{gsl}, and \library{ezlogger}. The companion of \program{tux} could use
\library{openmpi} to implement an MPI (Message Passing Interface). There are
other parallelization schemes available: multiple threads, GPUs using CUDA, etc.
We focus on the MPI implementation first. We borrow the source code of
\Cfile{fileman.c} from \library{readline} to implement shell environment in
\Cfile{tux.cpp}.  We have three main global-scope objects: \Cglobal{gFixed},
\Cglobal{gShortRead}, and \Cglobal{gManager}.  We log the flow of \program{tux}
using \library{ezlogger}. In the \Cfunction{main}, we set the verbosity level
using the following line: 
\begin{Verbatim}[frame=lines,framesep=5mm]
axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);
Use one of log_always, log_often, log_regularly, log_rarely, log_very_rarely.
\end{Verbatim}
In addition to the three main global variables we use \Cglobal{gGslRng}. In the
\Cfunction{main} we use once
\begin{Verbatim}[frame=lines,framesep=5mm]
fGslRngAlloc ();
\end{Verbatim}
at the start, and call the following line before exiting the program.
\begin{Verbatim}[frame=lines,framesep=5mm]
fGslRngFree ();
\end{Verbatim}
We first enter the interactive mode without options. See the batch mode. The
\program{tux} can show a manual page, its version, or execute commands including
\Ccommand{fixed}, \Ccommand{mcmc}, and \Ccommand{summarize}. The main option is
for an input file name: \Coption{-i}, \Coption{--in}, or \Coption{--infile}. The
input file describes the overall setup of the \program{tux}. We use
\library{yaml-cpp} to read in the program setup. If no such file with the input
file name is found, then the \program{tux} exits. The input file contains
\Cmember{mDatafile}. We read in the file and save it as \Cglobal{gShortRead}.
With the two global variables ready we can use \Cglobal{gManager}. 
When we are finished with the batch mode, we delete the memory to each short
read in \Cglobal{gShortRead}. We also call \Cfunction{fGslRngFree} before the
exit. Now, let us see \Cclass{Manager}.

\subsection{Manager}

\begin{lstlisting}
class Manager {
public:
  Fixed* mFixed;
  vector<Reads*> mTxReads;
  vector<unsigned long int> mProcessSeed;
public:
  Manager ();
  Manager (Fixed* m, const vector<Reads*>& shortRead);
  void show();
  void model();
  void mcmc(int r = 0);
  void summarize();
  void save();
  void load();
  void help();
  string logFilename (unsigned int i);
  string chainFilename (unsigned int i);
};
\end{lstlisting}

Members of \Cclass{Manager} are
\begin{itemize*}
\item public: 
\item   Fixed* mFixed; a mere pointer to the program setup
\item   vector<Reads*> mTxReads; mere pointers to short reads
\item   vector<unsigned long int> mProcessSeed; random seeds for separate
processes
\item public:
\item   Manager (); 
\item   Manager (Fixed* m, const vector<Reads*>\& shortRead);
\item   void show(); Not Yet Implemented (NYI) - shows the current status in the
shell
\item   void model(); NYI - shows the current model
\item   void mcmc(int r); executes an MCMC with rank $r$
\item   void summarize(); summarizes the posterior sample
\item   void save(); NYI - saves the state of the
currently running MCMC
\item   void load(); NYI - loads the state of a saved MCMC
\item   void help(); NYI - shows the manual page
\item   string logFilename (unsigned int i); uses mLogDirectory and mPrefix to
create a log file name for the $i$ chain.
\item   string chainFilename (unsigned int i); uses mChainDirectory and mPrefix
to create a log file name for the $i$ chain.
\end{itemize*}

The \Cclass{Manager} is one of the main global objects. This can access
\Cclass{Fixed} and \Cclass{Reads}. In the \Cmethod{mcmc} we use \Cclass{Mcmc} to
run a number of chains. A chain is a cold chain, and the rest of chains are hot
chains when \Cmember{mNumberProcess} is greater than 1.  The \Cclass{Mcmc}
coordinates multiple simultaneous runs of chains.  Each chain needs to know what
temperature to use. The \Cclass{Mcmc} owns the temperature member, and
\Cclass{ChainManager} owns its copy. The \Cclass{ChainManager} specifies the
temperature for the chains that it manages.
The \Cclass{Mcmc} contains \Cmember{mTemperature}
and \Cmember{mChainid} for accessing chains.  The \Cclass {Mcmc} creates a
list of temperature using \Cclass{c\_hlinear}, or \Cclass{c\_hgeometric} setting
values of \Cmember{temperature}. It sets \Cmember{mChainid} as a sequence of
non-negative integers. We need to set up a list of chains before running them.
The \Cclass{Mcmc} creates a list of chains, and executes each chain one at a time
using \Cmethod{step}. We have two classes for chains. One is for a chain that
does the sampling job, and the other is for a chain manager. The \Cclass{Mcmc}'s
\Cmethod{step} commands all of the chains to move a finite number of steps in
their own process. The chain manager will be run in a separate process. We use
Message Passing Interface (MPI), which is an application interface that allows
processes to communicate by sending and receiving messages. In essence, it
facilitates communication when multiple computers/processors/cores are
performing distributed computation.

Let's see how the communication works.  The \Cclass{Mcmc} sends a message of
\Cmethod{step} to \Cclass{ChainManager}, which in turn sends a message of
\Cmethod{step} to a list of \Cclass{Chain}.  A process owns one object of
\Cclass{ChainManager}, which communicates with \Cclass{Mcmc}.  After finishing
all of the messages of \Cmethod{step} in the list of \Cclass{Chain}, the
\Cclass{ChainManager} sends a message to \Cclass{Mcmc} to check whether it can
continue to move steps of the chains. The \Cclass{Mcmc} would swap chains by
receciving necessary values from \Cclass{ChainManager}. 

We wish to control the \program{tux} using signals by allowing \program{tux}
to monitor signals. A signal turns off the currently running MCMC, and makes the
\program{tux} save the states and exit. We use SIGUSR1 or SIGUSR2 to customize
signals for this purpose.  See
http://www.alexonlinux.com/signal-handling-in-linux.  The main process or rank 0
process receives the signal. Depending on the state of the main process we need
different actions. If the main process was moving the parameter state, then the
process needs to finish with it. If the main process was swapping chains, then
the process still needs to finish with it.  Because the main process has to
communicate the saving message with the rest of worker processes, the on-going
moves have to be finished. This would not make the \program{tux} stop instantly.
It would take time for the \program{tux} to stop. We need MPI message passing
for saving the state of the \program{tux} MCMC. When the signal caputre is not
available, we could use a file to let \program{tux} know that it is time to stop
and save the state of MCMC for later use.

The \Cmethod{mcmc} creates an instance of \Cclass{McmcSingle} or
\Cclass{McmcMpi}. We move as many steps as \Cmethod{mNumberSwap}. Then, we swap
chains. After the swap we save the state of each chain if the thinning count is
greater than the user specified number, or \Cmember{mMcmcThin}. 

We discuss output files. Each process has a \Cclass{ChainManager} object.
The process opens an output file and a log file. The output file name consists
of \Cmember{mChainDirectory}, and \Cmember{mPrefix}. The process rank ID or chain
manager ID follows the name with addition extension of ``chain.'' The log file
name is constructed similarly except for the extension of ``log.'' 

FIXME: We still need to code the \Cmethod{summarize} of \Cclass{Manager}.

\subsection{Model}
I do not find a role of \Cclass{Model}, yet. The \Cclass{Fixed} has a similar
role.

\subsection{Mcmc}
Chain swaps are done in \Cclass{Mcmc}.  The \Cclass{Mcmc} might have two things
in it: process management and Markov chains management.  We employ
Metropolis-coupled Markov chain Monte Carlo (MC3).  See
http://probability.ca/jeff/ftpdir/mcmcmc.pdf.

\begin{lstlisting}
class Mcmc {
public:
  unsigned int mRank; 
  Fixed* mFixed;
  vector<Reads*> mTxReads;
  ChainManager mChainManager;
  vector<unsigned int> mChainid;
  vector<double> mTemperature;
  vector<double> mLogLikelihoodPrior;
  vector<unsigned int> mNumberChainPerProcess;
  vector<unsigned int> mAccumulateNumberChain;
  vector<vector<unsigned int> > mSwapCount;
  vector<vector<unsigned int> > mSwapTryCount;
private:
  Mcmc ();
public:
  int swapChains ();
  Mcmc (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank);
  ~Mcmc ();
  int numberChainPerProcess ();
  int createChainManager (unsigned int r);
  int step (unsigned int n);
  virtual int swap () = 0;
  int sample ();
  int save ();
  int load ();
  void report (ostream &out);
  friend ostream& operator< < (ostream &out, const Mcmc &t);
};
\end{lstlisting}

Members of \Cclass{Mcmc}:
\begin{itemize*}
\item public:
\item   unsigned int mRank; the process ID, 0 for \Cclass{McmcSingle}
\item   Fixed* mFixed; a mere pointer to the program setup
\item   vector<Reads*> mTxReads; mere pointers to short reads
\item   ChainManager mChainManager; the chain manager
\item   vector<unsigned int> mChainid; chain IDs of the processes, e.g.,
c(1,4,0,5,3,2) is the chain IDs for the six processes
\item   vector<double> mLogLikelihoodPrior; sums of likelihood and prior of the
processes
\item   vector<double> mTemperature; temperature values of the chain IDs
\item   vector<unsigned int> mNumberChainPerProcess; e.g., c(3,3,2)  
\item   vector<unsigned int> mAccumulateNumberChain; e.g., c(0,3,6,8)
\item   vector<vector<unsigned int> > mSwapCount; number of successful swap
tries between chains
\item   vector<vector<unsigned int> > mSwapTryCount; number of swap tries
between chains
\item public:
\item   int swapChains (); uses values from all of the chains to arrange chain
temperatures - called by \Cmethod{swap}
\item   Mcmc (Fixed* m, const vector<Reads*>\& shortRead, unsigned int rank);
\item   ~Mcmc ();
\item   int numberChainPerProcess (); sets \Cmember{mNumberChainPerProcess} and
\Cmember{mAccumulateNumberChain} using the number of processors and compute
nodes
\item   int createChainManager (unsigned int r); uses \Cmember{mChainManager} to
create alloted chains for the current rank process
\item   int step (unsigned int n);
\item   virtual int swap () = 0; derived classes implement this method
\item   int sample ();
\item   int save ();
\item   int load ();
\item   void report (ostream \&out);
\item   friend ostream\& operator$\ll$ (ostream \&out, const Mcmc \&t);
\end{itemize*}

The \Cclass{c\_msg1} is used to send a message to the rank 0 process:
\begin{itemize*}
\item unsigned int processid; the ordered ID of a process
\item unsigned int chainid; the designated chain ID
\item double likelihoodPrior; the sum of likelihood and prior of a chain
\end{itemize*}

The constructor needs pointers to \Cclass{Fixed} and \Cclass{Reads}. It also
needs rank ID of the process where the \Cclass{Mcmc} object is created. We
compute how many chains are needed for each process. Then, we create chains for
the current process. We also prepare chain IDs, and temperature values. The
acceptance ratio for chain swaps is prepared in \Cmember{mSwapCount} and
\Cmember{SwapTryCount}.  The \Cclass{McmcSingle} and \Cclass{McmcMpi} implements
\Cmethod{swap}.  All of the chains managed by \Cclass{ChainManager} have their
own chain IDs, which are used to index temperature values. We also need the sums
of log likelihood and log prior to swap chains. We use \Cmethod{chainid} and
\Cmethod{likelihoodPrior} to access chain IDs and the sum of log likelihood and
log prior from the chains managed by \Cclass{ChainManager}.  We swap chain IDs
and the sums of log likelihood and log prior.  We know neighboring chains in
temperature values to swap chains nearby.  Let us see \Cmethod{swapChains}.  For
example, we have the following \Cmember{mChainid} and
\Cmember{mLogLikelihoodPrior}. We find chain IDs using \Cmember{mChainid} with
process index or ``Index.'' We also want to know the process index using
``chainIndex'' with chain IDs. We create ``chainIndex'' using
\Cmember{mChainid}, and swap values in ``chainIndex'' not in \Cmember{mChainid}.
After swaps we can recreate \Cmember{mChainid} using ``chainIndex.''
\begin{Verbatim}[frame=lines,framesep=5mm]
Index               0  1  2  3  4  5
mChainid            3  2  0  5  1  4   <- Keep these
mLogLikelihoodPrior v3 v2 v0 v5 v1 v4  <-   and these values.
chainIndex          2  4  1  0  5  3   <- We swap indices.
\end{Verbatim}
In order to swap chains we choose two chains nearby. See
\Cfunction{fGslRanMirror}. We give distance of either side and jump distance,
and get 1-based value from the left-hand side position. 

The \Cmethod{swap} for the rank 0 process waits for the rest of processes to
finish their \Cmethod{step}. Positively ranked processes send the rank 0 process
a message of likelihood and other values. The rank 0 process uses all of the
likelihood values to attempt swapping of chain temperature values. It finishes
the chain swapping by sending the rest of positively ranked processes a message
of the chosen temperature.
The \Cclass{ChainManager} sends the chain ID, and the sum of likelihood and
prior to the rank 0 process for each of the chains that it manages. The rank 0
process fills \Cmember{chainid} and \Cmember{likelihoodPrior} with those
received values. Note that the two vectors index chains managed by
\Cclass{ChainManager}. An element of \Cmember{chainid} is used to reference
a temperature value. Let us read the \Cmethod{swap} in detail.
Whatever the ranks are, \Cclass{ChainManager} calls \Cmethod{chainid} and
\Cmethod{likelihoodPrior} to get chain IDs, and sums of likelihood and prior for
the chains managed by the \Cclass{ChainManager} of the current rank process.
We start with the rank 0 process. We need sums of likelihood and prior from each
chain. We receive a message from each chain. Because \Cclass{ChainManager}
can contains multiple chains, we have two loops: one for the
\Cclass{ChainManager} and another for each chain in the \Cclass{ChainManager}.
A message is stored \Cmember{mMessage}. The \Cmember{processid} of 
\Cmember{mMessage} is the ordered index of a process that runs one chain. Do not
be confused by the name process. For example, if 
\Cmember{mNumberChainPerProcess} is c(3,3,2), the process indices run from 0 to
7. Processes are different in the assigned chain index, which is stored in
\Cmember{chainid} of \Cmember{mMessage}. We use \Cmember{processid} to index 
\Cmember{mChainid} and \Cmember{mLogLikelihoodPrior}. Now that we have chain
IDs, and sums of likelihood and prior. We call \Cmethod{swapChains}, and
rearrange \Cmember{mChainid}. 
We need to configure chains with the rearranged chain IDs. For the rank 0
process we find the chain IDs and save them in a vector of size being equal to
the number of chains in the rank 0 process. We send messages to the rest of
positively ranked processes. Let us turn to a postively ranked process. Note
that we have already stored chain IDs and sums of likelihood and prior. We send
those to the rank 0 process, and wait and receive messages from the rank 0
process. After getting all of the chain IDs we use \Cclass{ChainManager} to call
\Cmethod{setChainid}.


\subsection{ChainManager}
The \Cclass{Mcmc} owns an object of \Cclass{ChainManager}, which connects
\Cclass{Mcmc} and \Cclass{Chain}. The role of \Cclass{ChainManager} is simpler
than those of others. It manages a list of chains that runs on a single
processor or a thread.  The \Cclass{ChainManager} does not own objects of
\Cmember{mFixed}, and \Cmember{mTxReads}. It accesses the two classes using mere
pointers to the objects of them.  The \Cclass{Mcmc} would not own them either.
The \Cclass{ChainManager} owns \Cclass{Chain} objects in a vector. After the
call of the constructor with \Cmember{mFixed} and \Cmember{mTxReads} we call
\Cmethod{createChain} with specified number of chains to create chains in
\Cmember{mChain}. We have two version of \Cmethod{setChainid}. We use the
two-integer argument version when creating chains, and the vector argument one
when swapping chains.  We send chain IDs and sums of log likelihood and log
prior to \Cclass{Mcmc}, which uses \Cmethod{chainid} and
\Cmethod{likelihoodPrior} to get those values.  The chain of writing sample in a
file is as follows.
\begin{Verbatim}[frame=lines,framesep=5mm]
Manager::mcmc > operator Mcmc > operator ChainManager > operator Chain
\end{Verbatim}
We call \Cmethod{report} starting at \Cmethod{mcmc}.
\begin{Verbatim}[frame=lines,framesep=5mm]
Manager::mcmc > Mcmc.report > ChainManager.report > Chain.report
\end{Verbatim}
The \Cmethod{report} is different from writing samples in a file. It reports
some summary of each chains activity including chain ID changes, temperature
changes, likelihood changes, etc. The \Cmethod{report} is called at the end of
the \Cmethod{mcmc}.

\begin{lstlisting}
class ChainManager {
private:
  ChainManager ();
public:
  Fixed* mFixed;
  vector<Reads*> mTxReads;
  vector<Chain*> mChain;
  vector<double> mTemperature;
public:
  ChainManager (Fixed* m, const vector<Reads*>& shortRead);
  void createChain (unsigned int);
  ~ChainManager ();
  void step (unsigned int);
  void setChainid (unsigned int, unsigned int);
  void setChainid (vector<unsigned int>& v);
  void chainid (vector<unsigned int>&);
  void likelihoodPrior (vector<double>&);
  void report (ostream &out);
  friend ostream& operator< < (ostream &out, const ChainManager &t);
};
\end{lstlisting}

Members of \Cclass{ChainManager}:
\begin{itemize*}
\item private:
\item   ChainManager (); We do not allow a default constructor.
\item public:
\item   Fixed* mFixed;
\item   vector<Reads*> mTxReads;
\item   vector<Chain*> mChain;
\item   vector<double> mTemperature; This is a copy from \Cclass{Mcmc}.
\item public:
\item   ChainManager (Fixed* m, const vector<Reads*>\& shortRead);
\item   void createChain (unsigned int); This must be called only once because
it creates a vector of \Cclass{Chain}, connects \Cclass{Fixed} and
\Cclass{Reads}, and calls \Cclass{createParameter} of \Cclass{Chain}. 
\item   ~ChainManager ();
\item   void step (unsigned int);
\item   void setChainid (unsigned int s, unsigned int e); assigns chain IDs from
$s$ and $e$, inclusively.
\item   void setChainid (vector<unsigned int>\& v); assigns chain IDs using $v$
when swapping chains.
\item   void chainid (vector<unsigned int>\&); returns the chain IDs. This is
used in chain swaps.
\item   void likelihoodPrior (vector<double>\&); returns the sums of log
likelihood and log prior. This is used in chain swaps.
\item   void report (ostream \&out);
\item   friend ostream\& operator$\ll$ (ostream \&out, const ChainManager \&t);
\end{itemize*}

\subsection{Chain}
The \Cclass{Chain} owns objects from \Cclass{RandomVariable}:
\Cmember{mTxBoundaries}, and \Cmember{mTxExpression}.  The
\Cmember{mMoverManager} is auto variable, and the others are pointers, which
need to be deleted in the destructor.  The \Cclass{Chain} has access to
\Cmember{mFixed}, and \Cmember{mTxReads}.  The first two \Cclass{Parameter}
objects change their contents through \Cclass{Mover} objects that are managed by
\Cclass{MoverManager}.  The \Cmethod{createParameter} would create
\Cclass{Parameter} objects.  Additionally, \Cclass{Mover} objects are created in
methods of \Cclass{Chain}. Objects of \Cclass{Mover}'s subclasses such as
\Cclass{MoverTxBoundaries} are allowed to access \Cclass{Parameter} members in
\Cclass{Chain}. We do this by giving \Cclass{MoverTxBoundaries} a pointer to the
object of \Cclass{TxBoundaries}.  Let us check how we could propose a new state
of \Cclass{TxBoundaries}, and accept or reject it in \Cclass{MoverTxBoundaries}.
Do this in \Cclass{MoverTxExpression} as well.

Where do we set the $\beta$ temperature and chain ID? The $\beta$ temperature is
set at the same time when chain IDs are set in \Cmethod{setChainid} of
\Cclass{ChainManager}.  Where do we set the likelihood and prior? We have not
set this value at all. The likelihood and prior values should be specified by
\Cclass{Mover} such as \Cclass{MoverTxBoundaries}.

We print out the state of a chain in the following format in a file at
\Cmember{mChainDirectory}/\Cmember{mPrefix}.rankID.chain.
\begin{Verbatim}[frame=lines,framesep=5mm]
-
  - [mID, mStep]            <- integers
  - [mBeta, mLoglikelihood] <- doubles
  - [c0, c1, ..., ck, ... ] <- integers
  - [e0, e1, ..., ek, ... ] <- doubles
\end{Verbatim}

The \Cclass{Summarizer} reads in chain files.

\begin{lstlisting}
class Chain {
private:
  Chain ();
  void createParameter ();
public:
  unsigned int mID;
  unsigned int mStep;
  double mLoglikelihood;
  double mLogLikelihoodPrior;
  double mBeta;
  Fixed* mFixed;
  vector<Reads*> mTxReads;
  MoverManager mMoverManager;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
public:
  Chain (Fixed* m, const vector<Reads*>& shortRead, const double beta = 1.L);
  ~Chain ();
  void TxFixed (Fixed* m) {mFixed=m;}
  void TxReads (const vector<Reads*>& shortRead) {mTxReads=shortRead;}
  void step (unsigned int n);
  void report (ostream &out);
  friend ostream& operator< < (ostream &out, const Chain &t);
};
\end{lstlisting}

Members of \Cclass{Chain}:
\begin{itemize*}
\item private:
\item   Chain ();
\item   void createParameter (); creates boundaries and expression parameters
\item public:
\item   unsigned int mID; the chain ID, which is used to find $\beta$, the
heating temperature
\item   unsigned int mStep; the numbers steps
\item   double mLoglikelihood; the log likelihood
\item   double mLogLikelihoodPrior; the sum of log likelihood and log prior
\item   double mBeta; $\beta$ temperature value
\item   Fixed* mFixed; the program setup
\item   vector<Reads*> mTxReads; the data
\item   MoverManager mMoverManager; the mover manager
\item   TxBoundaries* mTxBoundaries; the first parameter of boundaries
\item   TxExpression* mTxExpression; the second parameter of expression
\item public:
\item   Chain (Fixed* m, const vector<Reads*>\& shortRead, const double beta);
\item   ~Chain (); deletes the two parameters
\item   void TxFixed (Fixed* m); sets the program setup
\item   void TxReads (const vector<Reads*>\& shortRead); sets the data
\item   void step (unsigned int n); moves $n$ steps
\item   void report (ostream \&out); writes some summary of the chain activity
\item   friend ostream\& operator$\ll$ (ostream \&out, const Chain \&t); writes
the state of the parameters
\end{itemize*}

\subsection{RandomVariables}

The \Cclass{TxBoundaries} is created in a method of class \Cclass{Chain}.  The
\Cclass{MoverTxBoundaries} should be also created in a method of \Cclass{Chain}.
Then, \Cclass{Chain} can connect its \Cclass{Parameters} and \Cclass{Data} to
\Cclass{MoverTxBoundaries}.  It passes the connected \Cclass{MoverTxBoundaries}
to \Cclass{MoverManager}.
The chain uses \Cclass{Probability} and \Cclass{RandomVariable} to change the
value of \Cclass{Parameter}. The \Cclass{Data} is a \Cclass{RandomVariable} that
does not change its value. The \Cclass{Probability} is not a part of the chain. 
The chain must contain objects of \Cclass{RandomVariable}. The \Cclass{Mover} is
applied to \Cclass{ChainManager} or \Cclass{Mcmc}. The \Cclass{Chain} may have
access to \Cclass{Mover}. There are multiple possible movers of parameters. The
\Cclass{Chain} is manipulated to switch from one mover to another. Each step
multiple movers are chosen to be applied to \Cclass{Chain}. The \Cclass{Mover}
may have access to \Cclass{Probability}: it could use some \Cclass{Probability}
to replace a current state of \Cclass{Parameter} with another. The
\Cclass{Chain} has an object of \Cclass{MoverManager}, which manages several
\Cclass{Mover} objects. The \Cclass{MoverManager} is operational in that it
returns a \Cclass{Mover} among the set of \Cclass{Mover} objects with
multinomial probability.

\subsection{Parameter}

This is merely connecting \Cclass{RandomVariable} and other concrete classes
such as \Cclass{TxBoundaries} or \Cclass{TxExpression}.

\subsection{TxBoundaries}

Members of \Cclass{TxBoundaries}:
\begin{itemize*}
\item public: 
\item   vector<unsigned int> mC; 1-based ending positions of segments
\item   unsigned int mLengthSampleSegmentA; lower bound of length of interval
\item   unsigned int mLengthSampleSegmentB; upper bound of length of interval
for choosing random segments
\item public:
\item   TxBoundaries ();
\item   unsigned int size (); the number of segments
\item   unsigned int L (); the length of the chromosome 
\item   void seq (unsigned int from, unsigned int to, unsigned int by); 
\item   void sampleSegment (unsigned int\&, unsigned int\&);
\item   friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, 
                                       const TxBoundaries \&tx);
\item   friend ostream\& operator$\ll$ (ostream \&out, const TxBoundaries \&t);
\end{itemize*}

This is an older version.

Members of \Cclass{TxBoundaries}
\begin{itemize*}
\item Data members:
\item vector<unsigned int> mC; the end position of $c_k$ where $k$ runs from 0
to $K$. $c_0$ is 0, and $c_K$ is $L$. \Cmember{mC} runs from 0 to $K-1$. The
$0$-th element is $c_1$, and $K-1$-th element is $c_K$. Note that the first
element is not 1.
\item unsigned int mLengthSampleSegment; 
\item Methods:
\item unsigned int length (); returns the number of segments.
\item unsigned int L (); returns the length of a chromosome. 
\item operator out (YAML::Emitter \&out, const TxBoundaries \&tx); prints
\Cmember{mC} in YAML format.
\item TxBoundaries::sampleSegment (unsigned int\& left, unsigned int\& right); gets
the end positions of beginning and ending segments. Choose one segment and
another that are at least one segment apart. Now, we just add 
\Cmember{mLengthSampleSegment} to the chosen position. We may use a distribution
to have different values of \Cmember{mLengthSampleSegment} across sampling
procedure.
\end{itemize*}
The \Cclass{TxBoundaries} object is created by \Cclass{ProbTxBoundaries}.


The \Cclass{TxBoundaries}'s main features include writing the content to a file,
and sampling segments to update. The \Cclass{TxBoundaries} is owned by
\Cclass{Chain}, and be accessed by \Cclass{MoverTxBoundaries}. 

\subsection{TxExpression}

Members of \Cclass{TxExpression}:
\begin{itemize*}
\item public:
\item   vector<double> mDelta; 
\item public:
\item   TxExpression ();
\item   void seq (unsigned int); sets the equal-sized delta 
\item   friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, 
                                    const TxExpression \&tx);
\item   friend ostream\& operator$\ll$ (ostream \&out, const TxExpression \&t);
\end{itemize*}

The \Cclass{TxExpression}'s main features include writing the content to a file,
and sampling segments to update. The \Cclass{TxExpression} is owned by
\Cclass{Chain}, and be accessed by \Cclass{MoverTxExpression}. 

\subsection{TxParameter}
We track other micellaneous parameters. 

Members of \Cclass{TxExpression}:

\subsection{Data}

We do not have members yet. This is just a base of fixed parameters.
We would need to read and write \Cclass{RandomVariable} from and to a file using
YAML. We have a likelihood that is used to compute the likelihood and to sample
data given parameters.

\subsection{Reads}

Members of \Cclass{Reads}
\begin{itemize*}
\item public: 
\item   vector<unsigned int> mCount; number of counts of reads at the position.
We only consider 5' end positions of short reads to count. 
\item   unsigned int mN; total number of counts derived from \Cmember{mCount}
\item   unsigned int mJ; j-th short reads
\item public:
\item   Reads ();
\item   ~Reads ();
\item   unsigned int size (); the length of a chromosome 
\item   void sample (unsigned int l, unsigned int ul=10); sets counts for each
site to random values, the random values are between 0 and ul. The number of
sites becomes $l$
\item   friend YAML::Emitter operator (YAML::Emitter out, const Reads tx);
\end{itemize*}

We create a vector of \Cclass{Reads} to store the data for \program{tux}. We can
find the index of the data using \Cmember{mJ}. The \Cmember{mN} is the total
number of short reads.

\subsection{Fixed}

Members of \Cclass{Fixed}
\begin{itemize*}
\item public: Data members
\item   unsigned long int mSeed; the random number generator seed
\item   unsigned int mK; the number of segments
\item   unsigned int mM; the number of segments
\item   vector<double> mZ; the size factors
\item   double mA0; the coefficient $a_0$ of the function $\phi$
\item   double mA1; the coefficient $a_1$ of the function $\phi$
\item   double mAlphaQExpression; the proposal controller of expression levels
\item   double mAlphaQBoundaries; the proposal controller of boundaries
\item   unsigned int mLengthSampleSegmentA; the length of sampled segments
\item   unsigned int mLengthSampleSegmentB; the length of sampled segments
\item   double mAlphaPriorExpression; constant $\alpha_k$ value for the
Dirichlet prior, we would set 0.01 to $\alpha_k$. 
\item   unsigned int mMcmcLength; total length of a MCMC chain
\item   unsigned int mMcmcBurnin; length of burn-in of the total length
\item   unsigned int mMcmcThin; length of generation between sampling
\item   unsigned int mNumberProcess; the number of processes
\item   unsigned int mNumberChain; the number of chains
\item   unsigned int mNumberSwap; the number of swap 
\item   unsigned int mNumberSwapTry; the number of swap tries
\item   unsigned int mSwapDistance; the jump distance from a chain ID
\item   string mPrefix; the prefix of all of output files
\item   string mOutDirectory; the output Directory name
\item   string mChainDirectory; the output chain Directory name
\item   string mLogDirectory; the log output Directory name
\item   string mDatafile; the output file name
\item public: Methods
\item   Fixed (); default setup, when the user does not provide tux with values
in the input yaml file, it uses the initialized values in this constructor.
\item   \~{}Fixed ();
\item   unsigned int K(); returns the number of segments
\item   friend YAML::Emitter\& operator$\ll$ (YAML::Emitter \&out, const Fixed \&t);
\item   friend void operator$\gg$ (const YAML::Node\& node, Fixed\& t);
\item   friend ostream\& operator$\ll$ (ostream \&out, const Fixed \&t);
\end{itemize*}

\subsection{Probability}

The \Cclass{Probability} is tightly linked with \Cclass{RandomVariable}. Two
sets of random variables are considered: one that is concerned, and the other
that is conditioned. We can sample random variates of the former set from
\Cclass{Probability}. We can compute the probability density for a specific
set of random variates. The set of random variables that are conditioned is
optional. We use \Cclass{Probability} for non-standard valued random variables.
We would use simpler functions or classes for sampling a random variate from a
uniform. 
Let us consider usages of \Cclass{Probability}. We want a negative binomial with
two parameters: mean and variance. The probability of a segment configuration is
distributed as a uniform with a probability of $\frac{1}{{L-1 \choose K-1}}$
where $L$ is the length of a genome where we have $K$ segments. A $k$-th segment
boundary is between $c_{k-1}+1$ and $c_k$ inclusively. The $c_0$ is 0, and $c_K$
is $L$. We impose a Dirichlet on expression level $\bm{\mu}$. An expression
level of $k$-th segment is $\mu_k$, which is $\delta_k M$ where $M$ is the total
expression level of a RNA-seq experiment. We should give a ``very''
uninformative prior on $\bm{\mu}$ using a set of values $\bm{\alpha}$. We use a
lagarithmic scale of $\bm{\mu}$. Given the prior we start with $\bm{s}^{(0)}$
and $\bm{\mu}^{(0)}$. These two values are sampled from each of their prior
distribution. The boundary value, $\bm{s}^{(0)}$, consists of
$\{c_{k}\}_{k=1\ldots K-1}$ where $c_k$ is the end position of $k$-th segment.
We need $K-1$ positive values. The expression value, $\bm{\mu}^{(0)}$, consists
of $K$ real values. We use $\bm{\delta}^{(0)}$ which is a set of fractions, and
only need $K-1$ values. We convert them in logarithmic scale. Let us go to
\Cclass{TxBoundaries} and \Cclass{TxExpression}, which are \Cclass{Parameter},
which in turn is \Cclass{RandomVariable}. A random variate is created from a
probability distribution. A class of \Cclass{Probability}, or a probability of a
set of transcript boundaries, would create an object of \Cclass{TxBoundaries}.
Let us create a probability of a set of transcript boundaries:
\Cclass{ProbTxBoundaries}. 

Members of \Cclass{Probability}
\begin{itemize*}
\item Data members:
\item vector<RandomVariable*> mV; a list of random variables
\item vector<RandomVariable*> mC; a list of conditioning random variables
\item
\item virtual double d () = 0; a value of a probability
\item virtual RandomVariable* r () = 0; a random variate
\end{itemize*}

\subsection{ProbTxBoundaries}

Members of \Cclass{ProbTxBoundaries}
\begin{itemize*}
\item Data members:
\item  unsigned int mL; the length of a chromosome 
\item  unsigned int mK; the number of segments
\item Methods:
\item ProbTxBoundaries (unsigned int l, unsigned int k); sets the length of a
chromsome to l, and the number of segments to k. 
\item double d (); a value of a probability of a transcipt boundaries
\item RandomVariable* r (); a random variate of a transcript boundaries.
\end{itemize*}

This is an older version.

Members of \Cclass{ProbTxBoundaries}
\begin{itemize*}
\item Data members:
\item unsigned int mL; the length of a genome
\item unsigned int mK; the number of segments
\item Method
\item double d (); logarithmic value of $1/{(L-1) \choose (K-1)}$
\item RandomVariable* r (); a random variate of \Cclass{TxBoundaries} object
\end{itemize*}

\Cmethod{ProbTxBoundaries::r} - 
Consider numerical stability in sampling a random variate of transcript
boundaries. A segment could be 0 in length. I let a segment be at least 1 in
length. How can I sample Dirichlet random variates that is at least $1/L$? How
can I sample from Dirichlet distribution? Let us see function 
gsl\_ran\_dirichlet. We use gsl\_ran\_choose to choose $k$ sites among $L$
sites. The value of $L$ can be large. Assuming bacterial genomes we use this
method. Otherwise, we have to use containt Dirichlet distribution.
We choose $K-1$ sites between 1 and $L-1$ inclusive.

\subsection{ProbTxExpression}

Members of \Cclass{ProbTxExpression}
\begin{itemize*}
\item Data members:
\item vector<double> mAlpha; a concentration parameter
\item vector<double> mTheta; a random variate of Dirichlet
\item Methods:
\item  ProbTxExpression (const unsigned int k, const double a = 1.L); sets the
concentration parameter of Dirichlet distribution. The size is $k$, and
$\alpha_k$ is 1.
\item  ~ProbTxExpression ();
\item double d (); a value of a probability of transcipt expressions 
\item RandomVariable* r (); a random variate of transcript expressions
\end{itemize*}

\subsection{Likelihood}
The \Cclass{Likelihood} is used to compute the likelihood of data given the
model parameters. It is useful in generating data given model parameters. The
parameters would be generated by \Cclass{ProbTxBoundaries} and
\Cclass{ProbTxExpression}. The length $L$ of a chromosome and the number $K$ of
segments is the parameter to create the two parameters of boundaries ${c_k}$ and
expression ${\delta_k}$. We need the average number $M$ of short reads, and/or
the size factor, $Z$, of $J$ samples. We would be given $a_0$ and $a_1$ of
negative binomial dispersion to sample short reads counts using the expression
intensity $\mu$, which is equal to $z_j M \delta_k.$  

\begin{lstlisting}
class Likelihood: public Probability {
public:
  Fixed* mFixed;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  unsigned int mJ;

  // Data members are set by the above RandomVariable objects
  double mA0; // given a_0
  double mA1; // given a_1
  unsigned int mL; // a given chromosome length
  unsigned int mK; // a given segments length
  double mM;       // a given average total counts
  double mSizeFactor; // a given size factor
  vector<double> mDelta;   // sample from a uniform Dirichlet distribution
  vector<unsigned int> mC; // sample from a uniform Dirichlet distribution
  vector<unsigned int> mCount;
public:
  Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te);
  Likelihood (unsigned int, unsigned int, double);
  double d ();
  RandomVariable* r (); 
  void J (unsigned int j);
  double sizeFactor () const {return mSizeFactor;}
  void sizeFactor (const double s) {mSizeFactor=s;}
  void alpha (const double a0, const double a1) {mA0=a0; mA1=a1;}
};
\end{lstlisting}

Members of \Cclass{Likelihood}
\begin{itemize*}
\item Data members:
\item unsigned int mL; the length of a chromosome
\item unsigned int mK; the number of segments
\item double mM; the level of total expression 
\item vector<double> mSizeFactor; a set of size factors
\item vector<double> mDelta; a set of delta given by TxExpression
\item vector<unsigned int> mC; a set of segments given by TxBoundaries
\item vector<unsigned int> mCount; a set of numbers along a chromosome
\item Methods:
\item  Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te); creates a
likelihood object using the three random variables objects
\item Likelihood (unsigned int l, unsigned int k, double m); 
$l$ sites along a chromosome, $k$ segments, and $m$ total expression level.
\item RandomVariable* Likelihood::r (); creates a data set.
\end{itemize*}

The \Cclass{Fixed} is created from a YAML file. Two probability classes create
\Cclass{TxBoundaries} and \Cclass{TxExpression}. The \Cclass{Likelihood} needs
the three \Cclass{RandomVariable} objects to create \Cclass{Data} object. It
does not own none of \Cclass{RandomVariable} objects.

\subsection{MoverManager}

Members of \Cclass{MoverManager}:
\begin{itemize*}
\item Data Member:
\item vector<Mover*> mMover; a set of \Cclass{Mover} objects.
The \Cclass{MoverManager} owns the \Cclass{Mover} object elements in
\Cmember{mMover}. The \Cmethod{add} allocates the memory of a \Cclass{Mover}
object. The \Cclass{MoverManager}'s destructor must deallocate the memory.
\item vector<unsigned int> mId; why do we need this?
\item vector<double> mWeight; why do we need this?
\item gsl\_ran\_discrete\_t* mGslRanDiscrete; a lookup tabl for the discrete
random number generator
\item Method:
\item MoverManager (); 
\item ~MoverManager ();
\item void add (Mover*, const unsigned int, const double); adds a mover object
with an ID and weight.
\item Mover* choose ();
\end{itemize*}

\subsection{Mover}

A \Cclass{Mover} may contain many different things. We would give an identifier
for a mover. A mover should be subclassed from the abstract \Cclass{Mover}.  

Members of \Cclass{Mover}:
\begin{itemize*}
\item  public:
\item    unsigned int mTry; the number of the move try
\item    unsigned int mAccepted; the number of the accepted ones
\item  public:
\item    Mover () : mTry(0), mAccepted(0) {}
\item    virtual int step () = 0;
\item    double acceptanceRatio (); returns the acceptance ratio in percent.
\end{itemize*}

\subsection{MoverTxBoundaries}

FIXME: we need to compute the total likelihood in somewhere.

In one iteration of boundaries move we choose a series of segment chunks and
apply a move to each of the chunks. Because moves on different chunks can be
handled independently, we consider one chunk only.


1. We choose a subset of the K segments.
1.1 We choose a site of the L sites.
1.2 We choose a length from a distribution or fixed value.
1.3 Group segments in the chosen region.
2. Find the lengths of the subset of the segments.
2.1 Sum the lengths.
2.2 Compute the fractions of the legnths with respect to the sum of the
length.
2.3 Multiply the factions by a pseudo-concentration parameter.
3. Use the multiplied factions as a set of concentration parameters to
sample a new set of random variates from the Dirichlet distribution.
3.1 Multiply the sum of the lengths of the subset to recover a new set of
segments. 
3.2 Adjust legnths of the segments so that legnths fit the remaining
segments.
4. Compute acceptance probability by using likelihood, priors, and
Metropolis-Hastings ratio.
4.1 The priors are p(mu|s)p(s)=p(mu)p(s). This value does not change
before and after the proposal.
4.2 Count reads on the subset and compute p(x|theta*)/p(x|theta).
Optimization of the likelihood ratio can be done by using forms of the
negative binomial probability functions.
4.3 Compute the Metropolis-Hastings ratio using the proposal.

\Cclass{MoverTxBoundaries} \Cmethod{step}
\begin{Verbatim}[frame=lines,framesep=5mm]
  // 1. We choose a subset of the K segments.
  // 1.1 We choose a site of the L sites.
  // 1.2 We choose a length from a distribution or fixed value.
  // 1.3 Group segments in the chosen region.
  // 2. Find the lengths of the subset of the segments.
  // 2.1 Sum the lengths.
  // 2.2 Compute the fractions of the legnths with respect to the sum of the
  // length.
  // 2.3 Multiply the factions by a pseudo-concentration parameter.
  // 3. Use the multiplied factions as a set of concentration parameters to
  // sample a new set of random variates from the Dirichlet distribution.
  // 3.1 Multiply the sum of the lengths of the subset to recover a new set of
  // segments. 
  // 3.2 Adjust legnths of the segments so that legnths fit the remaining
  // segments.
  // 4. Compute acceptance probability by using likelihood, priors, and
  // Metropolis-Hastings ratio.
  // 4.1 The priors are p(mu|s)p(s)=p(mu)p(s). This value does not change
  // before and after the proposal.
  // 4.2 Count reads on the subset and compute p(x|theta*)/p(x|theta).
  // Optimization of the likelihood ratio can be done by using forms of the
  // negative binomial probability functions.
  // 4.3 Compute the Metropolis-Hastings ratio using the proposal.
\end{Verbatim}

\subsection{MoverTxBSingle}
We shuffle $c_k$ first, then move one at a time. This is a second try of move of
boundaries. We give the ID 3 for this move.
Given a boundary site we find the left-hand side distance and the right-hand
side one. We sample a new boundary site given the two distances.

\subsection{MoverTxBOdd}
We shuffle $c_k$ first, then choose $k$ many boundaries on either side,
resulting in an odd number of boundaries except either end of the chromosome.
Then, we will apply MoverTxBoundaries update. This is the same as
MoverTxBoundaries update except the way we choose boundaries. Let us change the
MoverTxBoundaries.
We use \Cmember{mLengthSampleSegmentA} for the count of the either side boundary
sites.

\subsection{MoverTxExpression}

\begin{itemize*}
\item public: 
\item  TxBoundaries* mTxBoundaries; a pointer to TxBoundaries
\item  TxExpression* mTxExpression; a pointer to TxExpression
\item  Reads* mReads; a pointer to Reads
\item  double mAlpha; a concentration parameter of Dirichlet
\item  bool mIsData; a true/false as to whether we compute the likelihood
\item  double mAverageTotalCount; the average of total reads counts
\item public:
\item  MoverTxExpression ();
\item  MoverTxExpression (Fixed* f, vector<Reads*>\& r, 
                          TxBoundaries* txb, TxExpression* txe); sets program
                          setup, data, boundaries, and expression.
\item  int step (); 
\end{itemize*}

1. Use MoverTxBoundaries::step to choose a subset of the K segments.
2. Find delta's for the subset.
3. Sample a new delta's using the current delta's.
Take the sum of the a, and multiply a by mAlpha/sum.
mAlpha is 1. If it is smaller, then the variance of a would be
larger. Because GSL Dirichlet function needs a memory for a return
value. a is the new delta of the old delta b.
4. Compute likelihood, prior, and MH ratio.
Find the start and end so that we can use parts of delta's in mDelta.
The random variable class's method can return a random stuff. For example,
TxBoundaries can return a random subset of boundaries. This seems sensible
because we use a member of TxBoundaries to get something of the member.
Let's make a method in TxBoundaries to sample a subset of boundaries.

Use the different theta to compute the likeilhood ratio.
Compute the prior ratio because we give a diffuse Dirichlet prior.
Compute the MH ratio based on our move.
We need to access the prior of gene expression.
We need a point to the prior probability of expression.

Now, lK contains lengths of the segments.

Nj, a0, a1 are fixed for one sample. These are also fixed parameter.
They should be a part of data. We need a class of data for storing these
fixed parameters. Let us assume that we be given those fixed parameters.
ck, mDelta, 
ck, and Nj are for each sample.
gsl\_ran\_negative\_binomial\_pdf (k, p, n);
k is from ck.
mu is (Nj * mDelta)
p is n/(n+mu)
n is 1/(a0+a1/mu).


\subsection{Sample}
Each chain produces an output file. The output file contains running setup
(\Cclass{Fixed}), data (\Cclass{Reads}), and samples (\Cclass{Sample}). 
There are other files such as mc3 file, GSL RNG files. One of the multiple
chains in MC3 would creates mc3 file as well as chain file. 

\subsection{Summarizer}
We reads in posterior sample files from multiple chains to create
\Cclass{Summary} object.  



The \Cmemthod{fillStepIndex} finds the steps and associate them with indices, so
that we can use the index of a step when collecting values from chain files.

The \Cmethod{listLoglikelihood} creates a .p file using one or more chain files.
Use Tracer to view the trajectory of log likelihoods of all of the chains.

The \Cmethod{computeFrequencyBoundaries} creates a .wig file using one or more
chain files. Upload the wig file to the genome browser.


Use the following command line to print boundaries.
\begin{Verbatim}[frame=lines,framesep=5mm]
awk 'NR%5==4' s1.out.0.chain | less
\end{Verbatim}

\subsection{Summary}
We have a number of boundaries. We can compute the average number of times a
boundary exists to the right of a site. We compute average expression level for
each site. We do this using the posterior samples of boundaries and expression
levels. Use \Cclass{Summary} and \Cclass{Summarizer}. Multiple files should be
handled by \Cclass{Summarizer} because MPI processors create their own output
files. 


\subsection{System}
The \Cclass{System} inspects the local computer system. What do we need to know?
We need to know the number of CPUs, the size of memory, the number of computes
nodes, the speed of CPUs, etc.

\subsection{TUX GSL}

\begin{itemize*}
\item double gsl\_ran\_negative\_binomial\_lnpdf (const unsigned int k, const
double p, const double n); This computes logarithm of 
gsl\_ran\_negative\_binomial\_pdf funtion.
\end{itemize*}




Global variables
\begin{itemize*}
\item const gsl\_rng *gGslRng; the main function calls MPI\_Init function to create
processes. Prior to that function call we should create as many seeds as
processes.
\end{itemize*}


\subsection{GNU Scientific Library}

\begin{itemize*}
\item double                                                                          
gsl\_ran\_negative\_binomial\_lnpdf (const unsigned int k, 
                                 const double p, 
                                 const double n); computes logarithm of negaive
                                 binomial distribution
\item unsigned int 
fGslDistance (const vector<unsigned int>\& a, const vector<unsigned int>\& b);
computes the distance between two sets of boundaries.
\end{itemize*}

\begin{itemize*}
\item void fGslRngAlloc (); creates an random number generator.
\item void fGslRngFree (); deletes the random number genrator.
\item fGslRanDirichlet (vector<double>\& alpha, vector<double>\& theta, double e);
samples theta from Dirichlet distribution of concentration parameter
of alpha until all of the components in theta are greater than e.
\end{itemize*}

We borrow \Cfile{gtypes.h} from gnome's \Cfile{glib/gtypes.h}. 

\subsection{tux-gsl}
It tests GSL.

\subsection{tux-fixed}
We creates a \Cclass{Fixed} object and write the object to a file. We also
change the property of the object by reading in another file. This needs YAML
library.  We create a yaml file.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./tux-fixed tux-fixed.out
$ cp tux-fixed.out fixed.yaml
$ Edit fixed.yaml
\end{Verbatim}

The fixed.yaml should look like this.
\begin{Verbatim}[frame=lines,framesep=5mm]
Fixed:
  mA0: 0.5
  mA1: 2.5
  mAlphaQExpression: 1.5
  mAlphaQBoundaries: 1.7
  mLengthSampleSegmentA: 300
  mLengthSampleSegmentB: 600
  mAlphaPriorExpression: 0.04
  mMcmcLength: 3000
  mMcmcBurnin: 700
  mMcmcThin: 82
---
Reads:
  - [1, 32, 7, 9, 97, 3, 2, 5, 3, 7]
  - [2, 12, 7, 9, 98, 3, 1, 2, 3, 8]
  - [3, 13, 7, 8, 99, 3, 8, 4, 4, 9]
\end{Verbatim}

\subsection{tux-tx}
We use fixed.yaml to create tx.yaml.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./tux-tx tux-tx.out
$ cp tux-tx.out tx.yaml
\end{Verbatim}

The tx.yaml should look like the following verbatim section.
\begin{Verbatim}[frame=lines,framesep=5mm]
Fixed:
  mA0: 0.5
  mA1: 2.5
  mAlphaQExpression: 1.5
  mAlphaQBoundaries: 1.7
  mLengthSampleSegmentA: 300
  mLengthSampleSegmentB: 600
  mAlphaPriorExpression: 0.04
  mMcmcLength: 3000
  mMcmcBurnin: 700
  mMcmcThin: 82
---
Reads:
  - [1, 32, 7, 9, 97, 3, 2, 5, 3, 7]
---
TxBoundaries:
  - [2, 4, 6, 8, 10]
---
TxExpression:
  - [0.2, 0.2, 0.2, 0.2, 0.2]
\end{Verbatim}

\subsection{tux-probtx}
We test \Cclass{ProbTxBoundaries} and \Cclass{ProbTxExpression}.

\subsection{tux-prob}
We use \Cclass{Probability} to create \Cclass{RandomVariable} objects.

\subsection{tux-move}
We would read in input files. We change parameters. We do not include chains
yet.

\subsection{tux-chain}
We would test a single chain using \Cclass{Chain}.

\subsection{tux-log}
We would summarize an output file.

\subsection{tux-cm}
We would test multiple chains using \Cclass{ChainManager}.

\subsection{tux-sum}
We would summarize an output file.

\subsection{tux-mcmc}
We would test multiple chains in multiple processes.

\subsection{tux-cmd}
We would test tux commands using Readline library.

\subsection{tux-likelihood}

We generate a data set under the model. A number of model parameters include:
\begin{itemize*}
\item $J$ : 3
\item $L$ : 1,000 base pairs
\item $K$ : 5
\item $\bm{\lambda}$, $\bm{s}$ : a sample from Dirichlet(1)
\item $\bm{\delta}$, $\bm{\mu}$ : a sample from Dirichlet(1)
\item $\phi$ : a size as a function of $\mu$
\item $\bm{z}$ : a sample from uniform between 0.5 and 1.5
\item We repeat the above of simulation and inference 10 times. Note that we fix
the sampled values of $\bm{s}$, $\bm{\mu}$, and $\bm{z}$ throughout the 10 times
of simulation.
\end{itemize*}
We use \Cclass{Likelihood}, \Cclass{ProbTxBoundaries}, and
\Cclass{ProbTxExpression} to create objects of \Cclass{Reads},
\Cclass{TxBoundaries}, and \Cclass{TxExpression}. Then, we save them in a YAML
file. The three objects are serialized to YAML output stream. 

\section{Compilation}

\subsection{MacPort packages}

\subsection{Ubuntu packages}
Search http://packages.ubuntu.com for packages to install.
\begin{Verbatim}[frame=lines,framesep=5mm]
libgsl0-dev
libopenmpi-dev
libreadline6-dev
\end{Verbatim}

Build a debug version using CMake.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ cd output/src
$ mkdir debug
$ cd debug
$ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ CC=openmpicc CXX=openmpic++ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ openmpirun -n 2 tux mcmc
$ make
$ make VERBOSE=1
$ cd ..;rm -rf b;mkdir b;cd b;cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
$ cd ../../..;./run 2;cd output/src;rm -rf b;mkdir b;cd b;cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug;make
\end{Verbatim}

Delete CMakeCache.txt when you compile in a different machine.

Create a PDF document of this document. 
\begin{Verbatim}[frame=lines,framesep=5mm]
$ ./run 1
\end{Verbatim}

Tangle source codes of this document.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ mkdir -p output/src
$ ./run 2
$ pushd ../../..;./run 2;popd;make
\end{Verbatim}

To add a project create a source code, add it an executable in the CMakeLists
file, and tangle the source code by editting sh/noweb-tangle.sh script.

Debugging
\begin{Verbatim}[frame=lines,framesep=5mm]
print *(aAlpha._M_impl._M_start)@aAlpha.size()
\end{Verbatim}

\subsection{CMake}

See the following page for a tutorial of CTest.
\begin{Verbatim}
http://www.cmake.org/Wiki/CMake_Testing_With_CTest
\end{Verbatim}

\begin{Verbatim}
ENABLE_TESTING()
ADD_TEST(SimpleTest ${CMAKE_CURRENT_BINARY_DIR}/SimpleTest Hello)
\end{Verbatim}

When using Makefile generators, such as Unix Makefiles, Borland Makefiles, or
NMake Makefiles, the CTest can simply be run by running:
\begin{Verbatim}
make test
\end{Verbatim}

Use CMake, CTest, CDash, and CPack.

Find CMake modules at the following directory:
\begin{Verbatim}[frame=lines,framesep=5mm]
/Applications/CMake\ 2.8-8.app/Contents/share/cmake-2.8/Modules/
\end{Verbatim}

To add a custom CMake package
\begin{Verbatim}[frame=lines,framesep=5mm]
cp downloads/FindReadline.cmake output/src/cmake/Modules/
http://www.vtk.org/Wiki/CMake:How_To_Find_Libraries

cd test/cmake
./build s009
Find the CMAKE_ROOT
and copy downloads/FindGSL.cmake to CMAKE_ROOT
\end{Verbatim}

Set the version number.
Check if this system provide the log and exp functions.
See if we should use our own math functions.
Configure a header file to pass some of the CMake settings
to the source code.
Add the binary tree to the search path for include files
so that we will find config.h
Add the MathFunctions library.
Add the executable.
Add the install targets.
Enable dashboard scripting

-D\_DEBUG for having debug log.

cmake ../kdelibs -DCMAKE\_INSTALL\_PREFIX=/opt/kde4
CMAKE\_BUILD\_TYPE


<<CMakeLists.txt>>=
cmake_minimum_required(VERSION 2.8)
project (tux)
# find_package( MPI )
# set (CMAKE_VERBOSE_MAKEFILE true)
set (CMAKE_BUILD_TYPE DEBUG)
SET (yamlEmitter_SRCS 
  "yamlEmitter.cpp"
)
SET (monsters_SRCS 
  "monsters.cpp"
)
SET (ezlogger_SRCS 
  "ezlogger.cpp"
)
set (tux-log_SRCS 
  "tux-log.cpp"
)
set (tux-fixed_SRCS 
  "tux-fixed.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxData.cpp"
  "tuxFixed.cpp"
  "tuxReads.cpp"
)
set (tux-tx_SRCS 
  "tux-tx.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxData.cpp"
  "tuxFixed.cpp"
  "tuxReads.cpp"
)
set (tux-prob_SRCS 
  "tux-prob.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
)
set (tux-move_SRCS 
  "tux-move.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxRandomVariable.cpp"
  "tuxParameter.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxData.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
)
set (tux-chain_SRCS 
  "tux-chain.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-cm_SRCS 
  "tux-cm.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-mcmc_SRCS 
  "tux-mcmc.cpp"
  "tuxMcmc.cpp"
  "tuxMcmcMpi.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-single_SRCS 
  "tux-single.cpp"
  "tuxMcmc.cpp"
  "tuxMcmcSingle.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-likelihood_SRCS 
  "tux-likelihood.cpp"
  "tuxDefault.cpp"
  "tuxError.cpp"
  "tuxMcmc.cpp"
  "tuxMcmcSingle.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tux-probtx_SRCS 
  "tux-probtx.cpp"
  "tuxDefault.cpp"
  "tuxError.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
)
set (tux-sum_SRCS 
  "tux-sum.cpp"
  "tuxSummarizer.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
)
set (tux_SRCS 
  "tux.cpp"
  "tuxSummarizer.cpp"
  "tuxMcmcSingle.cpp"
  "tuxDefault.cpp"
  "tuxError.cpp"
  "tuxSignal.cpp"
  "tuxHelp.cpp"
  "tuxManager.cpp"
  "tuxMcmc.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxTxParameter.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxMoverTxBSingle.cpp"
  "tuxLikelihood.cpp"
  "tuxTotalLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
set (tuxmpi_SRCS 
  "tux.cpp"
  "tuxMcmcMpi.cpp"
  "tuxDefault.cpp"
  "tuxError.cpp"
  "tuxSignal.cpp"
  "tuxHelp.cpp"
  "tuxManager.cpp"
  "tuxMcmc.cpp"
  "tuxChainManager.cpp"
  "tuxGsl.cpp"
  "tuxGslRng.cpp"
  "tuxTxBoundaries.cpp"
  "tuxTxExpression.cpp"
  "tuxMoverManager.cpp"
  "tuxMover.cpp"
  "tuxMoverTxBoundaries.cpp"
  "tuxMoverTxExpression.cpp"
  "tuxLikelihood.cpp"
  "tuxReads.cpp"
  "tuxFixed.cpp"
  "tuxProbTxBoundaries.cpp"
  "tuxProbTxExpression.cpp"
  "tuxChain.cpp"
)
SET (fileman_SRCS 
  "fileman.cpp"
)

################################################################################
# This is for tux without MPI version.
# Comment the following two lines when compiling with MPI
################################################################################
set (CMAKE_C_FLAGS_DEBUG "-D_DEBUG -Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")
set (CMAKE_CXX_FLAGS_DEBUG "-D_DEBUG -Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -g3 -ggdb -O0")

################################################################################
# To compile using openmpi compilers
# Comment the following four lines when compiling without MPI
################################################################################
# Under Ubuntu with Package installation
#set (CMAKE_C_COMPILER mpicc)
#set (CMAKE_CXX_COMPILER mpic++)
# Under MacOSX with MacPort installation
#set (CMAKE_C_COMPILER openmpicc)
#set (CMAKE_CXX_COMPILER openmpic++)

################################################################################
# Definitions
################################################################################
add_definitions (-D_DEBUG)
# add_definitions (-D_MPI -D_DEBUG)

set (CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}")
set (tux_VERSION_MAJOR 0)
set (tux_VERSION_MINOR 1)
include (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake)
include (${CMAKE_ROOT}/Modules/CheckIncludeFiles.cmake)
check_function_exists (log HAVE_LOG)
check_function_exists (exp HAVE_EXP)
check_include_files (malloc.h HAVE_MALLOC_H)
check_include_files (sys/file.h HAVE_SYS_FILE_H)
check_include_files (unistd.h HAVE_UNISTD_H)
check_include_files (string.h HAVE_STRING_H)
check_include_files (stdlib.h HAVE_STDLIB_H)
option(USE_MYMATH "Use my math implementation" OFF)
configure_file (
  "${PROJECT_SOURCE_DIR}/config.h.in"
  "${PROJECT_BINARY_DIR}/config.h"
  )
include_directories ("${PROJECT_BINARY_DIR}")
if (USE_MYMATH)
  include_directories ("${PROJECT_SOURCE_DIR}/MathFunctions")
  add_subdirectory (MathFunctions)
  set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)
endif (USE_MYMATH)
#  set (EXTRA_LIBS ${EXTRA_LIBS})

# add_executable (ezlogger ${ezlogger_SRCS})
#add_executable (tux-log tux-log.cpp)

# GNU Scientific Library
find_package (GSL)
if (GSL_FOUND)
  include_directories (${GSL_INCLUDE_DIR})
#  add_executable (tux-gsl tux-gsl.cpp tuxGslRng.cpp)
#  target_link_libraries (tux-gsl ${GSL_LIBRARIES})
else (GSL_FOUND)
  message (FATAL_ERROR "No GNU GSL library found")
endif (GSL_FOUND)

# YAML-CPP static library
find_library(YAMLCPP yaml-cpp)
if(${YAMLCPP} MATCHES NOTFOUND)
  message(FATAL_ERROR "No yaml-cpp found")
else(${YAMLCPP} MATCHES NOTFOUND)
  add_library(yaml STATIC IMPORTED)
  set_property(TARGET yaml PROPERTY IMPORTED_LOCATION ${YAMLCPP})
  set (tux-tx_LIBS ${tux-tx_LIBS} yaml)

  set (tux-tx_LIBS ${tux-tx_LIBS} ${GSL_LIBRARIES})
#  add_executable (tux-tx ${tux-tx_SRCS})
#  target_link_libraries (tux-tx ${tux-tx_LIBS})

  set (tux-probtx_LIBS ${tux-tx_LIBS})
#  add_executable (tux-probtx ${tux-probtx_SRCS})
#  target_link_libraries (tux-probtx ${tux-probtx_LIBS})

  set (tux-prob_LIBS ${tux-tx_LIBS})
#  add_executable (tux-prob ${tux-prob_SRCS})
#  target_link_libraries (tux-prob ${tux-prob_LIBS})

  set (tux-move_LIBS ${tux-tx_LIBS})
#  add_executable (tux-move ${tux-move_SRCS})
#  target_link_libraries (tux-move ${tux-move_LIBS})
  
  set (tux-chain_LIBS ${tux-tx_LIBS})
#  add_executable (tux-chain ${tux-chain_SRCS})
#  target_link_libraries (tux-chain ${tux-chain_LIBS})
  
  set (tux-cm_LIBS ${tux-tx_LIBS})
#  add_executable (tux-cm ${tux-cm_SRCS})
#  target_link_libraries (tux-cm ${tux-cm_LIBS})
  
  set (tux-mcmc_LIBS ${tux-tx_LIBS})
#  add_executable (tux-mcmc ${tux-mcmc_SRCS})
#  target_link_libraries (tux-mcmc ${tux-mcmc_LIBS})
  
  set (tux-likelihood_LIBS ${tux-tx_LIBS})
#  add_executable (tux-likelihood ${tux-likelihood_SRCS})
#  target_link_libraries (tux-likelihood ${tux-likelihood_LIBS})
  
  set (tux-single_LIBS ${tux-tx_LIBS})
#  add_executable (tux-single ${tux-single_SRCS})
#  target_link_libraries (tux-single ${tux-single_LIBS})
  
  set (tux-sum_LIBS ${tux-tx_LIBS})
#  add_executable (tux-sum ${tux-sum_SRCS})
#  target_link_libraries (tux-sum ${tux-sum_LIBS})
  
  set (tux-fixed_LIBS ${tux-tx_LIBS})
#  add_executable (tux-fixed ${tux-fixed_SRCS})
#  target_link_libraries (tux-fixed ${tux-fixed_LIBS})

  set (yamlEmitter_LIBS ${tux-tx_LIBS})
#  add_executable (yamlEmitter ${yamlEmitter_SRCS})
#  target_link_libraries (yamlEmitter ${yamlEmitter_LIBS})

  set (monsters_LIBS ${tux-tx_LIBS})
#  add_executable (monsters ${monsters_SRCS})
#  target_link_libraries (monsters ${monsters_LIBS})

  set (tux_LIBS ${tux-tx_LIBS})
endif(${YAMLCPP} MATCHES NOTFOUND)

# Not needed.
# add_library(readline STATIC IMPORTED)
# set_property(TARGET readline PROPERTY IMPORTED_LOCATION /usr/local/lib/libreadline.a)
# include_directories(${CMAKE_CURRENT_BINARY_DIR})

# fileman test
#add_executable (fileman ${fileman_SRCS})
#target_link_libraries(fileman readline)
#target_link_libraries(fileman -ltermcap)

################################################################################
# TUX
# 1. No tux version - do this for compiling other programs
# 2. tux without MPI
# 3. tux with MPI
################################################################################
# 1.
#add_executable (tux tux-v1.cpp)
# 2.
add_executable (tux ${tux_SRCS})
target_link_libraries(tux ${tux_LIBS} readline termcap)
# 3.
#add_executable (tux ${tuxmpi_SRCS})
#target_link_libraries(tux ${tux_LIBS} mpi readline termcap)

#target_link_libraries (tux ${EXTRA_LIBS})

#add_executable (stl-transform stl-transform.cpp)

# Install
install (TARGETS tux DESTINATION bin)

# Tests
enable_testing ()
add_test (tuxUsage tux)
set_tests_properties (tuxUsage
  PROPERTIES 
  PASS_REGULAR_EXPRESSION "Usage:.*number"
  )

add_test (tuxGslCreate tux-gsl ${CMAKE_CURRENT_BINARY_DIR}/tux-gsl.out)
add_test (tuxGslCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-gsl.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-gsl.out)
add_test (tuxTxCreate tux-tx ${CMAKE_CURRENT_BINARY_DIR}/tux-tx.out)
add_test (tuxTxCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-tx.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-tx.out)
add_test (tuxProbCreate tux-prob ${CMAKE_CURRENT_BINARY_DIR}/tux-prob.out)
add_test (tuxProbCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-prob.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-prob.out)
add_test (tuxMoveCreate tux-move ${CMAKE_CURRENT_BINARY_DIR}/tux-move.out)
add_test (tuxMoveCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-move.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-move.out)
add_test (tuxChainCreate tux-chain ${CMAKE_CURRENT_BINARY_DIR}/tux-chain.out)
add_test (tuxChainCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-chain.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-chain.out)
add_test (tuxCMCreate tux-cm ${CMAKE_CURRENT_BINARY_DIR}/tux-cm.out)
add_test (tuxCMCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-cm.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-cm.out)
add_test (tuxSumCreate tux-sum ${CMAKE_CURRENT_BINARY_DIR}/tux-sum.out)
add_test (tuxSumCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-sum.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-sum.out)
add_test (tuxFixedCreate tux-fixed ${CMAKE_CURRENT_BINARY_DIR}/tux-fixed.out)
add_test (tuxFixedCompare ${CMAKE_COMMAND} -E compare_files 
          ${CMAKE_CURRENT_BINARY_DIR}/tux-fixed.out
          ${CMAKE_CURRENT_SOURCE_DIR}/tux-fixed.out)

include (${CMAKE_ROOT}/Modules/InstallRequiredSystemLibraries.cmake)
set (CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/gpl-3.0.txt")
set (CPACK_PACKAGE_VERSION_MAJOR "${tux_VERSION_MAJOR}")
set (CPACK_PACKAGE_VERSION_MINOR "${tux_VERSION_MINOR}")
set (CPACK_PACKAGE_CONTACT       "tuxg@googlegroups.com")
include (CPack)

include (CTest)
@

<<MathFunctions/CMakeLists.txt>>=
# first we add the executable that generates the table
add_executable(MakeTable MakeTable.cpp)

get_target_property(MakeTableLocation MakeTable LOCATION)

# add the command to generate the source code
add_custom_command (
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  DEPENDS MakeTable
  COMMAND ${MakeTableLocation}
  ARGS ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  )

set_source_files_properties (
  mysqrt.cpp PROPERTIES 
  OBJECT_DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  )

# add the binary tree directory to the search path for include files
include_directories( ${CMAKE_CURRENT_BINARY_DIR} )

# add the main library
add_library(MathFunctions mysqrt.cpp)

install (TARGETS MathFunctions DESTINATION bin)
install (FILES MathFunctions.h DESTINATION include)
@

<<CMakeListsV1.txt>>=
cmake_minimum_required(VERSION 2.8)
ENABLE_TESTING()

PROJECT (tux)
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/Modules/")
SET (gsl_SRCS 
  "gsl.cpp"
)

# SET (CMAKE_EXE_LINKER_FLAGS "-static")
ADD_DEFINITIONS(-DHAVE_CONFIG_H) 
# SET (CMAKE_C_FLAGS_DEBUG "-Wno-write-strings -g3 -ggdb -O0")
# SET (CMAKE_CXX_FLAGS_DEBUG "-Wno-write-strings -g3 -ggdb -O0")
SET (CMAKE_C_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")
SET (CMAKE_CXX_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wno-write-strings -fpermissive -g3 -ggdb -O0")

# YAML
add_library(yaml STATIC IMPORTED)
set_property(TARGET yaml PROPERTY IMPORTED_LOCATION /usr/local/lib/libyaml-cpp.a)
ADD_EXECUTABLE (monsters ${monsters_SRCS})
target_link_libraries(monsters yaml)
ADD_EXECUTABLE (yamlEmitter ${yamlEmitter_SRCS})
target_link_libraries(yamlEmitter yaml)

# GSL
ADD_EXECUTABLE (gsl ${gsl_SRCS})
find_package (GSL)
if (GSL_FOUND)
  include_directories(${GSL_INCLUDE_DIR})
  target_link_libraries (gsl ${GSL_LIBRARIES})
endif (GSL_FOUND)

# EzLogger
ADD_EXECUTABLE (ezlogger ${ezlogger_SRCS})

# Readline
# find_package (Readline)
add_library(readline STATIC IMPORTED)
set_property(TARGET readline PROPERTY IMPORTED_LOCATION /usr/local/lib/libreadline.a)
include_directories(${CMAKE_CURRENT_BINARY_DIR})
ADD_EXECUTABLE (fileman ${fileman_SRCS})
target_link_libraries(fileman readline)
target_link_libraries(fileman -ltermcap)

INCLUDE (CheckIncludeFiles)
CHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)
CHECK_INCLUDE_FILES (sys/file.h HAVE_SYS_FILE_H)
CHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)
CHECK_INCLUDE_FILES (string.h HAVE_STRING_H)
CHECK_INCLUDE_FILES (stdlib.h HAVE_STDLIB_H)
CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/config.h.in ${CMAKE_CURRENT_BINARY_DIR}/config.h)

@

\section{Code}

\subsection{Tux classes}

\begin{Verbatim}[frame=lines,framesep=5mm]
Manager - Dispatches user commands
  show - shows states of data, model, mcmc, and others
  model - sets model parameters
  mcmc - executes MCMC to sample from the posterior
  summarize - summarizes a posterior sample 
  save - saves the current state of data, model, mcmc, and others to a file
  load - loads a state of data, model, mcmc, and others from a file
  help - shows commands and their usages

Mcmc - Command MCMC
  show - shows a state of MCMC
  step - samples a next set of parameter values
  save - saves a current state of MCMC
  load - loads a state of mcmc from MCMC parts of a file
  burn - explores a posterior distribution without saving states of MCMC
  sample - continues to sample parameter values till a next save of a MCMC state
  swap - swaps chains of different temparatures

ChainManager - A controler of Markov chains
  step - proceeds to a next step of the chain
  save - saves a current state of the chain
  load - laods a state of a chain 
  temperature - temperature of the chain
  
Chain - A Markov chain of parameters
  step - proceeds to a next step of the chain
  save - saves a current state of the chain
  load - laods a state of a chain 
  temperature - temperature of the chain
  
Model - Command Model
  show - shows a state of model
  save - saves a current state of model
  load - loads a state of model

System - Computer system configuration
  show - shows info of CPUs, GPUs, memory, compute nodes

Help - Command help
  show - shows help messages by reading messages

Memory - Customized memory management

Probability - Probability distribution
  rv - add a set of random variables
  conditionalRv - add a set of conditional random variables
  d - computes density of the distribution
  r - generates random deviates of the distribution
  logD - computes log of density of the distribution

Likelihood - A probability of data given parameters
Posterior - A probability of parameters given data
Prior - A probability of paramters
Proposal - A probability of a set of parameters given another

ProbabilityRatio - A ratio of probabilities

RandomVariable - Random variables; e.g., data, parameters

Mover - Proposal of a new set of parameters

MoverTxBoundaries - Proposal of transcript boundaries
MoverTxExpression - Proposal of transcript expression

Data - A random variable that does not change

Reads - A data of short reads mapped on a genome

Parameter - A random variable that can vary

Temperature - A parameter of chain IDs 
TxBoundaries - A parameter of transcript boundaries
TxExpression - A parameter of transcript expression levels

Summarizer - Command summarize of chains of posterior samples
  show - shows a state of summarization
  do - computes summary of posterior samples
  save - saves a current state of the summary
  load - loads a state of a summary

Summary - Summary of chains of posterior samples for a parameter
  mean - computes mean values
  variance - computes variance to quantify uncertainty
  autocorrelation - computes autocorrelation
  save - saves a current state of the summary
  load - loads a state of a summary
\end{Verbatim}

\subsection{Copyright}
<<tux gnu copyright>>=
// This file is a part of tux.
//
// tux is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// tux is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with tux. If not, see <http://www.gnu.org/licenses/>.
@

\subsection{Main}

<<main gslrngrandomnumber>>=
namespace tux {
  struct c_gslrng {
    unsigned long int operator()() {
      return gsl_rng_get (gGslRng);
    }
  } gslrngRandomNumber;
}
<<tux.cpp>>=
<<tux gnu copyright>>
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif 
#include <cstdlib>               // strtoul
#include <string>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <vector>
#include <gsl/gsl_rng.h>
#include <readline/readline.h>
#include <readline/history.h>
#ifdef _MPI
#include <mpi.h>
#endif // _MPI
#include "yaml-cpp/yaml.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxGslRng.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxHelp.h"
#include "tuxDefault.h"
#include "tuxError.h"
#include "tuxSignal.h"
#include "tuxManager.h"
<<xmalloc decl>>
<<xmalloc defn>>
using namespace std;
using namespace tux;
Fixed gFixed;
vector<Reads*> gShortRead;
Manager gManager;
<<tux createArgvFromChar>>
<<main tuxlf>>
<<tux interative>>
<<command line>>
<<main gslrngrandomnumber>>
<<tux logfilename>>
int 
main (int argc, char* argv[])
{
  gFixed.init ();
  <<register signal>>
  stringstream ss; 
  string strLog;

  //////////////////////////////////////////////////////////////////////////////
  // Command lines - read a commmand and an input file name
  //////////////////////////////////////////////////////////////////////////////
  string logfilename = Default::mLogfilename;
  string infilename = Default::mInfilename;
  int sCommand = OPT_HELP;
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_HELP) 
            {
              Help::full ();
              return 0;
            }
          else if (args.OptionId() == OPT_VERSION) 
            {
              Help::version ();
              return 0;
            }
          else if (args.OptionId() == OPT_INFILE) 
            {
              infilename = args.OptionArg();
            }
          else if (args.OptionId() == OPT_LOGFILE) 
            {
              logfilename = args.OptionArg();
            }
          else if (args.OptionId() == OPT_FIXED
                   || args.OptionId() == OPT_INTERACTIVE
                   || args.OptionId() == OPT_MCMC
                   || args.OptionId() == OPT_SUMMARIZE) 
            {
              if (sCommand == OPT_HELP)
                {
                  sCommand = args.OptionId();
                }
              else
                {
                  cerr << "Error: Only one commmand is allowed!" << endl;
                  return 1;
                }
            }
        }
      else 
        {
          cerr << "Error: Invalid argument - " << args.OptionText() << endl;
          return 1;
        }
    }
  
  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  lf.open(logfilename.c_str(),std::fstream::out);
  if (lf.is_open() == false)
    {
      cerr << "Error: Could not open file ``" 
           << logfilename 
           << "''! Check if the file can be created!" << endl;
      return 1;
    }
  fGslRngAlloc ();

  //////////////////////////////////////////////////////////////////////////////
  // Interactive Mode
  //////////////////////////////////////////////////////////////////////////////
                
  if (argc == 1 || sCommand == OPT_INTERACTIVE)
    {
      char *line, *s;
      progname = argv[0];
      initialize_readline (); /* Bind our completer. */
      /* Loop reading and executing lines until the user quits. */
      for ( ; done == 0; )
        {
          line = readline ("> ");
          if (!line) break;
          /* Remove leading and trailing whitespace from the line.
             Then, if there is anything left, add it to the history list
             and execute it. */
          s = stripwhite (line);
          if (*s)
            {
              add_history (s);
              execute_line (s);
            }
          free (line);
        }
      fGslRngFree ();
      lf.close();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  ifstream fin(infilename.c_str());
  if (fin.is_open())
    {
      try 
        {
          YAML::Parser parser(fin);
          YAML::Node doc;
          parser.GetNextDocument(doc);
          doc["Fixed"] >> gFixed;
          fin.close();
        }
      catch(YAML::BadDereference& e) 
        {
          cerr << e.what() << "\n";
          cerr << "Error: Check if the file ``" << infilename
               << " is a proper tux yaml file." << endl;
          fin.close();
          lf.close();
          fGslRngFree ();
          return 1;
        }
      catch(YAML::ParserException& e) 
        {
          cerr << e.what() << "\n";
          fin.close();
          lf.close();
          fGslRngFree ();
          return 1;
        }
    }
  else
    {
      cerr << "Error: Could not open file ``" 
           << infilename 
           << "''! Check if the file exists." << endl;
      lf.close();
      fGslRngFree ();
      return 1;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Batch Mode - override options in the input file
  //////////////////////////////////////////////////////////////////////////////
  args.Init(argc, argv, g_rgOptions);
  bool isArgumentProcessedSuccessfully = true;
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_WITHOUT_DATA) 
            gFixed.mIsData = false;
          if (args.OptionId() == OPT_WITH_DATA) 
            gFixed.mIsData = true;
          else if (args.OptionId() == OPT_DATAFILE) 
            gFixed.mDatafile = args.OptionArg();
          else if (args.OptionId() == OPT_PREFIX) 
            gFixed.mPrefix = args.OptionArg();
          else if (args.OptionId() == OPT_OUTDIRECTORY) 
            gFixed.mOutDirectory = args.OptionArg();
          else if (args.OptionId() == OPT_CHAINDIRECTORY) 
            gFixed.mChainDirectory = args.OptionArg();
          else if (args.OptionId() == OPT_LOGDIRECTORY) 
            gFixed.mLogDirectory = args.OptionArg();
          else if (args.OptionId() == OPT_SEED) 
            gFixed.mSeed = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_MCMCLENGTH) 
            gFixed.mMcmcLength = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_MCMCBURNIN) 
            gFixed.mMcmcBurnin = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_MCMCTHIN) 
            gFixed.mMcmcThin = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_NUMBERCHAIN) 
            gFixed.mNumberChain = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_NUMBERSWAP) 
            gFixed.mNumberSwap = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_NUMBERSWAPTRY) 
            gFixed.mNumberSwapTry = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_SWAPDISTANCE) 
            gFixed.mSwapDistance = strtoul(args.OptionArg(),NULL,0);
          else if (args.OptionId() == OPT_HALPHA) 
            gFixed.mHAlpha = atof(args.OptionArg());
          else if (args.OptionId() == OPT_HBETA) 
            gFixed.mHBeta = atof(args.OptionArg());
          else if (args.OptionId() == OPT_LOGVERBOSITY) 
            gFixed.mLogVerbosity = atoi(args.OptionArg());
          else if (args.OptionId() == OPT_SIZEFACTOR) 
            {
              isArgumentProcessedSuccessfully = DoMultiArgs(args, -1);
            }
          else if (args.OptionId() == OPT_LENGTHSAMPLESEGMENTA) 
            {
              gFixed.mLengthSampleSegmentA = strtoul(args.OptionArg(),NULL,0);
            }
          else if (args.OptionId() == OPT_LENGTHSAMPLESEGMENTB) 
            {
              gFixed.mLengthSampleSegmentB = strtoul(args.OptionArg(),NULL,0);
            }
        }
    }
  if (gFixed.check () == false || args.LastError() != SO_SUCCESS
      || isArgumentProcessedSuccessfully == false )
    {
      lf.close();
      fGslRngFree ();
      return 1;
    }
  else
    {
      gFixed.mSeed = fGslRngSeed (gFixed.mSeed);
      ss << gFixed; 
      strLog = ss.str();
      EZLOGGERVLSTREAM2(axter::log_always,lf) << strLog; 
    }
  axter::ezlogger<>::set_verbosity_level_tolerance(
    static_cast<axter::verbosity>(gFixed.mLogVerbosity)
  );
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_very_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  bool isReadComplete = true;
  Reads* r;
  fin.open(gFixed.mDatafile.c_str());
  if (fin.is_open()) 
    {
      unsigned int i = 0;
      while (!fin.eof())
        {
          r = new Reads(i++);
          fin >> *r;
          if (r->mN == 0)
            {
              
            }
          else 
            {
              gShortRead.push_back(r);
            }
        }
      fin.close();
      unsigned int numberSite = r->size ();
      for (vector<Reads*>::iterator it = gShortRead.begin(); 
           it != gShortRead.end(); 
           it++)
        {
          if ((*it)->size() != numberSite)
            {
              isReadComplete = false;
            }
        }
    }
  else
    {
      cerr << "Error: Could not open file ``" 
           << gFixed.mDatafile
           << "''! Check if the file exists." << endl;
      lf.close();
      fGslRngFree ();
      return 1;
    }
  if (isReadComplete == false)
    {
      cerr << "Error: Could not successfully read file ``" 
           << gFixed.mDatafile
           << "''! Check the file." << endl;
      for (vector<Reads*>::iterator it = gShortRead.begin(); 
           it != gShortRead.end(); 
           it++)
        {
          delete *it;
        }
      lf.close();
      fGslRngFree ();
      return 1;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Execute the command.
  //////////////////////////////////////////////////////////////////////////////
  gManager.mFixed = &gFixed;
  gManager.mTxReads= gShortRead;

  switch (sCommand)
    {
    case OPT_MODEL:
      cout << "Modelling ..." << endl;
      break;
    case OPT_FIXED:
      cout << gFixed;
      for (vector<Reads*>::iterator it = gShortRead.begin(); 
           it != gShortRead.end(); 
           it++)
        {
          (*it)->summary(cout);
        }
      break;
    case OPT_MCMC:
      cout << "Starting MCMC ..." << endl;
#ifdef _MPI
      gManager.mProcessSeed.resize(gFixed.mNumberProcess); 
      generate (gManager.mProcessSeed.begin(), 
                gManager.mProcessSeed.begin(), 
                gslrngRandomNumber);
      int size,rank;
      int length;
      char name[80];
      MPI_Init(&argc, &argv);
      MPI_Comm_rank(MPI_COMM_WORLD,&rank);
      MPI_Comm_size(MPI_COMM_WORLD,&size);
      MPI_Get_processor_name(name,&length);
      assert(static_cast<unsigned int>(size)==gFixed.mNumberProcess);
      fGslRngSeed (gManager.mProcessSeed.at(rank));
      axter::ezlogger_output_policy::mEzloggerOutputFilename 
        = gManager.logFilename (rank);
      gManager.mcmc (rank);
      MPI_Finalize(); 
#else
      axter::ezlogger_output_policy::mEzloggerOutputFilename 
        = gManager.logFilename (0);
      gManager.mcmc (0);
#endif // _MPI
      break;
    case OPT_SUMMARIZE:
      cout << "Summarizing a posterior sample ..." << endl;
      gManager.summarize ();
      break;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = gShortRead.begin(); 
       it != gShortRead.end(); 
       it++)
    {
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngFree ();
  lf.close();
  return 0;
}
@

<<tux createArgvFromChar>>=
namespace tux {
int 
createArgvFromChar (string &c, const char* arg, char*** argv, int* argc)
{
  string s(arg);
  istringstream iss(s);
  *argc = 0; 
  do
    {
       string sub; iss >> sub; (*argc)++;
    } 
  while (iss);

  iss.str(s); iss.clear();
  (*argv) = (char**) malloc ((*argc)*sizeof(char*));
  (*argv)[0] = (char*) malloc ((c.size()+1)*sizeof(char));
  strcpy((*argv)[0],c.c_str());
  for (int i = 1; i < (*argc); i++)
    {
       string sub;
       iss >> sub;
       (*argv)[i] = (char*) malloc ((sub.size()+1)*sizeof(char));
       strcpy((*argv)[i],sub.c_str());
    }
  return 0;
}
}
<<command line>>=
enum { 
    OPT_HELP, 
    OPT_INTERACTIVE,
    OPT_MODEL,
    OPT_FIXED,
    OPT_MCMC,
    OPT_SUMMARIZE,
    OPT_VERSION,
    OPT_INFILE,
    OPT_OUTFILE,
    OPT_LOGFILE,
    OPT_WITHOUT_DATA,
    OPT_WITH_DATA,
    OPT_DATAFILE,
    OPT_PREFIX,
    OPT_OUTDIRECTORY,
    OPT_CHAINDIRECTORY,
    OPT_LOGDIRECTORY,
    OPT_SEED,
    OPT_MCMCLENGTH,
    OPT_MCMCBURNIN,
    OPT_MCMCTHIN,
    OPT_NUMBERCHAIN,
    OPT_NUMBERSWAP,
    OPT_NUMBERSWAPTRY,
    OPT_SWAPDISTANCE,
    OPT_HALPHA,
    OPT_HBETA,
    OPT_LOGVERBOSITY,
    OPT_ALPHAQEXPRESSION,
    OPT_ALPHAQBOUNDARIES,
    OPT_SIZEFACTOR,
    OPT_LENGTHSAMPLESEGMENTA,
    OPT_LENGTHSAMPLESEGMENTB,

    OPT_CHAIN,
    OPT_LIKELIHOOD,
    OPT_PRIOR,
    OPT_PRINT
};
CSimpleOpt::SOption g_rgOptions[] = {
    // ID TEXT TYPE
    { OPT_HELP,      "-h",        SO_NONE    },
    { OPT_HELP,      "--help",    SO_NONE    },
    { OPT_VERSION,   "--version", SO_NONE    },
    { OPT_INFILE,    "-i",        SO_REQ_SEP },
    { OPT_INFILE,    "--in",      SO_REQ_SEP },
    { OPT_INFILE,    "--infile",  SO_REQ_SEP },
    { OPT_OUTFILE,   "-o",        SO_REQ_SEP },
    { OPT_OUTFILE,   "--out",     SO_REQ_SEP },
    { OPT_OUTFILE,   "--outfile", SO_REQ_SEP },
    { OPT_LOGFILE,   "-l",        SO_REQ_SEP },
    { OPT_LOGFILE,   "--log",     SO_REQ_SEP },
    { OPT_LOGFILE,   "--logfile", SO_REQ_SEP },
    { OPT_PREFIX,    "--prefix",  SO_REQ_SEP },
    { OPT_OUTDIRECTORY,"--outdirectory", SO_REQ_SEP },
    { OPT_CHAINDIRECTORY,"--chaindirectory", SO_REQ_SEP },
    { OPT_LOGDIRECTORY,"--logdirectory", SO_REQ_SEP },
    // Commands
    { OPT_MODEL,     "model",     SO_NONE    },
    { OPT_INTERACTIVE,"interactive", SO_NONE},
    { OPT_FIXED,     "fixed",     SO_NONE    },
    { OPT_MCMC,      "mcmc",      SO_NONE    },
    { OPT_SUMMARIZE, "summarize", SO_NONE    },
    // Detailed options
    { OPT_WITHOUT_DATA, "--without-data", SO_NONE },
    { OPT_WITH_DATA, "--with-data", SO_NONE },
    { OPT_DATAFILE,  "--datafile", SO_REQ_SEP },
    { OPT_SEED,      "--seed", SO_REQ_SEP },
    { OPT_MCMCLENGTH,"--mcmclength", SO_REQ_SEP },
    { OPT_MCMCBURNIN,"--mcmcburnin", SO_REQ_SEP },
    { OPT_MCMCTHIN,  "--mcmcthin",   SO_REQ_SEP },
    { OPT_NUMBERCHAIN,"--numberchain", SO_REQ_SEP },
    { OPT_NUMBERSWAP,"--numberswap", SO_REQ_SEP },
    { OPT_NUMBERSWAPTRY,"--numberswaptry", SO_REQ_SEP },
    { OPT_SWAPDISTANCE,"--swapdistance", SO_REQ_SEP },
    { OPT_HALPHA,    "--halpha", SO_REQ_SEP },
    { OPT_HBETA,     "--hbeta", SO_REQ_SEP },
    { OPT_LOGVERBOSITY,"--logverbosity", SO_REQ_SEP },
    { OPT_ALPHAQEXPRESSION,"--alphaqexpression", SO_REQ_SEP },
    { OPT_ALPHAQBOUNDARIES,"--alphaqboundaries", SO_REQ_SEP },
    { OPT_SIZEFACTOR,"--sizefactor", SO_MULTI },
    { OPT_LENGTHSAMPLESEGMENTA,"--lengthsamplesegmenta", SO_REQ_SEP },
    { OPT_LENGTHSAMPLESEGMENTB,"--lengthsamplesegmentb", SO_REQ_SEP },

    // Other used commands
    { OPT_CHAIN, "chain", SO_NONE },
    { OPT_LIKELIHOOD, "likelihood", SO_NONE },
    { OPT_PRIOR, "prior", SO_NONE },
    SO_END_OF_OPTIONS // END
};

bool
DoMultiArgs(
    CSimpleOpt &    args, 
    int             nMultiArgs
    )
{
  bool v = true;
  char ** rgpszArg = NULL;

  // get the number of arguments if necessary
  if (nMultiArgs == -1) 
    {
      // first arg is a count of how many we have
      rgpszArg = args.MultiArg(1);
      if (!rgpszArg) 
        {
          cout << "Put --sizefactor at the end of the command line\n";
          v = false;
          return v;
        }
      nMultiArgs = atoi(rgpszArg[0]);
    }

  // get the arguments to follow
  rgpszArg = args.MultiArg(nMultiArgs);
  if (!rgpszArg) 
    {
      printf("%d: '%s' (1 use --help to get command line help) - %d\n",
             args.LastError(), args.OptionText(), nMultiArgs);
      v = false;
      return v;
    }

  if (args.OptionId() == OPT_SIZEFACTOR) 
    {
      gFixed.mZ.clear();
      for (int n = 0; n < nMultiArgs; ++n) 
        {
          double sizeFactor = atof(rgpszArg[n]);
          gFixed.mZ.push_back(sizeFactor);
        }
    } 
//  else if (args.OptionId() == OPT_LENGTHSAMPLESEGMENT) 
//    {
//      if (nMultiArgs == 2)
//        {
//          cout << rgpszArg[0] << " " << rgpszArg[1] << endl;
//          gFixed.mLengthSampleSegmentA = strtoul(rgpszArg[0],NULL,0);
//          gFixed.mLengthSampleSegmentB = strtoul(rgpszArg[1],NULL,0);
//        }
//      else 
//        {
//          v = false;
//        }
//    }
  return v;
}
@

<<tux interative>>=
int com_list PARAMS((char *));
int com_help PARAMS((char *));
int com_model PARAMS((char *));
int com_mcmc PARAMS((char *));
int com_save PARAMS((char *));
int com_load PARAMS((char *));
int com_fixed PARAMS((char *));
int com_reads PARAMS((char *));
int com_sum PARAMS((char *));
int com_quit PARAMS((char *));

typedef struct {
  char *name;/* User printable name of the function. */
  rl_icpfunc_t *func;/* Function to call to do the job. */
  char *doc;/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "list", com_list, "List files in DIR" },
  { "ls", com_list, "Synonym for `list'" },
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "model", com_model, "Model" },
  { "fixed", com_fixed, "Fixed" },
  { "reads", com_reads, "Reads" },
  { "sum", com_sum, "Summarize" },
  { "mcmc", com_mcmc, "MCMC" },
  { "save", com_save, "Saves a current state to a file" },
  { "load", com_load, "Loads a state from a file" },
  { "quit", com_quit, "Quit using tux" },
  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite (char *string);
COMMAND* find_command (char *name);
void too_dangerous (char *caller);
void initialize_readline ();
int execute_line (char *line);
int valid_argument (char *caller, char *arg);

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (char *s)
{
  char *r;

  r = (char *) xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

/* Execute a command line. */
int
execute_line (char *line)
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for tux.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (char *name)
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (char *string)
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator PARAMS((const char *, int));
char **fileman_completion PARAMS((const char *, int, int));

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
void
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "tux";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END bound the
   region of rl_line_buffer that contains the word to complete.  TEXT is
   the word to complete.  We can use the entire contents of rl_line_buffer
   in case we want to do some simple parsing.  Return the array of matches,
   or NULL if there aren't any. */
char **
fileman_completion (const char *text, int start, int end)
{
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);
  if (end == 0) { /* No code! */ }
    
  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (const char *text, int state)
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  name = commands[list_index].name;
  while (name)
    {
      list_index++;
      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
      name = commands[list_index].name;
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                          tux Commands                            */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* List the file(s) named in arg. */
int
com_list (char *arg)
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
int
com_help (char *arg)
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

int
com_model (char *arg)
{
  too_dangerous (arg);
  return (1);
}

enum { 
    OPT_FIXED_INFILE,
    OPT_FIXED_SHOW,
    OPT_FIXED_HELP
};
CSimpleOpt::SOption g_fixedOptions[] = {
    { OPT_FIXED_HELP,   "-h",       SO_NONE    },
    { OPT_FIXED_HELP,   "--help",   SO_NONE    },
    { OPT_FIXED_INFILE, "-i",       SO_REQ_SEP },
    { OPT_FIXED_INFILE, "--in",     SO_REQ_SEP },
    { OPT_FIXED_INFILE, "--infile", SO_REQ_SEP },
    { OPT_FIXED_SHOW,   "-s",       SO_NONE    },
    { OPT_FIXED_SHOW,   "--show",   SO_NONE    },
    SO_END_OF_OPTIONS // END
};

int
com_fixed (char *arg)
{
  string c("fixed");
  string infilename; 

  if (strlen(arg) == 0)
    {
      Help::fixed ();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Construct argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int argc;
  char** argv;
  createArgvFromChar (c, arg, &argv, &argc);

  //////////////////////////////////////////////////////////////////////////////
  // Use argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int sCommand;
  CSimpleOpt args(argc, argv, g_fixedOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_FIXED_HELP) 
            {
              sCommand = OPT_FIXED_HELP;
            }
          else if (args.OptionId() == OPT_FIXED_INFILE) 
            {
              infilename = args.OptionArg();
            }
          else if (args.OptionId() == OPT_FIXED_SHOW) 
            {
              cout << gFixed;
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }

  if (sCommand == OPT_FIXED_HELP)
    {
      Help::fixed ();
    }
  else if (infilename.size() > 0)
    {
      ifstream fin(infilename.c_str());
      if (fin.is_open())
        {
          YAML::Parser parser(fin);
          YAML::Node doc;
          parser.GetNextDocument(doc);
          doc["Fixed"] >> gFixed;
          fin.close();
          cout << "The file ``" << infilename 
               << "'' has been read successfully." << endl;
        }
      else
        {
          cout << "Check if the file ``" << infilename << "'' exists." << endl;
        }
    }

  //////////////////////////////////////////////////////////////////////////////
  // Finalize argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < argc; i++)
    {
      free(argv[i]);
    }
  free(argv);

  return (1);
}

enum { 
    OPT_READS_INFILE,
    OPT_READS_SHOW,
    OPT_READS_HELP
};
CSimpleOpt::SOption g_readsOptions[] = {
    { OPT_READS_HELP,   "-h",       SO_NONE    },
    { OPT_READS_HELP,   "--help",   SO_NONE    },
    { OPT_READS_INFILE, "-i",       SO_REQ_SEP },
    { OPT_READS_INFILE, "--in",     SO_REQ_SEP },
    { OPT_READS_INFILE, "--infile", SO_REQ_SEP },
    { OPT_READS_SHOW,   "-s",       SO_NONE    },
    { OPT_READS_SHOW,   "--show",   SO_NONE    },
    SO_END_OF_OPTIONS // END
};
int
com_reads (char *arg)
{
  string c("reads");
  string infilename; 

  if (strlen(arg) == 0)
    {
      Help::reads ();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Construct argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int argc;
  char** argv;
  createArgvFromChar (c, arg, &argv, &argc);

  //////////////////////////////////////////////////////////////////////////////
  // Use argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int sCommand;
  CSimpleOpt args(argc, argv, g_readsOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_READS_HELP) 
            {
              sCommand = OPT_READS_HELP;
            }
          else if (args.OptionId() == OPT_READS_INFILE) 
            {
              infilename = args.OptionArg();
            }
          else if (args.OptionId() == OPT_READS_SHOW) 
            {
              for (vector<Reads*>::iterator it = gShortRead.begin(); 
                   it != gShortRead.end(); 
                   it++)
                {
                  (*it)->summary(cout);
                }
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }

  if (sCommand == OPT_READS_HELP)
    {
      Help::reads ();
    }
  else if (infilename.size() > 0)
    {
      Reads* r;
      ifstream fin(infilename.c_str());
      if (fin.is_open()) 
        {
          unsigned int i = 0;
          while (!fin.eof())
            {
              r = new Reads(i++);
              fin >> *r;
              if (r->mN == 0)
                {
                  //EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                                      //<< m.mDatafile << std::endl;
                }
              else 
                {
                  gShortRead.push_back(r);
                }
            }
          fin.close();
          cout << "The data file ``" << infilename 
               << "'' has been read successfully." << endl;
        }
      else
        {
          cout << "Unable to open file " << infilename << endl;
          cout << "Check if the file ``" << infilename << "'' exists." << endl;
        }
    }

  //////////////////////////////////////////////////////////////////////////////
  // Finalize argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < argc; i++)
    {
      free(argv[i]);
    }
  free(argv);
  return (1);
}

enum { 
    OPT_MCMC_HELP,
    OPT_MCMC_RUN,
    OPT_MCMC_SHOW
};
CSimpleOpt::SOption g_mcmcOptions[] = {
    { OPT_MCMC_HELP,   "-h",       SO_NONE    },
    { OPT_MCMC_HELP,   "--help",   SO_NONE    },
    { OPT_MCMC_RUN,    "-r",       SO_NONE    },
    { OPT_MCMC_RUN,    "--run",    SO_NONE    },
    { OPT_MCMC_SHOW,   "-s",       SO_NONE    },
    { OPT_MCMC_SHOW,   "--show",   SO_NONE    },
    SO_END_OF_OPTIONS // END
};
int
com_mcmc (char *arg)
{
  string c("mcmc");
  string infilename; 

  if (strlen(arg) == 0)
    {
      Help::mcmc ();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Construct argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int argc;
  char** argv;
  createArgvFromChar (c, arg, &argv, &argc);

  //////////////////////////////////////////////////////////////////////////////
  // Use argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int sCommand;
  CSimpleOpt args(argc, argv, g_mcmcOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_MCMC_HELP) 
            {
              sCommand = OPT_MCMC_HELP;
            }
          else if (args.OptionId() == OPT_MCMC_RUN) 
            {
              sCommand = OPT_MCMC_RUN;
            }
          else if (args.OptionId() == OPT_MCMC_SHOW) 
            {
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }

  if (sCommand == OPT_MCMC_RUN)
    {
      gManager.mFixed = &gFixed;
      gManager.mTxReads= gShortRead;
      gManager.mcmc (0);
    }
  else if (sCommand == OPT_MCMC_HELP)
    {
      Help::mcmc ();
    }

  //////////////////////////////////////////////////////////////////////////////
  // Finalize argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < argc; i++)
    {
      free(argv[i]);
    }
  free(argv);
  return (1);
}

enum { 
    OPT_SUM_HELP,
    OPT_SUM_RUN
};
CSimpleOpt::SOption g_sumOptions[] = {
    { OPT_SUM_HELP, "-h", SO_NONE    },
    { OPT_SUM_HELP, "--help", SO_NONE    },
    { OPT_SUM_RUN, "-r",   SO_NONE },
    { OPT_SUM_RUN, "--run",   SO_NONE },
    SO_END_OF_OPTIONS // END
};
int
com_sum (char *arg)
{
  string c("sum");
  string infilename; 

  if (strlen(arg) == 0)
    {
      Help::sum ();
      return 0;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Construct argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int argc;
  char** argv;
  createArgvFromChar (c, arg, &argv, &argc);

  //////////////////////////////////////////////////////////////////////////////
  // Use argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  int sCommand;
  CSimpleOpt args(argc, argv, g_sumOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_SUM_HELP) 
            {
              sCommand = OPT_SUM_HELP;
            }
          else if (args.OptionId() == OPT_SUM_RUN) 
            {
              sCommand = OPT_SUM_RUN;
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }

  if (sCommand == OPT_SUM_RUN)
    {
      gManager.mFixed = &gFixed;
      gManager.mTxReads= gShortRead;
      gManager.summarize ();
    }
  else if (sCommand == OPT_SUM_HELP)
    {
      Help::sum ();
    }

  //////////////////////////////////////////////////////////////////////////////
  // Finalize argc and argv.
  //////////////////////////////////////////////////////////////////////////////
  for (int i = 0; i < argc; i++)
    {
      free(argv[i]);
    }
  free(argv);
  return (1);
}

int
com_save (char *arg)
{
  too_dangerous (arg);
  return (1);
}

int
com_load (char *arg)
{
  too_dangerous (arg);
  return (1);
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
int
com_quit (char *arg)
{
  if (!arg)
    arg = "";
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
void
too_dangerous (char *caller)
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (char *caller, char *arg)
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}


@

\subsection{Help}
<<tuxHelp.h>>=
<<tux gnu copyright>>
#ifndef _TUXHELP_H_
#define _TUXHELP_H_
namespace tux {
class Help {
public:
  static void full ();
  static void fixed ();
  static void reads ();
  static void mcmc ();
  static void sum ();
  static void version ();
};
}
#endif // _TUXHELP_H_

<<tuxHelp.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxDefault.h"
#include "tuxHelp.h"
using namespace std;
namespace tux {
void 
Help::full ()
{
  cout << ""
"tux Commands Manual\n"
"\n"
"NAME\n"
"   tux -- Transcripts boundaries uncertainty\n"
"\n"
"SYNOPSIS\n"
"   tux [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The program implements a statistical method of inferring uncertainty\n"
"   of transcript boundaries using RNA-seq data.\n"  
"   The method is described in Choi (2012).\n"
"\n"
"   General options: (Default Values)\n"
"      -h --help\n"
"         Shows this help message.\n"
"      --version\n"
"         Shows the version.\n"
"      -i, --in, --infile [INFILE]\n"
"         Reads in an input file (" 
<< Default::mInfilename << ").\n" << 
"      --datafile [DATAFILE]\n"
"         Reads the data file not specified in the input file ("
<< Default::mDatafile << ").\n" << 
"      -l, --log, --logfile [INFILE]\n"
"         Logs non-MCMC in a file (" 
<< Default::mLogfilename << ").\n" << 
"      --prefix [NAME]\n"
"         Output and log files prefix for MCMC (" 
<< Default::mPrefix << ").\n" << 
"      --outdirectory [DIRECTORY]\n"
"         Directory for MCMC summary output (" 
<< Default::mOutDirectory << ").\n" << 
"      --chaindirectory [DIRECTORY]\n"
"         Directory for MCMC output (" 
<< Default::mChainDirectory << ").\n" << 
"      --logdirectory [DIRECTORY]\n"
"         Directory for MCMC log (" 
<< Default::mLogDirectory << ").\n" << 
"      --without-data\n"
"         Runs MCMC without data or samples from the prior.\n"
"      --with-data\n"
"         Runs MCMC with data or samples from the posterior [Default].\n"
"      --seed [NUMBER]\n"
"         Sets the seed for the random number generator ("
<< Default::mSeed << ").\n" << 
"      --sizefactor [K] [N_1] [N_2] ... [N_K]\n"
"         Sets the size factors. Put this option at the end of the command line.\n"
"      --lengthsamplesegmenta [NUMBER]\n"
"         Sets the number of boundaries on either side. (Recommended value is <10)\n"
"         Sets the start of the range of sampling segments ("
<< Default::mLengthSampleSegmentA << ").\n" <<
"      --lengthsamplesegmentb [NUMBER]\n"
"         Sets the end of the range of sampling segments ("
<< Default::mLengthSampleSegmentB << ").\n" <<
"      --mcmclength [NUMBER]\n"
"         Sets the total chain length ("
<< Default::mMcmcLength << ").\n" <<
"      --mcmcburnin [NUMBER]\n"
"         Sets the chain bunrin length ("
<< Default::mMcmcBurnin << ").\n" <<
"      --mcmcthin [NUMBER]\n"
"         Sets the chain thin length ("
<< Default::mMcmcThin << ").\n" <<
"      --numberchain [NUMBER]\n"
"         Sets the number of chains ("
<< Default::mNumberChain << ").\n" <<
"      --numberswap [NUMBER]\n"
"         Sets the interval between chain swaps ("
<< Default::mNumberSwap << ").\n" <<
"      --numberswaptry [NUMBER]\n"
"         Sets the number of swap tries ("
<< Default::mNumberSwapTry << ").\n" <<
"      --swapdistance [NUMBER]\n"
"         Sets twice the distance between two chains for swap ("
<< Default::mSwapDistance << ").\n" <<
"      --halpha [NUMBER]\n"
"         Sets the alpha for Metropolis-Coupled MCMC ("
<< Default::mHAlpha << ").\n" <<
"      --hbeta [NUMBER]\n"
"         Sets the beta for Metropolis-Coupled MCMC ("
<< Default::mHBeta << ").\n" <<
"      --logverbosity [NUMBER]\n"
"         Sets the verbosity level from 1 (lowest) to 5 (highest) (" 
<< Default::mLogVerbosity << ")\n"
<<
"\n"
"   Commands:\n"
"      interactive\n"
"         Runs in interactive mode.\n"
"      fixed\n"
"         Shows the input file.\n"
"      mcmc\n"
"         Samples transcript boundaries.\n"
"      summarize\n"
"         Summarizes a posterior sample of transcript boundaries.\n"
"\n"
"   Files:\n"
"      INFILE\n"
"         A YAML file\n"
"      DATAFILE\n"
"         A short read counts data file\n"
"      OUTFILE\n"
"         Output and log files\n"
"      LOGFILE\n"
"         A log file\n"
"\n"
"   Usages:\n"
"      tux or tux interactive\n"
"         Run the interactive mode of tux.\n"
"      tux mcmc --infile INFILE\n"
"         Reads in an YAML file, and prints it out to standard output.\n"
"      tux summarize --infile INFILE\n"
"         Summarizes a posterior sample of transcript boundaries.\n"
"      tux mcmc -i INFILE --without-data --with-data\n"
"         The latter option --with-data overrides the former option.\n"
"\n"
"AUTHOR\n"
"   Written by Sang Chul Choi\n"
"\n"
"REPORTING BUGS\n"
"   Report bugs to google group of tuxg at tuxg at googlegroups dot com\n"
"   You can visit a website at http://code.google.com/p/tuxg/\n"
"\n"
"VERSION\n"
"   tux 1.0 - Build IMRBUILDDATETIME\n"
"\n"
"COPYRIGHT\n"
"   Copyright (C) 2012- Sang Chul Choi\n"
"   See the source for copying conditions.\n"
"   There is NO warranty; not even for MERCHANTABILITY\n"
"\n"
"tux 1.0\n"
"";
}
void 
Help::fixed ()
{
  cout << ""
"NAME\n"
"   tux-fixed -- Read in an .yaml file\n"
"\n"
"SYNOPSIS\n"
"   fixed [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The program reads in an .yaml file to setup the program.\n"
"\n"
"   General options:\n"
"      -h --help\n"
"         Shows this help message.\n"
"      -i --infile [INFILE]\n"
"         Reads in an input file.\n"
"      -s --show\n"
"         Prints out the input file.\n"
"";
}
void 
Help::reads ()
{
  cout << ""
"NAME\n"
"   tux-reads -- Read in a short-reads count file\n"
"\n"
"SYNOPSIS\n"
"   reads [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The command reads in a short-reads count file.\n"
"\n"
"   General options:\n"
"      -h --help\n"
"         Shows this help message.\n"
"      -i --infile [INFILE]\n"
"         Reads in a count file.\n"
"      -s --show\n"
"         Prints out some of the count file.\n"
"";
}
void 
Help::mcmc ()
{
  cout << ""
"NAME\n"
"   tux-mcmc -- Execute an Markov chain Monte Carlo\n"
"\n"
"SYNOPSIS\n"
"   mcmc [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The command executes an Markov chain Monte Carlo.\n"
"\n"
"   General options:\n"
"      -h --help\n"
"         Shows this help message.\n"
"      -r --run\n"
"         Executes an MCMC.\n"
"      -s --show\n"
"         Prints out what?.\n"
"";
}
void 
Help::sum ()
{
  cout << ""
"NAME\n"
"   tux-sum -- Summarize a posterior sample\n"
"\n"
"SYNOPSIS\n"
"   sum [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The command summarizes a posterior sample.\n"
"\n"
"   General options:\n"
"      -h --help\n"
"         Shows this help message.\n"
"      -r --run\n"
"         Executes an MCMC.\n"
"";
}
void 
Help::version ()
{
  cout << ""
"tux 1.0 - Build IMRBUILDDATETIME\n"
"Written by Sang Chul Choi.\n"
"\n"
"Copyright (c) 2012- Sang Chul Choi\n"
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
"";
}
}
@

\subsection{YAML: data serialization}
<<monsters.cpp>>=
#include "yaml-cpp/yaml.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

// our data types
struct Vec3 {
   float x, y, z;
};

struct Power {
   std::string name;
   int damage;
};

struct Monster {
   std::string name;
   Vec3 position;
   bool alive;
   std::vector <Power> powers;
};

// now the extraction operators for these types
void operator >> (const YAML::Node& node, Vec3& v) {
   node[0] >> v.x;
   node[1] >> v.y;
   node[2] >> v.z;
}

void operator >> (const YAML::Node& node, Power& power) {
   node["name"] >> power.name;
   node["damage"] >> power.damage;
}

void operator >> (const YAML::Node& node, Monster& monster) {
   node["name"] >> monster.name;
   node["position"] >> monster.position;
   node["alive"] >> monster.alive;
   const YAML::Node& powers = node["powers"];
   for(unsigned i=0;i<powers.size();i++) {
      Power power;
      powers[i] >> power;
      monster.powers.push_back(power);
   }
}

int main()
{
   std::ifstream fin("monsters.yaml");
   YAML::Parser parser(fin);
   YAML::Node doc;
   parser.GetNextDocument(doc);
   for(unsigned i=0;i<doc.size();i++) {
      Monster monster;
      doc[i] >> monster;
      std::cout << monster.name << " alive? " << monster.alive << "\n";
   }

   return 0;
}
@

\subsection{YAML: Emitter}
<<yamlEmitter.cpp>>=
#include "yaml-cpp/yaml.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
int main()
{
  YAML::Emitter out;
  out.SetIndent(2); 
  bool tf = true;

  out << "Hello, World!";

  out << YAML::BeginSeq;
  out << "eggs";
  out << "bread";
  out << "milk";
  out << YAML::EndSeq;

  out << YAML::BeginMap;
  out << YAML::Key << "name";
  out << YAML::Value << "Ryan Braun";
  out << YAML::Key << "position";
  out << YAML::Value << "LF";
  out << YAML::EndMap;

  out << YAML::BeginMap;
  out << YAML::Key << "name";
  out << YAML::Value << "Barack Obama";
  out << YAML::Key << "children";
  out << YAML::Value << YAML::BeginSeq << "Sasha" << "Malia" << YAML::EndSeq;
  out << YAML::Key << "TFTRUE";
  out << YAML::Value << tf;
  tf = false;
  out << YAML::Key << "TFFALSE";
  out << YAML::Value << tf;
  out << YAML::EndMap;

  out << YAML::Literal << "A\n B\n  C";

  out << YAML::Flow;
  out << YAML::BeginSeq << 2 << 3 << 5 << 7 << 11 << YAML::EndSeq;

  out << YAML::BeginMap;
  out << YAML::Key << "method";
  out << YAML::Value << "least squares";
  out << YAML::Comment("should we change this method?");
  out << YAML::EndMap;

  out << YAML::BeginSeq;
  out << YAML::Anchor("fred");
  out << YAML::BeginMap;
  out << YAML::Key << "name" << YAML::Value << "Fred";
  out << YAML::Key << "age" << YAML::Value << "42";
  out << YAML::EndMap;
  out << YAML::Alias("fred");
  out << YAML::EndSeq;
   
  std::vector <int> squares;
  squares.push_back(1);
  squares.push_back(4);
  squares.push_back(9);
  squares.push_back(16);

  std::map <std::string, int> ages;
  ages["Daniel"] = 26;
  ages["Jesse"] = 24;

  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << ages;
  out << YAML::EndSeq;


//. Genome sequence length: 2032925
//. Short reads positions along the S. mutans genome: FASTQ001.start (1,19,20)
//. Size factors: 0.8700484 1.0158870 1.1285131
//. Number of transcripts: 
//. mean=q*s, size=q*s/d, d=a0+a1/mean
//. a0, a1 = 0.0269 6.2076
//. q is a parameter
//. mean is computed for each transcript
  out << YAML::BeginMap;
  out << YAML::Key << "GenomeLength" << YAML::Value << 2032925;
  out << YAML::Key << "SizeFactor" << YAML::Value << YAML::Flow; 
  out << YAML::BeginSeq << 0.8700484 << 1.0158870 << 1.1285131 << YAML::EndSeq;
  out << YAML::Key << "Alpha0" << YAML::Value << 0.0269;
  out << YAML::Key << "Alpha1" << YAML::Value << 6.2076;
  out << YAML::Key << "NumberK" << YAML::Value << 500;
  out << YAML::Key << "ShortReads" << YAML::Value << YAML::Flow;
  out << YAML::BeginSeq;
  // Read values from FASTQ001.start and write them to YAML.
  std::ifstream myfile ("../../../downloads/FASTQ001.start");
  if (myfile.is_open())
  {
    double value;
    while ( myfile.good() )
    {
      myfile >> value;
      out << value;
    }
    myfile.close();
  }
  // out << 0.8700484 << 1.0158870 << 1.1285131;
  out << YAML::EndSeq;
  out << YAML::EndMap;

  out << YAML::BeginSeq;
  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << YAML::Flow << squares;
  out << YAML::EndSeq;
  out << YAML::BeginSeq;
  out << YAML::Flow << squares;
  out << YAML::Flow << squares;
  out << YAML::EndSeq;
  out << YAML::EndSeq;

  std::cout << "Here's the output YAML:\n" << out.c_str() << std::endl;

  return 0;
}
@



\subsection{EzLogger Library}
<<ezlogger.cpp>>=
// Example code for EZLOGGER macros
#include "ezlogger_headers.hpp"

void some_funcxx()
{
        EZLOGGERFUNCTRACKER;
}

void some_funcx()
{
        EZLOGGERFUNCTRACKER;
        some_funcxx();
}

void some_func6()
{
        EZLOGGERFUNCTRACKER;
        EZLOGGERDISPLAY_STACK;
}

void some_func5(int &x)
{
        EZLOGGERFUNCTRACKER;
        --x;
        if (x > 0)
                some_func5(x); //test recursion
        else
                some_func6();
}

void some_func4()
{
        EZLOGGERFUNCTRACKER;
        int x = 3;
        some_func5(x);
}

void some_func3()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_funcxx();
        some_func4();
}

void some_func2()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_funcxx();
        some_func3();
        some_funcxx();
}

void some_func1()
{
        EZLOGGERFUNCTRACKER;
        some_funcx();
        some_func2();
        some_funcxx();
}

int main(int argc, char**argv)
{
        axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);
        EZLOGGERFUNCTRACKER;
        int ReturnValue = 99;
        EZLOGGER_PRG_MAIN_ARG(argc, argv);
        EZDBGONLYLOGGER_PRG_MAIN_ARG(argc, argv);
        EZLOGGERVL_PRG_MAIN_ARG(axter::log_often, argc, argv);
        int i = 123;
        std::string somedata = "Hello World";
        EZLOGGER(i);
        EZDBGONLYLOGGER(i);
        EZLOGGERVL(axter::log_often)(i);

        EZLOGGERVAR(somedata);
        EZDBGONLYLOGGERVAR(somedata);
        EZLOGGERVLVAR(axter::log_often, somedata);
        
        bool SomeConditionVar = true;
        EZLOGGERVAR(SomeConditionVar == false);
        EZDBGONLYLOGGERVAR(SomeConditionVar == false);
        EZLOGGERVLVAR(axter::log_often, SomeConditionVar == true);

        EZLOGGERVLVARIFY(axter::log_often, SomeConditionVar == false);

        EZLOGGERSTREAM << somedata << " " << i << std::endl;
        EZLOGGERSTREAM << somedata << " next line " << i << std::endl;
        EZLOGGERSTREAM2(std::cerr) << somedata << " next line " << i << std::endl;
        EZDBGONLYLOGGERSTREAM << somedata << " " << i << std::endl;
        EZDBGONLYLOGGERSTREAM << somedata << " next line " << i << std::endl;
        EZLOGGERVLSTREAM(axter::log_often) << somedata << " " << i << std::endl;
        // EZLOGGERVLSTREAM(axter::levels(axter::log_often, axter::warn, __FUNCSIG__ /*or GNU PRETTY_FUNCTION*/,"Xyz Facility")) << somedata << " " << i << std::endl;

        EZLOGGERPRINT("i = %i and somedata = %s", i, somedata.c_str());
        EZDBGONLYLOGGERPRINT("i = %i and somedata = %s", i, somedata.c_str());
        EZLOGGERVLPRINT(axter::log_often)("i = %i and somedata = %s", i, somedata.c_str());
        //Alternative method
        EZLOGGERVL(axter::log_often).cprint("i = %i and somedata = %s", i, somedata.c_str());
        EZLOGGER.cprint("i = %i and somedata = %s", i, somedata.c_str());

        if (1)
        {
                EZLOGGERMARKER;
                EZDBGONLYLOGGERMARKER;
                EZLOGGERVLMARKER(axter::log_often);
        }

        some_func1();

        return EZLOGGERVAR(ReturnValue);
}
@

\subsection{Types}
<<gtypes.h>>=
<<tux gnu copyright>>
#ifndef __G_TYPES_H__
#define __G_TYPES_H__

#include <config.h>

__BEGIN_DECLS

/* Provide type definitions for commonly used types.
 * These are useful because a "gint8" can be adjusted
 * to be 1 byte (8 bits) on all platforms. Similarly and
 * more importantly, "gint32" can be adjusted to be
 * 4 bytes (32 bits) on all platforms.
 */

typedef char   gchar;
typedef short  gshort;
typedef int    gint;
typedef long   glong;
typedef gint   gboolean;

typedef unsigned char   guchar;
typedef unsigned short  gushort;
typedef unsigned int    guint;
typedef unsigned long   gulong;

typedef float   gfloat;
typedef double  gdouble;

typedef signed char gint8;
typedef unsigned char guint8;
typedef signed short gint16;
typedef unsigned short guint16;
typedef signed int gint32;
typedef unsigned int guint32;
typedef signed long gint64;
typedef unsigned long guint64;

/* Define min and max constants for the fixed size numerical types */
#define G_MININT8((gint8)  0x80)
#define G_MAXINT8((gint8)  0x7f)
#define G_MAXUINT8((guint8) 0xff)

#define G_MININT16((gint16)  0x8000)
#define G_MAXINT16((gint16)  0x7fff)
#define G_MAXUINT16((guint16) 0xffff)

#define G_MININT32((gint32)  0x80000000)
#define G_MAXINT32((gint32)  0x7fffffff)
#define G_MAXUINT32((guint32) 0xffffffff)

/* Portable endian checks and conversions
 *
 * glibconfig.h defines G_BYTE_ORDER which expands to one of
 * the below macros.
 */
#define G_LITTLE_ENDIAN 1234
#define G_BIG_ENDIAN    4321
#define G_PDP_ENDIAN    3412/* unused, need specific PDP check */


/* Basic bit swapping functions
 */
#define GUINT16_SWAP_LE_BE_CONSTANT(val)((guint16) ( \
    (guint16) ((guint16) (val) >> 8) |\
    (guint16) ((guint16) (val) << 8)))

#define GUINT32_SWAP_LE_BE_CONSTANT(val)((guint32) ( \
    (((guint32) (val) & (guint32) 0x000000ffU) << 24) | \
    (((guint32) (val) & (guint32) 0x0000ff00U) <<  8) | \
    (((guint32) (val) & (guint32) 0x00ff0000U) >>  8) | \
    (((guint32) (val) & (guint32) 0xff000000U) >> 24)))

__END_DECLS
#endif /* __G_TYPES_H__ */
@

\subsection{Manager}
<<tuxManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXMANAGER_H_
#define _TUXMANAGER_H_
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
namespace tux {
class Manager {
public:
  Fixed* mFixed;
  vector<Reads*> mTxReads;
  vector<unsigned long int> mProcessSeed;
public:
  Manager ();
  Manager (Fixed* m, const vector<Reads*>& shortRead);
  void show();
  void model();
  void mcmc(int r = 0);
  void summarize();
  void save();
  void load();
  void help();
  string logFilename (unsigned int i);
  string chainFilename (unsigned int i);
};
}
#endif // _TUXMANAGER_H_

<<tuxManager.cpp>>=
<<tux gnu copyright>>
#include <fstream>
#include <algorithm>
#include <vector>
#include "ezlogger_headers.hpp"
#include "tuxFixed.h"
#ifdef _MPI
#  include "tuxMcmcMpi.h"
#else
#  include "tuxMcmcSingle.h"
#endif // _MPI
#include "tuxSummarizer.h"
#include "tuxManager.h"
using namespace std;
namespace tux {
Manager::Manager ()
{
}
Manager::Manager (Fixed* m, const vector<Reads*>& shortRead)
  : mFixed(m), mTxReads(shortRead)
{
}
void 
Manager::show()
{
  return;
}
void 
Manager::model()
{
  return;
}
void 
Manager::mcmc(int r)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  string cfn = chainFilename (r);
  ofstream fout(cfn.c_str());
  if (fout.is_open() == false)
    {
      stringstream ss;
      string strLog;
      ss << "Error: Could not open file ``" 
         << cfn
         << "'' for MCMC output!" << endl;
      strLog = ss.str(); 
      EZLOGGERSTREAM << strLog;
      return;
    }
#ifdef _MPI
  McmcMpi mMcmc (mFixed,mTxReads,r);
#else
  McmcSingle mMcmc (mFixed,mTxReads);
#endif // _MPI
  unsigned int s = 0;
  unsigned int sThin = 0;
  while (s < mFixed->mMcmcLength) 
    {
      cerr << "Step: " << s << "\r";
      mMcmc.step (mFixed->mNumberSwap);
      s += mFixed->mNumberSwap; sThin += mFixed->mNumberSwap;
      if (mFixed->mNumberChain > 1)
        {
          mMcmc.swap ();
        }
      if (mFixed->mMcmcBurnin < s)
        {
          if (mFixed->mMcmcThin < sThin)
            {
              sThin -= mFixed->mMcmcThin;
              fout << mMcmc;
            }
        }
    }
  mMcmc.report (fout);
  fout.close();
  return;
}
void 
Manager::summarize()
{
  // Parse using one or more chain files.
  // Compute the mean estimate of the boundaries.
  Summarizer s (mFixed,mTxReads);
  s.execute ();
  return;
}
void 
Manager::save()
{
  return;
}
void 
Manager::load()
{
  return;
}
void 
Manager::help()
{
  return;
}
string 
Manager::logFilename (unsigned int i)
{
  string v(mFixed->mLogDirectory);
  v += mFixed->mPrefix;
  v += ".";
  // See http://www.cplusplus.com/articles/D9j2Nwbp
  string sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
  v += sID;
  v += ".log";
  return v;
}
string 
Manager::chainFilename (unsigned int i)
{
  string v(mFixed->mChainDirectory);
  v += mFixed->mPrefix;
  v += ".";
  string sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
  v += sID;
  v += ".chain";
  return v;
}
}
@

\subsection{Model}
<<tuxModel.h>>=
<<tux gnu copyright>>
#ifndef _TUXMODEL_H_
#define _TUXMODEL_H_
namespace tux {
class Model {
public:
  void full ();
};
}
#endif // _TUXMODEL_H_

<<tuxModel.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxModel.h"
using namespace std;
namespace tux {
void 
Model::full ()
{
  return;
}
}
@

\subsection{Mcmc}
<<tuxMcmc.h>>=
<<tux gnu copyright>>
#ifndef _TUXMCMC_H_
#define _TUXMCMC_H_
#include <cmath>
#include <vector>
#include "tuxChainManager.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class Mcmc {
public:
  unsigned int mRank; 
  Fixed* mFixed;
  vector<Reads*> mTxReads;
  ChainManager mChainManager;
  vector<unsigned int> mChainid;
  vector<double> mTemperature;
  vector<double> mLogLikelihoodPrior;
  vector<unsigned int> mNumberChainPerProcess;
  vector<unsigned int> mAccumulateNumberChain;
  vector<vector<unsigned int> > mSwapCount;
  vector<vector<unsigned int> > mSwapTryCount;

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return current++;}
  } uniqueNumber;

  struct c_hlinear {
    double halpha;
    unsigned int i;
    c_hlinear () {i=0; halpha=0.5;}
    double operator()() {
      double v = 1.0 / (1.0 + halpha * i);
      i++; 
      return v;
    }
  } hlinearNumber;

  struct c_hgeometric {
    unsigned int numChain;
    double halpha, hbeta;
    unsigned int i;
    c_hgeometric () {i=0; numChain = 10; halpha=0.95; hbeta=0.2;}
    double operator()() {
      double v = 1 
                 - (1 - hbeta) * i 
                 * pow (halpha, (double) (numChain - 1 - i)) 
                 / (double) (numChain - 1);
      i++;
      return v; 
    }
  } hgeometricNumber;

  struct c_setNumberChainPerProcess {
    unsigned int current;
    unsigned int numberChainPerProcess;
    unsigned int numberRemainingChain;
    c_setNumberChainPerProcess () {current=0;}
    unsigned int operator() () { 
      if (current++ < numberRemainingChain)
        return numberChainPerProcess + 1;
      else
        return numberChainPerProcess;
    }
  } setNumberChainPerProcess;

  struct c_msg1 {
    unsigned int processid;
    unsigned int chainid;
    double likelihoodPrior;
    void set (unsigned int x, unsigned int y, double z) {
      processid = x; chainid = y; likelihoodPrior = z;
    }
  } mMessage;

private:
  Mcmc ();
public:
  int swapChains ();
  Mcmc (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank);
  ~Mcmc ();
  int numberChainPerProcess ();
  int createChainManager (unsigned int r);
  int step (unsigned int n);
  virtual int swap () = 0;
  int sample ();
  int save ();
  int load ();
  void report (ostream &out);
  friend ostream& operator<< (ostream &out, const Mcmc &t);
};
}
#endif // _TUXMCMC_H_

<<tuxMcmc.cpp>>=
<<tux gnu copyright>>
#include <iomanip>
#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include <numeric>    // partial_sum
#include <functional>
#include <algorithm>  // swap
#include <cassert>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxChainManager.h"
#include "tuxFixed.h"
#include "tuxGslRng.h"
#include "tuxMcmc.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
Mcmc::Mcmc (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank)
  : mRank(rank), mFixed(m), mTxReads(shortRead), mChainManager(m,shortRead)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  numberChainPerProcess ();

  mLogLikelihoodPrior.resize (mFixed->mNumberChain);
  mChainid.resize(mFixed->mNumberChain);
  mTemperature.resize(mFixed->mNumberChain);

  // Each chain has a unique ID.
  uniqueNumber.current = 0;
  generate (mChainid.begin(),mChainid.end(),uniqueNumber);                  

  // Sets the temperature values
  if (mFixed->mNumberChain == 1)
    {
      mTemperature.front() = 1.0;
    }
  else
    {
      hgeometricNumber.numChain = mFixed->mNumberChain;
      hgeometricNumber.halpha = mFixed->mHAlpha;
      hgeometricNumber.hbeta = mFixed->mHBeta;
      generate (mTemperature.begin(),mTemperature.end(),hgeometricNumber);         

      // Swap counts. 
      mSwapCount.resize(mFixed->mNumberChain);
      mSwapTryCount.resize(mFixed->mNumberChain);
      for (unsigned int i = 0; i < mFixed->mNumberChain; i++)
        {
          mSwapCount.at(i).resize(mFixed->mNumberChain,0);
          mSwapTryCount.at(i).resize(mFixed->mNumberChain,0);
        }
    }

  // This needs to be called at the end of the constructor, partly because
  // we need to know temperature values.
  mChainManager.mTemperature = mTemperature;
  createChainManager (rank);
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) 
    << "Process rank - " << rank << endl;
  stringstream ss;
  string strLog;
  ss << "mNumberChainPerProcess -";
  for (unsigned int i = 0; i < mNumberChainPerProcess.size(); i++)
    {
      ss << " " << mNumberChainPerProcess.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
  ss.str(string());
  ss << "mAccumulateNumberChain -";
  for (unsigned int i = 0; i < mAccumulateNumberChain.size(); i++)
    {
      ss << " " << mAccumulateNumberChain.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
  ss.str(string());
  ss << "mChainid -";
  for (unsigned int i = 0; i < mChainid.size(); i++)
    {
      ss << " " << mChainid.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
  ss.str(string());
  ss << "mTemperature -";
  for (unsigned int i = 0; i < mTemperature.size(); i++)
    {
      ss << " " << mTemperature.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
}
Mcmc::~Mcmc () {}
int 
Mcmc::numberChainPerProcess ()
{
  // Allocate chains among processes e.g., (3,3,2).
  setNumberChainPerProcess.current = 0;
  setNumberChainPerProcess.numberChainPerProcess 
    = mFixed->mNumberChain / mFixed->mNumberProcess; 
  setNumberChainPerProcess.numberRemainingChain
    = mFixed->mNumberChain % mFixed->mNumberProcess;
  mNumberChainPerProcess.resize (mFixed->mNumberProcess); 
  generate (mNumberChainPerProcess.begin(), 
            mNumberChainPerProcess.end(), 
            setNumberChainPerProcess);
  unsigned int n;
  n = accumulate(mNumberChainPerProcess.begin(),
                 mNumberChainPerProcess.end(),0U);
  assert (n == mFixed->mNumberChain);

  // Construct a vector of partial sum. e.g., (0,3,6,8).
  mAccumulateNumberChain.resize(mNumberChainPerProcess.size());
  partial_sum(mNumberChainPerProcess.begin(),
              mNumberChainPerProcess.end(),
              mAccumulateNumberChain.begin());
  mAccumulateNumberChain.insert(mAccumulateNumberChain.begin(),0);
  return 0;
}
int 
Mcmc::createChainManager (unsigned int r)
{
  // Create chains for a chain manager.
  unsigned int n = mNumberChainPerProcess.at(r);
  mChainManager.createChain (n);
  // Set chain ID by using a vector of partial sum.
  mChainManager.setChainid (mAccumulateNumberChain[r],
                            mAccumulateNumberChain[r+1]-1);
  return 0;
}
int
Mcmc::step (unsigned int n)
{
#ifdef _DEBUG
  stringstream ss;
  ss << "Mover::step " << n << endl;
  string strLog(ss.str());
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
#endif // _DEBUG
  mChainManager.step (n);
  return 0;
}
int
Mcmc::sample ()
{
  return 0;
}
int
Mcmc::save ()
{
  return 0;
}
int
Mcmc::load ()
{
  return 0;
}
int
Mcmc::swapChains ()
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  vector<unsigned int> chainIndex(mChainid.size());
  for (unsigned int i = 0; i < mChainid.size(); i++)
    chainIndex.at(mChainid.at(i)) = i;

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  ss.str(string());
  ss << "  A-chainIndex" << mRank << ": ";
  for (unsigned int i = 0; i < chainIndex.size(); i++)
    {
      ss << " " << chainIndex.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

  for (unsigned int i = 0; i < mFixed->mNumberSwapTry; i++)
    {
      unsigned int ci, cj;
      ci = static_cast<unsigned int>(
             gsl_rng_uniform_int(gGslRng,
               static_cast<unsigned long int>(mFixed->mNumberChain))
             );
      // We choose cj using a specified step.
      unsigned int l; // left-side positions available
      unsigned int r; // right-side available
      unsigned int b; // 0-th position in the 2*mFixed->mSwapDistance window
      if (ci < mFixed->mSwapDistance)
        l = ci;
      else
        l = mFixed->mSwapDistance;
      b = ci - l;
      if (mFixed->mNumberChain - ci - 1 < mFixed->mSwapDistance)
        r = mFixed->mNumberChain - ci - 1;
      else
        r = mFixed->mSwapDistance;
      cj = ci;
      while (cj == ci)
        {
          // [1, l + 1 + r] is the range from fGslRanMirror.
          // So, we subtract 1 from fGslRanMirror.
          cj = fGslRanMirror (l, r, mFixed->mSwapDistance) - 1 + b;
        }
      
      // Now, we need to know which elements are ci and cj
      // because chain IDs are not consecutive.
      unsigned pi = chainIndex.at(ci);
      unsigned pj = chainIndex.at(cj);
      double sumi = mLogLikelihoodPrior.at(pi);
      double sumj = mLogLikelihoodPrior.at(pj);
      double ti = mTemperature.at(ci);
      double tj = mTemperature.at(cj);
      double logAlpha = (ti - tj) * (sumj - sumi);

      double logAlphaUniform = log(gsl_rng_uniform (gGslRng));
      mSwapTryCount[ci][cj]++; // Later, we will fold the matrix diagonally.
      if (logAlpha < logAlphaUniform)
        {
          // Reject it.
        }
      else
        {
          // Accept it.
          mSwapCount[ci][cj]++;
          std::swap(chainIndex.at(ci),chainIndex.at(cj));
        }
    }

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  ss.str(string());
  ss << "  B-chainIndex" << mRank << ": ";
  for (unsigned int i = 0; i < chainIndex.size(); i++)
    {
      ss << " " << chainIndex.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

  for (unsigned int i = 0; i < mChainid.size(); i++)
    mChainid.at(chainIndex.at(i)) = i;

  return 0;
}
void 
Mcmc::report (ostream &out)
{
  stringstream ss;
  string strLog;
  mChainManager.report (out);

  // Fold the swap matrix diagonally.
  char prev = out.fill('-');
  out << setw(80) << "-" << endl;
  out << "Lower triangular matrix of chains swap rate:" << endl;
  out << setw(80) << "-" << endl;
  out.fill(prev);
  out << setw(5) << setprecision(3);
  unsigned int n = mChainid.size();
  if (n > 1)
    {
      for (unsigned int i = 1; i < n; i++)
        {
          for (unsigned int j = 0; j < i; j++)
            {
              mSwapCount[i][j] += mSwapCount[j][i];
              mSwapTryCount[i][j] += mSwapTryCount[j][i];
            }
        }

      for (unsigned int i = 1; i < n; i++)
        {
          ss.str(string());
          ss << "c" << i;
          strLog = ss.str();
          out << setw(5) << strLog;
          for (unsigned int j = 0; j < i; j++)
            {
              double v = .0;
              if (mSwapTryCount[i][j] > 0)
                {
                  v = static_cast<double>(mSwapCount[i][j]) 
                      / static_cast<double>(mSwapTryCount[i][j])
                      * 100.0;
                }
              out << setw(5) << v;
            }
          out << endl;
        }

      out << setw(5) << "";
      for (unsigned int i = 0; i < n - 1; i++)
        {
          ss.str(string());
          ss << "c" << i;
          strLog = ss.str();
          out << setw(5) << strLog;
        }
      out << endl;
    }
  return;
}
ostream& 
operator<< (ostream &out, const Mcmc &t)
{
  out << t.mChainManager;
  return out;
}
}

<<tuxMcmcMpi.h>>=
<<tux gnu copyright>>
#ifndef _TUXMCMCMPI_H_
#define _TUXMCMCMPI_H_
#include <vector>
#include "tuxMcmc.h"
#include "tuxChainManager.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class McmcMpi: public Mcmc {
private:
  McmcMpi ();
public:
  McmcMpi (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank);
  ~McmcMpi ();
  int swap ();
};
}
#endif // _TUXMCMCMPI_H_

<<tuxMcmcMpi.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <sstream>
#include <vector>
#include <numeric>    // partial_sum
#include <functional>
#include <algorithm>  // swap
#include <mpi.h>
#include <cassert>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxChainManager.h"
#include "tuxFixed.h"
#include "tuxMcmc.h"
#include "tuxMcmcMpi.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
McmcMpi::McmcMpi (Fixed* m, const vector<Reads*>& shortRead, unsigned int rank)
  : Mcmc(m,shortRead,rank)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
}
McmcMpi::~McmcMpi ()
{
}
int
McmcMpi::swap ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  MPI_Status status;

  // Get chain IDs and likelihood prior sum values from each of ChainManagers.
  vector<unsigned int> v1;
  mChainManager.chainid (v1);
  vector<double> v2;
  mChainManager.likelihoodPrior (v2);

  if (mRank==0) 
    {
      // We are at the main process or rank 0 process.
      // Receive messages to fill chain IDs and sums of likelihood and prior.
      for (unsigned int workerIdx = 0; 
           workerIdx < mFixed->mNumberProcess; 
           workerIdx++) 
        {
          for (unsigned int i = mAccumulateNumberChain.at(workerIdx), j = 0;
               i < mAccumulateNumberChain.at(workerIdx+1);
               i++, j++)
            {
              if (mRank == workerIdx)
                {
                  // Process ID, Chain ID, and likelihood/prior value.
                  mMessage.set (i, v1.at(j), v2.at(j)); 
                }
              else
                {
                  MPI_Recv(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 
                           workerIdx, 999, MPI_COMM_WORLD, &status);
                }
              mChainid.at(mMessage.processid) = mMessage.chainid;
              mLogLikelihoodPrior.at(mMessage.processid) = mMessage.likelihoodPrior;
            }
        }
     
//      stringstream result;
//      copy(mChainid.begin(), mChainid.end(), 
//           ostream_iterator<unsigned int>(result, " "));
//      EZLOGGERPRINT("Before Rank 0 chain IDs: %s",result.str().c_str());  

      // Swap chains.
      swapChains ();

//      copy(mChainid.begin(), mChainid.end(), 
//           ostream_iterator<unsigned int>(result, " "));
//      EZLOGGERPRINT("After Rank 0 chain IDs: %s",result.str().c_str());  
      
      // Send messages
      v1.clear();
      v1.resize(mNumberChainPerProcess.at(mRank));
      for (unsigned int workerIdx = 0; 
           workerIdx < mFixed->mNumberProcess; 
           workerIdx++) 
        {
          for (unsigned int i = mAccumulateNumberChain[workerIdx], j = 0;
               i < mAccumulateNumberChain[workerIdx+1];
               i++, j++)
            {
              unsigned int pid = mAccumulateNumberChain[workerIdx] + j;
              assert (pid == i);
              mMessage.set (i, mChainid.at(i), .0); 
              if (mRank == workerIdx)
                {
                  //v1.at(mMessage.processid - mAccumulateNumberChain.at(mRank))
                    //= mMessage.chainid;
                  v1.at(j) = mMessage.chainid;
                }
              else
                {
                  MPI_Send(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 
                           workerIdx, 999, MPI_COMM_WORLD);
                }
            }
        }

      // Check if the message passing.
      //mChainid.assign (lenChain,9);
      //copy(mChainid.begin(), mChainid.end(), 
           //ostream_iterator<unsigned int>(result, " "));
      //EZLOGGERPRINT("After reset 0 chain IDs: %s",result.str().c_str());  
    }
  else 
    {
      // Send messages to rank 0 process
      for (unsigned int i = mAccumulateNumberChain[mRank], j = 0;
           i < mAccumulateNumberChain[mRank+1];
           i++, j++)
        {
          mMessage.set (i, v1.at(j), v2.at(j)); 
          MPI_Send(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 
                   0, 999, MPI_COMM_WORLD);
        }

      // Wait for the decision of the rank 0 process.
      v1.clear();
      v1.resize(mNumberChainPerProcess.at(mRank));
      for (unsigned int i = mAccumulateNumberChain[mRank], j = 0;
           i < mAccumulateNumberChain[mRank+1];
           i++, j++)
        {
          MPI_Recv(&mMessage, sizeof(struct c_msg1), MPI_BYTE, 0, 999, MPI_COMM_WORLD, &status);
          assert(mMessage.processid - mAccumulateNumberChain.at(mRank) < v1.size());
          v1.at(mMessage.processid - mAccumulateNumberChain.at(mRank))
            = mMessage.chainid;
        }
    }
  mChainManager.setChainid (v1);

  return 0;
}
}

<<tuxMcmcSingle.h>>=
<<tux gnu copyright>>
#ifndef _TUXMCMCSINGLE_H_
#define _TUXMCMCSINGLE_H_
#include <vector>
#include "tuxMcmc.h"
#include "tuxChainManager.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class McmcSingle: public Mcmc {
private:
  McmcSingle ();
public:
  McmcSingle (Fixed* m, const vector<Reads*>& shortRead);
  ~McmcSingle ();
  int swap ();
};
}
#endif // _TUXMCMCSINGLE_H_

<<tuxMcmcSingle.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <sstream>
#include <vector>
#include <numeric>    // partial_sum
#include <functional>
#include <algorithm>  // swap
#include <cassert>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGslRng.h"
#include "ezlogger_headers.hpp"
#include "tuxChainManager.h"
#include "tuxFixed.h"
#include "tuxMcmc.h"
#include "tuxMcmcSingle.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
McmcSingle::McmcSingle (Fixed* m, const vector<Reads*>& shortRead)
  : Mcmc(m,shortRead,0)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  assert (mFixed->mNumberProcess == 1);
}
McmcSingle::~McmcSingle ()
{
}
int
McmcSingle::swap ()
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

  // Get chain IDs and likelihood+prior sum values from each of ChainManagers.
  vector<unsigned int> v1;
  vector<double> v2;
  mChainManager.chainid (v1);
  mChainManager.likelihoodPrior (v2);

  assert (mRank == 0);
  assert (mFixed->mNumberProcess == 1);
  if (mRank==0) 
    {
      for (unsigned int workerIdx = 0; 
           workerIdx < mFixed->mNumberProcess; 
           workerIdx++) 
        {
          for (unsigned int i = mAccumulateNumberChain.at(workerIdx), j = 0;
               i < mAccumulateNumberChain.at(workerIdx+1);
               i++, j++)
            {
              if (mRank == workerIdx)
                {
                  // Process ID, Chain ID, and likelihood/prior value.
                  mMessage.set (i, v1.at(j), v2.at(j)); 
                }
              else
                {
                  assert(0);
                }
              mChainid.at(mMessage.processid) = mMessage.chainid;
              mLogLikelihoodPrior.at(mMessage.processid) = mMessage.likelihoodPrior;
            }
        }

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  ss.str(string());
  ss << "A-Rank " << mRank << ": ";
  for (unsigned int i = 0; i < mChainid.size(); i++)
    {
      ss << " " << mChainid.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

      // Swap chains.
      swapChains ();

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  ss.str(string());
  ss << "B-Rank " << mRank << ": ";
  for (unsigned int i = 0; i < mChainid.size(); i++)
    {
      ss << " " << mChainid.at(i);
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_regularly) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

      v1.clear();
      v1.resize(mNumberChainPerProcess.at(mRank));
      for (unsigned int workerIdx = 0; 
           workerIdx < mFixed->mNumberProcess; 
           workerIdx++) 
        {
          for (unsigned int i = mAccumulateNumberChain[workerIdx], j = 0;
               i < mAccumulateNumberChain[workerIdx+1];
               i++, j++)
            {
              unsigned int pid = mAccumulateNumberChain[workerIdx] + j;
              assert (pid == i);
              mMessage.set (i, mChainid.at(i), .0); 
              if (mRank == workerIdx)
                {
                  //v1.at(mMessage.processid - mAccumulateNumberChain.at(mRank))
                    //= mMessage.chainid;
                  v1.at(j) = mMessage.chainid;
                }
              else
                {
                  assert (0);
                }
            }
        }
    }

  mChainManager.setChainid (v1);

  return 0;
}
}
@

\subsection{ChainManager}
<<tuxChainManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXCHAINMANAGER_H_
#define _TUXCHAINMANAGER_H_
#include <iostream>
#include <vector>
using namespace std;
namespace tux {
class Fixed;
class Reads;
class Chain;
class ChainManager {
private:
  ChainManager ();
public:
  Fixed* mFixed;
  vector<Reads*> mTxReads;
  vector<Chain*> mChain;
  vector<double> mTemperature;
public:
  ChainManager (Fixed* m, const vector<Reads*>& shortRead);
  void createChain (unsigned int);
  ~ChainManager ();
  void step (unsigned int);
  void setChainid (unsigned int, unsigned int);
  void setChainid (vector<unsigned int>& v);
  void chainid (vector<unsigned int>&);
  void likelihoodPrior (vector<double>&);
  void report (ostream &out);
  friend ostream& operator<< (ostream &out, const ChainManager &t);
};
}
#endif // _TUXCHAINMANAGER_H_

<<tuxChainManager.cpp>>=
<<tux gnu copyright>>
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <algorithm>     // for_each
#include <vector>
#include <cassert>
#include <functional>    // bind2nd, mem_fun
#include <iomanip>
#include "ezlogger_headers.hpp"
#include "yaml-cpp/yaml.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
using namespace std;
namespace tux {
template <typename T>
void delete_pointed_to (T* p)
{
  delete p;
}
ChainManager::ChainManager (Fixed* m, const vector<Reads*>& shortRead)
  : mFixed(m), mTxReads(shortRead)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
}
ChainManager::~ChainManager ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  for_each(mChain.begin(),mChain.end(),delete_pointed_to<Chain>);
}
void 
ChainManager::createChain (unsigned int n)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  for (unsigned int i = 0; i < n; i++)
    {
      Chain* c = new Chain (mFixed, mTxReads);
      mChain.push_back(c);
    }
  return;
}
void 
ChainManager::step (unsigned int n)
{
//  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
//  I used to do this two lines:
//  stepChain.n = n;
//  for_each (mChain.begin(), mChain.end(), stepChain);
//  And, I was wondering if there are ways of doing this using without having
//    struct c_step {
//      unsigned int n;
//      void operator() (Chain *i) { i->step (n);}
//    } stepChain;
//  but like this
//  for_each(mChain.begin(),mChain.end(),bind1st(mem_fun(&Chain::step),this));
//  I was not happy with either of them. 
//  Try to think about mem_fun1_t.
#ifdef _DEBUG
  stringstream ss;
  ss << "ChainManager::step " << n << endl;
  string strLog(ss.str());
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
#endif // _DEBUG
  for (vector<Chain*>::iterator i = mChain.begin(); i != mChain.end(); i++)
    {
      (*i)->step(n);
    }
  return;
}
void 
ChainManager::setChainid (unsigned int s, unsigned int e)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  assert (e - s + 1 == mChain.size());
  vector<Chain*>::iterator iter1;
  unsigned int i = 0;
  for (iter1 = mChain.begin(); iter1 != mChain.end(); iter1++)
    {
      (*iter1)->mID = s + i;
      (*iter1)->mBeta = mTemperature.at(s + i);
      i++;
    }
}
void 
ChainManager::setChainid (vector<unsigned int>& v)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  assert (v.size() == mChain.size());
  vector<Chain*>::iterator iter1;
  vector<unsigned int>::iterator iter2;
  for (iter1 = mChain.begin(), iter2 = v.begin();
       iter1 != mChain.end();
       iter1++, iter2++)
    {
      (*iter1)->mID = *iter2;
      (*iter1)->mBeta = mTemperature.at(*iter2);
    }
}
void 
ChainManager::chainid (vector<unsigned int>& v)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  v.clear();
  vector<Chain*>::iterator iter1;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      v.push_back((*iter1)->mID);
    }
}
void 
ChainManager::likelihoodPrior (vector<double>& v)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  v.clear();
  vector<Chain*>::iterator iter1;
  for (iter1 = mChain.begin();
       iter1 != mChain.end();
       iter1++)
    {
      double w = (*iter1)->likelihoodPrior ();
      v.push_back(w);
    }
}
void 
ChainManager::report (ostream &out)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  for (vector<Chain*>::iterator i = mChain.begin();
       i != mChain.end();
       i++)
    {
      (*i)->report (out);
    }
  return;
}
ostream& 
operator<< (ostream &out, const ChainManager &t)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  for (vector<Chain*>::const_iterator i = t.mChain.begin();
       i != t.mChain.end();
       i++)
    {
    //  if ((*i)->mID == 0)
      out << **i;
    }
  return out;
}
}
@

\subsection{Chain}
<<tuxChain.h>>=
<<tux gnu copyright>>
#ifndef _TUXCHAIN_H_
#define _TUXCHAIN_H_
#include <iomanip>
#include <iostream>
#include <vector>
#include <string>
#include "tuxMoverManager.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class TxBoundaries;
class TxExpression;
class TxParameter;
class Chain {
private:
  Chain ();
  void createParameter ();
public:
  unsigned int mID;
  unsigned int mStep;
  double mBeta;
  Fixed* mFixed;
  vector<Reads*> mTxReads;
  MoverManager mMoverManager;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
  vector<unsigned int> mTallyChainid;
public:
  Chain (Fixed* m, const vector<Reads*>& shortRead, const double beta = 1.L);
  ~Chain ();
  double likelihoodPrior ();
  void TxFixed (Fixed* m) {mFixed=m;}
  void TxReads (const vector<Reads*>& shortRead) {mTxReads=shortRead;}
  void step (unsigned int n);
  void report (ostream &out);
  friend ostream& operator<< (ostream &out, const Chain &t);
};
}
#endif // _TUXCHAIN_H_

<<tuxChain.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <iostream>
#include <numeric>          // accumulate
#include <cassert>
#include <vector>
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxMoverTxBSingle.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxMoverManager.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxProbTxBoundaries.h" 
#include "tuxProbTxExpression.h" 
#include "tuxLikelihood.h" 
#include "tuxChain.h"
#include "ezlogger_headers.hpp"

using namespace std;
namespace tux {
Chain::Chain (Fixed* m, const vector<Reads*>& shortRead, const double beta)
  : mID(0), mStep(0),
    mBeta(beta), mFixed(m), mTxReads(shortRead)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  createParameter ();
}
Chain::~Chain ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  delete mTxBoundaries;
  delete mTxExpression;
  delete mTxParameter;
}
double 
Chain::likelihoodPrior ()
{
  return mTxParameter->mLoglikelihood + mTxParameter->mLogprior;
}
void 
Chain::createParameter ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  Reads* r = mTxReads.front();
  ProbTxBoundaries factoryTxBoundaries (r->size(),mFixed->K());
  mTxBoundaries = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  ProbTxExpression factoryTxExpression (mFixed->K());
  mTxExpression = static_cast<TxExpression*>(factoryTxExpression.r());
  mTxParameter = new TxParameter;

  // Boundaries mover
  MoverTxBoundaries* d1 = new MoverTxBoundaries (mFixed, 
                                                 mTxReads, 
                                                 mTxBoundaries, 
                                                 mTxExpression,
                                                 mTxParameter);
  mMoverManager.add (d1, 1U, mFixed->mMoverTxBWeight);
  // Expression mover
  MoverTxExpression* d2 = new MoverTxExpression (mFixed, 
                                                 mTxReads, 
                                                 mTxBoundaries, 
                                                 mTxExpression,
                                                 mTxParameter);
  mMoverManager.add (d2, 2U, mFixed->mMoverTxEWeight);
  // Boundaries single mover
  MoverTxBSingle* d3 = new MoverTxBSingle (mFixed, 
                                           mTxReads, 
                                           mTxBoundaries, 
                                           mTxExpression,
                                           mTxParameter);
  mMoverManager.add (d3, 3U, mFixed->mMoverTxBSingleWeight);

  // Compute the total likelihood.
  mTxParameter->mLoglikelihood = .0;
  if (mFixed->mIsData == true)
    {
      Likelihood factoryLikelihood (mFixed, mTxBoundaries, mTxExpression);
      for (vector<Reads*>::iterator i = mTxReads.begin(); 
           i != mTxReads.end(); 
           i++)
        {
          // We need mCount and mN to compute the total likelihood.
          factoryLikelihood.mCount =  (*i)->mCount;
          factoryLikelihood.mN =  (*i)->mN;
          mTxParameter->mLoglikelihood += factoryLikelihood.d ();
        }
    }
  mTallyChainid.resize(mFixed->mNumberChain,0);
  return;
}
void 
Chain::step (unsigned int n)
{
//  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  for (unsigned int i = 0; i < n; i++, mStep++)
    {
      EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
        << "Step " << mStep << endl;
      Mover* m = mMoverManager.choose ();
      m->step ();
    }
  mTallyChainid.at(mID) += n;
  return;
}
void 
Chain::report (ostream &out)
{
  stringstream ss; 
  string strLog;

  out << mMoverManager << endl;
  unsigned int n;
  n = accumulate(mTallyChainid.begin(),mTallyChainid.end(),0);
  out << setprecision(3);
  for (unsigned int i = 0; i < mTallyChainid.size(); i++)
    {
      double v = static_cast<double>(mTallyChainid.at(i))
                 /static_cast<double>(n) * 100.0;
      ss.str(string());
      ss << "c" << i;
      strLog = ss.str();
      out << setw(3) << strLog << setw(5) << v << " ";
    }
  out << endl;
  return;
}
ostream& 
operator<< (ostream &out, const Chain &t)
{
  out << "-" << endl
      << "  - [" << t.mID << ", " << t.mStep << "]" << endl
      << "  - [" << t.mBeta << ", " << t.mTxParameter->mLoglikelihood 
      << "]" << endl
      << *(t.mTxBoundaries)
      << *(t.mTxExpression);
  return out;
}
}
@

\subsection{RandomVariable}
<<tuxRandomVariable.h>>=
<<tux gnu copyright>>
#ifndef _TUXRANDOMVARIABLE_H_
#define _TUXRANDOMVARIABLE_H_
namespace tux {
class RandomVariable {
public:
  unsigned int id; // Nothing.
};
}
#endif // _TUXRANDOMVARIABLE_H_

<<tuxRandomVariable.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxRandomVariable.h"
using namespace std;
namespace tux {
}
@

\subsection{Parameter}
<<tuxParameter.h>>=
<<tux gnu copyright>>
#ifndef _TUXPARAMETER_H_
#define _TUXPARAMETER_H_
#include "tuxRandomVariable.h"
namespace tux {
class Parameter: public RandomVariable {
};
}
#endif // _TUXPARAMETER_H_

<<tuxParameter.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxParameter.h"
using namespace std;
namespace tux {
}
@

\subsection{TxBoundaries}
<<tuxTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXBOUNDARIES_H_
#define _TUXTXBOUNDARIES_H_
#include <iostream>
#include <vector>
#include "yaml-cpp/yaml.h"
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxBoundaries: public Parameter {
public:
  vector<unsigned int> mC;
  unsigned int mLengthSampleSegmentA;
  unsigned int mLengthSampleSegmentB;
public:
  TxBoundaries (const vector<unsigned int>& c);
  TxBoundaries ();
  bool check ();
  unsigned int size () {return mC.size();}
  unsigned int L () {return mC.back();}
  void seq (unsigned int from, unsigned int to, unsigned int by);
  void sampleSegment (unsigned int&, unsigned int&);
  void sampleSegment (vector<unsigned int>& right);
  struct c_seq {
    unsigned int from,by,c;
    c_seq () {from=0;by=1;c=from-by;}
    void reset (unsigned int ifrom, unsigned int iby) {
      from=ifrom;by=iby;c=from-by;
    }
    unsigned int operator()() {c+=by;return c;}
  } mSeq;
  friend YAML::Emitter& operator<< (YAML::Emitter &out, 
                                    const TxBoundaries &tx);
  friend ostream& operator<< (ostream &out, const TxBoundaries &t);
};
}
#endif // _TUXTXBOUNDARIES_H_

<<tuxTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>  // generate, upper_bound
#include <cassert>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxGslRng.h"
#include "tuxTxBoundaries.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
TxBoundaries::TxBoundaries (const vector<unsigned int>& c)
  : mC(c)
{
}
TxBoundaries::TxBoundaries () 
{
  mLengthSampleSegmentA = 0;
  mLengthSampleSegmentB = 0;
}
bool 
TxBoundaries::check ()
{
  bool v = true;
  unsigned int leftC = mC.front();
  unsigned int rightC;
  for (unsigned int i = 1; i < mC.size(); i++)
    {
      rightC = mC.at(i); 
      if (!(leftC < rightC))
        {
          v = false;
          break;
        }
      leftC = rightC;
    }
  return v;
}
void 
TxBoundaries::seq (unsigned int from, unsigned int to, unsigned int by)
{
  mSeq.reset (from, by);
  unsigned int a = (to - from) / by + 1;
  mC.resize(a);
  generate(mC.begin(),mC.end(),mSeq);
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const TxBoundaries &tx)
{
  out << YAML::BeginMap;
  out << YAML::Key << "TxBoundaries";
  out << YAML::Value << YAML::BeginSeq << YAML::Flow << tx.mC << YAML::EndSeq;
  out << YAML::EndMap;
  return out;
}
ostream& 
operator<< (ostream &out, const TxBoundaries &t)
{
  out << "  - [";
  copy(t.mC.begin(), t.mC.end() - 1, 
       ostream_iterator<unsigned int>(out, ", ") );
  out << t.mC.back() << "]" << endl;
  return out;
}
void
TxBoundaries::sampleSegment (unsigned int& left, unsigned int& right)
{
  unsigned long int l = static_cast<unsigned long int>(mC.back());
  unsigned int s, e, d;
  vector<unsigned int>::iterator upLeft = mC.end();
  vector<unsigned int>::iterator upRight = mC.end();
  while (upLeft == mC.end() || upRight == mC.end() || d < 1)
    {
      s = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
      e = s + mLengthSampleSegmentA;
      upLeft = upper_bound(mC.begin(),mC.end(),s);
      upRight = upper_bound(mC.begin(),mC.end(),e);
      d = static_cast<unsigned int>(distance(upLeft,upRight));
    }
  left = static_cast<unsigned int>(upLeft - mC.begin());
  right = static_cast<unsigned int>(upRight - mC.begin());
  return;
}
void
TxBoundaries::sampleSegment (vector<unsigned int>& right)
{
  right.clear();
  unsigned int lengthOfChromosome = mC.back();
  double A = static_cast<double>(mLengthSampleSegmentA);
  double B = static_cast<double>(mLengthSampleSegmentB);
  unsigned int pos = 0;
  unsigned int r; 
  while (pos < lengthOfChromosome)
    {
      double l = gsl_ran_flat (gGslRng, A, B);
      unsigned int interval = static_cast<unsigned int>(l + 0.5L);
      pos += interval;
      //cerr << "Pos: " << pos << endl;
      if (pos < lengthOfChromosome)
        {
          vector<unsigned int>::iterator upRight;
          upRight = upper_bound(mC.begin(),mC.end(),pos);
          r = static_cast<unsigned int>(upRight - mC.begin());
        }
      else
        {
          r = mC.size() - 1;
        }
      right.push_back(r);
      pos = mC.at(r);
    } 
  return;
}
}
@

\subsection{TxExpression}
<<tuxTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXEXPRESSION_H_
#define _TUXTXEXPRESSION_H_
#include <cassert>
#include <vector>
#include "yaml-cpp/yaml.h"
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxExpression: public Parameter {
public:
  vector<double> mDelta;
public:
  TxExpression (const vector<double>& d);
  TxExpression ();
  void seq (unsigned int);
  friend YAML::Emitter& operator<< (YAML::Emitter &out, 
                                    const TxExpression &tx);
  friend ostream& operator<< (ostream &out, const TxExpression &t);
  struct c_seq {
    double by,c;
    c_seq () {by=.1L;c=.0L;}
    void reset (double iby) {
      by=iby;c=.0L;
    }
    double operator()() {c+=by;return c;}
  } mSeq;
};
}
#endif // _TUXTXEXPRESSION_H_

<<tuxTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <iterator>
#include "yaml-cpp/yaml.h"
#include "tuxTxExpression.h"
using namespace std;
namespace tux {
TxExpression::TxExpression (const vector<double>& d)
  : mDelta(d)
{
}
TxExpression::TxExpression ()
{
 
}
void 
TxExpression::seq (unsigned int num)
{
  assert (num > 1);
  double by = 1.0L / static_cast<double>(num); 
  mDelta.resize(num,by);
  return;
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const TxExpression &tx)
{
  out << YAML::BeginMap;
  out << YAML::Key << "TxExpression";
  out << YAML::Value << YAML::BeginSeq;
  out << YAML::Flow << tx.mDelta << YAML::EndSeq;
  out << YAML::EndMap;
  return out;
}
ostream& 
operator<< (ostream &out, const TxExpression &t)
{
  out << "  - [";
  copy(t.mDelta.begin(), t.mDelta.end() - 1, 
       ostream_iterator<double>(out, ", ") );
  out << t.mDelta.back() << "]" << endl;
  return out;
}
}
@

\subsection{TxParameter}
<<tuxTxParameter.h>>=
<<tux gnu copyright>>
#ifndef _TUXTXPARAMETER_H_
#define _TUXTXPARAMETER_H_
#include <cassert>
#include <vector>
#include "yaml-cpp/yaml.h"
#include "tuxParameter.h"
using namespace std;
namespace tux {
class TxParameter: public Parameter {
public:
  double mLoglikelihood;
  double mLogprior;
public:
  TxParameter ();
  friend YAML::Emitter& operator<< (YAML::Emitter &out, 
                                    const TxParameter &tx);
  friend ostream& operator<< (ostream &out, const TxParameter &t);
};
}
#endif // _TUXTXPARAMETER_H_

<<tuxTxParameter.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <iterator>
#include "yaml-cpp/yaml.h"
#include "tuxTxParameter.h"
using namespace std;
namespace tux {
TxParameter::TxParameter ()
  : mLoglikelihood(.0), mLogprior(.0)
{
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const TxParameter &tx)
{
  out << YAML::BeginMap;
  out << YAML::Key << "TxParameter";
  out << YAML::Value << YAML::BeginSeq;
  out << YAML::Flow << tx.mLoglikelihood << tx.mLogprior << YAML::EndSeq;
  out << YAML::EndMap;
  return out;
}
ostream& 
operator<< (ostream &out, const TxParameter &t)
{
  out << "  - ["
      << t.mLoglikelihood
      << ", "
      << t.mLogprior;
  out << "]" << endl;
  return out;
}
}
@

\subsection{Data}
<<tuxData.h>>=
<<tux gnu copyright>>
#ifndef _TUXDATA_H_
#define _TUXDATA_H_
#include "tuxRandomVariable.h"
namespace tux {
class Data: public RandomVariable {
};
}
#endif // _TUXDATA_H_

<<tuxData.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxData.h"
using namespace std;
namespace tux {
}
@

\subsection{Reads}
<<tuxReads.h>>=
<<tux gnu copyright>>
#ifndef _TUXREADS_H_
#define _TUXREADS_H_
#include <iostream>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxGslRng.h"
#include "tuxData.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
class Reads: public Data {
public:
  vector<unsigned int> mCount;
  unsigned int mN;
  unsigned int mJ;
public:
  Reads (unsigned int j = 0);
  unsigned int size () {return mCount.size();}
  void sample (unsigned int l, unsigned int ul = 10);
  friend YAML::Emitter& operator<< (YAML::Emitter &out, const Reads &tx);
  friend void operator>> (const YAML::Node& node, Reads& t);
  friend ostream& operator<< (ostream &out, const Reads &t);
  friend istream& operator>> (istream &in, Reads &t);
  void summary (ostream &out);

  struct c_uniformInt {
    unsigned int l;
    c_uniformInt () {l=1000;}
    unsigned int operator()() {
      return static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
    }
  } mUniformInt;
};
}
#endif // _TUXREADS_H_
@

<<tuxReads.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <algorithm>        // generate
#include <numeric>          // accumulate
#include <iterator>         // ostream_iterator
#include <cassert>
#include "yaml-cpp/yaml.h"
#include "ezlogger_headers.hpp"
#include "tuxGslRng.h"
#include "tuxReads.h"
<<extern tuxGslRng>>
<<extern tuxlf>>
using namespace std;
namespace tux {
Reads::Reads (unsigned int j)
{
  mN = 0;
  mJ = j; 
}
void
Reads::sample (unsigned int l, unsigned int ul)
{
  mUniformInt.l = ul;
  mCount.resize(l);
  generate(mCount.begin(),mCount.end(),mUniformInt);
  mN = accumulate(mCount.begin(),mCount.end(),0);
}
ostream& 
operator<< (ostream &out, const Reads &t)
{
//  assert (t.mCount.size() > 0);
//  out << "Reads:" << endl
//      << "  - [";
//  copy(t.mCount.begin(), t.mCount.end() - 1, 
//       ostream_iterator<unsigned int>(out, ", ") );
//  out << t.mCount.back() << "]" << endl;
  copy(t.mCount.begin(), t.mCount.end() - 1, 
       ostream_iterator<unsigned int>(out, " ") );
  out << t.mCount.back();
  return out;
}
istream& operator>> (istream &fin, Reads &t)
{
  vector<unsigned int> a;
  string input;
  unsigned int nC = 0;
  while (!fin.eof()) 
    {
      char c = fin.peek();
      while (c == ' ')
        {
          c = fin.peek();
          if (c == ' ')
            c = fin.get();
          else
            break;
        }
      input.clear();
      if (isdigit(c))
        {
          c = fin.get();
          while (isdigit(c))
            {
              input += c;
              c = fin.get();
            }
          a.push_back(static_cast<unsigned int>
                      (strtoul(input.c_str(),NULL,0)));
          nC++;
          while (c == ' ')
            {
              c = fin.peek();
              if (c == ' ')
                {
                  c = fin.get();
                }
              else
                {
                  if (c == '\n')
                    c = fin.get();
                  else
                    c = ' ';
                  break;
                }
            }
          if (c != ' ')
            {
              EZLOGGERVLSTREAM2(axter::log_regularly,lf) 
                << "A new line in data section." << std::endl;
              t.mCount = a;
              a.clear();
              EZLOGGERVLSTREAM2(axter::log_regularly,lf) 
                << "Data " 
                << t.mJ
                << " - nC is " << nC << std::endl;
              c = fin.get();
              if (!fin.eof())
                fin.unget();
              break;
            }
        }
      else
        {
          if (!fin.eof()) 
            {
              nC++;
              EZLOGGERSTREAM2(lf) << "Fatal: counts must be numbers. "
                                  << "Character " << c << " is found at "
                                  << nC << "th from the start of the data."
                                  << std::endl;
              break;
            }
        }
    } 
  t.mN = accumulate(t.mCount.begin(),t.mCount.end(),0);

  stringstream ss; 
  ss << "Total number of reads is " << t.mN 
     << " from " << t.mCount.size() << " sites." << endl;
  string strLog(ss.str());
  EZLOGGERSTREAM2(lf) << strLog; 
  return fin;
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const Reads &t)
{
  out << YAML::BeginMap 
      << YAML::Key << "Reads" 
      << YAML::Value << YAML::BeginSeq << YAML::Flow << t.mCount << YAML::EndSeq
      << YAML::EndMap;
  return out;
}
void 
operator>> (const YAML::Node& node, Reads& t)
{
  node[t.mJ] >> t.mCount;
  t.mN = accumulate(t.mCount.begin(),t.mCount.end(),0);
  return;
}
void 
Reads::summary (ostream &out)
{
  out << "Reads #" << mJ << " - " << mN << endl;
  return;
}
}
@

\subsection{Fixed}
We use the following order of option setup: \Cclass{Default}, \Cclass{Fixed},
and the command line options in the \program{tux}.
<<tuxFixed.h>>=
<<tux gnu copyright>>
#ifndef _TUXFIXED_H_
#define _TUXFIXED_H_
#include <string>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "yaml-cpp/yaml.h"
#include "tuxData.h"
using namespace std;
namespace tux {
class Fixed: public Data {
public:
  double mMoverTxBSingleWeight;
  double mMoverTxBWeight;
  double mMoverTxEWeight;
  unsigned int mLogVerbosity;
  unsigned long int mSeed;
  unsigned int mL;
  unsigned int mK;
  double mM;
  vector<double> mZ;
  double mA0;
  double mA1;
  double mAlphaQExpression;
  double mAlphaQBoundaries;
  unsigned int mLengthSampleSegmentA;
  unsigned int mLengthSampleSegmentB;
  double mAlphaPriorExpression;
  unsigned int mMcmcLength;
  unsigned int mMcmcBurnin;
  unsigned int mMcmcThin;
  unsigned int mNumberProcess;
  unsigned int mNumberChain;
  unsigned int mNumberSwap;
  unsigned int mNumberSwapTry;
  unsigned int mSwapDistance;
  double mHAlpha;
  double mHBeta;
  string mPrefix;
  string mOutDirectory;
  string mChainDirectory;
  string mLogDirectory;
  string mLogfile;
  string mDatafile;
  bool mIsData;
public:
  Fixed ();
  ~Fixed ();
  void init ();
  bool check ();
  unsigned int K () {return mK;}
  unsigned int L () {return mL;}
  friend YAML::Emitter& operator<< (YAML::Emitter &out, const Fixed &t);
  friend void operator>> (const YAML::Node& node, Fixed& t);
  friend ostream& operator<< (ostream &out, const Fixed& t);
  string chainFilename (unsigned int i);
  string outFilename (unsigned int i);
  string pFilename (int i = -1);
  string prefixFilename (int i = -1);
};
}
#endif // _TUXFIXED_H_
@

<<tuxFixed.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <iostream>
#include "yaml-cpp/yaml.h"
#include "ezlogger_headers.hpp"
#include "tuxDefault.h"
#include "tuxFixed.h"
<<extern tuxlf>>
using namespace std;
namespace tux {
Fixed::Fixed ()
  : 
    mMoverTxBSingleWeight(Default::mMoverTxBSingleWeight),
    mMoverTxBWeight(Default::mMoverTxBWeight),
    mMoverTxEWeight(Default::mMoverTxEWeight),
    mLogVerbosity(Default::mLogVerbosity),
    mSeed(Default::mSeed),

    mAlphaQExpression(100.0), mAlphaQBoundaries(100.0),
    mLengthSampleSegmentA(5000U),
    mLengthSampleSegmentB(15000U),
    mMcmcLength(1000000U), mMcmcBurnin(500000U), mMcmcThin(5000U),
    mNumberProcess(1U), mNumberChain(1U), mNumberSwap(0U), mNumberSwapTry(0U),
    mSwapDistance(7),
    mHAlpha(0.98), mHBeta(.9), 
    mIsData(Default::mIsData)
{
  //cout << Default::mDatafile << endl; // Not constructed
}
Fixed::~Fixed ()
{
  
}
void
Fixed::init ()
{
  mMoverTxBSingleWeight = Default::mMoverTxBSingleWeight;
  mMoverTxBWeight       = Default::mMoverTxBWeight;
  mMoverTxEWeight       = Default::mMoverTxEWeight;
  mLogVerbosity         = Default::mLogVerbosity;
  mSeed                 = Default::mSeed;
  mL                    = Default::mL;
  mK                    = Default::mK;
  mM                    = Default::mM;
  //vector<double> mZ;
  mA0                   = Default::mA0;
  mA1                   = Default::mA1;
  mAlphaQExpression     = Default::mAlphaQExpression;
  mAlphaQBoundaries     = Default::mAlphaQBoundaries;
  mLengthSampleSegmentA = Default::mLengthSampleSegmentA;
  mLengthSampleSegmentB = Default::mLengthSampleSegmentB;
  //double mAlphaPriorExpression;
  mMcmcLength           = Default::mMcmcLength;
  mMcmcBurnin           = Default::mMcmcBurnin;
  mMcmcThin             = Default::mMcmcThin;
  mNumberProcess        = Default::mNumberProcess;
  mNumberChain          = Default::mNumberChain;
  mNumberSwap           = Default::mNumberSwap;
  mNumberSwapTry        = Default::mNumberSwapTry;
  mSwapDistance         = Default::mSwapDistance;
  mHAlpha               = Default::mHAlpha;
  mHBeta                = Default::mHBeta;
  mPrefix               = Default::mPrefix;
  mOutDirectory         = Default::mOutDirectory;
  mChainDirectory       = Default::mChainDirectory;
  mLogDirectory         = Default::mLogDirectory;
  //mLogfile              = Default::mLogfile;
  mDatafile             = Default::mDatafile;
  mIsData               = Default::mIsData;
  return;
}
bool 
Fixed::check ()
{
  bool v = true;
  if (!(1 <= mLogVerbosity && mLogVerbosity <= 5))
    {
      mLogVerbosity = Default::mLogVerbosity;
    }
  return v; 
}
ostream&
operator<< (ostream &out, const Fixed &t)
{
  out << "Fixed: " << endl
      << "  " << "mMoverTxBSingleWeight"
      << ": " << t.mMoverTxBSingleWeight << endl
      << "  " << "mMoverTxBWeight"
      << ": " << t.mMoverTxBWeight << endl
      << "  " << "mMoverTxEWeight"
      << ": " << t.mMoverTxEWeight << endl
      << "  " << "mLogVerbosity"
      << ": " << t.mLogVerbosity << endl
      << "  " << "mSeed"
      << ": " << t.mSeed << endl
      << "  " << "mL"
      << ": " << t.mL << endl
      << "  " << "mK"
      << ": " << t.mK << endl
      << "  " << "mM"
      << ": " << t.mM << endl
      << "  " << "mZ"
      << ": " << endl;
  for (vector<double>::const_iterator i = t.mZ.begin(); i != t.mZ.end(); i++)
    {
      out << "    - " << *i << endl;
    }
  out << "  " << "mA0"
      << ": " << t.mA0 << endl
      << "  " << "mA1"
      << ": " << t.mA1 << endl
      << "  " << "mAlphaQExpression"
      << ": " << t.mAlphaQExpression << endl
      << "  " << "mAlphaQBoundaries"
      << ": " << t.mAlphaQBoundaries << endl
      << "  " << "mLengthSampleSegmentA"
      << ": " << t.mLengthSampleSegmentA << endl
      << "  " << "mLengthSampleSegmentB"
      << ": " << t.mLengthSampleSegmentB << endl
      << "  " << "mAlphaPriorExpression"
      << ": " << t.mAlphaPriorExpression << endl
      << "  " << "mMcmcLength"
      << ": " << t.mMcmcLength << endl
      << "  " << "mMcmcBurnin"
      << ": " << t.mMcmcBurnin << endl
      << "  " << "mMcmcThin"
      << ": " << t.mMcmcThin << endl
      << "  " << "mNumberProcess"
      << ": " << t.mNumberProcess << endl
      << "  " << "mNumberChain"
      << ": " << t.mNumberChain << endl
      << "  " << "mNumberSwap"
      << ": " << t.mNumberSwap << endl
      << "  " << "mNumberSwapTry"
      << ": " << t.mNumberSwapTry << endl
      << "  " << "mSwapDistance"
      << ": " << t.mSwapDistance << endl
      << "  " << "mHAlpha"
      << ": " << t.mHAlpha << endl
      << "  " << "mHBeta"
      << ": " << t.mHBeta << endl
      << "  " << "mPrefix"
      << ": " << t.mPrefix << endl
      << "  " << "mOutDirectory"
      << ": " << t.mOutDirectory << endl
      << "  " << "mChainDirectory"
      << ": " << t.mChainDirectory << endl
      << "  " << "mLogDirectory"
      << ": " << t.mLogDirectory << endl
      << "  " << "mDatafile"
      << ": " << t.mDatafile << endl;
  if (t.mIsData == true) 
    out << "  mIsData: true" << endl;
  else
    out << "  mIsData: false" << endl;
  out << "---" << endl;
  return out;
}
YAML::Emitter& 
operator<< (YAML::Emitter &out, const Fixed &t)
{
  out << YAML::BeginMap << YAML::Key << "Fixed" << YAML::Value;
  out << YAML::BeginMap
      << YAML::Key << "mMoverTxBSingleWeight"
      << YAML::Value << t.mMoverTxBSingleWeight
      << YAML::Key << "mMoverTxBWeight"
      << YAML::Value << t.mMoverTxBWeight
      << YAML::Key << "mMoverTxEWeight"
      << YAML::Value << t.mMoverTxEWeight
      << YAML::Key << "mLogVerbosity"
      << YAML::Value << t.mLogVerbosity
      << YAML::Key << "mSeed"
      << YAML::Value << t.mSeed
      << YAML::Key << "mL"
      << YAML::Value << t.mL
      << YAML::Key << "mK"
      << YAML::Value << t.mK
      << YAML::Key << "mM"
      << YAML::Value << t.mM
      << YAML::Key << "mZ"
      << YAML::Value << t.mZ
      << YAML::Key << "mA0"
      << YAML::Value << t.mA0
      << YAML::Key << "mA1"
      << YAML::Value << t.mA1
      << YAML::Key << "mAlphaQExpression"
      << YAML::Value << t.mAlphaQExpression
      << YAML::Key << "mAlphaQBoundaries"
      << YAML::Value << t.mAlphaQBoundaries
      << YAML::Key << "mLengthSampleSegmentA"
      << YAML::Value << t.mLengthSampleSegmentA
      << YAML::Key << "mLengthSampleSegmentB"
      << YAML::Value << t.mLengthSampleSegmentB
      << YAML::Key << "mAlphaPriorExpression"
      << YAML::Value << t.mAlphaPriorExpression
      << YAML::Key << "mMcmcLength"
      << YAML::Value << t.mMcmcLength
      << YAML::Key << "mMcmcBurnin"
      << YAML::Value << t.mMcmcBurnin
      << YAML::Key << "mMcmcThin"
      << YAML::Value << t.mMcmcThin
      << YAML::Key << "mNumberProcess"
      << YAML::Value << t.mNumberProcess
      << YAML::Key << "mNumberChain"
      << YAML::Value << t.mNumberChain
      << YAML::Key << "mNumberSwap"
      << YAML::Value << t.mNumberSwap
      << YAML::Key << "mNumberSwapTry"
      << YAML::Value << t.mNumberSwapTry
      << YAML::Key << "mSwapDistance"
      << YAML::Value << t.mSwapDistance
      << YAML::Key << "mHAlpha"
      << YAML::Value << t.mHAlpha
      << YAML::Key << "mHBeta"
      << YAML::Value << t.mHBeta
      << YAML::Key << "mPrefix"
      << YAML::Value << t.mPrefix
      << YAML::Key << "mOutDirectory"
      << YAML::Value << t.mOutDirectory
      << YAML::Key << "mChainDirectory"
      << YAML::Value << t.mChainDirectory
      << YAML::Key << "mLogDirectory"
      << YAML::Value << t.mLogDirectory
      << YAML::Key << "mDatafile"
      << YAML::Value << t.mDatafile
      << YAML::Key << "mIsData"
      << YAML::Value << t.mIsData
      << YAML::EndMap;
  out << YAML::EndMap;
  return out;
}
void 
operator>> (const YAML::Node& node, Fixed& t) 
{
  // See yaml-cpp/include/yaml-cpp/exceptions.h
  // for exception handlers
  try 
    {
      node["mMoverTxBSingleWeight"] >> t.mMoverTxBSingleWeight;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mMoverTxBSingleWeight = Default::mMoverTxBSingleWeight;
    }
  try 
    {
      node["mMoverTxBWeight"] >> t.mMoverTxBWeight;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mMoverTxBWeight = Default::mMoverTxBWeight;
    }
  try 
    {
      node["mMoverTxEWeight"] >> t.mMoverTxEWeight;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mMoverTxEWeight = Default::mMoverTxEWeight;
    }
  try 
    {
      node["mLogVerbosity"] >> t.mLogVerbosity;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mLogVerbosity = Default::mLogVerbosity;
    }
  try 
    {
      node["mSeed"] >> t.mSeed;
    } 
  catch(YAML::KeyNotFound& e) 
    {
      t.mSeed = Default::mSeed;
    }
  try 
    {
      node["mL"] >> t.mL;
    }
  catch(YAML::KeyNotFound& e) 
    {
      t.mL = Default::mL;
    }
  node["mK"] >> t.mK;
  node["mM"] >> t.mM;
  node["mZ"] >> t.mZ;
  node["mA0"] >> t.mA0;
  node["mA1"] >> t.mA1;
  node["mAlphaQExpression"] >> t.mAlphaQExpression;
  node["mAlphaQBoundaries"] >> t.mAlphaQBoundaries;
  node["mLengthSampleSegmentA"] >> t.mLengthSampleSegmentA;
  node["mLengthSampleSegmentB"] >> t.mLengthSampleSegmentB;
  node["mAlphaPriorExpression"] >> t.mAlphaPriorExpression;
  node["mMcmcLength"] >> t.mMcmcLength;
  node["mMcmcBurnin"] >> t.mMcmcBurnin;
  node["mMcmcThin"] >> t.mMcmcThin;
  node["mNumberProcess"] >> t.mNumberProcess;
  node["mNumberChain"] >> t.mNumberChain;
  node["mNumberSwap"] >> t.mNumberSwap;
  node["mNumberSwapTry"] >> t.mNumberSwapTry;
  node["mSwapDistance"] >> t.mSwapDistance;
  node["mHAlpha"] >> t.mHAlpha;
  node["mHBeta"] >> t.mHBeta;
  node["mPrefix"] >> t.mPrefix;
  node["mOutDirectory"] >> t.mOutDirectory;
  node["mChainDirectory"] >> t.mChainDirectory;
  node["mLogDirectory"] >> t.mLogDirectory;
  node["mDatafile"] >> t.mDatafile;
  try 
    {
      node["mIsData"] >> t.mIsData;
    }
  catch(YAML::KeyNotFound& e) 
    {
      t.mIsData = Default::mIsData;
    }
  return;
}
string 
Fixed::chainFilename (unsigned int i)
{
  string v(mChainDirectory);
  v += mPrefix;
  v += ".";
  string sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
  v += sID;
  v += ".chain";
  return v;
}
string 
Fixed::outFilename (unsigned int i)
{
  string v(mOutDirectory);
  v += mPrefix;
  v += ".";
  string sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
  v += sID;
  v += ".out";
  return v;
}
string 
Fixed::pFilename (int i)
{
  string v(mOutDirectory);
  v += mPrefix;
  v += ".";
  if (!(i < 0))
    {
      string sID;
      sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
      v += sID;
      v += ".";
    }
  v += "p";
  return v;
}

string 
Fixed::prefixFilename (int i)
{
  string v(mOutDirectory);
  v += mPrefix;
  v += ".";
  if (!(i < 0))
    {
      string sID;
      sID = static_cast<ostringstream*>(&(ostringstream() << i))->str();
      v += sID;
      v += ".";
    }
  return v;
}
}
@

\subsection{Probability}
<<tuxProbability.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBABILITY_H_
#define _TUXPROBABILITY_H_
#include <vector>
using namespace std;
namespace tux {
class RandomVariable;
class Probability {
public:
  virtual double d () = 0;
  virtual RandomVariable* r () = 0;
};
}
#endif // _TUXPROBABILITY_H_

<<tuxProbability.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxProbability.h"
using namespace std;
namespace tux {
}
@

\subsection{ProbTxBoundaries}
<<tuxProbTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBTXBOUNDARIES_H_
#define _TUXPROBTXBOUNDARIES_H_
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"
using namespace std;
namespace tux {
class ProbTxBoundaries: public Probability {
public:
  unsigned int mL;
  unsigned int mK;
public:
  ProbTxBoundaries (unsigned int, unsigned int);
  double d ();
  RandomVariable* r (); 

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return ++current;}
  } mUniqueNumber;
};
}
#endif // _TUXPROBTXBOUNDARIES_H_

<<tuxProbTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_sf_gamma.h>
#include "ezlogger_headers.hpp"
#include "tuxGslRng.h"
#include "tuxTxBoundaries.h"
#include "tuxProbTxBoundaries.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
ProbTxBoundaries::ProbTxBoundaries (unsigned int l, unsigned int k)
{
  mL = l;
  mK = k;
}
double
ProbTxBoundaries::d ()
{
  return -gsl_sf_lnchoose(mL-1,mK-1);
}
RandomVariable* 
ProbTxBoundaries::r ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  vector<unsigned int> a(mK-1);
  vector<unsigned int> b(mL-1);
  generate (b.begin(),b.end(),mUniqueNumber);
  gsl_ran_choose (gGslRng, &a[0], mK-1, &b[0], mL-1, sizeof(unsigned int));
  a.push_back(mL);
  TxBoundaries* v = new TxBoundaries;
  v->mC = a;
  return v;
}
}
@

\subsection{ProbTxExpression}
<<tuxProbTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXPROBTXEXPRESSION_H_
#define _TUXPROBTXEXPRESSION_H_
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGslRng.h"
#include "tuxProbability.h"
<<extern tuxGslRng>>
namespace tux {
class ProbTxExpression: public Probability {
public:
  vector<double> mAlpha;
  vector<double> mTheta;
public:
  ProbTxExpression (const unsigned int k, const double a = 1.L);
  double d ();
  RandomVariable* r (); 
  void theta (vector<double>& t) {mTheta = t;}
  vector<double>& theta () {return mTheta;}

  unsigned int op_cast_unsigned_int (double i) { return static_cast<unsigned int>(i+0.5); }

  struct c_uniform {
    double a;
    double b;
    c_uniform () {a=0;b=1;}
    double operator()() {
      return gsl_ran_flat (gGslRng,a,b);
    }
  } gslrngUniform;

};
}
#endif // _TUXPROBTXEXPRESSION_H_

<<tuxProbTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <vector>
#include <algorithm>
#include <gsl/gsl_block.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxTxExpression.h"
#include "tuxProbTxExpression.h"
using namespace std;
namespace tux {
ProbTxExpression::ProbTxExpression (const unsigned int k, const double a)
{
  mAlpha.resize(k,a);
}
double
ProbTxExpression::d ()
{
  size_t k = static_cast<size_t>(mAlpha.size());
  return gsl_ran_dirichlet_lnpdf(k,&mAlpha[0],&mTheta[0]);
}
RandomVariable* 
ProbTxExpression::r ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  size_t k = static_cast<size_t>(mAlpha.size());
  mTheta.resize(k); 
  gsl_ran_dirichlet(gGslRng,k,&mAlpha[0],&mTheta[0]);
  TxExpression* v = new TxExpression;
  v->mDelta = mTheta;
  return v;
}
}
@

\subsection{Likelihood}
<<tuxLikelihood.h>>=
<<tux gnu copyright>>
#ifndef _TUXLIKELIHOOD_H_
#define _TUXLIKELIHOOD_H_
#include <vector>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxProbability.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
class Fixed;
class Data;
class TxBoundaries;
class TxExpression;
class Likelihood: public Probability {
public:
  Fixed* mFixed;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  unsigned int mJ;

  // Data members are set by the above RandomVariable objects
  double mA0; // given a_0
  double mA1; // given a_1
  unsigned int mL; // a given chromosome length
  unsigned int mK; // a given segments length
  double mM;       // a given average total counts
  double mSizeFactor; // a given size factor
  vector<double> mDelta;   // sample from a uniform Dirichlet distribution
  vector<unsigned int> mC; // sample from a uniform Dirichlet distribution

  // Note that the following is one instance of multiple data
  vector<unsigned int> mCount;
  unsigned int mN;
public:
  Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te);
  Likelihood (unsigned int, unsigned int, double);
  double d ();
  RandomVariable* r (); 
  void J (unsigned int j);
  double sizeFactor () const {return mSizeFactor;}
  void sizeFactor (const double s) {mSizeFactor=s;}
  void alpha (const double a0, const double a1) {mA0=a0; mA1=a1;}

  // FIXME: in a separte file under tux namespace.
  struct c_uniform {
    double a;
    double b;
    c_uniform () {a=0;b=1;}
    double operator()() {
      return gsl_ran_flat (gGslRng,a,b);
    }
  } gslrngUniform;

  struct c_nb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    unsigned int operator()(double i) {
      double mu = mSizeFactor * mM * i;
      double n = 1/(a0+a1/mu); // multiplied by mu?
      double p = n/(n+mu);
      unsigned int k = gsl_ran_negative_binomial(gGslRng, p, n);
      return k; 
    }
  } gslrngNb;

  struct c_countRead {
    vector<unsigned int>::iterator mIter;
    vector<unsigned int> mRead;
    c_countRead () {mIter = mRead.begin();}
    void resize() {mIter = mRead.begin();}
    unsigned int operator()(unsigned int l) {
      vector<unsigned int>::iterator mEnd = mIter + l;
      unsigned int sumCk = accumulate(mIter,mEnd,0);
      mIter = mEnd; 
      return sumCk;
    }
  } countRead;

};
}
#endif // _TUXLIKELIHOOD_H_

<<tuxLikelihood.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <string>
#include <iostream>
#include <functional>       // minus
#include <vector>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
using namespace std;
namespace tux {
Likelihood::Likelihood (Fixed* f, TxBoundaries* tb, TxExpression* te)
{
  // Check the three variables are valid. 
  mFixed = f;
  mTxBoundaries = tb;
  mTxExpression = te;
  mL = tb->L();
  mK = f->mK;
  mM = f->mM;
  mSizeFactor = f->mZ[0];
  mA0 = f->mA0;
  mA1 = f->mA1;
  mC = tb->mC;
  mDelta = te->mDelta;
}

Likelihood::Likelihood (unsigned int l, unsigned int k, double m)
{
  mL = l;
  mK = k;
  mM = m;
  // TxBoundaries is created. Likelihood owns it.
  ProbTxBoundaries priorTxBoundaries (mL, mK);
  priorTxBoundaries.mL = mL;
  priorTxBoundaries.mK = mK;
  TxBoundaries* vTxBoundaries = 
    static_cast<TxBoundaries*>(priorTxBoundaries.r());
  mC = vTxBoundaries->mC;
  delete vTxBoundaries;

  // TxExpression is created. Likelihood owns it.
  ProbTxExpression priorTxExpression (mK,1.L);
  TxExpression* vTxExpression = 
    static_cast<TxExpression*>(priorTxExpression.r());
  mDelta = vTxExpression->mDelta;
  delete vTxExpression;
}
void 
Likelihood::J (unsigned int j) 
{
  mJ=j;
  mSizeFactor = mFixed->mZ.at(mJ);
}
double
Likelihood::d ()
{
  // Find lengths lk using ck.
  vector<unsigned int> lk(mC);
  vector<unsigned int> lkLeft(mC);
  lkLeft.pop_back();
  lkLeft.insert(lkLeft.begin(),0);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<unsigned int>());

  // Count reads in ck.
  vector<unsigned int> c;
  unsigned int pos = lkLeft.front();
  for (vector<unsigned int>::iterator i = lk.begin(); 
       i != lk.end(); 
       i++)
    {
      unsigned int sumCk = accumulate(mCount.begin() + pos,
                                      mCount.begin() + pos + *i,
                                      0);
      pos += *i;
      c.push_back(sumCk);
   }

  // Compute the probability. 
  vector<double> logNb;
  for (unsigned int k = 0; k < mDelta.size(); k++)
    {
      unsigned int xk = c.at(k);
      double mu = mN * mDelta.at(k);
      double n = 1.0/(mFixed->mA0 + mFixed->mA1/mu);
      double p = n/(n+mu);
      double v = gsl_ran_negative_binomial_lnpdf (xk, p, n);
      logNb.push_back(v);
    }
  double vTotal = accumulate(logNb.begin(),logNb.end(),.0);

#ifdef _DEBUG
  stringstream ss;
  ss << "Likelihood::d returns " << vTotal << endl;
  string strLog(ss.str());
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
#endif // _DEBUG

  return vTotal;
//  countRead.mRead = mCount;
//  transform(mLk.begin(),mLk.end(),ck.begin(),countRead);
//  vector<double> logProbNb(mDelta);
//  transform(logProbNb.begin(),logProbNb.end(),ck.begin(),logProbNb.begin(),probNb);
}
RandomVariable*
Likelihood::r ()
{
  // For each i-th segment, sample j.
  // Use TxBoundaries and TxExpression to generate a set of Data.
  gslrngNb.a0 = mA0;
  gslrngNb.a1 = mA1;
  gslrngNb.mM = mM;
  gslrngNb.mSizeFactor = mFixed->mZ.at(mJ);
  vector<unsigned int> nk(mDelta.size());
  transform(mDelta.begin(),mDelta.end(),nk.begin(),gslrngNb);
   
  // Lengths of segments
  vector<unsigned int> lk(mC);
  lk.pop_back();
  lk.insert(lk.begin(),0);
  transform(mC.begin(),mC.end(),lk.begin(),lk.begin(),minus<double>());

  // Place counts on mRead of gslrngRead.
  vector<unsigned int> reads(mL,0);
  unsigned int s; 
  unsigned int p = 0;
  for (unsigned int i = 0; i < nk.size(); i++)
    {
      unsigned int n = nk.at(i);
      unsigned int l = lk.at(i);
      for (unsigned int j = 0; j < n; j++)
        {
          s = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,l));
          reads.at(p + s)++;
        }
      p += l;
    }

  // Data
  Reads* v = new Reads;
  v->mCount = reads;
  return v;
}
}
@

\subsection{TotalLikelihood}

<<tuxTotalLikelihood.h>>=
<<tux gnu copyright>>
#ifndef _TUXTOTALLIKELIHOOD_H_
#define _TUXTOTALLIKELIHOOD_H_
#include <vector>
#include "tuxProbability.h"
using namespace std;
namespace tux {
class Fixed;
class Reads;
class TxBoundaries;
class TxExpression;
class TotalLikelihood: public Probability {
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
public:
  TotalLikelihood (Fixed* fixed, vector<Reads*>& reads, 
                   TxBoundaries* txb, TxExpression* txe, TxParameter* txp);
  double d ();
  RandomVariable* r (); 
};
}
#endif // _TUXTOTALLIKELIHOOD_H_

<<tuxTotalLikelihood.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <string>
#include <iostream>
#include <functional>
#include <algorithm>  // transform, copy
#include <numeric>    // accumulate
#include <vector>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxTotalLikelihood.h"
using namespace std;
namespace tux {
TotalLikelihood::TotalLikelihood (Fixed* fixed, 
                                  vector<Reads*>& reads, 
                                  TxBoundaries* txb, 
                                  TxExpression* txe,
                                  TxParameter* txp)
  : mFixed(fixed), mReads(reads), 
    mTxBoundaries(txb), mTxExpression(txe), mTxParameter(txp)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
}
double
TotalLikelihood::d ()
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  vector<unsigned int> ck(mTxBoundaries->mC);
  vector<double> dk(mTxExpression->mDelta);
  vector<unsigned int> lk(ck);
  vector<unsigned int> lkLeft;
  lkLeft.push_back(0);
  lkLeft.insert(lkLeft.end(),lk.begin(),lk.end()-1);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<unsigned int>());

  vector<double> logNb;
  vector<unsigned int> c;
  for (unsigned int j = 0; j < mReads.size(); j++)
    {
      Reads* ds = mReads.at(j);
      c.clear();
      unsigned int pos = lkLeft.front();
      for (vector<unsigned int>::iterator i = lk.begin(); 
           i != lk.end(); 
           i++)
        {
          unsigned int sumCk = accumulate(ds->mCount.begin() + pos,
                                          ds->mCount.begin() + pos + *i,
                                          0);
          pos += *i;
          c.push_back(sumCk);
       }

      // Compute the probability of observing the counts using a and b.
      for (unsigned int k = 0; k < dk.size(); k++)
        {
          unsigned int xk = c.at(k);
          double mu = ds->mN * dk.at(k);
          double n = 1.0/(mFixed->mA0 + mFixed->mA1/mu);
          double p = n/(n+mu);
          double v = gsl_ran_negative_binomial_lnpdf (xk, p, n);
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
              ss.str(string()); 
              ss << "j k v mu xk p n " 
                 << j << " " << k << " " << v << " " << mu << " " 
                 << xk << " " << p << " " << n << endl;
              strLog = ss.str(); 
              EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

          logNb.push_back(v);
        }
    }
  double vTotal = accumulate(logNb.begin(),logNb.end(),.0);
  return vTotal;
}
RandomVariable*
TotalLikelihood::r ()
{
  RandomVariable* v = NULL;
  return v;
}
}
@

\subsection{MoverManager}
<<tuxMoverManager.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERMANAGER_H_
#define _TUXMOVERMANAGER_H_
#include <iostream>
#include <vector>
#include <gsl/gsl_randist.h>
using namespace std;
namespace tux {
class Mover;
class MoverManager {
public:
  vector<Mover*> mMover;
  vector<unsigned int> mId;
  vector<double> mWeight;
  gsl_ran_discrete_t* mGslRanDiscrete;
public:
  MoverManager ();
  ~MoverManager ();
  void add (Mover*, const unsigned int, const double);
  Mover* choose ();
  friend ostream& operator<< (ostream &out, const MoverManager &t);

  template <class T> struct c_delete {
    void operator() (T i) {delete i;}
  };
};
}
#endif // _TUXMOVERMANAGER_H_

<<tuxMoverManager.cpp>>=
<<tux gnu copyright>>
#include <sstream>
#include <string>
#include <iostream>
#include <algorithm>  // for_each
#include <cassert>
#include <gsl/gsl_block.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxGslRng.h"
#include "tuxMover.h"
#include "tuxMoverManager.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
MoverManager::MoverManager ()
{
  mGslRanDiscrete = NULL;
}
MoverManager::~MoverManager ()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  c_delete<Mover*> deleteMover;
  for_each (mMover.begin(), mMover.end(), deleteMover);           
  if (mGslRanDiscrete != NULL) 
    {
      gsl_ran_discrete_free(mGslRanDiscrete);
      mGslRanDiscrete = NULL;
    }
}
void
MoverManager::add (Mover* m, const unsigned int id, const double weight)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
    << "Mover " << id << " added with weight of " << weight << endl;

  mId.push_back(id); 
  mWeight.push_back(weight);
  mMover.push_back(m);

  size_t k = mMover.size();
  if (k > 1)
    {
      if (mGslRanDiscrete != NULL) 
        {
          gsl_ran_discrete_free(mGslRanDiscrete);
          mGslRanDiscrete = NULL;
        }
      mGslRanDiscrete = gsl_ran_discrete_preproc (k,&mWeight[0]); 
    }
}
Mover*
MoverManager::choose()
{
  assert (mMover.size() > 1);
  size_t k = gsl_ran_discrete(gGslRng,mGslRanDiscrete);
#ifdef _DEBUG
  stringstream ss;
  ss << "MoverManager::choose " << k << endl;
  string strLog(ss.str());
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
#endif // _DEBUG
  return mMover.at(k);
}
ostream& 
operator<< (ostream &out, const MoverManager &t)
{
  out << "Acceptance Ratio: ";
  for (unsigned int i = 0; i < t.mMover.size(); i++)
    {
      Mover* m = t.mMover.at(i);
      out << t.mId.at(i) << " (" << (*m) << ") ";
    }
  return out;
}
}
@

\subsection{Mover}
<<tuxMover.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVER_H_
#define _TUXMOVER_H_
#include <iostream>
using namespace std;
namespace tux {
class Mover {
public:
  unsigned int mTry;
  unsigned int mAccepted;
  bool mIsData;
public:
  Mover (bool d = true) : mTry(0), mAccepted(0), mIsData(d) {}
  virtual int step () = 0;
  double acceptanceRatio () const; 
  friend ostream& operator<< (ostream &out, const Mover &t);
};
}
#endif // _TUXMOVER_H_

<<tuxMover.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxMover.h"
using namespace std;
namespace tux {
double
Mover::acceptanceRatio () const 
{
  double v;
  if (mTry > 0)
    {
      v = double(mAccepted)/double(mTry)*100.0;
    }
  else
    {
      v = .0;
    }
  return v;
}
ostream& 
operator<< (ostream &out, const Mover &t)
{
  out << t.mAccepted << "/" << t.mTry << " " << t.acceptanceRatio ();
  return out;
}
}
@

\subsection{MoverTxBoundaries}
<<tuxMoverTxBoundaries.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXBOUNDARIES_H_
#define _TUXMOVERTXBOUNDARIES_H_
#include <vector>
#include <cmath>
#include <functional> // unary_function
#include <numeric>    // accumulate
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGslRng.h"
#include "tuxMover.h"
using namespace std;
<<extern tuxGslRng>>
namespace tux {
class TxBoundaries;
class TxExpression;
class TxParameter;
class Reads;
class Fixed;
class MoverTxBoundaries: public Mover {
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
  vector<unsigned int> mK;
public:
  MoverTxBoundaries ();
  MoverTxBoundaries (Fixed* f, vector<Reads*>& r, 
                     TxBoundaries* txb, TxExpression* txe, TxParameter* txp);
  int step ();
  int step (unsigned int left, unsigned int right);

  struct c_unique {
    unsigned int current;
    c_unique() {current=0;}
    unsigned int operator()() {return current++;}
  } uniqueNumber;

  struct c_countRead {
    vector<unsigned int>::iterator mIter;
    vector<unsigned int> mRead;
    c_countRead () {mIter = mRead.begin();}
    void resize() {mIter = mRead.begin();}
    unsigned int operator()(unsigned int l) {
      vector<unsigned int>::iterator mEnd = mIter + l;
      unsigned int sumCk = accumulate(mIter,mEnd,0);
      mIter = mEnd; 
      return sumCk;
    }
  } countRead;

  // Duplicate
  struct c_probNb {
    double a0;
    double a1;
    double mM;
    double mSizeFactor;
    double operator()(double d,unsigned int k) {
      double mu = d * mM * mSizeFactor; 
      double n = mu/(a0+a1/mu);
      double p = n/(n+mu);
      return log(gsl_ran_negative_binomial_pdf(k,p,n));
    }
  } probNb;

  struct c_round {
    unsigned int operator()(double i) {
      return static_cast<unsigned int>(i + 0.5L);
    }
  } mRound;
};
}
#endif // _TUXMOVERTXBOUNDARIES_H_

<<tuxMoverTxBoundaries.cpp>>=
<<tux gnu copyright>>
#include <cassert>
#include <cmath>
#include <iostream>
#include <sstream>
#include <numeric>         // partial_sum
#include <algorithm>       // generate
#include <functional>      // plus
#include <vector>
#include <gsl/gsl_math.h>  // gsl_fcmp
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxTotalLikelihood.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxMoverTxBoundaries.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
MoverTxBoundaries::MoverTxBoundaries ()
{
}
MoverTxBoundaries::MoverTxBoundaries (Fixed* f, vector<Reads*>& r, 
                                      TxBoundaries* txb, 
                                      TxExpression* txe,
                                      TxParameter* txp)
  : Mover(f->mIsData), mFixed(f), mReads(r), 
    mTxBoundaries(txb), mTxExpression(txe), mTxParameter(txp)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  mTxBoundaries->mLengthSampleSegmentA = mFixed->mLengthSampleSegmentA;
  mTxBoundaries->mLengthSampleSegmentB = mFixed->mLengthSampleSegmentB;

  // Create a sequence of non-negative integers from 0 to K-1.
  gUniqueNumberFromZero.current = 0;
  mK.resize(mFixed->mK-1);
  generate(mK.begin(),mK.end(),gUniqueNumberFromZero);                  
}
int 
MoverTxBoundaries::step ()
{
  unsigned int left = 0;
  unsigned int right = 0;
  gsl_ran_shuffle (gGslRng,&mK[0],mK.size(),sizeof(unsigned int)); 
  for (vector<unsigned int>::iterator i = mK.begin(); i != mK.end(); i++)
    {
      if (mFixed->mLengthSampleSegmentA < *i)
        {
          left = *i - mFixed->mLengthSampleSegmentA;
        }
      else
        {
          left = 0;
        }
      if (mFixed->mLengthSampleSegmentA < mK.size() - 1 - *i)
        {
          right = *i + mFixed->mLengthSampleSegmentA;
        }
      else
        {
          right = mK.size() - 1;
        }
      assert(left < right);
      step (left, right);
    }
//  vector<unsigned int> segmentKappa;
//  mTxBoundaries->sampleSegment (segmentKappa);
//  unsigned int left = 0;
//  unsigned int right = 0;
//  for (vector<unsigned int>::iterator i = segmentKappa.begin();
//       i != segmentKappa.end();
//       i++)
//    {
//      right = *i;
//      if (left < right)
//        {
//          step (left, right);
//        }
//      left = right + 1;
//    }
  return 0;
}
int 
MoverTxBoundaries::step (unsigned int left, unsigned int right)
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  int status;
  // Find the left and right.
  vector<unsigned int> ck(mTxBoundaries->mC.begin() + left,
                          mTxBoundaries->mC.begin() + right + 1);
  vector<unsigned int> ckA(ck);
  vector<double> deltaK(mTxExpression->mDelta.begin() + left,
                        mTxExpression->mDelta.begin() + right + 1);
  // Compute lk
  vector<unsigned int> lk(ck);
  vector<unsigned int> lkLeft;
  if (left == 0)
    lkLeft.push_back(0);
  else
    lkLeft.push_back(mTxBoundaries->mC.at(left - 1));
  lkLeft.insert(lkLeft.end(),lk.begin(),lk.end()-1);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<unsigned int>());
  
  // Propose new boundaries
  unsigned int sumLk = accumulate(lk.begin(),lk.end(),0);
  unsigned int kappa = lk.size();
  unsigned int sumLkStar = sumLk - kappa;
  vector<double> b(lk.size());
  transform(lk.begin(), lk.end(), b.begin(), 
            bind2nd(divides<double>(),static_cast<double>(sumLk)));
  vector<double> a(lk.size());
  vector<double> aAlpha(lk.size());
  vector<double> bAlpha(lk.size());
  transform(b.begin(), b.end(), bAlpha.begin(), 
            bind2nd(multiplies<double>(),mFixed->mAlphaQBoundaries));
  // Get a and aAlpha using bAlpha.
  // FIXME: check for the numerical stability?
  status = fGslRanDirichletCheck (b,bAlpha,a,aAlpha,mFixed->mAlphaQBoundaries);
  if (status != GSL_SUCCESS)
    {
      mTry++;
      return 0;
    }

  // Compute the new set, ckA, of boundaries using the new lambda, or a.
  vector<double> aPartialSum(a.size());
  partial_sum(a.begin(),a.end(),aPartialSum.begin());
  vector<double> ckADouble(a.size());
  transform(aPartialSum.begin(), aPartialSum.end(), ckADouble.begin(), 
            bind2nd(multiplies<double>(),static_cast<double>(sumLkStar)));
  transform (ckADouble.begin(),ckADouble.end(),ckA.begin(),mRound);
  ckA.back() = sumLkStar;
  // Now, we have ending positions. We will use the first kappa-1 elements.
  vector<unsigned int> s1(a.size());
  uniqueNumber.current = lkLeft.front() + 1;
  generate(s1.begin(),s1.end(),uniqueNumber);                  
  transform(ckA.begin(),ckA.end(),s1.begin(),ckA.begin(),plus<unsigned int>());

  // Now, we have ckA.
  assert(ckA.back()==ck.back());

  // Compute lkA
  vector<unsigned int> lkA(ckA);
  vector<unsigned int> lkALeft;
  if (left == 0)
    lkALeft.push_back(0);
  else
    lkALeft.push_back(mTxBoundaries->mC.at(left - 1));
  lkALeft.insert(lkALeft.end(),lkA.begin(),lkA.end()-1);
  transform(lkA.begin(),lkA.end(),lkALeft.begin(),lkA.begin(),
            minus<unsigned int>());

  // No prior ratio because of uniform prior on TxBoundaries
  double prExpression = 0;
  // MH ratio.
  double mhAtoB = gsl_ran_dirichlet_lnpdf(kappa,&aAlpha[0],&b[0]);
  double mhBtoA = gsl_ran_dirichlet_lnpdf(kappa,&bAlpha[0],&a[0]);
  double mhExpression = mhAtoB - mhBtoA;
  // Likelihood ratio.
  double likelihoodExpression; 
  if (mIsData == true)
    {
      // We count reads on the segments.
      vector<double> logNb;
      vector<unsigned int> cA;
      vector<unsigned int> cB;
      for (unsigned int j = 0; j < mReads.size(); j++)
        {
          Reads* d = mReads.at(j);
          cA.clear();
          unsigned int posA = lkLeft.front();
          for (vector<unsigned int>::iterator i = lkA.begin(); 
               i != lkA.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posA,
                                              d->mCount.begin() + posA + *i,
                                              0);
              posA += *i;
              cA.push_back(sumCk);
           }

          cB.clear();
          unsigned int posB = lkLeft.front();
          for (vector<unsigned int>::iterator i = lk.begin(); 
               i != lk.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posB,
                                              d->mCount.begin() + posB + *i,
                                              0);
              posB += *i;
              cB.push_back(sumCk);
           }

          // Compute the probability of observing the counts using a and b.
          for (unsigned int k = 0; k < deltaK.size(); k++)
            {
              unsigned int xkA = cA.at(k);
              double muA = d->mN * deltaK.at(k);
              double nA = 1.0/(mFixed->mA0 + mFixed->mA1/muA);
              double pA = nA/(nA+muA);
              double vA = gsl_ran_negative_binomial_lnpdf (xkA, pA, nA);

              unsigned int xkB = cB.at(k);
              double muB = d->mN * deltaK.at(k);
              double nB = 1.0/(mFixed->mA0 + mFixed->mA1/muB);
              double pB = nB/(nB+muB);
              double vB = gsl_ran_negative_binomial_lnpdf (xkB, pB, nB);
              logNb.push_back(vA - vB);
            }
        }
      likelihoodExpression = accumulate(logNb.begin(),logNb.end(),.0);
    }
  else
    {
      likelihoodExpression = 0;
    }
  double logAlpha = likelihoodExpression + prExpression + mhExpression;
  double logAlphaUniform = log(gsl_rng_uniform (gGslRng));
  mTry++;
  bool isAccepted = true;
  if (logAlpha < logAlphaUniform)
    {
      // Reject it.
      isAccepted = false;
    }
  else
    {
      // Accept it.
      mAccepted++;

#ifdef _DEBUG
      // Compute the total likelihood before the change to the boundaries.
      TotalLikelihood tl(mFixed,mReads,mTxBoundaries,mTxExpression,mTxParameter);
      double prevLoglikelihood = tl.d();
#endif // _DEBUG

      for (unsigned int i = 0; i < ckA.size() - 1; i++)
        {
          mTxBoundaries->mC.at(i + left) = ckA.at(i);
        }

#ifdef _DEBUG
      // Compute the total likelihood after the change to the boundaries.
      double currLoglikelihood = tl.d();
      // Compare the difference and likelihoodExpression.
      int diffV = gsl_fcmp(currLoglikelihood - prevLoglikelihood,
                           likelihoodExpression, 1e-6);
      if (diffV != 0)
        {
          assert(0);
        }
#endif // _DEBUG

      mTxParameter->mLoglikelihood += likelihoodExpression; 
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
      if (mTxBoundaries->check() == false)
        {
          ss.str(string()); 
          ss << "    ";
          ss << "TxB(old) start at " << lkLeft.front() << " k (lk-ck) ";
          for (unsigned int i = 0; i < ck.size(); i++)
            {
              unsigned int k = left + i;
              ss << " " << k << " (" << lk.at(i) << " - " << ck.at(i) << ")";
            }
          ss << endl;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog;
          ss.str(string());
          ss << "    ";
          ss << "TxB(new) start at " << lkLeft.front() << " k (lk-ck)";
          for (unsigned int i = 0; i < ckA.size(); i++)
            {
              unsigned int k = left + i;
              ss << " " << k << " (" << lkA.at(i) << " - " << ckA.at(i) << ")";
            }
          ss << endl;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog;
          assert (0);
        }
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

    }
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
    << "  TxB Move Left - Right: " << left << " - " << right << endl;
  ss << "    ";
  ss << "Total likelihood: (" 
     << mTxParameter->mLoglikelihood 
     << ") AlphaUnif: " << logAlphaUniform;
  if (isAccepted == true)
    ss << " < ";
  else
    ss << " > ";
  ss << "Alpha: " << logAlpha << " = "
     << likelihoodExpression << " + " << prExpression << " + " << mhExpression
     << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB(old) start at " << lkLeft.front() << " k (lk-ck) ";
  for (unsigned int i = 0; i < ck.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << lk.at(i) << " - " << ck.at(i) << ")";
    }
  ss << endl;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
  ss.str(string());
  ss << "    ";
  ss << "TxB(new) start at " << lkLeft.front() << " k (lk-ck)";
  for (unsigned int i = 0; i < ckA.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << lkA.at(i) << " - " << ckA.at(i) << ")";
    }
  ss << endl;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string());
  ss << "    ";
  ss << "TxB(b) ";
  for (unsigned int i = 0; i < a.size(); i++) ss << " " << b.at(i); 
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string());
  ss << "    ";
  ss << "TxB(a) ";
  for (unsigned int i = 0; i < a.size(); i++) ss << " " << a.at(i); 
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB Acceptance: " << mAccepted << " / " << mTry << " = " 
     <<  acceptanceRatio () << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  return 0;
}
}
@

\subsection{MoverTxBSingle}
<<tuxMoverTxBSingle.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXBSINGLE_H_
#define _TUXMOVERTXBSINGLE_H_
#include <vector>
#include "tuxMover.h"
using namespace std;
namespace tux {
class TxBoundaries;
class TxExpression;
class TxParameter;
class Reads;
class Fixed;
class MoverTxBSingle: public Mover {
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
  vector<unsigned int> mK;
public:
  MoverTxBSingle ();
  MoverTxBSingle (Fixed* f, vector<Reads*>& r, 
                  TxBoundaries* txb, TxExpression* txe, TxParameter* txp);
  int step ();
  int step (unsigned int pos);
};
}
#endif // _TUXMOVERTXBSINGLE_H_

<<tuxMoverTxBSingle.cpp>>=
<<tux gnu copyright>>
#include <cassert>
#include <cmath>
#include <iostream>
#include <sstream>
#include <numeric>    // partial_sum
#include <algorithm>  // generate
#include <functional> // plus
#include <vector>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxTotalLikelihood.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxMoverTxBSingle.h"
<<extern tuxGslRng>>
using namespace std;
namespace tux {
MoverTxBSingle::MoverTxBSingle ()
{
}
MoverTxBSingle::MoverTxBSingle (Fixed* f, vector<Reads*>& r, 
                                TxBoundaries* txb, 
                                TxExpression* txe,
                                TxParameter* txp)
  : Mover(f->mIsData), mFixed(f), mReads(r), 
    mTxBoundaries(txb), mTxExpression(txe), mTxParameter(txp)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);

  // Create a sequence of non-negative integers from 0 to K-1.
  gUniqueNumberFromZero.current = 0;
  mK.resize(mFixed->mK-1);
  generate(mK.begin(),mK.end(),gUniqueNumberFromZero);                  
}
int 
MoverTxBSingle::step ()
{
  gsl_ran_shuffle (gGslRng,&mK[0],mK.size(),sizeof(unsigned int)); 
  for (vector<unsigned int>::iterator i = mK.begin(); i != mK.end(); i++)
    step (*i);
  return 0;
}
int 
MoverTxBSingle::step (unsigned int pos)
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
  ss.str(string()); 
  ss << "MoverTxBSingle::step (" << pos << ")" << endl;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  // Find the deltaK of the two segments.
  unsigned int ck = mTxBoundaries->mC.at(pos);
  vector<double> deltaK(mTxExpression->mDelta.begin() + pos,
                        mTxExpression->mDelta.begin() + pos + 2);

  // Find the left side distance.
  unsigned int leftDistance;
  unsigned int rightDistance;
  unsigned int basePosition;
  if (pos == 0)
    {
      basePosition = 0;
    }
  else
    {
      basePosition = mTxBoundaries->mC.at(pos-1);
    }
  assert(pos < mTxBoundaries->mC.size() - 1);
  leftDistance = mTxBoundaries->mC.at(pos) - basePosition;
  rightDistance = mTxBoundaries->mC.at(pos+1) - mTxBoundaries->mC.at(pos) - 1;
  vector<unsigned int> lk(2);
  lk.at(0) = leftDistance;
  lk.at(1) = rightDistance + 1;
  // Find the number of positions that ck can be placed.
  unsigned int lengthWindow = leftDistance + rightDistance;
  if (lengthWindow == 0)
    {
      mTry++;
      return 0;
    }

  // Choose one of lengthWindow.
  // We could use the mirror jump for moderate update.
  unsigned int ckA = gsl_rng_uniform_int(gGslRng, lengthWindow) 
                     + basePosition + 1;
  vector<unsigned int> lkA(2);
  lkA.at(0) = ckA - basePosition;
  lkA.at(1) = mTxBoundaries->mC.at(pos+1) - ckA;

  // Prior ratio.
  double prExpression = 0;
  // MH ratio.
  double mhExpression = 0;
  // Likelihood ratio.
  double likelihoodExpression; 
  if (mIsData == true)
    {
      // We count reads on the segments.
      vector<double> logNb;
      vector<unsigned int> cA;
      vector<unsigned int> cB;
      for (unsigned int j = 0; j < mReads.size(); j++)
        {
          Reads* d = mReads.at(j);
          cA.clear();
          unsigned int posA = basePosition;
          for (vector<unsigned int>::iterator i = lkA.begin(); 
               i != lkA.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posA,
                                              d->mCount.begin() + posA + *i,
                                              0);
              posA += *i;
              cA.push_back(sumCk);
           }

          cB.clear();
          unsigned int posB = basePosition;
          for (vector<unsigned int>::iterator i = lk.begin(); 
               i != lk.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + posB,
                                              d->mCount.begin() + posB + *i,
                                              0);
              posB += *i;
              cB.push_back(sumCk);
           }

          // Compute the probability of observing the counts using a and b.
          for (unsigned int k = 0; k < deltaK.size(); k++)
            {
              unsigned int xkA = cA.at(k);
              double muA = d->mN * deltaK.at(k);
              double nA = 1.0/(mFixed->mA0 + mFixed->mA1/muA);
              double pA = nA/(nA+muA);
              double vA = gsl_ran_negative_binomial_lnpdf (xkA, pA, nA);
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
              ss.str(string()); 
              ss << "j k vA muA xkA pA nA " 
                 << j << " " << k << " " << vA << " " << muA << " " 
                 << xkA << " " << pA << " " << nA << endl;
              strLog = ss.str(); 
              EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////

              unsigned int xkB = cB.at(k);
              double muB = d->mN * deltaK.at(k);
              double nB = 1.0/(mFixed->mA0 + mFixed->mA1/muB);
              double pB = nB/(nB+muB);
              double vB = gsl_ran_negative_binomial_lnpdf (xkB, pB, nB);
              logNb.push_back(vA - vB);

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
              ss.str(string()); 
              ss << "j k vB muB xkB pB nB " 
                 << j << " " << k << " " << vB << " " << muB << " " 
                 << xkB << " " << pB << " " << nB << endl;
              strLog = ss.str(); 
              EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
            }
        }
      likelihoodExpression = accumulate(logNb.begin(),logNb.end(),.0);
    }
  else
    {
      likelihoodExpression = 0;
    }
  double logAlpha = likelihoodExpression + prExpression + mhExpression;
  double logAlphaUniform = log(gsl_rng_uniform (gGslRng));
  mTry++;
  bool isAccepted = true;
  if (logAlpha < logAlphaUniform)
    {
      // Reject it.
      isAccepted = false;
    }
  else
    {
      // Accept it.
      mAccepted++;

#ifdef _DEBUG
      // Compute the total likelihood before the change to the boundaries.
      TotalLikelihood tl(mFixed,mReads,mTxBoundaries,mTxExpression,mTxParameter);
      double prevLoglikelihood = tl.d();
#endif // _DEBUG

      mTxBoundaries->mC.at(pos) = ckA;

#ifdef _DEBUG
      // Compute the total likelihood after the change to the boundaries.
      double currLoglikelihood = tl.d();
      // Compare the difference and likelihoodExpression.
      int diffV = gsl_fcmp(currLoglikelihood - prevLoglikelihood,
                           likelihoodExpression, 1e-6);
      if (diffV != 0)
        {
          ss.str(string()); 
          ss << "diffV currLoglikelihood - prevLoglikelihood likelihoodExpression," 
             << diffV << " "
             << currLoglikelihood << " - " 
             << prevLoglikelihood << " " << likelihoodExpression << endl;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
          //assert(0);
        }
#endif // _DEBUG

      mTxParameter->mLoglikelihood += likelihoodExpression; 
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
      if (mTxBoundaries->check() == false)
        {
          ss.str(string()); 
          ss << "    ";
          ss << "TxB3(old) " << ck;
          ss << endl;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog;
          ss.str(string());
          ss << "    ";
          ss << "TxB3(new) " << ckA; 
          ss << endl;
          strLog = ss.str(); 
          EZDBGONLYLOGGERVLSTREAM(axter::log_always) << strLog;
          assert (0);
        }
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
    }
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
    << "  TxBSingle Move pos: " << pos << endl;
  ss.str(string()); 
  ss << "    ";
  ss << "Total likelihood: (" 
     << mTxParameter->mLoglikelihood 
     << ") AlphaUnif: " << logAlphaUniform;
  if (isAccepted == true)
    ss << " < ";
  else
    ss << " > ";
  ss << "Alpha: " << logAlpha << " = "
     << likelihoodExpression << " + " << prExpression << " + " << mhExpression
     << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB3(old) " << ck;
  ss << endl;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
  ss.str(string());
  ss << "    ";
  ss << "TxB3(new) " << ckA; 
  ss << endl;
  strLog = ss.str(); 
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB3 Acceptance: " << mAccepted << " / " << mTry << " = " 
     <<  acceptanceRatio () << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  return 0;
}
}
@

\subsection{MoverTxExpression}
<<tuxMoverTxExpression.h>>=
<<tux gnu copyright>>
#ifndef _TUXMOVERTXEXPRESSION_H_
#define _TUXMOVERTXEXPRESSION_H_
#include <vector>
#include <cmath>
#include <functional> // unary_function
#include "tuxMover.h"
using namespace std;
namespace tux {
class TxBoundaries;
class TxExpression;
class TxParameter;
class Reads;
class Fixed;
class MoverTxExpression: public Mover {
public:
  Fixed* mFixed;
  vector<Reads*> mReads;
  TxBoundaries* mTxBoundaries;
  TxExpression* mTxExpression;
  TxParameter* mTxParameter;
  double mAverageTotalCount;
public:
  MoverTxExpression ();
  MoverTxExpression (Fixed* f, vector<Reads*>& r, 
                     TxBoundaries* txb, TxExpression* txe, TxParameter* txp);
  int step ();
  int step (unsigned int left, unsigned int right);

  struct unaryLog: public unary_function<double,double> {
    double operator() (double number) {return log(number);}
  } mUnaryLog;

};
}
#endif // _TUXMOVERTXEXPRESSION_H_

<<tuxMoverTxExpression.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <numeric>
#include <algorithm>
#include <functional>
#include <vector>
#include <cassert>
#include <cmath>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxTxParameter.h"
#include "tuxTotalLikelihood.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverTxExpression.h"
using namespace std;
<<extern tuxlf>>
namespace tux {
MoverTxExpression::MoverTxExpression () : Mover()
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  mFixed = NULL;
  mTxBoundaries = NULL;
  mTxExpression = NULL;
  mTxParameter = NULL;
}
MoverTxExpression::MoverTxExpression (Fixed* f, vector<Reads*>& r, 
                                      TxBoundaries* txb, TxExpression* txe,
                                      TxParameter* txp)
  : Mover(f->mIsData), mFixed(f), mReads(r), 
    mTxBoundaries(txb), mTxExpression(txe), mTxParameter(txp)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  mAverageTotalCount = .0; 
  for (vector<Reads*>::iterator it = r.begin(); it != r.end(); it++)
    {
      mAverageTotalCount += static_cast<double>((*it)->mN);
    }
  mAverageTotalCount /= static_cast<double>(r.size());

  EZLOGGERSTREAM 
    << "The average of the total number of reads is "
    << mAverageTotalCount << endl;

  mTxBoundaries->mLengthSampleSegmentA = mFixed->mLengthSampleSegmentA;
  mTxBoundaries->mLengthSampleSegmentB = mFixed->mLengthSampleSegmentB;
}
int 
MoverTxExpression::step ()
{
//  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  vector<unsigned int> segmentKappa;
  mTxBoundaries->sampleSegment (segmentKappa);
  unsigned int left = 0;
  unsigned int right = 0;
  for (vector<unsigned int>::iterator i = segmentKappa.begin();
       i != segmentKappa.end();
       i++)
    {
      right = *i;
      if (left < right)
        {
          step (left, right);
        }
      left = right + 1;
    }
  return 0;
}
int 
MoverTxExpression::step (unsigned int left, unsigned int right)
{
////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  stringstream ss;
  string strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  int status;
  assert(left < right); 
  // Find the ck and lk for computing the likelihood.
  assert(right + 1 <= mTxBoundaries->mC.size());
  vector<unsigned int> ck(mTxBoundaries->mC.begin() + left,
                          mTxBoundaries->mC.begin() + right + 1);
 
  // Compute the lengths.
  vector<unsigned int> lk(ck);
  vector<unsigned int> lkLeft;
  if (left == 0)
    lkLeft.push_back(0);
  else
    lkLeft.push_back(mTxBoundaries->mC.at(left - 1));
  lkLeft.insert(lkLeft.end(),lk.begin(),lk.end()-1);
  transform(lk.begin(),lk.end(),lkLeft.begin(),lk.begin(),minus<unsigned int>());

  // Propose a new set of expression. 
  vector<double> dk(mTxExpression->mDelta.begin() + left,
                    mTxExpression->mDelta.begin() + right + 1);
  // Propose a new set of expression. 
  size_t kappa = static_cast<size_t>(dk.size());
  assert (kappa > 1);
  vector<double> dkA(dk);
  vector<double> a(kappa);
  vector<double> b(kappa);
  vector<double> aAlpha(kappa);
  vector<double> bAlpha(kappa);
  double sumDk = accumulate(dk.begin(),dk.end(),.0);
  transform(dk.begin(),dk.end(),b.begin(), 
            bind2nd(divides<double>(),sumDk));
  transform(b.begin(),b.end(),bAlpha.begin(), 
            bind2nd(multiplies<double>(),mFixed->mAlphaQExpression));
  status = fGslRanDirichletCheck (b,bAlpha,a,aAlpha,mFixed->mAlphaQExpression);
  if (status != GSL_SUCCESS)
    {
      mTry++;
      return 0;
    }
  transform(a.begin(), a.end(), dkA.begin(), 
            bind2nd(multiplies<double>(),sumDk));


/*******************************************************************************
  THE PRIOR RATIO SEEMS TO BE 1. THE FOLLOWING CODE IS UNNECESSARY.

  double priorExpressionAlpha = mFixed->mAlphaPriorExpression - 1.L;
  vector<double> logA(a);
  vector<double> logB(b);
  vector<double> logAminusB(a.size());
  vector<double> logAminusBtimesAlphaMinusOne(a.size());
  transform(logA.begin(),logA.end(),logA.begin(),mUnaryLog);
  transform(logB.begin(),logB.end(),logB.begin(),mUnaryLog);
  transform(logA.begin(),logA.end(),logB.begin(),logAminusB.begin(),
            minus<double>());
  transform(logAminusB.begin(), logAminusB.end(), 
            logAminusBtimesAlphaMinusOne.begin(), 
            bind2nd(multiplies<double>(),priorExpressionAlpha));
  double prExpression = accumulate(logAminusBtimesAlphaMinusOne.begin(),
                                   logAminusBtimesAlphaMinusOne.end(),.0L);
*******************************************************************************/
  double prExpression = .0L;

  // MH ratio.
  double mhAtoB = gsl_ran_dirichlet_lnpdf(kappa,&aAlpha[0],&b[0]);
  double mhBtoA = gsl_ran_dirichlet_lnpdf(kappa,&bAlpha[0],&a[0]);
  double mhExpression = mhAtoB - mhBtoA;
  // Likelihood ratio.
  double likelihoodExpression; 
  if (mIsData == true)
    {
      // We count reads on the segments.
      vector<double> logNb;
      for (unsigned int j = 0; j < mReads.size(); j++)
        {
          Reads* d = mReads.at(j);
          vector<unsigned int> c;
          unsigned int pos = lkLeft.front();
          for (vector<unsigned int>::iterator i = lk.begin(); 
               i != lk.end(); 
               i++)
            {
              unsigned int sumCk = accumulate(d->mCount.begin() + pos,
                                              d->mCount.begin() + pos + *i,
                                              0);
              pos += *i;
              c.push_back(sumCk);
           }
          // Compute the probability of observing the counts using a and b.
          for (unsigned int k = 0; k < ck.size(); k++)
            {
              unsigned int xk = c.at(k);

              double muA = d->mN * dkA.at(k);
              double nA = 1.0/(mFixed->mA0 + mFixed->mA1/muA);
              double pA = nA/(nA+muA);
              double vA = gsl_ran_negative_binomial_lnpdf (xk, pA, nA);

              double muB = d->mN * dk.at(k);
              double nB = 1.0/(mFixed->mA0 + mFixed->mA1/muB);
              double pB = nB/(nB+muB);
              double vB = gsl_ran_negative_binomial_lnpdf (xk, pB, nB);
              logNb.push_back(vA - vB);
            }
        }
      // Be careful in using accumulate with double. If the third argument is 0,
      // then the returned value would be 0.
      likelihoodExpression = accumulate(logNb.begin(),logNb.end(),.0);
    }
  else
    {
      likelihoodExpression = .0;
    }

  double logAlpha = likelihoodExpression + prExpression + mhExpression;
  double logAlphaUniform = log(gsl_rng_uniform(gGslRng));
  mTry++;
  bool isAccepted = true;
  if (logAlpha < logAlphaUniform)
    {
      // Reject it.
      // Keep the value of TxExpression* mTxExpression;
      isAccepted = false;
    }
  else
    {
      // Accept it.
      mAccepted++;


#ifdef _DEBUG
      // Compute the total likelihood before the change to the boundaries.
      TotalLikelihood tl(mFixed,mReads,mTxBoundaries,mTxExpression,mTxParameter);
      double prevLoglikelihood = tl.d();
#endif // _DEBUG

      // Change the value of TxExpression* mTxExpression;
      for (unsigned int i = 0; i < dkA.size(); i++)
        {
          mTxExpression->mDelta.at(i + left) = dkA.at(i);
        }

#ifdef _DEBUG
      // Compute the total likelihood after the change to the boundaries.
      double currLoglikelihood = tl.d();
      // Compare the difference and likelihoodExpression.
      int diffV = gsl_fcmp(currLoglikelihood - prevLoglikelihood,
                           likelihoodExpression, 1e-6);
      if (diffV != 0)
        {
          assert(0);
        }
#endif // _DEBUG

      mTxParameter->mLoglikelihood += likelihoodExpression;
    }

////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
////////////////////////////////////////////////////////////////////////////////
  EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) 
    << "  TxE Move Left - Right: " << left << " - " << right << endl;
  ss << "    ";
  ss << "Total likelihood: ("
     << mTxParameter->mLoglikelihood
     << ") AlphaUnif: " << logAlphaUniform;
  if (isAccepted == true)
    ss << " < ";
  else
    ss << " > ";
  ss << "Alpha: " << logAlpha << " = "
     << likelihoodExpression << " + " << prExpression << " + " << mhExpression
     << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string()); 
  ss << "    ";
  ss << "TxB(curr) start at " << lkLeft.front() << " k (lk-ck) ";
  for (unsigned int i = 0; i < ck.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << lk.at(i) << " - " << ck.at(i) << ")";
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
  ss.str(string()); 
  ss << "    ";
  ss << "TxE(old): k (dk)";
  for (unsigned int i = 0; i < dk.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << dk.at(i) << ")";
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
  ss.str(string()); 
  ss << "    ";
  ss << "TxE(new): k (dk)";
  for (unsigned int i = 0; i < dkA.size(); i++)
    {
      unsigned int k = left + i;
      ss << " " << k << " (" << dkA.at(i) << ")";
    }
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string());
  ss << "    ";
  ss << "TxE(b) ";
  for (unsigned int i = 0; i < a.size(); i++) ss << " " << b.at(i); 
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string());
  ss << "    ";
  ss << "TxE(a) ";
  for (unsigned int i = 0; i < a.size(); i++) ss << " " << a.at(i); 
  ss << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;

  ss.str(string()); 
  ss << "    ";
  ss << "TxE Acceptance: " << mAccepted << " / " << mTry << " = " 
     <<  acceptanceRatio () << endl;
  strLog = ss.str(); EZDBGONLYLOGGERVLSTREAM(axter::log_rarely) << strLog;
////////////////////////////////////////////////////////////////////////////////
#endif // _DEBUG
////////////////////////////////////////////////////////////////////////////////
  return 0;
}
}
@

\subsection{Sample}
<<tuxSample.h>>=
<<tux gnu copyright>>
#ifndef _TUXSAMPLE_H_
#define _TUXSAMPLE_H_
#include <fstream>
namespace tux {
class Sample {
public:
  string mFilename;
  ofstream mOs;
public:
  void open (const char* filename);
  void close ();
  void write (); 
};
}
#endif // _TUXSAMPLE_H_

<<tuxSample.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSample.h"
using namespace std;
namespace tux {
void 
Sample::full ()
{
  return;
}
}
@

\subsection{Summarizer}
<<tuxSummarizer.h>>=
<<tux gnu copyright>>
#ifndef _TUXSUMMARIZER_H_
#define _TUXSUMMARIZER_H_
#include <iostream>
#include <vector>
#include <gsl/gsl_siman.h>
using namespace std;
namespace tux {
class Fixed;
class Reads;
class Summarizer {
private:
  vector<unsigned int> mTxb;
  vector<unsigned int> mBestTxb;
private:
  Summarizer();
  double EfInitialize();
  double boltzmann(double E, double new_E, double T);
  double Ef(double);
  void takeStep();
  int fillStepIndex ();
  int fillTxbs ();
public:
  Fixed* mFixed;
  vector<Reads*> mTxReads;

  map<unsigned int,unsigned int> mStepIndex;
  vector<vector<unsigned int> > mTxbs;

  gsl_siman_params_t params; //  = {N_TRIES, ITERS_FIXED_T, STEP_SIZE,
                             //  K, T_INITIAL, MU_T, T_MIN};

  unsigned int mLeftInterval; 
  unsigned int mRightInterval; 
  unsigned int mStepsize;    // Preset this.
  unsigned int mCk;          // the boundary site we propose a new value for
  unsigned int mNewX;        // a new value for the proposed boundary site
  unsigned int mX;           // the old value for the proposed boundary site 

public:
  Summarizer (Fixed* m, const vector<Reads*>& shortRead);
  void execute ();
  void findMeanBoundaries ();
  void listLoglikelihood (unsigned int chainid = 0);
  void computeFrequencyBoundaries ();
  friend ostream& operator<< (ostream &out, const Summarizer &t);
};
}
#endif // _TUXSUMMARIZER_H_


<<tuxSummarizer.cpp>>=
<<tux gnu copyright>>
#include <iomanip>
#include <map>
#include <fstream>
#include <iterator>
#include <algorithm>  // upper_bound
#include <gsl/gsl_math.h>
#include "yaml-cpp/yaml.h"
#include "ezlogger_headers.hpp"
#include "tuxFixed.h"
#include "tuxReads.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxSummarizer.h"
using namespace std;
namespace tux {
template <typename T>
void delete_pointed_to (T* p)
{
  delete p;
}
Summarizer::Summarizer (Fixed* m, const vector<Reads*>& shortRead)
  : mFixed(m), mTxReads(shortRead)
{
  EZDBGONLYLOGGERVLFUNCTRACKER(axter::log_rarely);
  fillStepIndex ();
  fillTxbs ();
}
void
Summarizer::execute ()
{
  // Find the mean boundaries.
  listLoglikelihood (0);
//  computeFrequencyBoundaries ();
//  findMeanBoundaries ();
  return;
}
void 
Summarizer::listLoglikelihood (unsigned int chainid)
{
  // Now, we have stepIndex ready.
  unsigned int numberSample = mStepIndex.size();
  vector<vector<double> > pMatrix;
  pMatrix.resize(numberSample); 
  for (unsigned int i = 0; i < numberSample; i++)
    {
      pMatrix.at(i).resize(mFixed->mNumberChain+1,0);
    }

  // Now, we have pMatrix ready.
  for (unsigned int i = 0; i < mFixed->mNumberProcess; i++)
    {
      string cfn = mFixed->chainFilename (i);
      ifstream fin(cfn.c_str()); 
      YAML::Parser parser2(fin);
      YAML::Node doc2;
      parser2.GetNextDocument(doc2);
      for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
        {
          unsigned int id, s;
          (*it)[0][0] >> id;
          (*it)[0][1] >> s;
          double beta, loglikelihood;
          (*it)[1][0] >> beta;
          (*it)[1][1] >> loglikelihood;

          unsigned int rowIndex = mStepIndex[s];
          pMatrix.at(rowIndex).at(id+1) = loglikelihood;
          pMatrix.at(rowIndex).at(0) = s;
        }
      fin.close();
      // cout << "Number: " << doc2.size() << endl;
    }

  // Print the values in a .p file.
  string ofn = mFixed->pFilename ();
  ofstream fout(ofn.c_str()); 
  fout << "step"; 
  for (unsigned int i = 1; i < pMatrix.front().size(); i++)
    {
      fout << "\t" << i; 
    }
  fout << endl;
  for (unsigned int i = 0; i < pMatrix.size(); i++)
    {
      fout << static_cast<int>(pMatrix.at(i).front());
      for (unsigned int j = 1; j < pMatrix.at(i).size(); j++)
        {
          fout << "\t" << pMatrix.at(i).at(j);
        }
      fout << endl;
    }
  fout.close();
  return; 
}
int
Summarizer::fillStepIndex ()
{
  mStepIndex.clear();

  // Find the size of the sample, and index the steps.
  string cfn = mFixed->chainFilename (0);
  ifstream fin(cfn.c_str()); 
  if (fin.is_open())
    {
      YAML::Parser parser2(fin);
      YAML::Node doc2;
      parser2.GetNextDocument(doc2);
      for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
        {
          unsigned int id, s;
          (*it)[0][0] >> id;
          (*it)[0][1] >> s;
          mStepIndex[s] = 0;
        }
      fin.close();
    }
  else
    {
      return 1;
    }

  unsigned int k = 0;
  for (map<unsigned int,unsigned int>::iterator it = mStepIndex.begin(); 
       it != mStepIndex.end(); 
       it++)
    {
      it->second = k++;
    }
  return 0;
}

int
Summarizer::fillTxbs ()
{
  // Now, we have stepIndex ready.
  unsigned int numberSample = mStepIndex.size();
  mTxbs.resize(numberSample);
  vector<unsigned int> txb;

  // Now, we txbs ready.
  for (unsigned int i = 0; i < mFixed->mNumberProcess; i++)
    {
      string cfn = mFixed->chainFilename (i);
      ifstream fin(cfn.c_str()); 
      YAML::Parser parser2(fin);
      YAML::Node doc2;
      parser2.GetNextDocument(doc2);
      for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
        {
          unsigned int id, s;
          (*it)[0][0] >> id;
          (*it)[0][1] >> s;
          double beta, loglikelihood;
          (*it)[1][0] >> beta;
          (*it)[1][1] >> loglikelihood;

          // Many integers
          if (id == 0)
            {
              txb.clear();
              for (YAML::Iterator jt=(*it)[2].begin();jt!=(*it)[2].end();++jt) 
                {
                  unsigned int a; *jt >> a; 
                  // cout << a << " ";
                  txb.push_back(a);
                }
              unsigned int rowIndex = mStepIndex[s];
              mTxbs.at(rowIndex) = txb;
            }
        }
      fin.close();
    }
  return 0;
}
void 
Summarizer::computeFrequencyBoundaries ()
{
  vector<unsigned int> summaryTxB(mTxReads.front()->size(),0U);
  for (unsigned int i = 0; i < mTxbs.size(); i++)
    {
      for (unsigned int j = 0; j < mTxbs[i].size(); j++)
        {
          unsigned int ck = mTxbs[i][j];
          summaryTxB.at(ck-1)++;
        }
    }
  vector<double> fractionTxB(mTxReads.front()->size(),.0);
  for (unsigned int i = 0; i < summaryTxB.size(); i++)
    {
      fractionTxB.at(i) = static_cast<double>(summaryTxB.at(i)) 
                          / static_cast<double>(summaryTxB.size());
    }

  // Print the values in a .wig file.
  string ofn = mFixed->prefixFilename ();
  ofn += "wig";
  ofstream fout(ofn.c_str()); 
  for (unsigned int i = 0; i < summaryTxB.size(); i++)
    {
      unsigned int pos = i + 1;
      fout << pos << " " << fractionTxB.at(i) << endl;
    }
  fout.close();

  return;
}
double
Summarizer::boltzmann(double E, double new_E, double T)
{
  double x = -(new_E - E) / (params.k * T);
  /* avoid underflow errors for large uphill steps */
  return (x < GSL_LOG_DBL_MIN) ? 0.0 : exp(x);
}
void 
Summarizer::findMeanBoundaries ()
{
  double E, new_E, best_E;
  double T, T_factor;
  int n_evals = 1, n_iter = 0, n_accepts, n_rejects, n_eless;

  // Sets the mTxb and mBestTxb, and computes E.
  E = EfInitialize();
  best_E = E;

  cout << "E: " << E << endl;
 
  // int params.n_tries // The number of points to try for each step.

  params.iters_fixed_T = 1000; // The number of iterations at each temperature.

  //double params.step_size // The maximum step size in the random walk.

  params.k = 1.0;
  params.t_initial = 1e8;
  params.mu_t = 1.001;
  params.t_min = 10;
  //        The parameters of the Boltzmann distribution and cooling
  //        schedule.
  // HERE
  //return;

  T = params.t_initial;
  T_factor = 1.0 / params.mu_t;

  while (1) 
    {
      n_accepts = 0;
      n_rejects = 0;
      n_eless = 0;

      for (int i = 0; i < params.iters_fixed_T; ++i) 
        {
          takeStep ();    // Sets mCk, mX and mNewX.
          new_E = Ef (E); // Computes a new energy based on E, mX and mNewX.

          if (new_E <= best_E) 
            {
              mBestTxb.at(mCk) = mNewX;
              best_E = new_E;
            }

          ++n_evals;     /* keep track of Ef() evaluations */
          /* now take the crucial step: see if the new point is accepted
             or not, as determined by the boltzmann probability */
          if (new_E < E) 
            {
              if (new_E < best_E) 
                {
                  mBestTxb.at(mCk) = mNewX;
                  best_E = new_E;
                }
              /* yay! take a step */
              mTxb.at(mCk) = mNewX;
              E = new_E;
              ++n_eless;
            } 
          else if (gsl_rng_uniform(gGslRng) < boltzmann(E, new_E, T)) 
            {
              /* yay! take a step */
	            //copy_state(new_x, x, element_size, copyfunc);
              mTxb.at(mCk) = mNewX;
              E = new_E;
              ++n_accepts;
            } 
          else 
            {
              ++n_rejects;
            }
        }

      if (true) 
        {
          /* see if we need to print stuff as we go */
          /*       printf("%5d %12g %5d %3d %3d %3d", n_iter, T, n_evals, */
          /*           100*n_eless/n_steps, 100*n_accepts/n_steps, */
          /*           100*n_rejects/n_steps); */
          printf ("%5d   %7d  %12g", n_iter, n_evals, T);
          //print_position (x);
          printf ("  %12g  %12g\n", E, best_E);
        }

      /* apply the cooling schedule to the temperature */
      /* FIXME: I should also introduce a cooling schedule for the iters */
      T *= T_factor;
      ++n_iter;
      if (T < params.t_min) break;
    }

  /* at the end, copy the result onto the initial point, so we pass it
     back to the caller */
  mTxb = mBestTxb;
  for (vector<unsigned int>::iterator i = mTxb.begin(); 
       i != mTxb.end(); 
       i++)
    {
      cout << setw(6) << *i;
    }
  cout << endl;
  return;
}
double
Summarizer::EfInitialize ()
{
  // Choose a TxB in TxBs.
  unsigned long int s = static_cast<unsigned long int>(mTxbs.size());
  s = gsl_rng_uniform_int (gGslRng,s);
  mTxb = mTxbs.at(s);
  mBestTxb = mTxb;

  // Compute the total distance between TxB and each of TxBs.
  double v = .0;
  for (unsigned int i = 0; i < mTxbs.size(); i++)
    {
      unsigned int d = fGslDistance (mTxb, mTxbs.at(i));
      v += static_cast<double>(d);
    }
  return v;
}
double
Summarizer::Ef (double E)
{
  vector<unsigned int>::iterator u;
  unsigned int leftDistance;
  unsigned int rightDistance;
  for (unsigned int i = 0; i < mTxbs.size(); i++)
    {
      vector<unsigned int>& b = mTxbs.at(i);
      u = upper_bound(b.begin(),b.end(),mNewX);
      assert (u != b.end());
      if (u == b.begin())
        {
          leftDistance = mNewX;
          rightDistance = *u - mNewX;
        }
      else
        {
          leftDistance = mNewX - *(u-1);
          rightDistance = *u - mNewX;
        }
      unsigned int d = GSL_MIN(leftDistance,rightDistance);
      E += static_cast<double>(d);

      assert (u != b.end());
      u = upper_bound(b.begin(),b.end(),mX);
      if (u == b.begin())
        {
          leftDistance = mX - 1;
          rightDistance = *u - mX;
        }
      else
        {
          leftDistance = mX - *(u-1);
          rightDistance = *u - mX;
        }
      d = GSL_MIN(leftDistance,rightDistance);
      E -= static_cast<double>(d);
    }
  return E;
}
void 
Summarizer::takeStep ()
{
  // Choose one boundary. 
  // Find its two neighboring boundaries.
  unsigned long int s = static_cast<unsigned long int>(mTxb.size());
  s = gsl_rng_uniform_int (gGslRng,s - 1);
  mX = mTxb.at(s); // Boundary site
  mCk = s; // Boundary site index
  if (s == 0)
    {
      mLeftInterval = mX - 1U;
    }
  else
    {
      mLeftInterval = mX - mTxb.at(s-1) - 1U;
    }
  mRightInterval = mTxb.at(s+1) - mX - 1U;
  mStepsize = 50;
  mNewX = fGslRanMirror (mLeftInterval,mRightInterval,mStepsize);
  if (s > 0)
    {
      mNewX += mTxb.at(s-1);
    }
  return;
}
ostream& 
operator<< (ostream &out, const Summarizer &t)
{
  
  return out;
}
}
@

\subsection{Summary}
<<tuxSummary.h>>=
<<tux gnu copyright>>
#ifndef _TUXSUMMARY_H_
#define _TUXSUMMARY_H_
#include "tuxRandomVariable.h"
namespace tux {
class Summary: public RandomVariable {
public:
  Summary ();
  ~Summary ();
};
}
#endif // _TUXSUMMARY_H_

<<tuxSummary.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSummary.h"
using namespace std;
namespace tux {
Summary::Summary ()
{
}
Summary::~Summary ()
{
}
}
@

\subsection{System}
<<tuxSystem.h>>=
<<tux gnu copyright>>
#ifndef _TUXSYSTEM_H_
#define _TUXSYSTEM_H_
namespace tux {
class System {
public:
  void full ();
};
}
#endif // _TUXSYSTEM_H_

<<tuxSystem.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxSystem.h"
using namespace std;
namespace tux {
void 
System::full ()
{
  return;
}
}
@

\subsection{TUX GSL}
<<tuxGsl.h>>=
<<tux gnu copyright>>
#ifndef _TUXGSL_H_
#define _TUXGSL_H_
#include <vector>
using namespace std;
namespace tux {
double                                                                          
gsl_ran_negative_binomial_lnpdf (const unsigned int k, 
                                 const double p, 
                                 const double n);
unsigned int 
fGslDistance (const vector<unsigned int>& a, const vector<unsigned int>& b);
}
#endif // _TUXGSL_H_

<<tuxGsl.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <algorithm>  // upper_bound
#include <iterator>
#include <cmath>
#include <cassert>
#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGsl.h"
using namespace std;
namespace tux {
double                                                                          
gsl_ran_negative_binomial_lnpdf (const unsigned int k, 
                                 const double p, 
                                 const double n)
{ 
  double f = gsl_sf_lngamma (k + n);                                           
  double a = gsl_sf_lngamma (n);                                               
  double b = gsl_sf_lngamma (k + 1.0);                                         

  double P = (f-a-b) + n * log(p) + static_cast<double>(k) * log(1 - p); 
  return P;
}
unsigned int 
fGslDistance (const vector<unsigned int>& a, const vector<unsigned int>& b)
{
  unsigned int v = 0;
  vector<unsigned int>::const_iterator u;
  unsigned int leftDistance;
  unsigned int rightDistance;
  for (vector<unsigned int>::const_iterator i = a.begin(); i != a.end(); i++)
    {
      u = upper_bound(b.begin(),b.end(),*i);
      if (u == b.begin())
        {
          leftDistance = *i - 1;
          rightDistance = *u - *i;
        }
      else if (u == b.end())
        {
          leftDistance = 0;
          rightDistance = 0;
        }
      else
        {
          leftDistance = *i - *(u-1);
          rightDistance = *u - *i;
        }
      unsigned int d = GSL_MIN(leftDistance,rightDistance);
      v += d;
    }
  return v;
}
}
@

\subsection{GNU Scientific Library}

Use the following environment variables.
\begin{Verbatim}[frame=lines,framesep=5mm]
GSL_RNG_TYPE="taus" GSL_RNG_SEED=123
\end{Verbatim}

<<gsl.cpp>>=
#include <stdio.h>
#include <gsl/gsl_sf_bessel.h>
     
int main (void)
{
  double x = 5.0;
  double y = gsl_sf_bessel_J0 (x);
  printf ("J0(%g) = %.18e\n", x, y);
  return 0;
}
@

<<tuxGslRng.h>>=
<<tux gnu copyright>>
#ifndef _TUXGSLRNG_H_
#define _TUXGSLRNG_H_
#include <vector>
#include <gsl/gsl_sf_result.h>
using namespace std;
namespace tux {
void fGslRngAlloc ();
unsigned long fGslRngSeed(unsigned long seed = 0);
void fGslRngFree ();
void fGslRanDirichlet (const vector<double>& alpha, 
                       vector<double>& theta, double e);
int
fGslRanDirichletCheck (const vector<double>& bTheta, 
                       const vector<double>& bAlpha, 
                       vector<double>& aTheta, 
                       vector<double>& aAlpha, 
                       double sAlpha);
int
fGslRanDirichletLnpdf (const size_t K,
                       const double alpha[], const double theta[],
                       gsl_sf_result * result);
struct c_unique {
  unsigned int current;
  c_unique() {current=0;}
  unsigned int operator()() {return ++current;}
};
struct c_unique_from_zero {
  unsigned int current;
  c_unique_from_zero() {current=0;}
  unsigned int operator()() {return current++;}
};
vector<unsigned int>
fGslRanTxBoundaries (const unsigned int mL, const unsigned int mK);
unsigned int
fGslRanMirror (const unsigned int l, const unsigned int r, 
               const unsigned int s);
}
#endif /* _TUXGSLRNG_H_ */
@

<<tuxGslRng.cpp>>=
<<tux gnu copyright>>
#include <cstdio>
#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>         // find_if, transform
#include <functional>        // less
#include <cmath>
#include <gsl/gsl_sf_result.h>
#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "tuxGslRng.h"
using namespace std;
namespace tux {
gsl_rng* gGslRng;
c_unique gUniqueNumber;
c_unique_from_zero gUniqueNumberFromZero;
void 
fGslRngAlloc () 
{
  const gsl_rng_type* T;
  gsl_rng_env_setup();
  T = gsl_rng_default;
  gGslRng = gsl_rng_alloc(T);
}
unsigned long 
fGslRngSeed (unsigned long seed)                                       
{                                                                               
  unsigned long tseed;
  FILE *devrandom;
  if(seed==0)
    {
      if ((devrandom = fopen("/dev/random","r")) == NULL)                       
        {                                                                       
          tseed = (unsigned long) time(NULL);                                   
          // printf("Got seed %lu from time()\n",tseed);                           
        }                                                                       
      else                                                                      
        {                                                                       
          fread(&tseed,sizeof(tseed),1,devrandom);                              
          // printf("Got seed %lu from /dev/random\n",tseed);                      
          fclose(devrandom);                                                    
        }                                                                       
    }                                                                           
  else                                                                          
    {                                                                           
      tseed=seed;                                                               
      //printf("Using specified seed %lu\n",tseed);                               
    }                                                                           
  gsl_rng_set(gGslRng,tseed);                                                       
  return(tseed);                                                                
}    
void 
fGslRngFree ()
{
  gsl_rng_free (gGslRng);
}
void 
fGslRanDirichlet (const vector<double>& alpha, vector<double>& theta, double e)
{
  vector<double>::iterator it;
  size_t kappa = static_cast<size_t>(alpha.size());
  unsigned int s = 0;
  bool isS = false;
  do
    {
      s++;
      gsl_ran_dirichlet(gGslRng,kappa,&alpha[0],&theta[0]);
      it = find_if(theta.begin(),theta.end(),bind2nd(less<double>(),e));
      if (s % 100000 == 0) 
        {
          isS = true;
          cerr << "-";
        }
    }
  while (it != theta.end());
  if (isS) cerr << endl;
  return;
}
// Given bAlpha we sample aTheta. 
// We check if bTheta is a possible value with aAlpha, which is computed from a.
// We check whehter there are too small values in aTheta.
int
fGslRanDirichletCheck (const vector<double>& bTheta, 
                       const vector<double>& bAlpha, 
                       vector<double>& aTheta, 
                       vector<double>& aAlpha, 
                       double sAlpha)
{
  int status = GSL_SUCCESS;
  gsl_sf_result r;
  vector<double>::iterator it;
  unsigned int kappa = bTheta.size();
  unsigned int s = 0;
  double e = 1e-25;
  do
    {
      s++;
      gsl_ran_dirichlet(gGslRng,kappa,&bAlpha[0],&aTheta[0]);
      it = find_if(aTheta.begin(),aTheta.end(),bind2nd(less<double>(),e));
      if (it != aTheta.end()) 
        {
          status = GSL_EINVAL;
          continue;
        }
      transform(aTheta.begin(),aTheta.end(),aAlpha.begin(), 
                bind2nd(multiplies<double>(),sAlpha));

      status = fGslRanDirichletLnpdf (kappa,&aAlpha[0],&bTheta[0],&r);
      if (status != GSL_SUCCESS) continue;
      status = fGslRanDirichletLnpdf (kappa,&bAlpha[0],&aTheta[0],&r);
      if (status != GSL_SUCCESS) continue;
      // Use r.val to get the result of the value. double mhBtoA = r.val;
    }
  while (s < 100 && status != GSL_SUCCESS);
  return status;
}
int
fGslRanDirichletLnpdf (const size_t K,
                       const double alpha[], const double theta[],
                       gsl_sf_result * result)
{                                                                                  
  /*We calculate the log of the pdf to minimize the possibility of overflow */  
  size_t i;
  double log_p = 0.0;
  double sum_alpha = 0.0;
  gsl_sf_result r;
  int status = GSL_SUCCESS;

  for (i = 0; i < K; i++)
    {
      double logTheta = log (theta[i]);
      if (logTheta == HUGE_VAL)
        {
          status = GSL_ERANGE;
          return status;
        }
      log_p += (alpha[i] - 1.0) * logTheta;
    }

  for (i = 0; i < K; i++)
    {
      sum_alpha += alpha[i];
    }

  status = gsl_sf_lngamma_e(sum_alpha,&r);
  if (status != GSL_SUCCESS) return status;
  log_p += r.val;
                                                                                   
  for (i = 0; i < K; i++)
    {
      status = gsl_sf_lngamma_e(alpha[i],&r);
      if (status != GSL_SUCCESS) return status;
      log_p -= r.val;
    }
  result->val = log_p;
  return status;
}
vector<unsigned int>
fGslRanTxBoundaries (const unsigned int mL, const unsigned int mK)
{
  vector<unsigned int> a(mK-1);
  vector<unsigned int> b(mL-1);
  generate (b.begin(),b.end(),gUniqueNumber);
  gsl_ran_choose (gGslRng, &a[0], mK-1, &b[0], mL-1, sizeof(unsigned int));
  a.push_back(mL);
  return a;
}
// x: l + 1 + r
// x: v in [1,l+r+1]
unsigned int
fGslRanMirror (const unsigned int l, const unsigned int r, 
               const unsigned int s)
{
  unsigned int d, f;
  d = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,s+1));
  f = static_cast<unsigned int>(gsl_rng_uniform_int(gGslRng,2UL));
  assert(f == 0 || f == 1U);
  if (f == 0)
    {
      d += l + 1;
    }
  else
    {
      if (d < l)
        d = l + 1 - d;
      else
        d = d - l;
    }
  unsigned int q;
  //q = d / (l+r+2);
  q = d / (l+r+1);
  unsigned int remainder;
  // remainder = d % (l+r+2);
  remainder = d % (l+r+1);
  unsigned int v;
  if (q % 2 == 0)
    {
      if (remainder == 0)
        {
          v = 1;
        }
      else
        {
          v = remainder;
        }
    }
  else
    {
      if (remainder == 0)
        {
          v = l + r + 1;
        }
      else
        {
          v = l + r + 2 - remainder;
        }
    }
//  if (q % 2 == 0)
//    {
//      if (remainder == 0)
//        {
//          v = 1;
//        }
//      else
//        {
//          v = remainder;
//        }
//    }
//  else
//    {
//      if (remainder == 0)
//        {
//          v = l + r + 1;
//        }
//      else
//        {
//          v = l + r + 2 - remainder;
//        }
//    }
  return v;
}
}
@

<<extern tuxGslRng>>=
namespace tux {
extern gsl_rng* gGslRng;
extern c_unique_from_zero gUniqueNumberFromZero;
}
@

\subsection{Error codes}
<<tuxError.h>>=
<<tux gnu copyright>>
#ifndef _TUXERROR_H_
#define _TUXERROR_H_
namespace tux {
enum { 
  ERR_OK,
  ERR_FILE,
  ERR_RT_OUT_OF_MEMORY
};
char* err2msg(int code);
}
#endif // _TUXERROR_H_

<<tuxError.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxError.h"
using namespace std;
namespace tux {
struct Error {
  int value;
  char* name;
} error_codes[] = {
  { ERR_OK, "ERR_OK" },
  { ERR_FILE, "File not found" },
  { ERR_RT_OUT_OF_MEMORY, "ERR_RT_OUT_OF_MEMORY" },
  { 0, 0 }
};
char* err2msg(int code)
{
  for (int i = 0; error_codes[i].name; ++i)
    if (error_codes[i].value == code)
      return error_codes[i].name;
  return "unknown";
}
}
@


\subsection{Signal}

\begin{Verbatim}[frame=lines,framesep=5mm]
#include <signal.h>
\end{Verbatim}

<<register signal>>=
signal(SIGUSR1, sig_handler);
<<tuxSignal.h>>=
<<tux gnu copyright>>
#ifndef _TUXSIGNAL_H_
#define _TUXSIGNAL_H_
#include <signal.h>
namespace tux {
void sig_handler(int signum);
}
#endif // _TUXSIGNAL_H_

<<tuxSignal.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include <signal.h>
#include "tuxSignal.h"
using namespace std;
namespace tux {
void sig_handler(int signum)
{
  cout << "Received signal " << signum << endl;
}
}
@

\subsection{Default}
<<tuxDefault.h>>=
<<tux gnu copyright>>
#ifndef _TUXDEFAULT_H_
#define _TUXDEFAULT_H_
#include <vector>
#include <string>
using namespace std;
namespace tux {
class Default {
public:
  static string mInfilename;
  static string mLogfilename;

  // From Fixed
  static double mMoverTxBSingleWeight;
  static double mMoverTxBWeight;
  static double mMoverTxEWeight;
  static unsigned int mLogVerbosity;
  static unsigned long int mSeed;
  static unsigned int mL;
  static unsigned int mK;
  static double mM;
  static vector<double> mZ;
  static double mA0;
  static double mA1;
  static double mAlphaQExpression;
  static double mAlphaQBoundaries;
  static unsigned int mLengthSampleSegmentA;
  static unsigned int mLengthSampleSegmentB;
  static double mAlphaPriorExpression;
  static unsigned int mMcmcLength;
  static unsigned int mMcmcBurnin;
  static unsigned int mMcmcThin;
  static unsigned int mNumberProcess;
  static unsigned int mNumberChain;
  static unsigned int mNumberSwap;
  static unsigned int mNumberSwapTry;
  static unsigned int mSwapDistance;
  static double mHAlpha;
  static double mHBeta;
  static string mPrefix;
  static string mOutDirectory;
  static string mChainDirectory;
  static string mLogDirectory;
  static string mDatafile;
  static bool mIsData;
};
}
#endif // _TUXDEFAULT_H_

<<tuxDefault.cpp>>=
<<tux gnu copyright>>
#include <string>
#include "tuxDefault.h"
using namespace std;
namespace tux {
string Default::mInfilename("in.tux");  
string Default::mLogfilename("in.log");  

// From Fixed.
double Default::mMoverTxBSingleWeight(1.0);
double Default::mMoverTxBWeight(1.0);
double Default::mMoverTxEWeight(1.0);
unsigned int Default::mLogVerbosity(1);
unsigned long Default::mSeed(0);
unsigned int Default::mL(10000U);
unsigned int Default::mK(10U);
double Default::mM(100000.0);
  //vector<double> mZ;
double Default::mA0(.05);
double Default::mA1(5.0);
double Default::mAlphaQExpression(100.0);
double Default::mAlphaQBoundaries(100.0);
unsigned int Default::mLengthSampleSegmentA(3000U);
unsigned int Default::mLengthSampleSegmentB(7000U);
  //double mAlphaPriorExpression;
unsigned int Default::mMcmcLength(1000000U);
unsigned int Default::mMcmcBurnin(500000U);
unsigned int Default::mMcmcThin(10000U);
unsigned int Default::mNumberProcess(1U);
unsigned int Default::mNumberChain(1U);
unsigned int Default::mNumberSwap(100U);
unsigned int Default::mNumberSwapTry(10U);
unsigned int Default::mSwapDistance(1U);
double Default::mHAlpha(0.99);
double Default::mHBeta(0.77);
string Default::mPrefix("tux.out");
string Default::mOutDirectory("./");
string Default::mChainDirectory("./");
string Default::mLogDirectory("./");
string Default::mDatafile("in.dat");
bool Default::mIsData(true);
}
@

\subsection{Xyz}
<<tuxXyz.h>>=
<<tux gnu copyright>>
#ifndef _TUXXYZ_H_
#define _TUXXYZ_H_
namespace tux {
class Xyz {
public:
  void full ();
};
}
#endif // _TUXXYZ_H_

<<tuxXyz.cpp>>=
<<tux gnu copyright>>
#include <iostream>
#include "tuxXyz.h"
using namespace std;
namespace tux {
void 
Xyz::full ()
{
  return;
}
}
@

\subsection{GNU Readline Library}
<<xmalloc decl>>=
#include <cstdlib>
void * xmalloc (size_t size);
<<xmalloc defn>>=
void *
xmalloc (size_t size)
{
   register void *value = (void*)malloc(size);
   if (value == 0)
      fprintf(stderr, "virtual memory exhausted");
   return value;
}
<<config.h.in>>=
#ifndef _CONFIG_H_
#define _CONFIG_H_

#undef __BEGIN_DECLS
#undef __END_DECLS
#ifdef __cplusplus
# define __BEGIN_DECLS extern "C" {
# define __END_DECLS }
#else
# define __BEGIN_DECLS /* empty */
# define __END_DECLS /* empty */
#endif

#define tux_VERSION_MAJOR @tux_VERSION_MAJOR@
#define tux_VERSION_MINOR @tux_VERSION_MINOR@

#cmakedefine USE_MYMATH

#cmakedefine HAVE_LOG
#cmakedefine HAVE_EXP

#cmakedefine HAVE_MALLOC_H 1
#cmakedefine HAVE_SYS_FILE_H
#cmakedefine HAVE_UNISTD_H
#cmakedefine HAVE_STRING_H
#cmakedefine HAVE_STDLIB_H

#endif /* _CONFIG_H_ */

<<fileman.cpp>>=
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif 

// #include "rlstdc.h"

#include <sys/types.h>
#ifdef HAVE_SYS_FILE_H
#  include <sys/file.h>
#endif
#include <sys/stat.h>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#include <fcntl.h>
#include <stdio.h>
#include <errno.h>

#if defined (HAVE_STRING_H)
#  include <string.h>
#else /* !HAVE_STRING_H */
#  include <strings.h>
#endif /* !HAVE_STRING_H */

#ifdef HAVE_STDLIB_H
#  include <stdlib.h>
#endif

#include <time.h>

// #include "xmalloc.h"

#include <readline/readline.h>
#include <readline/history.h>

<<xmalloc decl>>
<<xmalloc defn>>

// extern char *xmalloc PARAMS((size_t));

/* The names of functions that actually do the manipulation. */
int com_list PARAMS((char *));
int com_view PARAMS((char *));
int com_rename PARAMS((char *));
int com_stat PARAMS((char *));
int com_pwd PARAMS((char *));
int com_delete PARAMS((char *));
int com_help PARAMS((char *));
int com_cd PARAMS((char *));
int com_quit PARAMS((char *));

/* A structure which contains information on the commands this program
   can understand. */

typedef struct {
  char *name;/* User printable name of the function. */
  rl_icpfunc_t *func;/* Function to call to do the job. */
  char *doc;/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "cd", com_cd, "Change to directory DIR" },
  { "delete", com_delete, "Delete FILE" },
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "list", com_list, "List files in DIR" },
  { "ls", com_list, "Synonym for `list'" },
  { "pwd", com_pwd, "Print the current working directory" },
  { "quit", com_quit, "Quit using Fileman" },
  { "rename", com_rename, "Rename FILE to NEWNAME" },
  { "stat", com_stat, "Print out statistics on FILE" },
  { "view", com_view, "View the contents of FILE" },
  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite (char *string);
COMMAND* find_command (char *name);
void too_dangerous (char *caller);
void initialize_readline ();
int execute_line (char *line);
int valid_argument (char *caller, char *arg);

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (char *s)
{
  char *r;

  r = (char *) xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

int
main (int argc, char **argv)
{
  char *line, *s;

  progname = argv[0];
  if (argc == 1) { }

  initialize_readline ();/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}

/* Execute a command line. */
int
execute_line (char *line)
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (char *name)
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (char *string)
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;
    
  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator PARAMS((const char *, int));
char **fileman_completion PARAMS((const char *, int, int));

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
void
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END bound the
   region of rl_line_buffer that contains the word to complete.  TEXT is
   the word to complete.  We can use the entire contents of rl_line_buffer
   in case we want to do some simple parsing.  Return the array of matches,
   or NULL if there aren't any. */
char **
fileman_completion (const char *text, int start, int end)
{
  char **matches;

  if (end == 0) {}

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = rl_completion_matches (text, command_generator);

  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (const char *text, int state)
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  name = commands[list_index].name;
  while (name) 
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
      name = commands[list_index].name;
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                       FileMan Commands                           */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* List the file(s) named in arg. */
int
com_list (char *arg)
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}

int 
com_view (char *arg)
{
  if (!valid_argument ("view", arg))
    return 1;

#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "less %s", arg);
#else
  sprintf (syscom, "more %s", arg);
#endif
  return (system (syscom));
}

int
com_rename (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "rename %s", arg);
#else
  sprintf (syscom, "rename %s", arg);
#endif
  too_dangerous (syscom);
  return (1);
}

int
com_stat (char *arg)
{
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %d byte%s in length.\n",
  arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          (int) finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}

int
com_delete (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "delete %s", arg);
#else
  sprintf (syscom, "delete %s", arg);
#endif
  too_dangerous (syscom);
  return (1);
}

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
int
com_help (char *arg)
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

/* Change to the directory ARG. */
int
com_cd (char *arg)
{
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}

/* Print out the current working directory. */
int
com_pwd (char *ignore)
{
  char dir[1024], *s;

  s = getcwd (dir, sizeof(dir) - 1);
  if (s == 0)
    {
      printf ("Error getting pwd: %s %s\n", dir, ignore);
      return 1;
    }

  printf ("Current directory is %s %s\n", dir, ignore);
  return 0;
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
int
com_quit (char *arg)
{
#if defined (__MSDOS__)
  /* more.com doesn't grok slashes in pathnames */
  sprintf (syscom, "quit %s", arg);
#else
  sprintf (syscom, "quit %s", arg);
#endif
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
void
too_dangerous (char *caller)
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (char *caller, char *arg)
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}
@

\subsection{Logarithm of sum}
We use a head file log-double.H of BAli-Phy.
<<benLogDouble.h>>=
// The following is a header file of BAli-Phy authored by Ben.

/*
   Copyright (C) 2004-2005 Benjamin Redelings

This file is part of BAli-Phy.

BAli-Phy is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

BAli-Phy is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with BAli-Phy; see the file COPYING.  If not see
<http://www.gnu.org/licenses/>.  */

#ifndef LOG_DOUBLE_H
#define LOG_DOUBLE_H

#include <cassert>
#include "logsum.H"

/// A class for handling positive real number in terms of their natural log.
class log_double_t {
  /// Natural log of the number.
  double value;
public:

  /// Access the log of the number.
  double  log() const {return value;}
  /// Access the log of the number.
  double& log()       {return value;}

  log_double_t& operator +=(const log_double_t& y) {loginc(value,y.log()); return *this;}
  log_double_t& operator -=(const log_double_t& y) {value = logdiff(log(),y.log()); return *this;}
  log_double_t& operator *=(const log_double_t& y) {value += y.log(); return *this;}
  log_double_t& operator /=(const log_double_t& y) {value -= y.log(); return *this;}

  operator double() const {return exp(value);}

  log_double_t& operator=(double y) {
    assert(y >= 0);
    if (y == 0)
      value = log_0;
    else if (y == 1)
      value = 0;
    else
      value = ::log(y);
    return *this;
  }


  log_double_t():value(log_0) {}

  log_double_t(double x) {
    operator=(x);
  }
};

inline double log(log_double_t x) {
  return x.log();
}

#define decl_double(rtype,op)  \
inline rtype operator op (double x,log_double_t y) { \
  return log_double_t(x) op y; \
} \
\
inline rtype operator op (log_double_t x,double y) {\
  return x op log_double_t(y);\
}

inline log_double_t operator+(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z += y;
  return z;
}

inline log_double_t operator-(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z -= y;
  return z;
}

inline log_double_t operator*(log_double_t x,log_double_t y) {
  log_double_t z = x;
  z *= y;
  return z;
}

inline log_double_t operator/(log_double_t x,log_double_t y) {
  log_double_t z=x;
  z /= y;
  return z;
}

decl_double(log_double_t,+)
decl_double(log_double_t,-)
decl_double(log_double_t,*)
decl_double(log_double_t,/)

inline bool operator< (log_double_t x,log_double_t y) {
  return log(x)<log(y);
}

decl_double(bool,<)

inline bool operator<=(log_double_t x,log_double_t y) {
  return log(x)<=log(y);
}

decl_double(bool,<=)

inline bool operator> (log_double_t x,log_double_t y) {
  return log(x)>log(y);
}

inline bool operator>(log_double_t x,double y) {
  if (y==0)
    return log(x) > log_limit;
  else
    return x > log_double_t(y);
}

inline bool operator>(double  x,log_double_t y) {
  return log_double_t(x) > y;
}

inline bool operator>=(log_double_t x,log_double_t y) {
  return log(x)>=log(y);
}

decl_double(bool,>=)


inline bool operator==(log_double_t x,log_double_t y) {
  return log(x)==log(y);
}

inline bool operator==(log_double_t x,double y) {
  if (y==0.0)
    return log(x) <= log_limit;
  else if (y==1)
    return log(x) == 0.0;
  else
    return double(x) == y;
}

/*
inline bool operator==(log_double_t x,double y) {
  if (y==0)
    return (x==log_0);
  else if (y==1)
    return (x==0);
  else
    return (x==log(y));
}
*/

inline bool operator!=(log_double_t x,log_double_t y) {
  return log(x)!=log(y);
}

inline bool operator!=(log_double_t x,double y) {
  if (y==0.0)
    return log(x) > log_limit;
  else if (y==1)
    return log(x) != 0.0;
  else
    return double(x) != y;
}

#undef decl_double

inline log_double_t pow(log_double_t x,double p) 
{
  x.log() *= p;
  return x;
}

inline bool different(log_double_t x,log_double_t y,double tol=1.0e-9)
{
  double diff = log(x) - log(y);

  if (std::abs(diff)<tol) return false;

  if (x == y) return false;

  return true;
}

template<class T> T exp(double);

template<> inline log_double_t exp<log_double_t>(double x) {
  log_double_t y;
  y.log() = x;
  return y;
}

// Don't do pow<log_double_t>(x,y): do pow(log_double_t(x),y), instead.
//
// template<class T> T pow(double,double);
// 
// template<> inline log_double_t pow<log_double_t>(double x,double p) {
//   log_double_t y;
//   y.log() = p * ::log(x);
//   return y;
// }

#endif
@

\section{Tests}

\subsection{Generation of data}
Data generation requires procedures. The \Cclass{RandomVariable} and its two
other subclasses of \Cclass{Parameter} and \Cclass{Data} are abstract. The
\Cclass{TxBoundaries}, \Cclass{TxExpression}, and \Cclass{Reads} are concrete.  

\subsection{Test of Main}
<<tux-v1.cpp>>=
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include "config.h"

#ifdef USE_MYMATH
#include "MathFunctions.h"
#endif

int main (int argc, char *argv[])
{
  if (argc < 2)
    {
      fprintf(stdout,"%s Version %d.%d\n",
      argv[0],
      tux_VERSION_MAJOR,
      tux_VERSION_MINOR);
      fprintf(stdout,"Usage: %s number\n",argv[0]);
      return 1;
    }

  double inputValue = atof(argv[1]);

#ifdef USE_MYMATH
  double outputValue = mysqrt(inputValue);
#else
  double outputValue = sqrt(inputValue);
#endif

  fprintf(stdout,"The square root of %g is %g\n",
          inputValue, outputValue);
  return 0;
}
@

<<MathFunctions/mysqrt.cpp>>=
#include <cstdio>
#include "MathFunctions.h"
#include "TutorialConfig.h"

// include the generated table
#include "Table.h"

#include <math.h>

// a hack square root calculation using simple operations
double mysqrt(double x)
{
  if (x <= 0)
    {
    return 0;
    }
  
  double result;

  // if we have both log and exp then use them
  double delta;  

  // use the table to help find an initial value
  result = x;
  if (x >= 1 && x < 10)
    {
    result = sqrtTable[static_cast<int>(x)];
    }

  // do ten iterations
  int i;
  for (i = 0; i < 10; ++i)
    {
    if (result <= 0)
      {
      result = 0.1;
      }
    delta = x - (result*result);
    result = result + 0.5*delta/result;
    fprintf(stdout,"Computing sqrt of %g to be %g\n",x,result);
    }

  return result;
}
@

<<MathFunctions/MakeTable.cpp>>=
// A simple program that builds a sqrt table 
#include <stdio.h>
#include <math.h>

int main (int argc, char *argv[])
{
  int i;
  double result;

  // make sure we have enough arguments
  if (argc < 2)
    {
    return 1;
    }
  
  // open the output file
  FILE *fout = fopen(argv[1],"w");
  if (!fout)
    {
    return 1;
    }
  
  // create a source file with a table of square roots
  fprintf(fout,"double sqrtTable[] = {\n");
  for (i = 0; i < 10; ++i)
    {
    result = sqrt(static_cast<double>(i));
    fprintf(fout,"%g,\n",result);
    }

  // close the table with a zero
  fprintf(fout,"0};\n");
  fclose(fout);
  return 0;
}
@

\subsection{GSL}
<<tux-gsl.cpp>>=
#include <cassert>
#include <fstream>
#include <vector>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
<<extern tuxGslRng>>
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  fGslRngSeed (100);
  unsigned long int s = gsl_rng_uniform_int(gGslRng,100);

  std::fstream f;
  f.open (argv[1], std::fstream::out);
  f << s << std::endl;

  // Test of Dirichlet and vectors
  std::vector<double> a(3,1.L);
  std::vector<double> b;
  b.resize(3);
  gsl_ran_dirichlet(gGslRng,3,&a[0],&b[0]);
  for (std::vector<double>::iterator i = b.begin(); i != b.end(); i++) {
    f << *i << "\t";
  }
  f << std::endl;

  vector<unsigned int> ui1Count(15,0);
  for (unsigned int i = 0; i < 100000; i++)
    {
      // unsigned int ui1 = fGslRanMirror (5, 9, 7);
      // unsigned int ui1 = fGslRanMirror (1, 13, 7);
      unsigned int ui1 = fGslRanMirror (6, 8, 7);
      ui1Count.at(ui1-1)++;
      // assert (1 <= ui1 && ui1 <= 15);
    }
  for (unsigned int i = 0; i < ui1Count.size(); i++)
    {
      f << ui1Count.at(i) << " ";
    }
  f << std::endl;

  f.close();
  fGslRngFree ();
  return 0;
}
@


\subsection{STL}
<<stl-transform.cpp>>=
#include <iomanip>
#include <iostream>
#include <string>
#include <algorithm>  // transform, copy
#include <vector>
#include <functional> // bind2nd, unary_function
#include <numeric>    // accumulate
#include <iterator>   // ostream_iterator
#include <cmath>
using namespace std;
struct myclass {
  void operator() (double i) {cout << " " << i;}
} myobject;

struct unaryLog : public unary_function<double,double> {
  double operator() (double number) {return log(number);}
};

int
main ()
{
  static const double a[] = {1,2,3};
  static const double b[] = {1,2,3};
  vector<double> v (a, a + sizeof(a) / sizeof(a[0]) );
  vector<double> vb (b, b + sizeof(b) / sizeof(a[0]) );
  // Sum of a.
  double s = accumulate(v.begin(),v.end(),0);
  // Divide a by the sum.
  transform(v.begin(),v.end(),v.begin(),bind2nd(divides<double>(),s));
  // Print the a/sum.
  for_each(v.begin(),v.end(),myobject);
  cout << endl;

  // Log of a.
  unaryLog unaryLogObject;
  transform(v.begin(),v.end(),v.begin(),unaryLogObject);
  for_each(v.begin(),v.end(),myobject);
  cout << endl;

  // vector A minus vector B = vector C.
  vector<double> vc(v.size());
  transform(v.begin(),v.end(),vb.begin(),vc.begin(),minus<double>());
  for_each(vc.begin(),vc.end(),myobject);
  cout << endl;

  // unsigned int / double
  cout << std::scientific;
  cout << std::setprecision(std::numeric_limits<double>::digits);
  unsigned int ui = 25;
  static const unsigned int scui[] = {1,2,3,4,5};
  vector<unsigned int> scuiA (scui, scui + sizeof(scui) / sizeof(scui[0]) );
  vector<double> scuiB (scuiA.size());
  transform(scuiA.begin(), scuiA.end(), scuiB.begin(), 
            bind2nd(divides<double>(),static_cast<double>(ui)));
  for_each(scuiB.begin(),scuiB.end(),myobject);
  cout << endl;

  double d = 10.0;
  static const double scd[] = {1.0, 2.0, 3.0, 4.0, 5.0};
  cout << scd[0] << endl;
  cout << scd[4] << endl;
  cout << d << endl;
  double dv = scd[0]/d;
  cout << "1/10 = " << dv << endl;
  vector<unsigned int> scdA (scd, scd + sizeof(scd) / sizeof(scd[0]) );
  vector<double> scdB (scdA.size());
  transform(scdA.begin(), scdA.end(), scdB.begin(), 
            bind2nd(divides<double>(),static_cast<double>(d)));
  for_each(scdB.begin(),scdB.end(),myobject);
  cout << endl;

  return 0;
}
@

\subsection{Test-Fixed and YAML}

<<simpleopt>>=
enum { OPT_HELP, OPT_FLAG, OPT_ARG };
CSimpleOpt::SOption g_rgOptions[] = {
  { OPT_FLAG, "-a",     SO_NONE    }, // "-a"
  { OPT_FLAG, "-b",     SO_NONE    }, // "-b"
  { OPT_ARG,  "-f",     SO_REQ_SEP }, // "-f ARG"
  { OPT_HELP, "-?",     SO_NONE    }, // "-?"
  { OPT_HELP, "--help", SO_NONE    }, // "--help"
  SO_END_OF_OPTIONS                       // END
};
void ShowUsage() {
  std::cout << "Usage: tux [-?] [--help] tux.yaml tux.out tux.log\n";
}
<<tux-fixed.cpp>>=
#include <cstdlib>
#include <fstream>
#include <iomanip>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxFixed.h"
#include "tuxReads.h"
using namespace tux;
<<extern tuxGslRng>>
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    std::cout << "Error while reading two files" << std::endl;
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);

  std::fstream f;
  f.open(glob.File(1), std::fstream::out);
  f << std::scientific;// << std::fixed;
  f << std::setprecision(std::numeric_limits<double>::digits);
  //f << std::setprecision(std::numeric_limits<int>::max());

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  vector<unsigned int> a;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
  }
  // The data consists of just numbers and spaces.
  unsigned int nC = 0;
  while (!fin.eof()) 
    {
      unsigned int i;
      char c = fin.peek();
      while (c == ' ')
        {
          c = fin.peek();
          if (c == ' ')
            c = fin.get();
          else
            break;
        }
      input.clear();
      if (isdigit(c))
        {
          c = fin.get();
          while (isdigit(c))
            {
              input += c;
              c = fin.get();
            }
          a.push_back(static_cast<unsigned int>
                      (strtoul(input.c_str(),NULL,0)));
          nC++;
          while (c == ' ')
            {
              c = fin.peek();
              if (c == ' ')
                {
                  c = fin.get();
                }
              else
                {
                  if (c == '\n')
                    c = fin.get();
                  else
                    c = ' ';
                  break;
                }
            }
          if (c != ' ')
            {
              EZLOGGERSTREAM2(lf) << "A new line in data section." << std::endl;
              r = new Reads(static_cast<unsigned int>(shortRead.size()));
              r->mCount = a;
              shortRead.push_back(r);
              a.clear();
              i = static_cast<unsigned int>(shortRead.size()); 
              EZLOGGERSTREAM2(lf) << "Data " 
                                  << i
                                  << " - nC is " << nC << std::endl;
            }
        }
      else
        {
          if (!fin.eof()) 
            {
              nC++;
              EZLOGGERSTREAM2(lf) << "Fatal: counts must be numbers. "
                                  << "Character " << c << " is found at "
                                  << nC << "th from the start of the data."
                                  << std::endl;
              break;
            }
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator i = shortRead.begin(); 
       i != shortRead.end(); 
       i++)
    {
      f << **i;
      delete *i;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  f.close();

  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{TxBoundaries, TxExpression, and Reads}
<<tux-tx.cpp>>=
#include <iomanip>
#include <string>
#include <sstream>
#include <fstream>
#include <iterator>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Create TxBoundaries, TxExpression, and Reads
  //////////////////////////////////////////////////////////////////////////////
  // TxBoundaries
  TxBoundaries txb;
  static const unsigned int s[] = {10,40,80,120,150,500,1500};
  vector<unsigned int> sv(s, s + sizeof(s)/sizeof(s[0]));
  txb.mC = sv;
  txb.mLengthSampleSegmentA = 30;
  txb.mLengthSampleSegmentB = 60;
  vector<unsigned int> segmentKappa;
  txb.sampleSegment (segmentKappa);
  stringstream result;
  copy(segmentKappa.begin(), segmentKappa.end(), 
       ostream_iterator<unsigned int>(result, " "));
  cout << result.str().c_str() << endl;
//  txb.seq (2,r.size(),2); 
//  out << txb;

  // Sample two points
//  out << YAML::BeginMap << YAML::Key << "SegmentSubset";
//  out << YAML::Value << YAML::BeginSeq;
//  unsigned int l1,l2;
//  for (unsigned int i = 0; i < 3; i++)
//    {
//      txb.mLengthSampleSegment = 200;
//      txb.sampleSegment (l1,l2);
//      out << l1 << l2;
//    }
//  out << YAML::EndSeq << YAML::EndMap;

  // TxExpression
//  TxExpression txe;
//  txe.seq (txb.size());
//  out << txe;

  // Reads
//  Reads shortReads;
//  shortReads.sample (txb.L());
//  std::cout << shortReads;
////////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;


}
@

\subsection{tux-probtx}

Run the following command.
\begin{Verbatim}[frame=lines,framesep=5mm]
./tux-probtx s1.tux s1.out s1.log
\end{Verbatim}

The \program{tux-probtx} creates boundaries and expression parameters written in
\Cfile{s1.out}. 
<<tux-probtx.cpp>>=
#define EZLOGGER_REPLACE_EXISTING_LOGFILE_
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxFixed.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>

<<tux logfilename>>

int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Set the random Seed.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngSeed (m.mSeed);
  
  //////////////////////////////////////////////////////////////////////////////
  // Generate data.
  //////////////////////////////////////////////////////////////////////////////
  std::ofstream dataof;
  dataof.open(m.mDatafile.c_str());
  if (!dataof) 
    {
      std::cerr << "Unable to open file " << m.mDatafile << std::endl;
      EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                          << m.mDatafile << std::endl;
      fGslRngFree ();
      return 1;
    }
  of << "-" << endl;
  ProbTxBoundaries priorTxBoundaries (m.L(), m.K());
  TxBoundaries* txb = static_cast<TxBoundaries*>(priorTxBoundaries.r());
  of << *txb;
  ProbTxExpression priorTxExpression (m.K(),1.0);
  TxExpression* txe = static_cast<TxExpression*>(priorTxExpression.r());
  of << *txe;

  // Log only
  int iii = 123;
  std::string somedata = "Hello World";
  axter::ezlogger_output_policy::mEzloggerOutputFilename = "another.log";
  EZLOGGERSTREAM << somedata << " " << iii << std::endl;

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  delete txb;
  delete txe;

  //////////////////////////////////////////////////////////////////////////////
  // Close the output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{tux-prob}

<<tux-prob.cpp>>=
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);

  // Add your source codes.
  YAML::Emitter out;
  
  // Read in a YAML file.
  Fixed m;
  Reads r;
  // Read in a file: the same code as tux-fixed.cpp.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; out << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  r.mJ = 0; doc["Reads"] >> r; out << r;
  fin.close();

  ProbTxBoundaries factoryTxBoundaries (r.size(),m.K());
  out << YAML::BeginMap;
  out << YAML::Key << "ProbTxBoundaries";
  out << YAML::Value << factoryTxBoundaries.d (); 
  out << YAML::EndMap;
  TxBoundaries* txb = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  out << *txb; 

  ProbTxExpression factoryTxExpression (m.K());
  TxExpression* txe = static_cast<TxExpression*>(factoryTxExpression.r());
  out << *txe;

  // L: 1000, K:10, M:10000 
  //static const double sf[] = {0.8700484, 1.0158870, 1.1285131};
  //vector<double> sizeFactor(sf, sf + sizeof(sf)/sizeof(sf[0]));
  Likelihood factoryData (&m,txb,txe);
  for (unsigned int i = 0; i < m.mZ.size(); i++)
    {
      factoryData.J(i);
      Reads* shortRead = static_cast<Reads*>(factoryData.r());
      out << *shortRead;
      delete shortRead;
    }

  delete txb;
  delete txe;

  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{Movers}
<<tux-move.cpp>>=
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
using namespace tux;
int 
main (int argc, char *argv[])
{
  if (argc < 2)
    {
      return 1;
    }

  fGslRngAlloc ();
  std::fstream f;
  f.open (argv[1], std::fstream::out);
  YAML::Emitter out;

  // Add your source codes.
  // Read in a YAML file.
  Fixed m;
  // Read in a file: the same code as tux-fixed.cpp.
  std::ifstream fin("fixed.yaml");
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  std::cout << "Number of docs: " << doc.size() << std::endl;
  doc["Fixed"] >> m; out << m;
  // --- separates documents
  parser.GetNextDocument(doc);
  std::cout << "Number of another docs: " << doc.size() << std::endl;
  const YAML::Node& node = doc["Reads"];
  vector<Reads*> shortRead;
  Reads* r;
  for (unsigned int i = 0; i < node.size(); i++)
    {
      r = new Reads(i);
      doc["Reads"] >> *r;
      shortRead.push_back(r);
    }
  fin.close();
//  for (vector<Reads*>::iterator i = shortRead.begin(); 
//       i != shortRead.end(); 
//       i++)
//    {
//      std::cout << **i;
//    }
  // Initial values;
  r = shortRead.front();
  ProbTxBoundaries factoryTxBoundaries (r->size(),m.K());
  TxBoundaries* txb = static_cast<TxBoundaries*>(factoryTxBoundaries.r());
  out << *txb; 
  ProbTxExpression factoryTxExpression (m.K());
  TxExpression* txe = static_cast<TxExpression*>(factoryTxExpression.r());
  out << *txe; 

  // MCMC
  MoverManager mMoverManager;
  MoverTxBoundaries* d1;
  MoverTxExpression* d2;
  // Boundaries Mover
  d1 = new MoverTxBoundaries (&m, shortRead, txb, txe);
  mMoverManager.add (d1, 1, 1);
  // Expression Mover
  d2 = new MoverTxExpression (&m, shortRead, txb, txe);
  mMoverManager.add (d2, 2, 1);

  for (unsigned int i = 0; i < m.mMcmcLength; i++)
    {
      Mover* mover = mMoverManager.choose ();
      mover->step ();
      // Other information for steps.
      out << *txb;
      out << *txe;
    }
  // Movers are deleted by MoverManager.
  // RandomVariables must be removed.
  delete txb;
  delete txe;
  for (vector<Reads*>::iterator i = shortRead.begin(); 
       i != shortRead.end(); 
       i++)
    {
      delete *i;
    }

  // END of TEST
  f << out.c_str();
  f << std::endl;
  f.close();

  fGslRngFree ();
  return 0;
}
@

\subsection{Chains and chain manager}

<<extern tuxlf>>=
namespace tux {
extern std::ofstream lf; // log file
}
<<main tuxlf>>=
namespace tux {
  std::ofstream lf; // log file
}
<<tux-chain.cpp>>=
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Create a chain.
  //////////////////////////////////////////////////////////////////////////////
  Chain mChain (&m, shortRead);
  unsigned int s = 0;
  while (s < m.mMcmcLength) 
    {
      mChain.step (m.mMcmcThin);
      std::cerr << "Step: " << s << "\r";
      s += m.mMcmcThin;
      if (m.mMcmcBurnin < s)
        {
          of << mChain;
        }
    }
  mChain.report (of);

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

<<tux-cm.cpp>>=
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Create a chain manager.
  //////////////////////////////////////////////////////////////////////////////
  ChainManager mChainManager (&m, shortRead);
  mChainManager.createChain (m.mNumberChain);
  mChainManager.setChainid (0,m.mNumberChain-1);
  unsigned int s = 0;
  while (s < m.mMcmcLength) 
    {
      mChainManager.step (m.mMcmcThin);
      std::cerr << "Step: " << s << "\r";
      s += m.mMcmcThin;
      if (m.mMcmcBurnin < s)
        {
          of << mChainManager;
        }
    }
  mChainManager.report (of);

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{MCMC and MPI}
<<tux-mcmc.cpp>>=
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <mpi.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
#include "tuxMcmcMpi.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
<<main gslrngrandomnumber>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // MPI Init
  //////////////////////////////////////////////////////////////////////////////
  fGslRngSeed (m.mSeed);
  vector<unsigned long int> mProcessSeed;
  mProcessSeed.resize(m.mNumberProcess); 
  generate (mProcessSeed.begin(),mProcessSeed.begin(),gslrngRandomNumber);

  int size,rank;
  int length;
  char name[80];

  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD,&rank);
  MPI_Comm_size(MPI_COMM_WORLD,&size);
  MPI_Get_processor_name(name,&length);

  // Now we are in one of the processes.
  // Reset the gGslRng.
  fGslRngSeed (mProcessSeed.at(rank));
  
  //////////////////////////////////////////////////////////////////////////////
  // Create an MCMC.
  //////////////////////////////////////////////////////////////////////////////
  assert (m.mNumberSwap < m.mMcmcThin);
  McmcMpi mMcmc (&m, shortRead, rank);
  unsigned int s = 0;
  unsigned int sThin = 0;
  while (s < m.mMcmcLength) 
    {
      std::cerr << "Step: " << s << "\r";
      mMcmc.step (m.mNumberSwap);
      s += m.mNumberSwap; sThin += m.mNumberSwap;
      mMcmc.swap ();
      if (m.mMcmcBurnin < s)
        {
          if (m.mMcmcThin < sThin)
            {
              sThin -= m.mMcmcThin;
              of << mMcmc;
            }
        }
    }
  mMcmc.report (of);

  //////////////////////////////////////////////////////////////////////////////
  // MPI Final
  //////////////////////////////////////////////////////////////////////////////
  MPI_Finalize(); 

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}

<<tux-single.cpp>>=
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
#include "tuxMcmcSingle.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
<<main gslrngrandomnumber>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Set the random Seed.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngSeed (m.mSeed);
  
  //////////////////////////////////////////////////////////////////////////////
  // Create an MCMC.
  //////////////////////////////////////////////////////////////////////////////
  assert (m.mNumberSwap < m.mMcmcThin);
  McmcSingle mMcmc (&m, shortRead);
  unsigned int s = 0;
  unsigned int sThin = 0;
  while (s < m.mMcmcLength) 
    {
      std::cerr << "Step: " << s << "\r";
      mMcmc.step (m.mNumberSwap);
      s += m.mNumberSwap; sThin += m.mNumberSwap;
      mMcmc.swap ();
      if (m.mMcmcBurnin < s)
        {
          if (m.mMcmcThin < sThin)
            {
              sThin -= m.mMcmcThin;
              of << mMcmc;
            }
        }
    }
  mMcmc.report (of);

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{Summary}
<<tux-sum.cpp>>=
#include <limits>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <gsl/gsl_rng.h>
#include "config.h"
#include "ezlogger_headers.hpp"
#include "yaml-cpp/yaml.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "tuxGsl.h"
#include "tuxGslRng.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxSummarizer.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 3) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Read in data as a vector of Reads objects.
  //////////////////////////////////////////////////////////////////////////////
  vector<Reads*> shortRead;
  string input;
  Reads* r;
  EZLOGGERSTREAM2(lf) << "mDatafile is " << m.mDatafile << std::endl;
  fin.open(m.mDatafile.c_str());
  if (!fin) {
    std::cerr << "Unable to open file " << m.mDatafile << std::endl;
    EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                        << m.mDatafile << std::endl;
    return 1;
  }
  unsigned int i = 0;
  while (!fin.eof())
    {
      r = new Reads(i++);
      fin >> *r;
      if (r->mN == 0)
        {
          EZLOGGERSTREAM2(lf) << "Fatal: unable to read in file "
                              << m.mDatafile << std::endl;
        }
      else 
        {
          shortRead.push_back(r);
        }
    }
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Create a summarizer.
  //////////////////////////////////////////////////////////////////////////////
  vector<vector<unsigned int> > txbs;
  vector<unsigned int> txb;

  cout << std::scientific;// << std::fixed;
  cout << std::setprecision(std::numeric_limits<double>::digits);
  fin.open("tux.sum");
  YAML::Parser parser2(fin);
  YAML::Node doc2;
  parser2.GetNextDocument(doc2);
  for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
    {
      // Two integers
      for (YAML::Iterator jt=(*it)[0].begin();jt!=(*it)[0].end();++jt) 
        {
          // unsigned int a; *jt >> a; cout << a << " ";
        }
      // Two doubles
      for (YAML::Iterator jt=(*it)[1].begin();jt!=(*it)[1].end();++jt) 
        {
          // string a; *jt >> a; double b = strtod(a.c_str(),NULL);
          // cout << b << " ";
        }
      // Many integers
      txb.clear();
      for (YAML::Iterator jt=(*it)[2].begin();jt!=(*it)[2].end();++jt) 
        {
          unsigned int a; *jt >> a; 
          // cout << a << " ";
          txb.push_back(a);
        }
      txbs.push_back(txb);
      // Many doubles
      for (YAML::Iterator jt=(*it)[3].begin();jt!=(*it)[3].end();++jt) 
        {
          string a; *jt >> a; double b = strtod(a.c_str(),NULL);
          // cout << b << " ";
        }
    }
  fin.close();

  // A random sample of TxB.
  txb = fGslRanTxBoundaries (shortRead.front()->size(),m.mK);
  // Compute this txb and each of txbs.
  for (unsigned int i = 0; i < txbs.size(); i++)
    {
      unsigned int d = fGslDistance (txb, txbs.at(i));
      cout << d << endl;
    }

  ////////////////////////////////////////////////////////////////////////////// 
  // Find a mean boundaries and count boundaries.
  ////////////////////////////////////////////////////////////////////////////// 
  // We can start with a random boundaries or one of the boundaries.
  // How can we step between two sets of boundaries? Randomly choose a finite
  // number of boundary sites, and increase or decrease the number by
  // considering its neighboring boundary sites. We need to choose how many
  // sites we move, and how many sites to increase or decrease. We use a uniform
  // distribution for the choice.
  //
  // Another summary is simpler. We count the number of posterior samples where
  // a site is a boundary site for each site. I am not clear about boundaries.
  // What is a boundary?
  vector<unsigned int> summaryTxB(shortRead.front()->size(),0U);
  for (unsigned int i = 0; i < txbs.size(); i++)
    {
      for (unsigned int j = 0; j < txbs[i].size(); j++)
        {
          unsigned int ck = txbs[i][j];
          summaryTxB.at(ck-1)++;
        }
    }
  vector<double> fractionTxB(shortRead.front()->size(),.0);
  for (unsigned int i = 0; i < summaryTxB.size(); i++)
    {
      fractionTxB.at(i) = static_cast<double>(summaryTxB.at(i)) 
                          / static_cast<double>(summaryTxB.size());
    }
  // Now, print fractionTxB.
  ////////////////////////////////////////////////////////////////////////////// 
  // Find a mean set of boundaries.
  ////////////////////////////////////////////////////////////////////////////// 
  Summarizer mSummarizer (&m,shortRead);
  mSummarizer.mTxbs = txbs;
  mSummarizer.params.n_tries = 0;            // Not used.
  mSummarizer.params.iters_fixed_T = m.mK;
  mSummarizer.params.step_size = 10.0;
  mSummarizer.params.k = 1.0;
  mSummarizer.params.t_initial = 1e10;
  mSummarizer.params.mu_t = 1.00001;
  mSummarizer.params.t_min = 1e-1;

  // Execute the summarizer and print it out.
  mSummarizer.execute ();
  of << mSummarizer;

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      of << **it;
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@

\subsection{tux-likelihood}
First, create a file called \Cfile{s1.tux} with the following content.
\begin{Verbatim}[frame=lines,framesep=5mm]
Fixed:
  mSeed: 12345
  mL: 10000
  mK: 10
  mM: 100000
  mZ:
    - 0.8699429
    - 1.0158870
    - 1.1287902
  mA0: 0.027
  mA1: 6.131
  mAlphaQExpression: 10
  mAlphaQBoundaries: 10
  mLengthSampleSegmentA: 4000
  mLengthSampleSegmentB: 6000
  mAlphaPriorExpression: 1
  mMcmcLength: 30
  mMcmcBurnin: 15
  mMcmcThin: 5
  mNumberProcess: 1
  mNumberChain: 3
  mNumberSwap: 2
  mNumberSwapTry: 2
  mSwapDistance: 7
  mHAlpha: 0.98
  mHBeta: 0.7
  mPrefix: s1.out
  mOutDirectory: ./
  mChainDirectory: ./
  mLogDirectory: ./
  mDatafile: s1.in
  mIsData: true
\end{Verbatim}

Run the following command.
\begin{Verbatim}[frame=lines,framesep=5mm]
./tux-probtx s1.tux s1.txb s1.log
./tux-likelihood s1.tux s1.out s1.log s1.txb
\end{Verbatim}

The \program{tux-probtx} creates two parameters in \Cfile{s1.txb}.
The \program{tux-likelihood} creates data in a data \Cfile{s1.in}.
<<tux-likelihood.cpp>>=
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <fstream>
#include <stdexcept>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include "config.h"
#include "tuxGslRng.h"
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "ezlogger_headers.hpp"
#include "tuxProbTxBoundaries.h"
#include "tuxProbTxExpression.h"
#include "tuxLikelihood.h"
#include "tuxTxBoundaries.h"
#include "tuxTxExpression.h"
#include "tuxReads.h"
#include "tuxFixed.h"
#include "tuxMoverManager.h"
#include "tuxMover.h"
#include "tuxMoverTxBoundaries.h"
#include "tuxMoverTxExpression.h"
#include "tuxChain.h"
#include "tuxChainManager.h"
#include "tuxMcmcSingle.h"
using namespace tux;
<<simpleopt>>
<<main tuxlf>>
<<main gslrngrandomnumber>>
int 
main (int argc, char *argv[])
{
  //////////////////////////////////////////////////////////////////////////////
  // Read two file names; the first is a .yaml file, and the second is the
  // output file name of the current tux-fixed program.
  //////////////////////////////////////////////////////////////////////////////
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) {
    if (args.LastError() == SO_SUCCESS) {
      if (args.OptionId() == OPT_HELP) {
          ShowUsage();
          return 0;
      }
      printf("Option, ID: %d, Text: '%s', Argument: '%s'\n",
          args.OptionId(), args.OptionText(),
          args.OptionArg() ? args.OptionArg() : "");
    }
    else {
      std::cout << "Invalid argument: " << args.OptionText() << std::endl;
      return 1;
    }
  }
  CSimpleGlob glob(SG_GLOB_NODOT|SG_GLOB_NOCHECK);
  if (SG_SUCCESS != glob.Add(args.FileCount(), args.Files())) {
    std::cout << "Error while globbing files" << std::endl;
    return 1;
  }

  if (glob.FileCount() != 4) {
    ShowUsage();
    return 1;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Log level
  //////////////////////////////////////////////////////////////////////////////
  // log_very_rarely
  // log_rarely
  axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);

  //////////////////////////////////////////////////////////////////////////////
  // Create GSL RNG and open an output file.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngAlloc ();
  lf.open(glob.File(2),std::fstream::out);
  std::fstream of;
  of.open(glob.File(1),std::fstream::out);
  of << std::scientific;// << std::fixed;
  of << std::setprecision(std::numeric_limits<double>::digits);

  // Add your source codes.
  //////////////////////////////////////////////////////////////////////////////
  // Read in a YAML file as a Fixed object m.
  //////////////////////////////////////////////////////////////////////////////
  Fixed m;
  std::ifstream fin(glob.File(0));
  YAML::Parser parser(fin);
  YAML::Node doc;
  parser.GetNextDocument(doc);
  doc["Fixed"] >> m;
  EZLOGGERSTREAM2(lf) << "Fixed is read" << std::endl;
  fin.close();

  //////////////////////////////////////////////////////////////////////////////
  // Set the random Seed.
  //////////////////////////////////////////////////////////////////////////////
  fGslRngSeed (m.mSeed);
  
  //////////////////////////////////////////////////////////////////////////////
  // Generate data.
  //////////////////////////////////////////////////////////////////////////////
  std::ofstream dataof;
  dataof.open(m.mDatafile.c_str());
  if (!dataof) 
    {
      std::cerr << "Unable to open file " << m.mDatafile << std::endl;
      EZLOGGERSTREAM2(lf) << "Fatal: unable to open file "
                          << m.mDatafile << std::endl;
      fGslRngFree ();
      return 1;
    }

//  ProbTxBoundaries priorTxBoundaries (m.L(), m.K());
//  TxBoundaries* txb = static_cast<TxBoundaries*>(priorTxBoundaries.r());
//  of << *txb;
//  ProbTxExpression priorTxExpression (m.K(),1.L);
//  TxExpression* txe = static_cast<TxExpression*>(priorTxExpression.r());
//  of << *txe;

  vector<unsigned int> txb;
  vector<double> txe;
  fin.open(glob.File(3));
  YAML::Parser parser2(fin);
  YAML::Node doc2;
  parser2.GetNextDocument(doc2);
  assert (doc2.size() == 1);
  for (YAML::Iterator it=doc2.begin();it!=doc2.end();++it) 
    {
      txb.clear();
      txe.clear();
      for (YAML::Iterator jt=(*it)[0].begin();jt!=(*it)[0].end();++jt) 
        {
          unsigned int a; *jt >> a; 
          txb.push_back(a);
        }
      // Many doubles
      for (YAML::Iterator jt=(*it)[1].begin();jt!=(*it)[1].end();++jt) 
        {
          string a; *jt >> a; double b = strtod(a.c_str(),NULL);
          txe.push_back(b);
        }
    }
  fin.close();
  TxBoundaries mTxB(txb);
  TxExpression mTxE(txe);

  Likelihood dataLikelihood (&m, &mTxB, &mTxE);
  vector<Reads*> shortRead;
  Reads* r;
  for (unsigned int j = 0; j < m.mZ.size(); j++)
    {
      r = static_cast<Reads*>(dataLikelihood.r());
      shortRead.push_back(r);
      dataof << *r << endl;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Delelet data.
  //////////////////////////////////////////////////////////////////////////////
  for (vector<Reads*>::iterator it = shortRead.begin(); 
       it != shortRead.end(); 
       it++)
    {
      delete *it;
    }

  //////////////////////////////////////////////////////////////////////////////
  // Close the  output file, and delete GSL RNG.
  //////////////////////////////////////////////////////////////////////////////
  of.close();
  lf.close();
  fGslRngFree ();

  return 0;
}
@


\subsection{Log}

Edit ezlogger\_format\_policy.hpp to change the log output.

Define the following definition to change the log file.
\begin{Verbatim}[frame=lines,framesep=5mm]
Check ezlogger_output_policy.hpp
#define EZLOGGER_OUTPUT_FILENAME "tux-log.out"
\end{Verbatim}

<<tux logfilename>>=
std::string axter::ezlogger_output_policy::mEzloggerOutputFilename = "log.txt";
<<tux-log.cpp>>=
#include <iomanip>
#include <fstream>
#include <cassert>
#include <vector>
#include "config.h"
#define EZLOGGER_OUTPUT_FILENAME "tux-log.out"
#include "ezlogger_headers.hpp"
void FunctFoo()
{
EZLOGGERFUNCTRACKER;
EZLOGGERDISPLAY_STACK;
//Function Foo code here....
}
int 
main (int argc, char *argv[])
{
  EZLOGGERFUNCTRACKER;
  EZLOGGERDISPLAY_STACK;
  EZLOGGER_PRG_MAIN_ARG(argc, argv);
  int i = 123;
  std::string somedata = "Hello World";
  std::string somedataOften = "Often, Hello World";
  std::ofstream f("tux-log.out2");
  bool b = true;
  static const unsigned int a[] = {16,2,77,29,5,2,3,3,2,3};
  std::vector<unsigned int> v(a,a+sizeof(a)/sizeof(a[0]));

  // log_always = 1, log_often, log_regularly, log_rarely, log_very_rarely
  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_very_rarely);

  EZLOGGER << "Start of ezlogger" << std::endl;
  EZLOGGER("ezlogger", 1, 0.77898);
  EZLOGGERVAR(b);
  //EZLOGGERVAR(v);
  EZLOGGERMARKER;
  FunctFoo();

  //Simple usage with standard verbosity level
  EZLOGGERSTREAM << somedata << " " << i << std::endl;

  //Can use alternate stream
  EZLOGGERSTREAM2(std::cerr) << somedata << " next line " << i << std::endl;
  EZLOGGERSTREAM2(f) << somedata << " next line " << i << std::endl;
  EZLOGGERVARIFY(b == false);
  //assert(b == false);

  //Verbosity level logging example
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_rarely);
  EZLOGGERSTREAM << somedata << " " << i << std::endl;
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_regularly);
  EZLOGGERSTREAM << somedata << " " << i << std::endl;
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_often);
  EZLOGGERSTREAM << somedata << " " << i << std::endl;
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  //axter::ezlogger<>::set_verbosity_level_tolerance(axter::log_always);
  EZLOGGERSTREAM << somedata << " " << i << std::endl;
  EZLOGGERVLSTREAM(axter::log_always) << " always" << std::endl;
  EZLOGGERVLSTREAM(axter::log_often) << " often" << std::endl;
  EZLOGGERVLSTREAM(axter::log_regularly) << " regularly" << std::endl;
  EZLOGGERVLSTREAM(axter::log_rarely) << " rarely" << std::endl;
  EZLOGGERVLSTREAM(axter::log_very_rarely) << " very_rarely" << std::endl;

  f.close();
  return 0;
}
@
\subsection{MPI}

\end{document}
