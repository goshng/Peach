\documentclass{article}
\usepackage{noweb}
\usepackage{fancyvrb}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage[authoryear]{natbib}
\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}
\pagestyle{noweb}
\noweboptions{}
\begin{document}

\title{Inferring ancestral population sizes and recombination rates}
\author{Sang Chul Choi\\
Dept.\ of Genetics, Rutgers University,\\
Piscataway, NJ 08854}

\maketitle

\tableofcontents

\newpage{}
\section{History}
\begin{enumerate}
\item Sun Apr 18 18:20:38 EDT 2010: The noweb file is created.
\end{enumerate}

\newpage{}
\section{Installation}

\begin{Verbatim}[frame=lines,framesep=5mm]
../configure CFLAGS="-Wall -Wextra -W -Wshadow -Wcast-qual -Wwrite-strings -g3 -ggdb -O0"
../configure 
../configure CFLAGS="-DNDEBUG -O3 --fast-math"
\end{Verbatim}


\newpage{}
\section{Overview}

\newpage{}
\section{Implementation}

\subsection{Boilerplates}
Chunks [[c decls]], [[c begin decls]], and [[c end decls]] are
a boilerplate for C++ client codes. The implementation of [[IMamp]] in C may be
relatively easily reused by C++ client codes. The three code sections may help
adjust [[IMamp]] C implementation to C++ codes maybe sometime later.
<<c decls>>=
#undef __BEGIN_DECLS
#undef __END_DECLS
#ifdef __cplusplus
# define __BEGIN_DECLS extern "C" {
# define __END_DECLS }
#else
# define __BEGIN_DECLS /* empty */
# define __END_DECLS /* empty */
#endif

<<c begin decls>>=
__BEGIN_DECLS

<<c end decls>>=
__END_DECLS

<<im3 copyright>>=
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2010 Sang Chul Choi and Jody Hey
//
// This file is part of IMa3.
// 
// IMa3 is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// IMa3 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with IMamp.  If not, see <http://www.gnu.org/licenses/>.
///////////////////////////////////////////////////////////////////////////////

@
\subsection{Useful commands for working with this noweb file}
You do not know where you were at. Here can be a start of coding.
\begin{Verbatim}[frame=lines,framesep=5mm]
NEED TO BE REVISED
------------------
../../simdiv/simdiv -isim3pop.i -wsim3pop.l -osim3pop-l5-is.dat -L5 -z0 -s25 -j4
pushd ../../src; ./c; popd; pushd ../../build; ../configure CFLAGS="-g3 -ggdb -O0 -DBF"; make clean; make; popd
pushd ../../src; ./c; popd; pushd ../../build; ../configure CFLAGS="-g3 -ggdb -O0"; make clean; make; popd
pushd ../../src; ./c; popd; pushd ../../build; make; popd; gdb ../../build/src/IMa2
\end{Verbatim}


@
\subsection{The file ``c''}
We have a master file for the development. Start with this file.
\begin{Verbatim}[frame=lines,framesep=5mm]
notangle -Rb ../noweb/IMa2p.nw > b; bash b 
notangle -Rc ../noweb/IMa2p.nw > c; bash c
\end{Verbatim}

We use Object design files of section 13 of ooc. For this we should use 11
report.
<<b>>=
#!/bin/bash
PROJECT=IMaLamarc
if [[ $OSTYPE == 'darwin10.0' ]]; then
  NOWEB=/Users/goshng/works/$PROJECT/noweb/$PROJECT.nw
elif [[ $OSTYPE == 'linux-gnu' ]]; then
  NOWEB=/home/goshng/Documents/Projects/$PROJECT/noweb/$PROJECT.nw
fi
notangle -Rc $NOWEB > c; bash c


<<c>>=
#!/bin/bash
PROJECT=IMaLamarc
if [[ $OSTYPE == 'darwin10.0' ]]; then
  oc="/Users/goshng/bin/oc -11"
  NOWEB=/Users/goshng/works/$PROJECT/noweb/$PROJECT.nw
  SEQ=jot
elif [[ $OSTYPE == 'linux-gnu' ]]; then
  oc="/home/goshng/Documents/Projects/ooc/ooc/ooc -11"
  NOWEB=/home/goshng/Documents/Projects/$PROJECT/noweb/$PROJECT.nw
  SEQ=seq
fi

function header1 () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -L -R${array[i]}.h $NOWEB | cpif ${array[i]}.h
  done
}

function source1 () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -L -R${array[i]}.c $NOWEB > ${array[i]}.c
    notangle -L -R${array[i]}.h $NOWEB | cpif ${array[i]}.h
  done
}

function header1noline () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -R${array[i]}.h $NOWEB | cpif ${array[i]}.h
  done
}

function source1noline () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -R${array[i]}.c $NOWEB > ${array[i]}.c
    notangle -R${array[i]}.h $NOWEB | cpif ${array[i]}.h
  done
}

function compile1 () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    gcc -Wall -W -Wextra -DWCH -g3 -ggdb -O0 -c ${array[i]}.c
  done
}

function header2 () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -L -R${array[i]}.hh $NOWEB | cpif ${array[i]}.hh
  done
}

function source2 () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -L -R${array[i]}.cc $NOWEB > ${array[i]}.cc
    notangle -L -R${array[i]}.hh $NOWEB | cpif ${array[i]}.hh
  done
}

function only2 () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -L -R${array[i]}.cc $NOWEB > ${array[i]}.cc
  done
}

function header2noline () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -R${array[i]}.hh $NOWEB | cpif ${array[i]}.hh
  done
}

function source2noline () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -R${array[i]}.cc $NOWEB > ${array[i]}.cc
    notangle -R${array[i]}.hh $NOWEB | cpif ${array[i]}.hh
  done
}

function only2 () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    notangle -L -R${array[i]}.cc $NOWEB > ${array[i]}.cc
  done
}

function compile2 () {
  array=( "$@" )
  for i in `$SEQ $#`; do
    i=$(($i - 1))
    g++ -Wall -W -Wextra -DWCH -g3 -ggdb -O0 -c ${array[i]}.cc
  done
}

##############################################################################
# IMawch
##############################################################################
function buildIMawch () {
  source2 imptools savegtree assertgenealogy Integrate ParserPoptreestring Pedge Prob Ptree Weight updatewch updatewchq IMParameter EdgeIMParameter
  source1 imalgorithm gtree imtools immalloc immath imrng
  header1 imglobal imenum imdef 
  header2 readata imstruct buildgtree calcprobdata VectorOperation autoc buildgtree calcprobdata freemem ginfo initialize mcmcfiles output swapchains updategenealogy updategtreecommon updatetRY updatemcparams
  # compile
  compile1 imalgorithm gtree imtools immalloc immath imrng 
  compile2 readata imptools savegtree assertgenealogy Integrate ParserPoptreestring Pedge Prob Ptree Weight updatewch updatewchq build_gtree calc_prob_data autoc build_gtree calc_prob_data freemem ginfo imamain initialize mcmcfiles output swapchains update_gtree update_gtree_common update_t_RY updatemcparams
  g++ imptools.o savegtree.o updatewch.o updatewchq.o assertgenealogy.o Integrate.o ParserPoptreestring.o Pedge.o Prob.o Ptree.o Weight.o autoc.o build_gtree.o calc_prob_data.o freemem.o ginfo.o gtree.o imalgorithm.o imamain.o immalloc.o immath.o imrng.o imtools.o initialize.o mcmcfiles.o output.o readata.o swapchains.o update_gtree.o update_gtree_common.o update_t_RY.o updatemcparams.o -o IMawch
#  valgrind --leak-check=full ./IMa3 -idata/t5-1.dat -oo/t5-1.out -b10 -l100 -d2 -m0.1 -t20 -q20 -s132323
#  ./IMa3 -idata/t5-1.dat -oo/t5-1.out -b100000 -l1000 -d100 -m0.5 -t10 -q5 -s132323
  exit
}

function buildIMawchnoline () {
  source2noline imptools savegtree assertgenealogy Integrate ParserPoptreestring Pedge Prob Ptree Weight updatewch updatewchq IMParameter EdgeIMParameter
  source1noline imalgorithm gtree imtools immalloc immath imrng
  header1noline imglobal imenum imdef 
  header2noline readata imstruct buildgtree calcprobdata VectorOperation autoc buildgtree calcprobdata freemem ginfo initialize mcmcfiles output swapchains updategenealogy updategtreecommon updatetRY updatemcparams

  tar zcf source.tar.gz \
  imptools.cc savegtree.cc assertgenealogy.cc Integrate.cc \
  ParserPoptreestring.cc Pedge.cc EdgeIMParameter.cc IMParameter.cc \
  Prob.cc Ptree.cc Weight.cc updatewch.cc updatewchq.cc \
  imptools.hh savegtree.hh assertgenealogy.hh Integrate.hh ParserPoptreestring.hh Pedge.hh \
  Prob.hh Ptree.hh Weight.hh updatewch.hh updatewchq.hh IMParameter.hh EdgeIMParameter.hh \
  imalgorithm.c gtree.c imtools.c immalloc.c immath.c imrng.c readata.cc \
  imalgorithm.h gtree.h imtools.h immalloc.h immath.h imrng.h \
  imglobal.h imenum.h imdef.h readata.hh \
  imstruct.hh buildgtree.hh calcprobdata.hh VectorOperation.hh autoc.hh \
  buildgtree.hh calcprobdata.hh freemem.hh ginfo.hh initialize.hh mcmcfiles.hh \
  output.hh swapchains.hh updategenealogy.hh updategtreecommon.hh updatetRY.hh \
  updatemcparams.hh xtrapbits.h \
  build_gtree.cc calc_prob_data.cc autoc.cc calc_prob_data.cc \
  freemem.cc ginfo.cc imamain.cc initialize.cc mcmcfiles.cc output.cc \
  swapchains.cc update_gtree.cc update_gtree_common.cc update_t_RY.cc \
  updatemcparams.cc msdirent.c msdirent.h


  compile1 imalgorithm gtree imtools immalloc immath imrng 
  compile2 readata imptools savegtree assertgenealogy Integrate ParserPoptreestring Pedge Prob Ptree Weight updatewch updatewchq build_gtree calc_prob_data autoc calc_prob_data freemem ginfo imamain initialize mcmcfiles output swapchains update_gtree update_gtree_common update_t_RY updatemcparams
  g++ imptools.o savegtree.o updatewch.o updatewchq.o assertgenealogy.o Integrate.o ParserPoptreestring.o Pedge.o Prob.o Ptree.o Weight.o autoc.o build_gtree.o calc_prob_data.o freemem.o ginfo.o gtree.o imalgorithm.o imamain.o immalloc.o immath.o imrng.o imtools.o initialize.o mcmcfiles.o output.o readata.o swapchains.o update_gtree.o update_gtree_common.o update_t_RY.o updatemcparams.o -o IMawch
#  valgrind --leak-check=full ./IMa3 -idata/t5-1.dat -oo/t5-1.out -b10 -l100 -d2 -m0.1 -t20 -q20 -s132323
#  ./IMa3 -idata/t5-1.dat -oo/t5-1.out -b100000 -l1000 -d100 -m0.5 -t10 -q5 -s132323
  exit
}


##############################################################################
# IMa3
##############################################################################
# some source files are not included:
# gtint.c, histograms.c jointfind.c utilities.c multi_t_bins.c
# surface_call_functions.c surface_search_functions.c
# treeprint.c popmig.c readpriorfile.c
#
# Not yet added
# build_poptree.c
function buildIMa3 () {
  source2 imptools savegtree assertgenealogy Integrate ParserPoptreestring Pedge Prob Ptree Weight updatetree
  source1 imalgorithm gtree imtools immalloc immath imrng
  header1 imglobal imenum imdef readata
  header2 imstruct buildgtree calcprobdata VectorOperation autoc buildgtree calcprobdata freemem ginfo initialize mcmcfiles output swapchains updategenealogy updategtreecommon updatetNW updatetRY updatemcparams
  # compile
  compile1 imalgorithm gtree imtools immalloc immath imrng readata
  compile2 imptools savegtree assertgenealogy Integrate ParserPoptreestring Pedge Prob Ptree Weight updatetree build_gtree calc_prob_data autoc build_gtree calc_prob_data freemem ginfo imamain initialize mcmcfiles output swapchains update_gtree update_gtree_common update_t_NW update_t_RY updatemcparams
  g++ imptools.o savegtree.o updatetree.o assertgenealogy.o Integrate.o ParserPoptreestring.o Pedge.o Prob.o Ptree.o Weight.o autoc.o build_gtree.o calc_prob_data.o freemem.o ginfo.o gtree.o imalgorithm.o imamain.o immalloc.o immath.o imrng.o imtools.o initialize.o mcmcfiles.o output.o readata.o swapchains.o update_gtree.o update_gtree_common.o update_t_NW.o update_t_RY.o updatemcparams.o -o IMa3
#  valgrind --leak-check=full ./IMa3 -idata/t5-1.dat -oo/t5-1.out -b10 -l100 -d2 -m0.1 -t20 -q20 -s132323
#  ./IMa3 -idata/t5-1.dat -oo/t5-1.out -b100000 -l1000 -d100 -m0.5 -t10 -q5 -s132323
  exit
}

function buildIMaLamarc () {
  #source2 Integrate ParserPoptreestring Pedge Prob Ptree Weight IMParameter EdgeIMParameter
  #compile2 Integrate ParserPoptreestring Pedge Prob Ptree Weight IMParameter EdgeIMParameter
  source2 IMParameter
  compile2 IMParameter
  exit
}




# header1 for C header
# header2 for C++ header

#buildIMa3
#buildIMawch
#buildIMawchnoline
#buildIMaLamarc

##############################################################################
# Ptree
##############################################################################
# header1 imenum - we need to deal with it.
header2 imset imdef 
source2 imconstants imglobal
source2 immath imptools Weight Integrate imrng IMParameter EdgeIMParameter Pedge \
ParserPoptreestring Ptree
only2 Ptree-t
header2 VectorOperation
compile2 imconstants imglobal
compile2 immath imptools Weight Integrate imrng IMParameter EdgeIMParameter Pedge \
Ptree Ptree-t
g++ imglobal.o imconstants.o immath.o imptools.o Weight.o Integrate.o imrng.o IMParameter.o \
EdgeIMParameter.o Pedge.o ParserPoptreestring.o Ptree.o Ptree-t.o -o Ptree-t
./Ptree-t
exit




##############################################################################
# Pedge
##############################################################################
source2 immath imptools Weight Integrate imrng IMParameter EdgeIMParameter Pedge
only2 Pedge-t
header2 VectorOperation
compile2 immath imptools Weight Integrate imrng IMParameter EdgeIMParameter Pedge Pedge-t
g++ immath.o imptools.o Weight.o Integrate.o imrng.o IMParameter.o \
EdgeIMParameter.o Pedge.o Pedge-t.o -o Pedge-t
./Pedge-t
exit


##############################################################################
# immath
##############################################################################
source2 immath
only2 immath-t
compile2 immath immath-t
g++ immath.o immath-t.o -o immath-t
./immath-t
exit

##############################################################################
# Integrate
##############################################################################
source2 imptools Integrate
only2 Integrate-t
compile2 imptools Integrate Integrate-t
g++ imptools.o Integrate.o Integrate-t.o -o Integrate-t
./Integrate-t
exit


##############################################################################
# ParserPoptreestring
##############################################################################
source2 ParserPoptreestring
only2 ParserPoptreestring-t
compile2 ParserPoptreestring ParserPoptreestring-t
g++ ParserPoptreestring.o ParserPoptreestring-t.o -o ParserPoptreestring-t
./ParserPoptreestring-t
exit


##############################################################################
# Weight
##############################################################################
source2 imptools Weight 
only2 Weight-t
compile2 imptools Weight Weight-t
g++ imptools.o Weight.o Weight-t.o -o Weight-t
./Weight-t
exit

##############################################################################
# imtools.cc using C++
##############################################################################
source2 imptools
only2 imptools-t
compile2 imptools imptools-t
g++ imptools.o imptools-t.o -o imptools-t
./imptools-t
exit

##############################################################################
# Prob
##############################################################################
source2 Prob
only2 Prob-t
compile2 Prob Prob-t
g++ Prob.o Prob-t.o -o Prob-t
./Prob-t
exit

##############################################################################
# EdgeIMParameter
##############################################################################
source2 imrng IMParameter EdgeIMParameter
only2 EdgeIMParameter-t
header2 VectorOperation
compile2 imrng IMParameter EdgeIMParameter EdgeIMParameter-t 
g++ imrng.o EdgeIMParameter.o IMParameter.o EdgeIMParameter-t.o -o EdgeIMParameter-t
./EdgeIMParameter-t
exit

##############################################################################
# IMParameter
##############################################################################
source2 imrng IMParameter
only2 IMParameter-t
compile2 imrng IMParameter IMParameter-t
g++ imrng.o IMParameter.o IMParameter-t.o -o IMParameter-t
exit

##############################################################################
# Boost uniform
##############################################################################
source2 imrng
only2 imrng-t
compile2 imrng imrng-t
g++ imrng.o imrng-t.o -o imrng-t
./imrng-t
exit

##############################################################################
# Lmcmc
##############################################################################
only2 Lmcmc
source2 IParam Lmode Ltree Ledge IMParameter EdgeIMParameter Ptree Pedge Weight Integrate ParserPoptreestring imptools 
source1 imtools imrng immath
header1 imenum imglobal imdef
header2 VectorOperation
compile2 IParam Lmode Ltree Ledge IMParameter EdgeIMParameter Ptree Pedge Weight Integrate ParserPoptreestring imptools Lmcmc
compile1 imtools imrng immath
g++ -g3 -ggdb -O0 -c anyoption.cpp
g++ IParam.o Lmode.o Ltree.o Ledge.o IMParameter.o EdgeIMParameter.o Ptree.o Pedge.o Weight.o Integrate.o ParserPoptreestring.o imptools.o Lmcmc.o imtools.o imrng.o immath.o anyoption.o -o Lmcmc
#gdb ./Lmcmc
./Lmcmc --ml -i o/t5-1.out -g 10000 -t 10 -b .0 --iLH 160
#./Lmcmc --sort -i o/Belfiore.out -g 10000 -t 10 -b .0 --iLH 160
#valgrind --leak-check=full --show-reachable=yes ./Lmcmc -i o/t5-1.out -g 3 -t 1 -b .0 --iLH 160 --seed 123
#gdb ./Lmcmc 
exit



##############################################################################
# pair
##############################################################################
only2 pair
g++ pair.cc -o pair
./pair
exit



##############################################################################
# IParam-t
##############################################################################
source2 IParam
only2 IParam-t
compile2 IParam IParam-t
g++ IParam.o IParam-t.o -o IParam-t
./IParam-t
exit


##############################################################################
# Ptree
##############################################################################
source1 imtools imrng immath
header1 imenum imglobal imdef
header2 VectorOperation
source2 Ptree Pedge Weight Integrate ParserPoptreestring imptools 
only2 Ptree-t
compile1 imtools imrng immath
compile2 Ptree Pedge Weight Integrate ParserPoptreestring Ptree-t imptools
g++ imptools.o ParserPoptreestring.o imrng.o imtools.o immath.o Ptree.o Pedge.o Weight.o Integrate.o Ptree-t.o -o Ptree-t
valgrind ./Ptree-t
exit


##############################################################################
# ParserPoptreestring-t
##############################################################################
source2 ParserPoptreestring
only2 ParserPoptreestring-t
compile2 ParserPoptreestring ParserPoptreestring-t
g++ ParserPoptreestring.o ParserPoptreestring-t.o -o ParserPoptreestring-t
#gdb ./ParserPoptreestring-t
valgrind ./ParserPoptreestring-t
exit

##############################################################################
# Lmode-t
##############################################################################
only2 Lmode-t
source2 Lmode Ltree Ledge IMParameter EdgeIMParameter Ptree Pedge Weight Integrate ParserPoptreestring imptools 
source1 imtools imrng immath
only2 Ltree-t
header1 imenum imglobal imdef
header2 VectorOperation
compile2 Lmode Ltree Ledge IMParameter EdgeIMParameter Lmode-t Ptree Pedge Weight Integrate ParserPoptreestring imptools 
compile1 imtools imrng immath
g++ Lmode.o Ltree.o Ledge.o IMParameter.o EdgeIMParameter.o Ptree.o Pedge.o Weight.o Integrate.o ParserPoptreestring.o imptools.o Lmode-t.o imtools.o imrng.o immath.o -o Lmode-t
#gdb ./Lmode-t
exit



##############################################################################
# Ltree
##############################################################################
source2 Ltree Ledge IMParameter EdgeIMParameter Ptree Pedge Weight Integrate ParserPoptreestring imptools 
source1 imtools imrng immath
only2 Ltree-t
header1 imenum imglobal imdef
header2 VectorOperation
compile2 Ltree Ledge IMParameter EdgeIMParameter Ltree-t Ptree Pedge Weight Integrate ParserPoptreestring imptools 
compile1 imtools imrng immath
g++ Ltree.o Ledge.o IMParameter.o EdgeIMParameter.o Ptree.o Pedge.o Weight.o Integrate.o ParserPoptreestring.o imptools.o Ltree-t.o imtools.o imrng.o immath.o -o Ltree-t
./Ltree-t
exit


##############################################################################
# Ledge 
##############################################################################
source2 Ledge IMParameter EdgeIMParameter 
only2 Ledge-t
source1 imrng
compile2 Ledge IMParameter EdgeIMParameter Ledge-t
compile1 imrng
g++ imrng.o EdgeIMParameter.o IMParameter.o Ledge.o Ledge-t.o -o Ledge-t
./Ledge-t
exit

##############################################################################
# Pedge
##############################################################################
source1 immath imtools imrng
source2 Pedge Weight Integrate IMParameter EdgeIMParameter imptools
header2 VectorOperation
only2 Pedge-t
compile2 Pedge Weight Integrate IMParameter EdgeIMParameter Pedge-t imptools
compile1 immath imtools imrng 
g++ imptools.o immath.o imtools.o imrng.o Pedge.o Weight.o Integrate.o EdgeIMParameter.o IMParameter.o Pedge-t.o -o Pedge-t
./Pedge-t
exit

##############################################################################
# IMParameter
##############################################################################
source2 IMParameter
source1 imrng
only2 IMParameter-t
compile2 IMParameter IMParameter-t
compile1 imrng
g++ imrng.o IMParameter.o IMParameter-t.o -o IMParameter-t
./IMParameter-t
exit





##############################################################################
# imtools.cc using C++
##############################################################################
source2 imptools
only2 imptools-t
compile2 imptools imptools-t
g++ imptools.o imptools-t.o -o imptools-t
./imptools-t
exit




##############################################################################
# Ptree
##############################################################################
source1 imtools imrng immath
header1 imenum imglobal imdef
header2 VectorOperation
source2 Ptree Pedge Weight Integrate ParserPoptreestring imptools
only2 Ptree-t
compile1 imtools imrng immath
compile2 Ptree Pedge Weight Integrate ParserPoptreestring Ptree-t imptools
g++ imptools.o ParserPoptreestring.o imrng.o imtools.o immath.o Ptree.o Pedge.o Weight.o Integrate.o Ptree-t.o -o Ptree-t
./Ptree-t
exit


##############################################################################
# IMa3
##############################################################################
# some source files are not included:
# gtint.c, histograms.c jointfind.c utilities.c multi_t_bins.c
# surface_call_functions.c surface_search_functions.c
# treeprint.c popmig.c readpriorfile.c
#
# Not yet added
# build_poptree.c
source2 imptools savegtree assertgenealogy Integrate ParserPoptreestring Pedge Prob Ptree Weight updatetree
source1 imalgorithm gtree imtools immalloc immath imrng
header1 imglobal imenum imdef readata
header2 buildgtree calcprobdata VectorOperation autoc buildgtree calcprobdata freemem ginfo initialize mcmcfiles output swapchains updategenealogy updategtreecommon updatetNW updatetRY updatemcparams
# compile
compile1 imalgorithm gtree imtools immalloc immath imrng readata
compile2 imptools savegtree assertgenealogy Integrate ParserPoptreestring Pedge Prob Ptree Weight updatetree build_gtree calc_prob_data autoc build_gtree calc_prob_data freemem ginfo imamain initialize mcmcfiles output swapchains update_gtree update_gtree_common update_t_NW update_t_RY updatemcparams
g++ imptools.o savegtree.o updatetree.o assertgenealogy.o Integrate.o ParserPoptreestring.o Pedge.o Prob.o Ptree.o Weight.o autoc.o build_gtree.o calc_prob_data.o freemem.o ginfo.o gtree.o imalgorithm.o imamain.o immalloc.o immath.o imrng.o imtools.o initialize.o mcmcfiles.o output.o readata.o swapchains.o update_gtree.o update_gtree_common.o update_t_NW.o update_t_RY.o updatemcparams.o -o IMa3
exit

foo 1 2 nice okay
exit


# Ledge
source2 Ledge
compile2 Ledge
source2 IMParameter
compile2 IMParameter
source2 EdgeIMParameter
compile2 EdgeIMParameter
source1 imrng
compile1 imrng
test2 Ledge
g++ imrng.o EdgeIMParameter.o IMParameter.o Ledge.o Ledge-t.o -o Ledge-t
./Ledge-t
exit

g++ -g3 -ggdb -O0 -c anyoption.cpp
source2 Lmcmc
compile2 Lmcmc
g++ Lmcmc.o anyoption.o -o Lmcmc
./Lmcmc -q 10 -m 0.5 -i 1.out -g 10000 -t 10 -b .2
exit

#compile2 imamain.cc
#g++ savegtree.o updatetree.o assertgenealogy.o Integrate.o ParserPoptreestring.o Pedge.o Prob.o Ptree.o Weight.o autoc.o build_gtree.o calc_prob_data.o freemem.o ginfo.o gtree.o imalgorithm.o imamain.o immalloc.o immath.o imrng.o imtools.o initialize.o mcmcfiles.o output.o readata.o swapchains.o update_gtree.o update_gtree_common.o update_t_NW.o update_t_RY.o updatemcparams.o -o IMa3
#exit


# string-t
exe1 string-t
./string-t
exit


# assertgenealogy
source2 assertgenealogy
exit

source2 updatetree
exit 

source2 savegtree
exit


# imamain.cc
header2 mcmcfiles
header2 swapchains
source1 imtools
header1 readata
header2 updatetNW
header2 updatetRY
header2 updategenealogy
header2 imstruct
header1 imenum
header1 imdef
g++ -g3 -ggdb -O0 -c imamain.cc 
exit



# freemem.cc
header2 freemem
g++ -g3 -ggdb -O0 -c freemem.cc 
exit

# mcmcfiles.hh
header2 mcmcfiles
g++ -g3 -ggdb -O0 -c mcmcfiles.cc 
exit

# swapchains.hh
header2 swapchains
g++ -g3 -ggdb -O0 -c swapchains.cc 
exit

# output.cc
header2 output
g++ -g3 -ggdb -O0 -c output.cc 
exit

# readata.h
header1 readata
gcc -g3 -ggdb -O0 -c readata.c  
exit

# updatemcparams.hh
header2 updatemcparams
g++ -g3 -ggdb -O0 -c updatemcparams.cc 
exit

# updatetNW.hh
header2 updatetNW
g++ -g3 -ggdb -O0 -c update_t_NW.cc
exit

# updatetRY.hh
header2 updatetRY
g++ -g3 -ggdb -O0 -c update_t_RY.cc
exit


# updategenealogy.hh
header2 updategenealogy
g++ -g3 -ggdb -O0 -c update_gtree.cc
exit

# initialize.hh
source1 imalgorithm
header2 updategtreecommon
source1 immath
source2 Ptree
header1 imdef
header1 imenum
header2 imstruct
header2 initialize
g++ -g3 -ggdb -O0 -c initialize.cc
exit


# update gtree common.hh
source1 imalgorithm
source1 immath
source2 Ptree
header2 imstruct
header2 updategtreecommon
g++ -g3 -ggdb -O0 -c update_gtree_common.cc
exit

# imalgorithm
source1 imalgorithm
exit


# ginfo.hh
header2 ginfo
header2 imstruct
g++ -g3 -ggdb -O0 -c ginfo.cc
exit

# calc_prob_data.cc
source1 imtools
header1 imenum
header1 imdef
header2 imstruct
source1 gtree
header2 calcprobdata
g++ -g3 -ggdb -O0 -c calc_prob_data.cc
exit

# build_gtree.cc
source1 gtree
header1 imdef
header2 imstruct
header2 buildgtree
g++ -g3 -ggdb -O0 -c build_gtree.cc
exit


# immath.h
source1 immath
exit

# gtree.h
source1 gtree
exit


# autoc.cc
header2 Prob
header2 imstruct
header2 autoc
g++ -g3 -ggdb -O0 -c autoc.cc
exit

# immalloc-t
source1 imtools
source1 immalloc
exit

# CommandLine
# http://www.hackorama.com/anyoption/
g++ -g3 -ggdb -O0 -c anyoption.cpp
g++ -g3 -ggdb -O0 -c demo.cpp
g++ anyoption.o demo.o -o demo
exit

# IMa3
source1 assertgenealogy
source1 updatetree
source1 savegtree

# Pair
exe1 pair
./pair
exit
# string-t
exe1 string-t
./string-t
exit

# Vector-t
header2 VectorOperation
test2 vector
g++ vector-t.o -o vector-t
./vector-t
exit


# Integrate
source2 Integrate
test2 Integrate
g++ Integrate.o Integrate-t.o -o Integrate-t
./Integrate-t
exit


# Iparam
source2 Iparam
test2 Iparam
g++ Iparam.o Iparam-t.o -o Iparam-t
./Iparam-t
exit

# Weight
source2 Weight
test2 Weight
g++ Weight.o Weight-t.o -o Weight-t
./Weight-t
exit


# Pair
exe1 pair
./pair
exit

# Word
exe1 word
./word
exit

# Bookstore
exe1 bookstore
./bookstore
exit

# Plotpoint
source2 Plotpoint
test2 Plotpoint
g++ Plotpoint.o Plotpoint-t.o -o Plotpoint-t
./Plotpoint-t
exit

# Plotpoint
source2 Plotpoint
test2 Plotpoint
g++ Plotpoint.o Plotpoint-t.o -o Plotpoint-t
./Plotpoint-t
exit

# ParserPoptreestring
source2 ParserPoptreestring
test2 ParserPoptreestring
g++ ParserPoptreestring.o ParserPoptreestring-t.o -o ParserPoptreestring-t
./ParserPoptreestring-t
exit

# CString
source2 CString
test2 CString
g++ CString.o CString-t.o -o CString-t
./CString-t
exit

# test C++ code 
test2 cc
g++ cc-t.o -o cc-t
./cc-t

source1 assertgenealogy
source1 updatetree
source1 savegtree
#gcc -c classes.c 
compile_object
#class2 Wrapper
#class2 Int
#class2 TreeNode
#class2 Plotter
#class2 Phylogeny
class2 Iparam
test1 Iparam
class2 Plotpoint
test1 Plotpoint
class2 CString
test1 CString
class2 Pedge
test1 Pedge
class2 Ptree
test1 Ptree
class2 Weight
test1 Weight
class2 Prob
test1 Prob
class2 Integrate
test1 Integrate
class2 ParserPoptreestring
test1 ParserPoptreestring
exit

@
\section{Brainstorming for IMa3}
We will find all possible objects and their properties.
Node is a node of a trsee
: GenealogyNode, PhylogenyNode.
Genealogy is a gene tree.
Phylogeny is a species or population tree.
Sampler is the MCMC operator.
Individual belongs to one of sampled populations.
Population consists of multiple individuals.
Plot shows the trend of values in time.
Point is a dot on Plot.
Axis is a x or y bar on Plot.
Data are a list of loc.
Locus is a datum.
Genotype is a DNA sequence or microsatellite
: ISGenotype, HKYGenotype, SWGenotype, and ISSWGenotype.
MutationModel is a model for computing likelihood of data given a gene tree
: ISMutationModel, HKYMutationModel, SWMutationModel, ISSWMutationModel.
Probability is a function for probabilities
: LikelihoodXG, PriorG, PriorTheta, PriorGTheta, PriorThetaG.
Chain is a sequence of states of parameters.
Chains are mulitiple instances of Chain.
State is a value of the parameter.
IMParameter is a free random variable (Data is a fixed variable).
Updator changes State of a parameter: propose, accept, or reject.
Input takes inputs from a user.
Output prints something.
String is an array of characters.
Analyzer is the postprocessor of a posterior sample.
Screen is a user interface that responds to user's keyboard inputs, a simple
screen output controller: we need two threads one for the main working thread,
and another for the user interface (log mode or command mode). Or we could use
signal to stop MCMC and change running option such Ctrl+D.
Variable is a value that we can change.
Constant is a value that we cannot change.
RNG generates a pseudo random number: we could use the implementation of either
IMa2 or GNU Scientific Library.
Autocorrelation computes autocorrelation of a random variable using 1000 values.
Migstruct has migration event time and source population label.

STRUCTUREs that I could not understand: 
struct extendnum,
struct eevent,
struct hlists,
struct hkyinfo (I may have to use this without modification),
struct edgemiginfo (saving and restoring edge information),


We will need more classes.
We will have basic data structures.

We can take XML or IMa2 input files.
We provide interactive and batch mode. We could use the tutorial of ooc for the
interactive mode. IMa2 input file can be read with IMa2's command options for
the batch mode. We will convert XML to and from an IMa2 input file. The XML file
will contain all of the information for running IMa2 in the batch mode. 

Why am I doing this? Population tree update? A quick and good solution? Species
tree inference with very small individuals? Posterior sampling of demographic
parameters using a sample of genealogies as data? Trajectory of migration rate
in time? Trajectory of population size in time? More diverse mutation models?
What values do I earn?
@
\subsection{Number of labeled history}

\[
n!(n-1)!/2^{n-1}\]

n  count  
--------
2: 1
       * 3
3: 3          + 3
       * 6
4: 18         + 4
       * 10
5: 180        + 5
       * 15
6: 2700       + 6
       * 21
7: 56700      + 7
       * 28


@
\subsection{Jukes-Cantor Model}

<<model jc header>>=
double likelihoodJC (int ci, int li, double u);
int computeLk (double (*l_k)[4], double u, int li, im_edge *t, int k, int si);
double PijJC (int i, int j, double t);
double IMA_edge_length (im_edge *t, int ei);
<<model jc>>=
double
likelihoodJC (int ci, int li, double u)
{
  double l_k[4];
  double v;
  int si;
  im_edge *gtree; 

  gtree = C[ci]->G[li].gtree;
  v = 0.0;
  for (si = 0; si < L[li].numsites; si++)
    {
      computeLk (&l_k, u, li, gtree, C[ci]->G[li].root, si);
      v += logsum (4, l_k[0], l_k[1], l_k[2], l_k[3]);
      v -= M_LN2 * 2;
    }

  return v;
}

/* Function: computeLk
* l_k: return value for the conditional likelihood
* u  : branch length scaler
* li : locus index
* t  : tree
* k  : node index
* si : site index */
int
computeLk (double (*l_k)[4], double u, int li, im_edge *t, int k, int si)
{
  int s;
  int x;
  int y;
  int left;
  int right;
  int base;
  int basel;
  int baser;
  double l_kl[4] = { 0.0, 0.0, 0.0, 0.0};
  double l_kr[4] = { 0.0, 0.0, 0.0, 0.0};
  double l_kleft;
  double l_kright;
  double A;
  double tl;
  double tr;

  left = t[k].up[0];
  right = t[k].up[1];
  base = -1;
  if (left < 0 && right < 0)
    {
      assert (!(k < 0));
      assert (k < L[li].numgenes);
      base = L[li].seq[k][si];
    }
  else
    {
      assert (!(left < 0 || right < 0));
      basel = computeLk (&l_kl, u, li, t, left, si);
      baser = computeLk (&l_kr, u, li, t, right, si);
      tl = u * IMA_edge_length (t, left);
      tr = u * IMA_edge_length (t, right);

      for (s = 0; s < 4; s++)
        {
          l_kleft = 0.0;
          if (basel == -1)
            {
              for (x = 0; x < 4; x++)
                {
                  A = PijJC (x, s, tl) + l_kl[x];
                  LogSum2 (l_kleft, l_kleft, A);
                }
            }
          else
            {
              assert (basel == 0 || basel == 1 || basel == 2 || basel == 3);
              l_kleft = PijJC (basel, s, tl);
            }

          l_kright = 0.0;
          if (baser == -1)
            {
              for (y = 0; y < 4; y++)
                {
                  A = PijJC (y, s, tr) + l_kr[y];
                  LogSum2 (l_kright, l_kright, A);
                }
            }
          else
            {
              assert (baser == 0 || baser == 1 || baser == 2 || baser == 3);
              l_kright = PijJC (baser, s, tr);
            }
          (*l_k)[s] = l_kleft + l_kright;
        }
    }

  return base; 
}

double
PijJC (int i, int j, double t)
{
  double v;
  double A;

  if (i == j)
    {
      A = -4.0 * t / 3.0;
      LogDiff (v, 0.0, A);
      v -= M_LN2 * 2;
    }
  else
    {
      A = -4.0 * t / 3.0 + log (3.0);
      LogSum2 (v, 0.0, A);
      v -= M_LN2 * 2;
    }
  return v;
}

double
IMA_edge_length (im_edge *t, int ei)
{
  double upt;
  int up0;

  up0 = t[ei].up[0];
  if (up0 < 0)
    {
      upt = 0.0;
    }
  else
    {
      upt = t[up0].time;
    }
  return t[ei].time - upt;
}


@
\subsection{Assert genealogy}

<<assertgenealogy.hh>>=
<<im3 copyright>>
#ifndef _ASSERTGENEALOGY_HH_
#define _ASSERTGENEALOGY_HH_
<<model jc header>>
void assertgenealogy (int ci);
void assertgenealogyloc (int ci, int li);
void IMA_convert_IM2Mrbayes (char *mrbayes);
void IMA_output_mrbayes_bat (char *fname);
int imaGtreePop (int ci, int li, int ei);
double imaGtreeBranchLength (int ci, int li, int ei);
double imaGtreeTime (int ci, int li, int ei);
int imaGtreeNmig (int ci, int li, int ei);
#endif /* _ASSERTGENEALOGY_HH_ */

<<assertgenealogy.cc>>=
<<im3 copyright>>
#include <cstdio>
#include <cstdlib>
#include "imdef.h"
#include "imenum.h"
#include "imstruct.hh"
#include "gtree.h"
#include "Ptree.hh"
#include "assertgenealogy.hh"

extern struct locus *L;
extern struct chain **C;

static void assertgenealogylabel (int ci);
static void assertgenealogyloclabel (int ci, int li);
static void assertgenealogyedgelabel (int ci, int li, int ei);
static void assertgenealogyultrametric (int ci);
static void assertgenealogylocultrametric (int ci, int li);
static void IMA_check_popn_up (int ci, int kprevperiod, int prevpop, int kperiod, int pop);
static void IMA_check_popn_move (int ci, int notpop, int kperiod, int pop);

extern char popnames[][NAMELENGTH];
<<model jc>>

void 
IMA_output_mrbayes_bat (char *fname)
{
  FILE *fp;
  char *batname;
  char *bname;
  int lenbatname;

  fp = NULL;
  batname = NULL;
  lenbatname = strlen (fname) + 4 + 1;
  batname = (char *) malloc (lenbatname * sizeof (char));
  sprintf (batname, "%s.bat", fname);

#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
  bname = strrchr (fname, '\\');
#else
  bname = strrchr (fname, '/');
#endif
  if (bname == NULL)
    {
      bname = fname;
    }
  else
    {
      bname++;
    }

  fp = fopen (batname, "w");
  fprintf (fp, "execute %s.nex\n", bname);
  fprintf (fp, "sumt nruns=1\n");
  fprintf (fp, "quit\n");
  fclose (fp);
  fp = NULL;

  free (batname);
  batname = NULL;
  return;
}

void
IMA_convert_IM2Mrbayes (char *mrbayes)
{
  int i;
  FILE *infile;

  infile = fopen (mrbayes, "w");

  fprintf (infile, "#NEXUS\n");
  fprintf (infile, "begin data;\n");
  fprintf (infile, "dimensions ntax=%d nchar=1;\n", npops);
  fprintf (infile, "format datatype=dna interleave=no gap=-;\n");
  fprintf (infile, "matrix\n");
  for (i = 0; i < npops; i++)
    {
      fprintf (infile, "%s A\n", popnames[i]);
    }
  fprintf (infile, ";\n");
  fprintf (infile, "end;\n");

  fclose (infile);
  infile = NULL;

  return;
}


void
assertgenealogyloc (int ci, int li)
{
  assertgenealogyloclabel (ci, li);
  assertgenealogylocultrametric (ci, li);
  return;
}

void
assertgenealogy (int ci)
{
  assertgenealogylabel (ci);
  assertgenealogyultrametric (ci);
  return;
}

void
assertgenealogyedgelabel (int ci, int li, int ei)
{
  /* Check all labels of events along a branch! */
  int left;
  int right;
  int gparent;
  int nmigs;
  int mi;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  double ktime;
  double kprevtime;
  int kperiod;
  int kprevperiod;
  int pop;
  int prevpop;
  int ngenes;
  int ngnodes;

  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  left = gtree[ei].up[0];
  right = gtree[ei].up[1];
  gparent = gtree[ei].down;
  if (modeloptions[NOMIGRATION] == 1)
    {
      nmigs = 0;
    }
  else
    {
      nmigs = imaGtreeNmig (ci, li, ei);
    }
  assert (!(nmigs < 0));

  if (gparent < 0)
    {
      assert (nmigs == 0);
      kprevperiod = -1;
      prevpop = -1;
    }
  else
    {
      ngenes = L[li].numgenes;
      ngnodes = 2 * ngenes - 1;
      assert (gparent < ngnodes);
      assert (!(gtree[gparent].pop < 0));
      kprevtime = gtree[ei].time;
      kprevperiod = C[ci]->ptree.PtreeFindperiod (kprevtime);
      prevpop = gtree[gparent].pop; 
    }
  for (mi = 0; mi < nmigs; mi++)
    {
      ktime = gtree[ei].mig[nmigs - 1 - mi].mt;
      assert (!(ktime < 0.0));
      kperiod = C[ci]->ptree.PtreeFindperiod (ktime);
      assert (!(prevpop < 0));
      pop = gtree[ei].mig[nmigs - 1 - mi].mp;
      IMA_check_popn_up (ci, kprevperiod, prevpop, kperiod, pop);
      prevpop = pop;
      if (mi == nmigs - 1)
        {
          pop = gtree[ei].pop;
        }
      else
        {
          pop = gtree[ei].mig[nmigs - 2 - mi].mp;
        }
      IMA_check_popn_move (ci, prevpop, kperiod, pop);
      assert (!(pop < 0));
      kprevperiod = kperiod;
      prevpop = pop;
    }
  ktime = imaGtreeTime (ci, li, ei);
  kperiod = C[ci]->ptree.PtreeFindperiod (ktime);
  pop = gtree[ei].pop;
  IMA_check_popn_up (ci, kprevperiod, prevpop, kperiod, pop);

  if (left < 0 && right < 0)
    {
      /* No Code */
    }
  else
    {
      assertgenealogyedgelabel (ci, li, left);
      assertgenealogyedgelabel (ci, li, right);
    }
  return;
}

void
assertgenealogylabel (int ci)
{
  int li;

  for (li = 0; li < nloci; li++)
    {
      assertgenealogyloclabel (ci, li);
    }
  return;
}

void
assertgenealogyloclabel (int ci, int li)
{
  struct genealogy *G = NULL;

  G = &(C[ci]->G[li]);
  assertgenealogyedgelabel (ci, li, G->root);

  return;
}

void
assertgenealogyultrametric (int ci)
{
  int li;

  for (li = 0; li < nloci; li++)
    {
      assertgenealogylocultrametric (ci, li);
    }
  return;
}

void
assertgenealogylocultrametric (int ci, int li)
{
  int ngenes;
  int ei;
  int gparent;
  double l;
  double len;
  double lentoroot;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  ngenes = L[li].numgenes;


  for (ei = 0; ei < ngenes; ei++)
    {
      gparent = gtree[ei].down;
      len = imaGtreeBranchLength (ci, li, ei);
      assert (len > 0.00000000000000001);
      while (gparent != G->root)
        {
          l = imaGtreeBranchLength (ci, li, gparent);
          assert (l > 0.00000000000000001);
          len += l;
          gparent = gtree[gparent].down;
        }
      if (ei == 0)
        {
          lentoroot = len;
        }
      assert (fabs(len - lentoroot) < 0.0001);
    }
  return;
}

/* SANGCHUL: I have no other good names for these two functions. */
void
IMA_check_popn_up (int ci, int kprevperiod, int prevpop, int kperiod, int pop)
{
  if (!(kprevperiod < 0))
    {
      assert (!(kperiod > kprevperiod));
    }
  assert (!(kperiod < 0));
  assert (kperiod < npops);
  assert (kprevperiod < npops);

  if (kprevperiod < 0) /* a root's population */
    {
      assert (ISELEMENT (pop, C[ci]->ptree.PtreeGetPeriodset (kperiod)));
      //assert (BitIsTrue (saC.Ps[kperiod], pop));
    }
  else /* a non-root's population */
    {
      assert (ISELEMENT (pop, C[ci]->ptree.PtreeGetPeriodset (kperiod)));
      assert (C[ci]->ptree.PtreePopndown (pop, kprevperiod) == prevpop);
    }
  return;
}

void
IMA_check_popn_move (int ci, int notpop, int kperiod, int pop)
{
  /* [[notpop]] must exist in period [[kperiod]]. */ 
  assert (!(kperiod < 0));
  assert (kperiod < npops);
  assert (ISELEMENT (notpop, C[ci]->ptree.PtreeGetPeriodset (kperiod)));
  assert (notpop != pop);

  /* pop does not belong to notpop's descendants. */
  assert (notpop != C[ci]->ptree.PtreePopndown (pop, kperiod));

  return;
}

int 
imaGtreeNmig (int ci, int li, int ei)
{
  int n;
  int gparent;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;

  assert (!(ci < 0));
  assert (!(li < 0));

  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  gparent = gtree[ei].down;

  if (gparent < 0)
    {
      if (gtree[ei].cmm > 0)
        {
          assert (gtree[ei].mig[0].mt < -0.5);
        }
    }

  n = 0;

  if (gtree[ei].cmm > 0)
    {
      while (gtree[ei].mig[n].mt > -0.5)
        {
          n++; 
        }
      assert (!(n < 0));
    }

  gtree[ei].nmig = n;
  return n;
}

double
imaGtreeTime (int ci, int li, int ei)
{
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  int gchild;
  double t;

  G = &(C[ci]->G[li]);
  gtree = G->gtree;

  gchild = gtree[ei].up[0]; /* this may be also up[1]. */
  if (gchild < 0)
    {
      t = 0.0;
    }
  else
    {
      assert (gchild < L[li].numlines);
      t = gtree[gchild].time;
    }
  return t;
}

double
imaGtreeBranchLength (int ci, int li, int ei)
{
  double len;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
    
  assert (ei != G->root);
  len = gtree[ei].time - imaGtreeTime (ci, li, ei);
  return len;
}

int
imaGtreePop (int ci, int li, int ei)
{
  return C[ci]->G[li].gtree[ei].pop;
}

@
\subsection{Class Saved - Saving and restoring genealogies}
Function [[imaSavedSaveLocusInfo]] saves ``simple'' scalar values not including
complicated ones, and may replace the role of function [[storetreestats]].
Function [[IMA_savelocusgtinfo]] saves member [[gtinfo]], and
it may replace the role of function [[copy_treeinfo]]. Function
[[IMA_savechaingtinfo]] saves member [[allgtinfo]] of a chain, and may replace
the role of function [[copy_treeinfo]]. [[IMA_savechainpcalc]] saves member
[[allpcalc]] of a chain, and may replace the role of function [[copy_probcalc]]. 
Where do we allocate and deallocate memory of [[savedgtinfo]],
[[savedallgtinfo]], and [[savedallpcalc]]?

<<savegtree.hh>>=
<<im3 copyright>>
#ifndef _SAVEGTREE_HH_
#define _SAVEGTREE_HH_
<<savegtree structs>>
<<savegtree function header>>
#endif /* _SAVEGTREE_HH_ */


<<savegtree.cc>>=
#include <cstdlib>
#include <cstring>
#include "imdef.h"
#include "imenum.h"
#include "imstruct.hh"
#include "readata.hh"
#include "gtree.h"
#include "imtools.h"
#include "savegtree.hh"

extern int nloci;
extern int modeloptions[MODELOPTIONSNUMBER];
extern struct locus *L;
extern struct chain **C;

static im_savedlocus *saT;         /* _s_tatic _a_ssignment _T_ree */

<<savegtree function>>

<<savegtree structs>>=
struct im_node_struct
{
  int li;               /* locus id               */
  int ei;               /* node and its branch id */
  double t;             /* time at the node       */
}; 

typedef struct im_node_struct im_node;

struct im_savededge_struct
{
  int savedpop;           /* old population the edge is in at its top */
  im_migstruct *savedmig; /* migration events                         */
  int cmm;                /* current size of mig array                */
};

typedef struct im_savededge_struct im_savededge;

struct im_savedlocus_struct
{
  /* copy members of locus structure */
  int nlinked;
  int model; 
  /* for saving population labels    */
  im_savededge *gtree;
  /* for saving some branches        */
  struct edge *saved;
  int savedi;
  int savedn;
  /* for saving locus members        */
  int savedroot;
  int savedmignum;
  double savedroottime;
  double savedlength;
  double savedtlength;
  // SANGCHUL: tree - struct genealogy_weights savedgweight;
  double savedpdg;
  //double savedplg;
  double *savedpdg_a;

  /* rootmove global variable would be removed from update_gtree.c */
  int copyedge[3];
  int holddownA[MAXLINKED];
  int medgedrop;
  int mrootdrop;
  int rootmove;
  double lmedgedrop;
  double lmrootdrop;
  double holdsisdlikeA[MAXLINKED];
};

typedef struct im_savedlocus_struct im_savedlocus;

<<savegtree function header>>=
void imaSavedSaveLocusInfo (int ci, int li);
void imaSavedRestoreLocusInfo (int ci, int li);
<<savegtree function>>=
// We will use ... not yet though.
void
imaSavedSaveLocusInfo (int ci, int li)
{
  int ai;
  struct genealogy *G = NULL;
  G = &(C[ci]->G[li]);
  saT[li].savedroot = G->root;
  saT[li].savedmignum = G->mignum;
  saT[li].savedroottime = G->roottime;
  saT[li].savedlength = G->length;
  saT[li].savedtlength = G->tlength;
  saT[li].savedpdg = G->pdg;        
  //saT[li].savedplg = G->plg;
  for (ai = 0; ai < L[li].nlinked; ai++)
    {
      saT[li].savedpdg_a[ai] = G->pdg_a[ai];
    }
  return;
}

void
imaSavedRestoreLocusInfo (int ci, int li)
{
  int ai;
  struct genealogy *G = NULL;
  G = &(C[ci]->G[li]);
  G->root = saT[li].savedroot;
  G->mignum = saT[li].savedmignum;
  G->roottime = saT[li].savedroottime;
  G->length = saT[li].savedlength;
  G->tlength = saT[li].savedtlength;
  G->pdg = saT[li].savedpdg;
  //G->plg = saT[li].savedplg;
  for (ai = 0; ai < L[li].nlinked; ai++)
    {
      G->pdg_a[ai] = saT[li].savedpdg_a[ai];
    }
  return;
}

@
How do we save a genealogy? How do we restore it? How do we join two edges and
merge two edges? How do we split an edge? We deal with answers to these
questions in this section. As we scramble a genealogy here and there, we have
more edges to save for restore upon rejection of a proposed genealogy. As
an extreme case a proposed genealogy is completely different from its original.
We then would save the original as a whole genealogy. As another extreme case we
may only change the population label of a tip node. We do not deal with those
kinds of extreme cases, rather something in between. 

We have [[im_savedlocus]] type structure with array variable [[scT]]. The members
of the structure used to be in structure [[locus]]. Jody and I discussed
something related to those members, and decided to remove them from structure
[[locus]]. We move those member to those in structure [[im_savedlocus]]. 
We allow member [[saved]]
to grow upon request of more edges to save. We need to know which element of
array [[saved]] corresponds to which of array [[gtree]] for restore of the
element: we have a new member [[ei]] of structure [[edge]]. We keep track of
capacity of array [[saved]] and index of a new element of the array: we
have new members [[savedn]] and [[savedi]]. 

Function [[imaSavedSaveBranch]] adds an edge to array [[saved]]. 
Before adding a given edge we check whether the edge has been added. If the edge
is in array [[saved]], then we does nothing but return. What
members of structure [[edge]] would be saved? Let us list them: connections to 
other edges, time of edge, population of edge, index of edge, and migrations.
Function [[imaSavedFree]] frees memory of members [[saved]] of the
loci of all chains. It deallocates memory of migration events.
Function [[IMA_genealogy_join_edges]] joins edge [[ei1]] and [[ei3]] and
bypasses edge [[ei2]]. Edge [[ei1]] takes all migration events of [[ei2]].
We use function [[joinsisdown]] from [[IMamp]].
We use function [[splitsisdown]] to implement [[IMA_genealogy_split_edges]].
<<savegtree function header>>=
void imaSavedReset (int li);
void imaSavedInit ();
void imaSavedFree ();
int  imaSavedSaveBranch (int ci, int li, int ei);
void imaSavedRestore (int ci, int li);
<<savegtree function>>=
void 
imaSavedReset (int li)
{
  saT[li].savedi = 0;
  return;
}

@
We allocate [[saT]].
<<savegtree function>>=
void 
imaSavedInit ()
{
  int li;
  int ngnodes;
  struct genealogy *G;

  saT = NULL; 

#if 0 /* SANGCHUL: tree */
  init_genealogy_weights (&saC.savedallgweight); 
  init_probcalc (&saC.savedallpcalc);
#endif
  saT = (im_savedlocus *) malloc (nloci * sizeof (im_savedlocus));
  if (saT == NULL)
    {
      IM_err (IMERR_MEM, "saT");
    }
  for (li = 0; li < nloci; li++)
    {
      G = &C[0]->G[li];
      ngnodes = L[li].numlines;
      saT[li].nlinked = L[li].nlinked;
      saT[li].model = L[li].model;
      saT[li].gtree = NULL;

      /* FIXME: this must be fixed. the sizeof argument used to be
       * im_savedlocus. Is this problematic? Larger memory was used.  */
      saT[li].gtree = (im_savededge *) malloc (ngnodes * sizeof (im_savededge));

      if (saT[li].gtree == NULL)
        {
          IM_err (IMERR_MEM, "sat[%d].gtree", li);
        }
      memset (saT[li].gtree, 0, ngnodes * sizeof (im_savededge));
      saT[li].saved = NULL; /* Whenever we use more, we allocate it. */
      saT[li].savedi = 0;
      saT[li].savedn = 0;
      /* init_genealogy_weights (&saT[li].savedgweight); */
      saT[li].savedpdg_a = NULL;
      saT[li].savedpdg_a = (double *) malloc (L[li].nlinked * sizeof (double));
      if (saT[li].savedpdg_a == NULL)
        {
          IM_err (IMERR_MEM, "saT[%d] savedpdg_a", li);
        }
    }

  return;
}

@
We do not deal with all pointers of structure [[edge]].
<<savegtree function>>=
void 
imaSavedFree ()
{
  struct edge *saved = NULL; /* genealogy of locus li */
  int savedi;
  int savedn;
  int si;
  int li;
  int ei;
  int ngnodes;
  im_savedlocus *G;

  for (li = 0; li < nloci; li++)
    {
      G = &saT[li];
      saved = G->saved;
      savedi = G->savedi;
      savedn = G->savedn;

      for (si = 0; si < savedn; si++)
        {
          free (saved[si].mig); 
          saved[si].mig = NULL;
          free (saved[si].A);
          saved[si].A = NULL;
          free (saved[si].dlikeA);
          saved[si].dlikeA = NULL;
        }
      free (saved);
      saved = NULL;
      free (G->savedpdg_a);
      G->savedpdg_a = NULL;

      /* member gtree of im_savedlocus */
      ngnodes = L[li].numlines;
      for (ei = 0; ei < ngnodes; ei++)
        {
          if (G->gtree[ei].cmm > 0)
            {
              free (G->gtree[ei].savedmig);
              G->gtree[ei].savedmig = NULL;
              G->gtree[ei].cmm = 0;
            }
        }
      free (G->gtree);
      G->gtree = NULL;
    }
  free (saT);
  saT = NULL;

  return;
}

@
The number of elements in array [[saved]] is equal to [[savedn]]. 
We return the index for the saved edge. If there is already the edge, we return
the index in [[saved]]. If there is no such edge, we add the edge and return the
index for the added edge. Note that we do not return the number of edges saved.
<<savegtree function>>=
int
imaSavedSaveBranch (int ci, int li, int ei)
{
  int si;
  int ai;
  int mi;
  int savedi;
  int savedn;
  im_savedlocus *G = NULL;
  struct edge *gtree = NULL;
  struct edge *saved = NULL;

  G = &saT[li];
  gtree = C[ci]->G[li].gtree;
  assert (!(ei < 0));
  assert (ei < L[li].numlines);
  if (!(G->savedi < G->savedn))
    {
      /* allocate more memory of saved */
      G->savedn++;
      G->saved = (struct edge *) realloc (G->saved, G->savedn * sizeof(struct edge));
      G->saved[G->savedi].cmm = 0;
      G->saved[G->savedi].mig = NULL;

      G->saved[G->savedi].A = (int *) malloc (L[li].nlinked * sizeof (int));
      G->saved[G->savedi].dlikeA = (double *) malloc (L[li].nlinked * sizeof (double));

    }
  gtree = C[ci]->G[li].gtree;
  saved = G->saved;
  savedi = G->savedi;
  savedn = G->savedn;

  /* Should we check this loop first?          */
  /* We may use bitset to check the existence. */
  for (si = 0; si < savedi; si++)
    {
      if (saved[si].ei == ei)
        {
          return si;
        }
    }

  saved[savedi].ei = ei;
  saved[savedi].up[0] = gtree[ei].up[0]; 
  saved[savedi].up[1] = gtree[ei].up[1]; 
  saved[savedi].down = gtree[ei].down;
  saved[savedi].time = gtree[ei].time;
  saved[savedi].pop = gtree[ei].pop;

  if (L[li].model == STEPWISE || L[li].model == JOINT_IS_SW)
    {       
      for (ai = (L[li].model == JOINT_IS_SW); 
           ai < L[li].nlinked;
           ai++)
        {
          saved[savedi].A[ai] = gtree[ei].A[ai];
          saved[savedi].dlikeA[ai] = gtree[ei].dlikeA[ai];
        }
    }

  if (modeloptions[NOMIGRATION] == 0)
    {
      if (saved[savedi].cmm < gtree[ei].cmm)
        {
          saved[savedi].cmm = gtree[ei].cmm;
          saved[savedi].mig = 
            (struct migstruct *) realloc (saved[savedi].mig, 
                                          saved[savedi].cmm * sizeof (struct migstruct));
        }
      for (mi = 0; mi < gtree[ei].cmm; mi++)
        {
          saved[savedi].mig[mi].mt = gtree[ei].mig[mi].mt;
          saved[savedi].mig[mi].mp = gtree[ei].mig[mi].mp;
          if (gtree[ei].mig[mi].mt < -0.5)
            {
              break;
            }
        }
    }

  G->savedi++;
  return savedi; 
}

void 
imaSavedRestore (int ci, int li)
{
  im_savedlocus *G = NULL;
  struct edge *gtree = NULL; /* genealogy of locus li */
  struct edge *saved = NULL; /* genealogy of locus li */
  int savedi;
  int savedn;
  int mi;
  int si;
  int ei;
  int ai;

  G = &saT[li];
  gtree = C[ci]->G[li].gtree;
  saved = G->saved;
  savedi = G->savedi;
  savedn = G->savedn;

  for (si = 0; si < savedi; si++)
    {
      ei = saved[si].ei;
      assert (!(ei < 0));
      assert (ei < L[li].numlines);
      gtree[ei].up[0] = saved[si].up[0]; 
      gtree[ei].up[1] = saved[si].up[1]; 
      gtree[ei].down = saved[si].down;
      gtree[ei].time = saved[si].time;
      gtree[ei].pop = saved[si].pop;

      if (L[li].model == STEPWISE || L[li].model == JOINT_IS_SW)
        {       
          for (ai = (L[li].model == JOINT_IS_SW); 
               ai < L[li].nlinked;
               ai++)
            {
              gtree[ei].A[ai] = saved[si].A[ai];
              gtree[ei].dlikeA[ai] = saved[si].dlikeA[ai];
            }
        }

      if (modeloptions[NOMIGRATION] == 0)
        {
          for (mi = 0; mi < saved[si].cmm; mi++)
            {
              assert (mi < gtree[ei].cmm);
              gtree[ei].mig[mi].mt = saved[si].mig[mi].mt;
              gtree[ei].mig[mi].mp = saved[si].mig[mi].mp;
              if (gtree[ei].mig[mi].mt < -0.5)
                {
                  break;
                }
            }
        }
    }
  return;
}

@
\subsection{Wang's population tree update}
Wang-Choi-Hey (WCH) update.

Only infinite-site and finite-site models are considered.
Multiple chains must be considered.


<<updatewch.hh>>=
<<im3 copyright>>
#ifndef _UPDATEWCH_HH_
#define _UPDATEWCH_HH_
<<updatewch function header>>
#endif /* _UPDATEWCH_HH_ */

<<updatewch.cc>>=
<<im3 copyright>>
#include <vector>
#include "imdef.h"
#include "imenum.h"
#include "imstruct.hh"
#include "updategtreecommon.hh"
#include "Ptree.hh"
#include "Prob.hh"
#include "savegtree.hh"
#include "assertgenealogy.hh"
#include "updatewchq.hh"
#include "updatewch.hh"

extern struct locus *L;
extern struct chain **C;

using std::vector;

<<updatewch population tree update>>

<<updatewch function header>>=
int updatewch (int ci);
<<updatewch population tree update>>=
int
updatewch (int ci)
{
  double lweight;
  double logU;
  double mweight;
  double hweight;

  assert (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0);

  /* Count up the number of tries of MCMC cycles. */
  if (ci == 0)
    {
      L[0].t_rec->upinf[IM_UPDATE_TREE_TPT_TYPE1].tries++;
    }

  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }

  // T : the population tree of a current state
  // T*: the tree of a proposed state
  // Gh: all of the hidden genealogies 
  // G : all of the genealogies under T
  // G*: all of the genealogies under T*
  //
  // Slide a branch of the population tree.
  // Compute the Hastings term for q(T*->T)/q(T->T*).
  // Generate G* from Gh under T*.
  // Generate G from Gh under T.
  // Compute p(G*)/p(G).
  // Compute q(G*->Gh)/q(G->Gh). 
  //
  // q(G->Gh) and p(G) must have been stored so that 
  // we do not need to calculate it again.
  //
  // There are a few functions that I needed to implement for this update to
  // work for us: wchSlide, wchSlideWeight, wchSlideBack, and ima::generate.
  // ima::generateQ will be implemented by Jody.  I should first figure out
  // what interface one may need.
  // We also need a version of updategenealogy: updategenealogywch.

  C[ci]->ptree.PtreeStoreWeight (nloci); // cc, mc, ...
  C[ci]->ptree.PtreeStoreProbCalc ();    // qintegrate, ...
  C[ci]->holdprob.ProbCopyExceptPdg (C[ci]->prob); // probg and qhidden

  C[ci]->ptree.wchSlide (); // FIXME: implement it!
  ima::generate (C[ci]->G, C[ci]->Gh, &C[ci]->ptree); // FIXME: implement it!
  double qGstar2Gh = ima::generateQ (C[ci]->G, C[ci]->Gh, &C[ci]->ptree); // FIXME: implement it!
  C[ci]->prob.ProbSetQhidden (qGstar2Gh);
  hweight = C[ci]->ptree.wchSlideWeight () // FIXME: implement it!
            + C[ci]->prob.ProbGetQhidden() 
            - C[ci]->holdprob.ProbGetQhidden();

  C[ci]->ptree.PtreeResetGweight (nloci);
  for (int li = 0; li < nloci; li++)
    {
      C[ci]->ptree.PtreeResetGweight (li);
      treeweight (ci, li);
      C[ci]->ptree.PtreeAddWeight (li);
    }
  double v = C[ci]->ptree.PtreeIntegrateTreeProb ();
  C[ci]->prob.ProbSetProbg (v);

  logU = log (uniform ());

  mweight = C[ci]->prob.ProbGetProbg () - C[ci]->holdprob.ProbGetProbg ();

  lweight = beta[ci] * mweight + hweight;
  assert (beta[ci] * mweight + hweight > -1e200
          && beta[ci] * mweight + hweight < 1e200);

  int accp = 0;
  if (lweight > logU)
    {
      /* accept the update */
      accp = 1;
      if (ci == 0)
        {
          L[0].t_rec->upinf[IM_UPDATE_TREE_TPT_TYPE1].accp++;
        }
      C[ci]->ptree.PtreeAccept ();
    }
  else
    {
      C[ci]->ptree.wchSlideBack ();
      for (int li = 0; li < nloci; li++)
        {
          // NOTE: PtreeRestoreWeight must be called after treemoveI or II
          // because we restore weight and probcalc (qintegrate and mintegrate)
          // based on the current population tree.
          C[ci]->ptree.PtreeRestoreWeight (li);
        }
      C[ci]->ptree.PtreeRestoreWeight (nloci);
      C[ci]->ptree.PtreeRestoreProbCalc ();
      C[ci]->prob.ProbCopyExceptPdg (C[ci]->holdprob);
    }

#if 0 // SC: we do not need to do anything about HKY parts, do we?
  for (li = 0; li < nloci; li++)
    {
      if (L[li].model == HKY)
        {
          restorescalefactors (ci, li);
        }
    }
#endif

  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }
  return accp;
}

<<updatewchq.hh>>=
<<im3 copyright>>
#ifndef _UPDATEWCHQ_HH_
#define _UPDATEWCHQ_HH_
#include "imdef.h"
#include "imenum.h"
#include "imstruct.hh"
#include "Ptree.hh"
<<updatewchq header>>
#endif /* _UPDATEWCHQ_HH_ */

<<updatewchq header>>=
namespace ima {
  double generateQ (struct genealogy *G, struct genealogy *Gh, Ptree * ptree);
  void generate (struct genealogy *G, struct genealogy *Gh, Ptree * ptree);
}

@
We start at the top of a lineage and assign it to one of populations. 
<<updatewchq.cc>>=
<<im3 copyright>>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <utility>
#include <cstdlib>
#include <cstring>
#include "imdef.h"
#include "gtree.h"
#include "updatewchq.hh"

using std::string;
using std::cout;
using std::endl;

extern struct locus *L;

namespace ima {

double 
generateQ (struct genealogy *G, struct genealogy *Gh, Ptree * ptree) 
{
  return .0L;
}

// Did we allocate the memory of Gh? We should do it.
// 
// We copy all migration events from all of the hidden genealogies (Gh) 
// to their corresponding actual genealogies (G) under the current 
// population tree (ptree).
void
generate (struct genealogy *G, struct genealogy *Gh, Ptree * ptree) 
{
  for (int li = 0; li < nloci; li++)
    {
      struct edge * gt = G[li].gtree;
      struct edge * gh = Gh[li].gtree;
      for (int ei = 0; ei < L[li].numlines; ei++)
        {
          assert (!(gt[ei].cmm > gh[ei].cmm));
          if (gt[ei].cmm < gh[ei].cmm)
            {
              gt[ei].mig = (struct migstruct *) realloc (gt[ei].mig, gh[ei].cmm * sizeof (struct migstruct));
              gt[ei].cmm = gh[ei].cmm;
            }
          int mp = gh[ei].pop;
          double t; 
          int daughter = gh[ei].up[0]; 
          if (daughter < 0)
            {
              t = 0.0;
            }
          else
            {
              t = gh[daughter].time;
            }
          int k = ptree->PtreeFindperiod (t);
          int mpdown = ptree->PtreePopndown (mp, k);
          gt[ei].pop = mpdown;
          int mi = 0;
          double mt = gt[ei].mig[mi].mt;
          while (mt > -0.5)
            {
              mp = gh[ei].mig[mi].mp;
              k = ptree->PtreeFindperiod (mt);
              mpdown = ptree->PtreePopndown (mp, k);
              gt[ei].mig[mi].mp = mpdown;
              mi++;
              mt = gt[ei].mig[mi].mt;
            }
        }
    }
}

} // End of namespace ima

@
We change the population tree to the proposed one.
We detach [[pedgeMove]] from the full species tree. 

Precondition: a full population tree. 
Postconditions: a new full population tree. [[tmrcachange]] is set to 1 if we
detached [[pedgeMove]] from the root node of the starting full tree. Both
[[tmrcachange]] members of [[pbf]] and [[qbf]] must be the same.

<<updatetree static>>=
static int bftreetSet (int ci, iaBFupdate *pbf, iaBFupdate *qbf);
<<updatetree function>>=
int
bftreetSet (int ci, iaBFupdate *pbf, iaBFupdate *qbf)
{
  int li;

  bftreetDetach (ci, pbf, qbf);
  for (li = 0; li < nloci; li++)
    {
      bftreegLabelDowntosis (ci, li, pbf);
    }
  bftreetAttach (ci, pbf, qbf);
  for (li = 0; li < nloci; li++)
    {
      bftreegLabelSistodown (ci, li, qbf);
    }

  return 0;
}

@
Precondition: a full population tree.
Postcondition: a partial population tree that does not have the moving edge and
its down edge. The old sister, [[sbfold.pedgeSis]], is joined to the down of its
down if it exists. The socalled downdown edge does not exist if the down is the
rooting edge.
<<updatetree static>>=
static int bftreetDetach (int ci, iaBFupdate *pbf, iaBFupdate *qbf);
<<updatetree function>>=
int
bftreetDetach (int ci, iaBFupdate *pbf, iaBFupdate *qbf)
{
  iatTreeJoinsisdown (ci, 
                      pbf->pedgeSis, 
                      &pbf->tmrcachange);
  qbf->tmrcachange = pbf->tmrcachange;
  return 0;
}

@
Precondition: a partial population tree (possibly partial genealgies as well)
Postcondition: a full population tree

This applies to only forward of update: we deal with [[sbfold]] only. 
<<updatetree static>>=
static int bftreetAttach (int ci, iaBFupdate *pbf, iaBFupdate *qbf);
<<updatetree function>>=
int
bftreetAttach (int ci, iaBFupdate *pbf, iaBFupdate *qbf)
{
  iatTreeSplitsisdown (ci, 
                       pbf->pedgeMove,
                       pbf->pedgeDown,
                       qbf->pedgeSis,
                       &pbf->rootmove);
  qbf->rootmove = pbf->rootmove; 
  return 0;
}

@
We copy [[slider]] function from Jody's update genealogy function.
We only change [[gtree]] to [[ptree]]. The number of tip is replaced by 
[[npops]]. Since this is a duplicate of the original [[slider]] in the update of
genealogy, we may have a function like this:
\begin{Verbatim}[frame=lines,framesep=5mm]
static void iatTreeSlider (void *ptree,
                           int ntips,
                           int slidingedge, 
                           int *sis, 
                           double *timepoint, 
                           double *slidedist);
\end{Verbatim}
<<updatetree static>>=
static void iatTreeSlider (int ci, 
                           int slidingedge, 
                           int *sis, 
                           double *timepoint, 
                           double *slidedist);
<<updatetree function>>=
void
iatTreeSlider (int ci, 
               int slidingedge, 
               int *sis, 
               double *timepoint,
               double *slidedist)
{
  double uplimit;
  im_popedge *ptree;

  ptree = C[ci]->popedge;

  if (*slidedist < 0)
  {
    /* go up */
    *slidedist = -*slidedist;
    if (slidingedge < npops)
      uplimit = 0;
    else
      uplimit = ptree[ptree[slidingedge].up[0]].time;
    assert (*timepoint >= uplimit);

    /* if uplimit >= sis up time - slidingedge cannot reach a node */
    if (ptree[*sis].up[0] == -1 || uplimit >= ptree[ptree[*sis].up[0]].time)
    {
      if (*slidedist < *timepoint - uplimit)
      {
        /* slide up and stop, sis remains the same */
        *timepoint -= *slidedist;
        *slidedist = 0;
        assert (*timepoint > uplimit);
        return;
      }
      else
      {
        /* slide up and reflect, sis remains the same, leave slidedist 
         * positive so slidingedge goes down with next call to slider */
        *slidedist -= *timepoint - uplimit;
        *timepoint = uplimit;
        assert (*slidedist > 0);
        iatTreeSlider (ci, slidingedge, sis, timepoint, slidedist);
        return;
      }
    }
    else
    {
      /* uplimit is less than sis up time, and thus slidingedge can reach a node */
      if (*slidedist < *timepoint - ptree[ptree[*sis].up[0]].time)
      {
        /* slide up and stop, sis remains the same */
        *timepoint -= *slidedist;
        *slidedist = 0;
        assert (*timepoint > ptree[ptree[*sis].up[0]].time);
        return;
      }
      else
      {
        /* slide up and reach a node, pick one side at random and recurse */
        *slidedist -= *timepoint - ptree[ptree[*sis].up[0]].time;
        *timepoint = ptree[gtree[*sis].up[0]].time;
        if (bitran () /*uniform() < 0.5 */ ) /* FIXME: SPRNG */
        {
          *sis = ptree[*sis].up[0];
        }
        else
        {
          *sis = ptree[*sis].up[1];
        }

        /* reset slidedist to negative, so slidingedge continues up the 
         * ptree in next call to slider */
        *slidedist = -*slidedist;
        assert (*slidedist < 0);
        iatTreeSlider (ci, slidingedge, sis, timepoint, slidedist);
        return;
      }
    }
  }
  else
  {
    /* go down */
    if (ptree[*sis].down == -1 || *timepoint + *slidedist < ptree[*sis].time)
    {
      /* if sis is the root, or distance is less than to next down node, just slide down */
      *timepoint += *slidedist;
      if (*timepoint >= IMConstants::TIMEMAX)
      {
        *timepoint = IMConstants::TIMEMAX;
      }
      *slidedist = 0;
      return;
    }
    else
    {
      /* a down node is reached */
      *slidedist -= ptree[*sis].time - *timepoint;
      *timepoint = ptree[*sis].time;
      if (bitran ())
      {
        /* begin to slide down the down node */
        *sis = ptree[*sis].down;
        iatTreeSlider (ci, slidingedge, sis, timepoint, slidedist);
        return;
      }
      else
      {
        /* begin to slide up the sis  */
        if (ptree[ptree[*sis].down].up[0] == *sis)
        {
          *sis = ptree[ptree[*sis].down].up[1];
        }
        else
        {
          *sis = ptree[ptree[*sis].down].up[0];
        }
        *slidedist = -*slidedist;
        iatTreeSlider (ci, slidingedge, sis, timepoint, slidedist);
        return;
      }
    }
  }
}                               /* iatTreeSlider */

@
We borrow the code of [[joinsisdown]] of the update of genealogy.
<<updatetree static>>=
static void iatTreeJoinsisdown (int ci, int sis, int *tmrcachange);
<<updatetree function>>=
void
iatTreeJoinsisdown (int ci, int sis, int *tmrcachange)
{
  int down;
  int downdown;
  int rootmove;
  double uptime;
  im_popedge *ptree;

  assert (!(sis < 0));
  assert (sis < numtreepops);

  ptree = C[ci]->poptree;
  down = ptree[sis].down;
  assert (!(down < 0));
  assert (down < numtreepops);
  downdown = ptree[down].down; 

  if (downdown != -1)
    {
      assert (!(downdown < 0));
      assert (downdown < numtreepops);
      *tmrcachange = 0;
      if (ptree[downdown].up[0] == down)
        {
          ptree[downdown].up[0] = sis;
        }
      else
        {
          ptree[downdown].up[1] = sis;
        }
     ptree[sis].down = downdown;
     ptree[sis].time = ptree[down].time; 
    }
  else
    {
      *tmrcachange = 1;
      if (sis < npops)
        {
          uptime = 0.0;
        }
      else
        {
          uptime = ptree[ptree[sis].up[0]].time;
        }

      C[ci]->rootpop = sis;
      ptree[sis].down = -1;
      ptree[sis].time = IMConstants::TIMEMAX;

      C[ci]->G[li].roottime = uptime; /* FIXME: population tree change */
    }
  return;
}

@
Unlike [[slider]], [[splitsisdown]] and [[joinsisdown]] are changed too much. We
should keep separate these functions.
<<updatetree static>>=
static void iatTreeSplitsisdown (int ci, 
                                 int slidingedge, 
                                 int down, 
                                 int newsis,
                                 int *rootmove);
<<updatetree function>>=
void
iatTreeSplitsisdown (int ci, 
                     int slidingedge, 
                     int down, 
                     int newsis, 
                     int *rootmove)
{
  /* split newsis into two parts, and make a new down edge out of the lower part */
  int i;
  int j;
  int downdown;
  double curt;
  im_popedge *ptree;

  ptree = C[ci]->poptree;
  curt = ptree[slidingedge].time;
  ptree[down].time = ptree[newsis].time;
  ptree[newsis].time = curt;

  downdown = ptree[newsis].down;
  if (downdown != -1)
    {
      *rootmove = 0;
      if (ptree[downdown].up[0] == newsis)
        {
          ptree[downdown].up[0] = down;
        }
      else
        {
          ptree[downdown].up[1] = down;
        }
    }
  else
    {
      *rootmove = 1;
      /* newsis is the current root so the root must move down */
      C[ci]->rootpop = down;
      C[ci]->roottime = curt;
      if (C[ci]->roottime > IMConstants::TIMEMAX)
        {
          IM_err (IMERR_ROOTTIMEMAXFAIL, 
                  "roottime greater than TIMEMAX, chain: %d, roottime %lf, TIMEMAX %lf",
                  ci, C[ci]->roottime, IMConstants::TIMEMAX);
        }
    }
  ptree[down].down = downdown;
  ptree[newsis].down = down;
  ptree[slidingedge].down = down;
  ptree[down].up[0] = newsis;
  ptree[down].up[1] = slidingedge;
  return;
}



@
\subsection{Population tree update}
We will implement the three-point-turn update. How can we reconcile the original
implementation of IMa2 and this implementation? We may keep the most of IMa2
implementation. 

We could change migration prior during MCMC for the sake of updating population
trees.

<<updatetree.hh>>=
<<im3 copyright>>
#ifndef _UPDATETREE_HH_
#define _UPDATETREE_HH_
<<updatetree function header>>
#endif /* _UPDATETREE_HH_ */


<<updatetree.cc>>=
<<im3 copyright>>
#include "imdef.h"
#include "imenum.h"
#include "imstruct.hh"
#include "updategtreecommon.hh"
#include "Ptree.hh"
#include "Prob.hh"
#include "savegtree.hh"
#include "assertgenealogy.hh"
#include "updatetree.hh"

extern struct locus *L;
extern struct chain **C;

<<updatetree static>>
<<updatetree population tree update>>

<<updatetree function header>>=
int updateassignmentptree (int ci);
<<updatetree population tree update>>=
int
updateassignmentptree (int ci)
{
  int rperiod; 
  int accp;
  double lweight;
  double logU;
  double mweight;
  double hweight;
  struct genealogy *G;
  int li;
  int popx;
  int popa;
  int popb;
  int popc;
  int popal;
  int popbl;
  int popcl;
  int popau;
  int popbu;
  int popcu;
  int iTypeMove;
  double v;

  assert (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0);

  /* Count up the number of tries of MCMC cycles. */
  if (ci == 0)
    {
      L[0].t_rec->upinf[IM_UPDATE_TREE_TPT_TYPE1].tries++;
    }

  G = NULL;
  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }

  iTypeMove = Phylogeny_choose_a_period (ci, &rperiod);
  switch (iTypeMove)
    {
      case 0:
        /* We do not need this? rperiod = tptChooseCoalescentPeriod (ci); */
        return 0;
        break;
      case 1:
        popc = C[ci]->ptree.PhylogenyTptChooseAnIngroup (rperiod, &popx, &popa);
        popb = C[ci]->ptree.PtreePedgeSister (popc);
        break;
      case 2:
        C[ci]->ptree.PhylogenyTptChooseAllPopulations (rperiod, 
                                          &popal, &popbl, &popcl,
                                          &popau, &popbu, &popcu);
        break;
      default:
        assert (0);
    }

  /* Save the current state of a chain */
  for (li = 0; li < nloci; li++)
    {
      imaSavedReset (li); // FIXME: 
      imaSavedSaveLocusInfo (ci, li); // FIXME: 

      C[ci]->ptree.PtreeStoreWeight (li);
#if 0 /* SANGCHUL: tree */
      copy_treeinfo (&saT[li].savedgweight, &C[ci]->G[li].gweight);
#endif
    }

  C[ci]->ptree.PtreeStoreWeight (nloci);
#if 0 /* SANGCHUL: tree */
  copy_treeinfo (&saC.savedallgweight, &C[ci]->allgweight);
#endif

  /* We do not call copy_probcalc_all because we do not change likelihood. */
  C[ci]->ptree.PtreeStoreProbCalc ();
  C[ci]->holdprob.ProbCopyProbgOnly (C[ci]->prob);
#if 0 /* SANGCHUL: tree */
  copy_probcalc (&saC.savedallpcalc, &C[ci]->allpcalc);
#endif

  /* Propose a new state of genealogy and assignment. */
  switch (iTypeMove)
    {
      case 1:
        /* FIXME: we have not computed hweight correctly? LOG2's have not been
         * subtracted yet. */
        hweight = treemoveI (ci, rperiod, 
                             popx, popa, popb, popc);
        break;
      case 2:
        hweight = treemoveII (ci, rperiod, 
                              popal, popbl, popcl, 
                              popau, popbu, popcu);
        break; 
      default:
        assert (0);
        break;
    }

  /* Compute Metropolis-ratio. */
  C[ci]->ptree.PtreeResetGweight (nloci);
#if 0 /* SANGCHUL: tree */
  setzero_genealogy_weights (&C[ci]->allgweight);
#endif
  for (li = 0; li < nloci; li++)
    {
      C[ci]->ptree.PtreeResetGweight (li);
#if 0 /* SANGCHUL: tree */
      setzero_genealogy_weights (&C[ci]->G[li].gweight);
#endif
      treeweight (ci, li);

      C[ci]->ptree.PtreeAddWeight (li);
#if 0 /* SANGCHUL: tree */
      sum_treeinfo (&C[ci]->allgweight, &C[ci]->G[li].gweight);
#endif
    }

  v = C[ci]->ptree.PtreeIntegrateTreeProb ();
  C[ci]->prob.ProbSetProbg (v);
#if 0 /* SANGCHUL: tree */
  initialize_integrate_tree_prob (ci, &C[ci]->allgweight, &C[ci]->allpcalc);
#endif

  logU = log (uniform ());

  mweight = C[ci]->prob.ProbGetProbg () - C[ci]->holdprob.ProbGetProbg ();
#if 0 /* SANGCHUL: tree */
  mweight = C[ci]->allpcalc.probg - saC.savedallpcalc.probg;
#endif

  lweight = beta[ci] * mweight + hweight;
  assert (beta[ci] * mweight + hweight > -1e200
          && beta[ci] * mweight + hweight < 1e200);


  accp = 0;

  if (lweight > 0.0 || lweight > logU)
    {
      /* accept the update */
      accp = 1;
      if (ci == 0)
        {
          L[0].t_rec->upinf[IM_UPDATE_TREE_TPT_TYPE1].accp++;
        }
      C[ci]->ptree.PtreeAccept ();
    }
  else
    {
      /* Revert it to the original state of genealogy and assignment. */
      // NOTE: We must restore the basic structure of the population tree before
      // we restore weights, qintegrate, mintegrate.
      switch (iTypeMove)
        {
          case 1:
            hweight = treemoveI (ci, rperiod, 
                                 popx, popb, popa, popc);
            break;
          case 2:
            hweight = treemoveII (ci, rperiod, 
                                  popau, popbu, popcu,
                                  popal, popbl, popcl); 
            break; 
          default:
            break;
        }
      for (li = 0; li < nloci; li++)
        {
          /* restore edges changed during update */
          imaSavedRestore (ci, li); // FIXME:
          imaSavedRestoreLocusInfo (ci, li); // FIXME:

          // NOTE: PtreeRestoreWeight must be called after treemoveI or II
          // because we restore weight and probcalc (qintegrate and mintegrate)
          // based on the current population tree.
          C[ci]->ptree.PtreeRestoreWeight (li);
#if 0 /* SANGCHUL: tree */
          copy_treeinfo (&C[ci]->G[li].gweight, &saT[li].savedgweight);
#endif
        }
      C[ci]->ptree.PtreeRestoreWeight (nloci);
      C[ci]->ptree.PtreeRestoreProbCalc ();
      C[ci]->prob.ProbCopyProbgOnly (C[ci]->holdprob);
#if 0 /* SANGCHUL: tree */
      copy_treeinfo (&C[ci]->allgweight, &saC.savedallgweight);
      copy_probcalc (&C[ci]->allpcalc, &saC.savedallpcalc);
#endif
    }

#if 0
  for (li = 0; li < nloci; li++)
    {
      if (L[li].model == HKY)
        {
          restorescalefactors (ci, li);
        }
    }
#endif

  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }
  return accp;
}


@
[[treemove]] is a multiple populatin version of [[tptmove]].

We could change [[mp]] of all migration events within the period.  We check each
lineage which type of population branch it belongs to: A, B, D, or X.  If it
belongs to A, B, D or non-X branch, then we find all of the migration events and
replace C with A, B with C.  If it belongs to X branch, we replace B with A.
We recycle C.  We only change the population tree and save its Newick formatted
tree.
<<updatetree static>>=
static double treemoveI (int ci, int rperiod, int popx, int popa, int popb, int popc);
<<updatetree population tree update>>=
double
treemoveI (int ci, int rperiod, int popx, int popa, int popb, int popc)
{
  double lhweight;
  lhweight = 0.0;
  int v;
  int li;
  int ei;
  double t;     /* up time of an gtree edge. */
  double tdown; /* down time of the gtree edge. */

  int mi;
  struct edge *gtree;
  double mt;
  int mp;
  double upt;
  double dnt;
  int pi;

  static int statici = 0;
  statici++;


  upt = C[ci]->ptree.PtreeGetTval (rperiod - 1);
  dnt = C[ci]->ptree.PtreeGetTval (rperiod);

  /********************************************************************/
  /* Tree update with PtreeMoveI                                      */
  /********************************************************************/
  C[ci]->ptree.PtreeMoveI (rperiod, popx, popa, popb, popc);

  v = 0;
  for (li = 0; li < nloci; li++)
    {
      gtree = C[ci]->G[li].gtree;
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          tdown = gtree[ei].time;

          if (tdown < upt || dnt < t)
            {
              continue;
            }

          imaSavedSaveBranch (ci, li, ei);

          if (t < upt && upt < tdown)
            {
              mi = Genealogy_skipMig (ci, li, ei, upt);
              pi = Migration_above_startpopn (ci, li, ei, mi, rperiod);
            }
          else
            {
              mi = 0;
            }

          mt = gtree[ei].mig[mi].mt;
          if (pi == popx)
            {
              while (mt > -0.5 && mt < dnt)
                {
                  /* Swap popa and popb. */
                  mp = gtree[ei].mig[mi].mp;
                  if (mp == popa)
                    {
                      gtree[ei].mig[mi].mp = popb;
                    }
                  else if (mp == popb)
                    {
                      gtree[ei].mig[mi].mp = popa;
                    }
                  else
                    {
                      /* No code */
                    }
                  mi++;
                  mt = gtree[ei].mig[mi].mt;
                }
            }
          else
            {
              while (mt > -0.5 && mt < dnt)
                {
                  /* Replace popc with popa, popb with popc. */
                  mp = gtree[ei].mig[mi].mp;
                  if (mp == popc)
                    {
                      gtree[ei].mig[mi].mp = popa;
                    }
                  else if (mp == popb)
                    {
                      gtree[ei].mig[mi].mp = popc;
                    }
                  else 
                    {
                      /* No code */
                    }
                  mi++;
                  mt = gtree[ei].mig[mi].mt;
                }
            }
        }
    }

  return lhweight; /* Everything is deterministic. */
}

@
We do not allow any migration between popal and popbl.  
We do not even allow any indirect connection between popal and popbl (We may
have to allow this one). 

We change population labels of all lineages within the chosen period.  We
replace [[popal]] and [[popbl]] with [[popcl]] because the two populations merge
within the chosen period.  We will change the label of [[popcu]] to one of
[[popau]] or [[popbu]].  

The first part of the code is the same as [[treemoveI]].
<<updatetree static>>=
static double treemoveII (int ci, int rperiod, 
                        int popal, int popbl, int popcl,
                        int popau, int popbu, int popcu);
<<updatetree population tree update>>=
double 
treemoveII (int ci, int rperiod, 
          int popal, int popbl, int popcl,
          int popau, int popbu, int popcu)
{
  double lhweight;
  int v;
  int li;
  int ei;
  double t;     /* up time of an gtree edge. */
  double tdown; /* down time of the gtree edge. */

  int mi;
  struct edge * gtree;
  double mt;
  int mp;
  double upt;
  double dnt;

  upt = C[ci]->ptree.PtreeGetTval (rperiod - 1);
  dnt = C[ci]->ptree.PtreeGetTval (rperiod);

  /********************************************************************/
  /* We change struct Chain and saC.                                  */
  /* static im_popntree saC;                                          */
  /********************************************************************/
  /* Change periodset: Check function fillplist. */
  C[ci]->ptree.PtreeMoveII (rperiod, 
               popal, popbl, popcl,
               popau, popbu, popcu);
  /********************************************************************/
  /* End of Tree update                                               */
  /********************************************************************/


  v = 0;
  lhweight = 0.0;
  for (li = 0; li < nloci; li++)
    {    
      gtree = C[ci]->G[li].gtree;
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          tdown = gtree[ei].time;

          if (tdown < upt || dnt < t)
            {
              continue;
            }

          imaSavedSaveBranch (ci, li, ei);

          if (t < upt && upt < tdown)
            {
              mi = Genealogy_skipMig (ci, li, ei, upt);
              /* mp = Migration_startpopn (ci, li, ei, mi); */
              /* pi = Migration_popnAtTime (ci, li, ei, upt); */
            }
          else
            {
              mi = 0;
            }
          
          mt = gtree[ei].mig[mi].mt;

          while (mt > -0.5 && mt < dnt)
            {
              /* Merge popal and popbl to popcl. */
              /* Divide popcu to popau and popbu. */
              mp = gtree[ei].mig[mi].mp;
              if (mp == popal || mp == popbl)
                {
                  gtree[ei].mig[mi].mp = popcl;
                  lhweight -= LOG2;
                }
              else if (mp == popcu)
                {
                  if (bitran () /*uniform() < 0.5 */ )
                    {
                      gtree[ei].mig[mi].mp = popau;
                    }
                  else
                    {
                      gtree[ei].mig[mi].mp = popbu;
                    }
                  lhweight += LOG2;
                }
              else
                {
                  /* No code. */
                }
              mi++;
              mt = gtree[ei].mig[mi].mt;
            }
        }
    }

  return lhweight; /* Everything is deterministic. */
}


@
[[Phylogeny_imaGtreeSwap]] is a multiple-population version of [[imaGtreeSwap]]. 
In the function [[imaGtreeSwap]] we instead keep labels of population
trees unchanged, and we change labels of genealogies.
In the phylogeny version, we will change labels of population trees. 

There are a few situations to consider.
\begin{Verbatim}[frame=lines,framesep=5mm]
0     1    2
|     |    |
+--3--+    | <- upt
  |       |
  +---4---+ <- dnt
      |
      |
      R

to 

0     2    1 
|     |    |
+--3--+    | <- upt
  |       |
  +---4---+ <- dnt
      |
      |
      R



0     1   2     3
|     |   |     |
+--4--+   |     |
  |      |     |
  |      +--5--+
  |         |
  +----6----+
       |
       |
       R
\end{Verbatim}

A branch begins at the top of a period, and it ends in the bottom of the
period.  Along the branch and its sister branch segment during the period exist
no coalescent events.  Then, we use the three-point-turn update.  Using function 
[[tptChooseCoalescentPeriod]] we draw such a period at random. We return the
chosen period that must be neither the first nor the last one. A negative value
(i.e., -1) is returned otherwise.

Function [[Phylogeny_isCoalescent]] returns 1 if there are coalescent events
between [[upt]] and [[dnt]] along two branches, 0 otherwise.

Function [[Phylogeny_isCoalescent2]] returns 1 if there are coalescent events
between [[upt]] and [[dnt]] along three branches, 0 otherwise.

Function [[Phylogeny_isMigration]] returns 1 if there are migration events
between two branches, 0 otherwise.

We copied the code tptChooseCoalescentPeriod (int ci) we need to
find a period and decide the type of tree update. It returns 1 or 2 for the type
of updating a tree. We return 0 if there is no available branch to update.

<<updatetree static>>=
static int Phylogeny_choose_a_period (int ci, int * rperiod);
static int Phylogeny_isCoalescent (int ci, double upt, double dnt, int b1, int b2);
static int Phylogeny_isCoalescent2 (int ci, double upt, double dnt, 
                                  int b1, int b2, int b3);
static int Phylogeny_isMigration (int ci, double upt, double dnt, int b1, int b2);
<<updatetree population tree update>>=
int 
Phylogeny_choose_a_period (int ci, int * rperiodv)
{
  /* It returns the type of tree update using Three-point-turn updating method. */
  int v;
  double upt;
  double dnt;
  int pi;
  int a1;
  int b1;
  int b2;
  int type;
  int i;
  int pop0, pop1, pop2;

  assert (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0);

  *rperiodv = -1;
  type = 0;
  for (i = 0; i < npops; i++)
    {
      pi = randposint (npops);
      if (pi == 0 || pi == npops - 1)
        {
          continue;
        }
      if (treeoptions[POPULATIONTREEOUTGROUP] == 1 && pi == npops - 2)
        {
          continue;
        }
      upt = C[ci]->ptree.PtreeGetTval (pi - 1);
      dnt = C[ci]->ptree.PtreeGetTval (pi);

      pop0 = C[ci]->ptree.PtreeGetAddpop (pi);
      pop1 = C[ci]->ptree.PtreeGetLeftDroppop (pi + 1);
      pop2 = C[ci]->ptree.PtreeGetRightDroppop (pi + 1);
      if (pop0 == pop1 || pop0 == pop2)
#if 0 /* SANGCHUL: tree */
      if (C[ci]->addpop[pi] == C[ci]->droppops[pi + 1][0]
          || C[ci]->addpop[pi] == C[ci]->droppops[pi + 1][1])
        {
          b1 = C[ci]->droppops[pi + 1][0];
          b2 = C[ci]->droppops[pi + 1][1];
#endif
        {
          b1 = pop1;
          b2 = pop2;
          v = Phylogeny_isCoalescent (ci, upt, dnt, b1, b2);
          if (v == 0)
            {
              type = 1;
              *rperiodv = pi;
              break;
            }
        }
      else 
        {
          a1 = pop0;
          b1 = pop1;
          b2 = pop2;
#if 0 /* SANGCHUL: tree */
          a1 = C[ci]->addpop[pi]; 
          b1 = C[ci]->droppops[pi + 1][0];
          b2 = C[ci]->droppops[pi + 1][1];
#endif
          v = Phylogeny_isMigration (ci, upt, dnt, b1, b2);
          if (v > 0)
            {
              continue;
            }
          v += Phylogeny_isCoalescent2 (ci, upt, dnt, a1, b1, b2);
          if (v == 0)
            {
              type = 2;
              *rperiodv = pi;
              break;
            }
        }
    }

  if (type == 0)
    {
      assert (*rperiodv == -1);
    }
  else if (type == 1 || type == 2)
    {
      assert (0 < *rperiodv && *rperiodv < npops - 1);
    }
  else
    {
      assert (0);
    }
  return type;

}

<<updatetree population tree update>>=
int 
Phylogeny_isMigration (int ci, double upt, double dnt, int b1, int b2)
{
  int v;
  int li;
  int ei;
  double t;     /* up time of an gtree edge. */
  double tdown; /* down time of the gtree edge. */

  int mi;
  struct edge *gtree;
  double mt;
  int mp;
  int mp0;

  v = 0;
  for (li = 0; li < nloci; li++)
    {
      gtree = C[ci]->G[li].gtree;
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          tdown = gtree[ei].time;

          if (!(tdown < upt) && !(dnt < t))
            {
              if (upt < t && t < dnt) /* Type II and IV */
                {
                  mi = 0;
                }
              else /* Type I and III */
                {
                  assert (t < upt);
                  mi = Genealogy_skipMig (ci, li, ei, upt);
                }
              mt = gtree[ei].mig[mi].mt;

              /* Check migration events between [[upt]] and [[dnt]]. */
              /* For Type II and IV, the second condition can be deleted. */
              while (mt > -0.5 && mt < dnt) 
                {
                  /* Find the starting population. */
                  mp0 = Migration_startpopn (ci, li, ei, mi);

                  /* Find the ending population. */
                  mp = gtree[ei].mig[mi].mp;    

                  /* Check if the migration event is between b1 and b2. */
                  if ((mp0 == b1 && mp == b2) || (mp0 == b2 && mp == b1))
                    {
                      v = 1;
                      return v;
                      ei = L[li].numlines;
                      li = nloci;
                      break;
                    }
                  mi++;
                  mt = gtree[ei].mig[mi].mt;    
                }
            }
        }
    }

  return v;
  }

@
If there are migration events before [[t]] (starting from the top of the edge),
we skip those events and return the index of next migration event.  If there is
If there are no such events, we return 0.  We also return 0 if just there are 
no migation event.
<<updatetree static>>=
static int Genealogy_skipMig (int ci, int li, int ei, double t);
<<updatetree population tree update>>=
int 
Genealogy_skipMig (int ci, int li, int ei, double t)
{
int mi;
struct edge *gtree;
double mt;

gtree = C[ci]->G[li].gtree;
mi = 0;
/* Skip all migration events before [[t]]. */
mt = gtree[ei].mig[mi].mt;    
while (mt > -0.5 && mt < t)
  {
    mi++;
    mt = gtree[ei].mig[mi].mt;
  }
return mi;
}

@
We find the starting population of the migration [[mi]].
/* Find the starting population. */
<<updatetree static>>=
static int Migration_above_startpopn (int ci, int li, int ei, int mi, int ki);
static int Migration_startpopn (int ci, int li, int ei, int mi);
<<updatetree population tree update>>=
int 
Migration_above_startpopn (int ci, int li, int ei, int mi, int ki)
{
  int mp;
  struct edge *gtree;

  assert (!(mi < 0)); 
  gtree = C[ci]->G[li].gtree;
  if (mi == 0)
    {
      mp = gtree[ei].pop;
    }
  else
    {
      mp = gtree[ei].mig[mi-1].mp;
    }
  mp = C[ci]->ptree.PtreePopndown (mp, ki - 1);
#if 0 /* SANGCHUL: tree */
  mp = C[ci]->popndown[mp][ki-1];
#endif

  return mp;
}

int 
Migration_startpopn (int ci, int li, int ei, int mi)
{
  int mp0;
  double mt;
  int ki;
  struct edge *gtree;

  assert (!(mi < 0)); 
  gtree = C[ci]->G[li].gtree;
  if (mi == 0)
    {
      mp0 = gtree[ei].pop;
    }
  else
    {
      mp0 = gtree[ei].mig[mi-1].mp;
    }
  mt = gtree[ei].mig[mi].mt;
  ki = C[ci]->ptree.PtreeFindperiod (mt);
  mp0 = C[ci]->ptree.PtreePopndown (mp0, ki);
#if 0 /* SANGCHUL: tree */
  mp0 = C[ci]->popndown[mp0][ki];
#endif

  return mp0;
}

<<updatetree population tree update>>=
int 
Phylogeny_isCoalescent (int ci, double upt, double dnt, int b1, int b2)
{
int v;
int li;
int ei;
double t;
int b;

v = 0;
for (li = 0; li < nloci; li++)
  {
    for (ei = 0; ei < L[li].numlines; ei++)
      {
        t = imaGtreeTime (ci, li, ei);
        b = imaGtreePop (ci, li, ei);
        if (upt < t && t < dnt && (b == b1 || b == b2))
          {
            v = 1;
            li = nloci;
            break;
          }
      }
  }
return v;
}

int 
Phylogeny_isCoalescent2 (int ci, double upt, double dnt, int b1, int b2, int b3)
{
int v;
int li;
int ei;
double t;
int b;

v = 0;
for (li = 0; li < nloci; li++)
  {
    for (ei = 0; ei < L[li].numlines; ei++)
      {
        t = imaGtreeTime (ci, li, ei);
        b = imaGtreePop (ci, li, ei);
        if (upt < t && t < dnt && (b == b1 || b == b2 || b == b3))
          {
            v = 1;
            li = nloci;
            break;
          }
      }
  }
return v;
}



@
\section{IMa3 - Lmode using C++ classes}

\subsection{Lmcmc}
We set out another implementation of ``L-mode'' of IMa.  We do not intend to
replace the published version of [[IMa2]].  We need one that takes a new format
of ``.ti'' file and compute the function of the approximated posterior
distribution of demographic parameters.  We implement two main classes:
[[Ltree]] and [[Ptree]].  Each main class cooperates with its corresponding
relative classes.  [[Ptree]] represents a population tree and its relatives
include [[Pedge]], [[Weight]], [[Integrate]], [[EdgeIMParameter]], and
[[IMParameter]].  [[Ltree]] is a version of [[Ptree]], but it does not have an 
actual tree structure.  The tree structure can be found using [[Ptree]], and
[[Ltree]] provides an interface through which we can compute $\pi(\theta|G).$ The
posterior distribution of $\theta$ or $\pi(\theta|X)$ can be approximated as the
sum of $\pi(\theta|G_i)$ where $G_i$ is a sampled genealogy.  Note that a
genealogy is associated with a particular population tree.  [[Ltree]]'s
relatives include [[Ledge]].  [[Ltree]] can access [[Ptree]]'s demographic
parameter values.  [[Pedge]] instantiates [[EdgeIMParameter]] and 
corresponding [[Ledge]] can access it through a pointer.  This does make sense
in that a population tree is the only parameter we need and [[Ltree]] needs to
know what those parameters are to compute $\pi(\theta|G).$ There are two more
relative files for [[Ltree]]: [[Lmode]] and [[Lmcmc]]. [[Lmode]] is a class that
accommodates [[Ptree]] and [[Ltree]].  [[Lmcmc]] is an application of [[Lmode]].
One could implement another appliation of [[Lmode]] like [[Lmcmc]].

We need more files for [[IMa3]] to work.

\begin{enumerate}
\item ParserPoptreestring: parses a population tree string to build a population
tree,
\item Prob: stores probability values,
\item VectorOperation: eases printing and setting elements of a vector,
\item imptools: provides tools for C++ version of [[IMa]],
\item anyoption: eases argument parsing,
\end{enumerate}

We replace some of key source files of [[IMa2]] with C++ version.  The contents
of them have not changed but their format for C++. These include genealogy
update, split time update, and mutation rates update.  
\begin{enumerate}
\item src/updategtree.hh
\item src/updategenealogy.hh
\item src/updategtreecommon.hh
\item src/updatemcparams.hh
\item src/updatetNW.hh
\item src/updatetRY.hh
\item src/updatetree.hh
\end{enumerate}

There are many important source files that are converted to C++ format.
\begin{enumerate}
\item src/autoc.hh
\item src/buildgtree.hh
\item src/buldgtree.hh
\item src/calcprobdata.hh
\item src/freemem.hh
\item src/ginfo.hh
\item src/imamain.hh
\item src/initialize.hh
\item src/mcmcfiles.hh
\item src/output.hh
\item src/swapchains.hh
\item src/savegtree.hh
\item src/assertgenealogy.hh
\end{enumerate}

We keep much of the original implemention of [[IMa2]] using C.  
The two files or [[imamp.h]] and [[utilities.h]] are split to more files.
\begin{enumerate}
\item src/imdef.h
\item src/imenum.h
\item src/imstruct.hh
\item src/imglobal.h
\item src/imalgorithm.h
\item src/immath.h
\item src/imrng.h
\item src/imtools.h
\item src/immalloc.h
\end{enumerate}

Some of them are not changed to C++ format.
\begin{enumerate}
\item src/readata.c/h
\item src/xtrapbits.h
\end{enumerate}

<<Lmcmc.cc>>=
/*
 * Here is a sample of how to use AnyOption to
 * parse comand line argumnets and an ptions file
 *
 * Create  sample.txt as follows
 *
 *      # sample options file
 *      # this is a comment 
 *      zip  
 *      size  : 42 
 *      title : This is a test title.
 *
 * Run the sample with any combination of the options
 *
 *      a.out -c --zip -s 20 --name foo.jpg argtest1 argtest2 
 */

#include <cstdlib>
#include <string>
#include "anyoption.h"
#include "imdef.h"
#include "Lmode.hh"

int step;
char popnames[IMConstants::MAXPOPS][NAMELENGTH];

using std::cout;
using std::endl;
using std::string;

void example( int argc, char* argv[] );

int
main( int argc, char* argv[] )
{
  example (argc, argv); 
  return 0 ;
}

void
example( int argc, char* argv[] )
{

  /* 1. CREATE AN OBJECT */
  AnyOption *opt = new AnyOption();

  /* 2. SET PREFERENCES  */
  //opt->noPOSIX(); /* do not check for POSIX style character options */
  opt->setVerbose(); /* print warnings about unknown options */
  opt->autoUsagePrint(true); /* print usage for bad options */

  /* 3. SET THE USAGE/HELP   */
  opt->addUsage( "" );
  opt->addUsage( "Usage: " );
  opt->addUsage( "" );
  opt->addUsage( " -h  --help     Prints this help" );
  opt->addUsage( " -i  --infile   IMa3 output file" );
  opt->addUsage( " -g  --gen 1000 MCMC generations" );
  opt->addUsage( " -t  --thin 10  MCMC thin" );
  opt->addUsage( " -b  --burn 0.1 MCMC burn in percent" );
  opt->addUsage( " -x  --iLH 0.1  Labeled history" );
  opt->addUsage( " -q  10         Theta prior" );
  opt->addUsage( " -m  0.1        migration prior" );
  opt->addUsage( " -s  --seed 123 random seed number" );
  opt->addUsage( " --mcmc         MCMC" );
  opt->addUsage( " --ml           ML" );
  opt->addUsage( " --sort         Sort trees" );
  opt->addUsage( "" );

  /* 4. SET THE OPTION STRINGS/CHARACTERS */

	/* by default all  options  will be checked on the command line and from option/resource file */
  opt->setFlag(  "help", 'h' );   /* a flag (takes no argument), supporting long and short form */ 
  opt->setOption(  "infile", 'i' ); /* an option (takes an argument), supporting long and short form */
  opt->setOption(  "gen", 'g' );
  opt->setOption(  "thin", 't' );
  opt->setOption(  "burn", 'b' );
  opt->setOption(  "iLH", 'x' );
  opt->setOption(  "seed", 's' );
  opt->setOption(  "", 'q' );
  opt->setOption(  "", 'm' );
  opt->setFlag( "mcmc" );
  opt->setFlag( "ml" );
  opt->setFlag( "sort" );

	/* for options that will be checked only on the command and line not in option/resource file */
  opt->setCommandFlag(  "zip" , 'z'); /* a flag (takes no argument), supporting long and short form */

	/* for options that will be checked only from the option/resource file */
  opt->setFileOption(  "title" ); /* an option (takes an argument), supporting only long form */

  /* 5. PROCESS THE COMMANDLINE AND RESOURCE FILE */

  /* read options from an option/resource file with ':' separated opttions or flags, one per line */
  string home(getenv ("HOME"));
  home += "/.ima";
  opt->processFile( home.c_str() );  

  /* go through the command line and get the options  */
  opt->processCommandArgs( argc, argv );

	if( ! opt->hasOptions()) { /* print usage if no options */
    opt->printUsage();
	  delete opt;
		return;
	}

  /* 6. GET THE VALUES */
  if ( opt->getFlag( "help" ) || opt->getFlag( 'h' ) ) 
    opt->printUsage();

  //string a (opt->getValue( 'i' )); 
  //double q = atof (opt->getValue( 'q' ));
  //double m = atof (opt->getValue( 'm' ));

  int iLH;
  int gen;
  int thin; 
  int seed;
  double burn;
  string a;
  if ( opt->getValue( 'i' ) != NULL  || opt->getValue( "infile" ) != NULL  )
  {
    a = opt->getValue( 'i' ); 
  }
  if ( opt->getValue( 'x' ) != NULL  || opt->getValue( "iLH" ) != NULL  )
  {
    iLH = atoi (opt->getValue( "iLH" ));
  }
  if ( opt->getValue( 'g' ) != NULL  || opt->getValue( "gen" ) != NULL  )
  {
    gen = atoi (opt->getValue( 'g' ));
  }
  if ( opt->getValue( 't' ) != NULL  || opt->getValue( "thin" ) != NULL  )
  {
    thin = atoi (opt->getValue( 't' ));
  }
  if ( opt->getValue( 'b' ) != NULL  || opt->getValue( "burn" ) != NULL  )
  {
    burn = atof (opt->getValue( 'b' ));
  }
  else
  {
    burn = .0L;
  }
  if ( opt->getValue( 's' ) != NULL  || opt->getValue( "seed" ) != NULL  )
  {
    seed = atoi (opt->getValue( 's' ));
  }
  else
  {
    seed = 100;
  }
#if 0
    iLH = 160;
    gen = 100;
    thin = 10;
    burn = .0L;
    seed = 123;
#endif
  Lmode l;
  if (opt->getFlag( "mcmc" ))
  {
    l.load (a, iLH); 
    l.mcmc (a, gen, thin, burn, seed); // 100 generation, 10 thin
  }
  else if (opt->getFlag( "ml" ))
  {
    l.load (a, iLH); 
    l.ml (a);
  }
  else if (opt->getFlag( "sort" ))
  {
    l.sort (a);
  }

#if 0
	/* 7. GET THE ACTUAL ARGUMENTS AFTER THE OPTIONS */
  for( int i = 0 ; i < opt->getArgc() ; i++ ) {
    cout << "arg = " <<  opt->getArgv( i ) << endl ;
  }
#endif

  /* 8. DONE */
  delete opt;
}

@
\subsection{Lmode.hh}
[[Lmode]] computes $\pi(\theta|G_j)$ for each posterior sampled genealogy $G_j$ to
approximate $\pi(\theta|X)$.  The input file is the output file of [[IMa3]].  We
use the file name to access other files that are suffixed.  An output file name
such as ``test.out'' is used to find its ``.ti'' file with its name
``test.out.ti.''  A computed value for $\pi(\theta|X)$ is stored in [[_v]].  Two
more member variables are [[_ltree]] and [[_ptree]].  A population tree is fixed
and the demographic parameters related to the tree are found in [[_ptree]].
Sampled genealogies are stored in [[_ltree]].  We will have multiple sampled
genealogies but all of the genealogies must share the same population tree
instantiated by [[_ptree]].
All of the genealogy weights and integrates are stored in [[_ltree]] and 
demographic parameters are stored in [[_ptree]].  [[Lmode]] is supposed to
estimate demographic parameters using sampled genealogies for a particular
population tree. We use either maximum-likelihood or Bayesian approach to
achieve this goal.  For now we only try to implement one Bayesian approach.

We provide three main methods for estimating all demographic parameters jointly
using a Bayesian approach. We pretend that the approximated value of
$\pi(\theta|X)$ is the true.  We update demographic parameters with uniform
priors. The default constructor [[Lmode]] does nothing.  All of members are
initialized by the method [[load]].  It needs the base file name or the output
file name of [[IMa3]].  We should provide the index of a population tree so that
we use genealogies that are associated with a particular population tree with
the index [[iLH]].  Yang and Rannala (1997) describe the method of ranking and
unranking a population tree.  We use the technique to one-to-one map a number 
to a population tree.  We can extract population size and
migration rate priors from the output file of [[IMa3]] by finding the command
line option.  We can specify them in the method [[load]].  

After all weights and integrates are stored in [[_ltree]] and all demographic
parameter values in [[_ptree]] we call [[compute]] to calculate the approximate
value of $\pi(\theta|X)$.  We call the method at the beginning of [[Lmode]].
Later we would only change one of the demographic parameters and call the method
for a particular demographic parameter.  A particular demographic parameter can
be recognized by two population labels: [[pi]] and [[qi]].  The value of [[qi]]
is set to -1 for a population size.  Both [[pi]] and [[qi]] is set for a
population migration rate parameter.  We call the same name [[compute]] for each
sampled genealogy or [[Ltree]].  Note that a sampled genealogy means a set of
genealogies for a particular population tree, and it is stored in [[Ltree]].
If a proposed new demographic parameter value is not accepted, we have to revert
to the original value using [[_ptree]].  Computed values of $\pi(\theta|G)$ are
stored in each element of [[_ltree]], which has to call its [[revert]]. 

To summarize demographic parameters sampled from the posterior distribution,
$\pi(\theta|X)$ we save all values in a format that the program called
``Tracer'' can handle.  These methods, [[record]] and [[recordHeader]], are
called in the method [[mcmc]].  We need to pay attention to this method and
[[load]] and [[move]].

Method [[load]] uses the ``.ti'' file that contains posterior samples of
genealogies.  The sample consists of weights and integrates.  Although we call
them genealogies, they are more like something that is related with a population
tree.  The method uses some functions in [[imptools]]: [[readNpopsFromTi]] to
know the number of sampled populations, [[readPriorFromTiFile]] to know the
prior of population size and migration rate.  We use these three values with
[[iLH]] the index of a population tree to make [[_ptree]].  We then read the
``.ti'' file using [[PtreeRestoreSampInf]] and setup an element [[Ltree]] using
[[Ptree]] to add it to [[_ltree]].  The last one we do is to set [[_wp]].  It
is a list of integer pairs: [[pi]] and [[qi]].  All demographic parameters can
be relatively easily enumerated using the list.  Note that we have the three
main members: [[_ptree]], [[_ltree]], and [[_wp]].  All of the three members are
set in the method [[load]].

Method [[mcmc]] is quite an easy-to-read function.  Its helper [[move]] needs
more attention.  We choose one demographic parameter using [[_wp]].
[[_ptree]]'s method [[proposeTheta]] changes the parameter's current value.
With the new parameter value we compute $\pi(\theta^*|X)$ and compare it with its
previous value of $\pi(\theta|X)$.  Unless the acceptance probability is larger
than a random log value, we revert $\theta^*$ to $\theta$.

<<Lmode.hh>>=
<<im3 copyright>>
#ifndef _LMODE_HH_
#define _LMODE_HH_
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <utility>
#include "imrng.h"
#include "Ptree.hh"
#include "EdgeIMParameter.hh"
#include "Ltree.hh"

using std::string;
using std::vector;
using std::pair;

class SortLH {
public:
  bool operator()(const pair<int,int> &s1, const pair<int,int> &s2)
  {
    return s1.second > s2.second;
  }
};

class Lmode {
  friend std::ostream& operator<<(std::ostream& os, const Lmode& lm);
  double _v;
  double _vhold;
  string _file;
  vector<Ltree> _ltree;
  Ptree _ptree; 
  vector< pair<int,int> > _wp; 
public:
  Lmode () {}
  ~Lmode () { unsetseeds(); }
  void load (const string &s, int iLH);
  void load (const string &s, int iLH, const double thetaprior, const double mprior);
  void mcmc (const string &bfile, const int gen, const int thin, 
             const double burnin = .0L, const int seed = 100);
  void ml (const string &bfile);
  void sort (const string &bfile);
private:
  void mlsh (const string &fn);
  void mlsh1 (const string &fn, const string &s);

  void move ()
  {
    int nparam = _ptree.getNparam ();
    for (int i = 0; i < 2 * nparam; i++)
      {
        int j = randposint (nparam);
        int pi = _wp[j].first;
        int qi = _wp[j].second;
        _ptree.proposeTheta (pi, qi);
        compute (pi, qi);
        double logU = log (uniform());
        double metropolis = _v - _vhold;
        if (metropolis < logU)
          {
            revert (pi, qi);
          }
      }
  }

  double compute ()
  {
    vector<Ltree>::iterator i = _ltree.begin();
    _v = i->compute ();
    i++;
    for (;
         i != _ltree.end();
         i++)
      {
        double v1 = i->compute ();
        LogSum2 (_v, _v, v1);
      }
    return _v;
  }

  double compute (const int pi, const int qi)
  {
    _vhold = _v;
    vector<Ltree>::iterator i = _ltree.begin();
    _v = i->compute (pi, qi);
    i++;
    for (;
         i != _ltree.end();
         i++)
      {
        double v1 = i->compute (pi, qi);
        //LogSum2 (_v, _v, v1);

    if (v1 > 0)
      int xxxxxx = 0;
    if (_v > 0)
      int xxxxxx = 0;
    if ((_v) > (v1)) \
      if ((_v) - (v1) < 7.0978271289338397e+02) \
        (_v) = (v1) + log (exp ((_v) - (v1)) + 1.0); \
      else \
        (_v) = (_v); \
    else \
      if ((v1) - (_v) < 7.0978271289338397e+02) \
        (_v) = (_v) + log (exp ((v1) - (_v)) + 1.0); \
      else \
        (_v) = (v1);




      }
    return _v;
  }

  double computeMarginal (const int pi, const int qi)
  {
    vector<Ltree>::iterator i = _ltree.begin();
    _v = i->computeMarginal (pi, qi);
    i++;
    for (;
         i != _ltree.end();
         i++)
      {
        double v1 = i->computeMarginal (pi, qi);
        LogSum2 (_v, _v, v1);
      }
    return _v;
  }

  void revert (const int pi, const int qi)
  {
    _v = _vhold; 
    _ptree.revert (pi, qi);

    for (vector<Ltree>::iterator i = _ltree.begin();
         i != _ltree.end();
         i++)
      {
        i->revert (pi, qi);
      }
  }

  void recordHeader (const string &pfile)
  {
    std::ofstream os(pfile.c_str(), std::ios::out);
    if (!os)
      {
        std::cerr << "Error: file " << pfile << " could not be opened"
                  << std::endl;
        exit (1);
      }

    os << "gen";
    for (vector< pair<int,int> >::iterator i = _wp.begin();
         i != _wp.end();
         i++)
      {
        if (i->second == -1)
          os << "\tq" << i->first;
        else
          os << "\tm" << i->first << ">" << i->second;
      }
    os << std::endl;
  }

  void record (const string &pfile, const int step)
  {
    std::ofstream os(pfile.c_str(), std::ios::out | std::ios::app);
    if (!os)
      {
        std::cerr << "Error: file " << pfile << " could not be opened" 
                  << std::endl;
        exit (1);
      }

    os << step;
    for (vector< pair<int,int> >::iterator i = _wp.begin();
         i != _wp.end();
         i++)
      {
        os << "\t";
        os << _ptree.getTheta (i->first, i->second);
      }
    os << std::endl;
  }
};
#endif /* _LMODE_HH_ */

<<Lmode.cc>>=
<<im3 copyright>>
#include <fstream>
#include <sstream>
#include <vector>
#include <utility>
#include <map>
#include <algorithm>
#include "imptools.hh"
#include "Ltree.hh"
#include "Ptree.hh"
#include "IParam.hh"
#include "Lmode.hh"

using std::vector;
using std::pair;
using std::map;

void 
Lmode::load (const string &s, int iLH)
{
  string tiFile = s + ".ti";
  double qprior = ima::readPriorFromTiFile (tiFile, "q");
  double mprior = ima::readPriorFromTiFile (tiFile, "m");
  load (s, iLH, qprior, mprior);
}

void 
Lmode::load (const string &s, int iLH, const double thetaprior, const double mprior)
{
  string tFile = s + ".time.p";
  string tiFile = s + ".ti";
  int npops = ima::readNpopsFromTi (tiFile);
  _ptree.Initialize (npops, 1, iLH);
  _ptree.setPriorQ (thetaprior);
  _ptree.setPriorM (mprior);

  std::ifstream is(tiFile.c_str (), std::ios::in);
  if (!is)
    {
      std::cerr << "Error: file " << s << "could not be opened";
      exit (1);
    }
  if (!ima::readTill (is))
    {
      std::cerr << "Not found VALUESSTART in the ti file " 
                << tiFile << std::endl;
      exit (1);
    }

  _ptree.printHeaderSplitTime (tFile);
  _ltree.clear();
  int r = 1;
  int v = 0;
  while (r != -1)
    {
      r = _ptree.PtreeRestoreSampInf (is, iLH);
      if (r == 1)
        {
          Ltree t(_ptree); // parameters' pointers are set 
          _ltree.push_back(t);
          _ptree.printSplitTime (tFile, v);
        }
      v++;
    }
  std::cout << "# of ltree: " << _ltree.size() << std::endl;
  _ptree.setWp (_wp);

  _v = compute ();
}

void 
Lmode::mcmc (const string &bfile, const int gen, const int thin, 
             const double burnin, const int seed)
{
  int step;
  int nburnin;
  string pfile = bfile + ".p";

  setseeds (seed);

  step = 0;
  nburnin = int (burnin * gen);
  while (step++ < nburnin)
    {
      move ();
    }

  recordHeader (pfile);
  while (step++ < gen)
    {
      if (step % 100 == 0)
        std::cout << "Step: " << step << " (" << step/double(gen) << ")\n";
      if (step % thin == 0)
        record (pfile, step);
      move ();
    }
}

void 
Lmode::mlsh (const string &fn)
{
  std::ofstream os(fn.c_str(), std::ios::out);
  if (!os)
    {
      std::cerr << "Error: file " << fn << "could not be opened";
      exit (1);
    }
  os << "function draw () {\n"
     << "  graph -T ps $1 > $1.ps\n"
     << "}\n";
  os.close ();
}

void 
Lmode::mlsh1 (const string &fn, const string &s)
{
  std::ofstream os(fn.c_str(), std::ios::out | std::ios::app);
  if (!os)
    {
      std::cerr << "Error: file " << fn << "could not be opened";
      exit (1);
    }
  os << "draw " << s << "\n";
  os.close ();
}

void 
Lmode::ml (const string &bfile)
{
  string sfile;
  string shfile;
  std::stringstream sout;

  shfile = bfile + ".sh";
  mlsh (shfile);

 
  int nparam = _ptree.getNparam ();
  for (int i = 0; i < nparam; i++)
    {
      int pi = _wp[i].first;
      int qi = _wp[i].second;

      IParam ip (_ptree.getThetaPrior (pi, qi));

      // some x, some y
      int n = ip.gridSize();
      for (int j = 0; j < n; j++)
        {
          double x = ip.getX (j);
          _ptree.setTheta (pi, qi, x);
          ip.setY (j, computeMarginal (pi, qi));
        }
      sout.str("");
      if (qi == -1)
        sout << bfile << "-q" << pi << ".s";
      else
        sout << bfile << "-m" << pi << "-" << qi << ".s";
      sfile = sout.str();
      ip.drawXY (sfile);
      mlsh1 (shfile, sfile);
    }
}


void 
Lmode::sort (const string &bfile)
{
  string tiFile = bfile + ".ti";
  std::ifstream is(tiFile.c_str (), std::ios::in);
  if (!is)
    {
      std::cerr << "Error: file " << tiFile << "could not be opened";
      exit (1);
    }
  if (!ima::readTill (is))
    {
      std::cerr << "Not found VALUESSTART in the ti file " 
                << tiFile << std::endl;
      exit (1);
    }
 
  vector< pair<int,int> > cLH;
  int gen;
  int iLH;
  is >> gen;
  is >> iLH;
  while (!is.eof())
    {
      bool isFound = false;
      for (vector< pair<int,int> >::iterator i = cLH.begin();
           i != cLH.end();
           i++)
        {
          if (i->first == iLH)
            {
              i->second++;
              isFound = true;
              break;
            }
        }
      if (isFound == false)
        {
          cLH.push_back (make_pair(iLH,1));
        }

      ima::readToEndl (is);
      is >> gen;
      is >> iLH;
    }
 
  std::sort (cLH.begin(), cLH.end(), SortLH());
  int sum = 0;
  for (vector< pair<int,int> >::iterator i = cLH.begin();
       i != cLH.end();
       i++)
    {
      std::cout << i->first << " => " << i->second << std::endl;
      sum += i->second;
    }
  std::cout << "sum: " << sum << std::endl;
}

@
We need organize the classes.
<<Lmode-t.cc>>=
#include <string>
#include "imdef.h"
#include "Lmode.hh"

using std::string;

int step;
char popnames[IMConstants::MAXPOPS][NAMELENGTH];

int main (int argc, char* argv[])
{
  string a("../run/t5/o/t5-1.out");
  Lmode l;
  l.load (a, 40); // We will take the three trees with index of LH being 40
  //l.mcmc (a, 100, 10); // 100 generation, 10 thin
  l.ml (a);
  return 0;
}


<<IParam.hh>>=
<<im3 copyright>>
#ifndef _IPARAM_HH_
#define _IPARAM_HH_
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <utility>

using std::string;
using std::vector;
using std::pair;

class IParam {
  friend std::ostream& operator<<(std::ostream& os, const IParam& lm);
  double _u;
  double _l;
  int _ngrid;
  vector< pair<double,double> > _xy; 
public:
  IParam (const double u = 1.0L, const int ngrid = 1000) 
  { 
    _l = .0L;
    _u = u;
    _ngrid = ngrid;
    _xy.resize (ngrid);
    int j = 0;
    for (vector< pair<double,double> >::iterator i = _xy.begin();
         i != _xy.end();
         i++, j++)
      {
        i->first = _l + ((j + 0.5) * (_u - _l))/ngrid;
      }
  }
  double getX (const int idx) { return _xy[idx].first; }
  void setY (const int idx, const double y) { _xy[idx].second = y; }
  void drawXY (const string &fn);
  int gridSize () { return _ngrid; }
};

#endif /* _IPARAM_HH_ */

<<IParam.cc>>=
<<im3 copyright>>
#include <fstream>
#include <vector>
#include <string>
#include <utility>
#include "IParam.hh"

using std::string;
using std::vector;
using std::pair;

void
IParam::drawXY (const string &fn)
{
  std::ofstream os(fn.c_str(), std::ios::out);
  if (!os)
    {
      std::cerr << "Error: file " << fn << "could not be opened";
      exit (1);
    }
  for (vector< pair<double,double> >::iterator i = _xy.begin();
       i != _xy.end();
       i++)
    {
      os << i->first << "\t" << i->second << std::endl;
    }
  os.close ();
}

<<IParam-t.cc>>=
#include <iostream>
#include <vector>
#include "IParam.hh"

using std::vector;

int main (int argc, char* argv[])
{
  double v;

  IParam ip (3.0L);

  for (int i = 0; i < ip.gridSize(); i++)
    {
      double x = ip.getX (i);
      double y = x + 2.0L;
      ip.setY (i, y);
    }
  ip.drawXY ("ip.txt");
}

@
\subsection{Plotter}
Plot shows the trend of values in time.
Point is a dot on Plot.
Axis is a x or y bar on Plot.
Function [[callasciicurves]] is written by an object.
Function [[callasciitrend]] is also rewritten by an object.
<<Plotter.hh>>=
#ifndef _PLOTTER_HH_
#define _PLOTTER_HH_
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <cassert>
#include "imdef.h"
#include "imstruct.h"

class Plotter {
  char ** graph;     // maxleny-by-maxlenx canvas
  size_t maxleny;
  size_t maxlenx;
public:
  void move (int dx, int dy);
  void draw (...);
  void setmaxlenx (const size_t x) { maxlenx = x; }
  void setmaxleny (const size_t x) { maxleny = x; }
};

class TrendPlotter: public Plotter {
  char * str;
  char * strshort;
  int doXYplot;
  int doLogplot;
  struct plotpoint * xy;
  struct priorvalues plotrange;
  double plotrescale;           // 1 unless needed for some reason
  int doTrend;
  double * trend;
  int doAutoc;
  // struct autoc ac[AUTOCTERMS];
  int beforemin;
  int aftermax;
public:
  void setX (int isint);
};

// Constants for asciicurve ACXPLOT and AXYPLOT  determine the area of the plot
#define  ACXLEFTSPACE 10
#define  ACXPLOT  75
#define ACXMAX (ACXLEFTSPACE + ACXPLOT)
#define ACYPLOT 50
#define  ACYBOTSPACE 3
#define ACYMAX (ACYPLOT + ACYBOTSPACE)
#define  ASCIICURVEMINVAL 1e-6

class CurvePlotter: public Plotter {

};


#endif /* _PLOTTER_HH_ */

<<Plotter.cc>>=

% Plotter ctor { // void * ctor (void * va_list * app)
  struct Plotter * self = super_ctor(Plotter(), app);
  size_t i;
  
  _maxleny = va_arg(* app, size_t);
  _maxlenx = va_arg(* app, size_t);
  _graph = malloc (_maxleny * sizeof (char *)); 
  for (i = 0; i < _maxleny; i++)
    {
      _graph[i] = malloc (_maxlenx * sizeof (char));
    }
  return self;
}

% Plotter dtor { // void * dtor (void * _self)
%casts
  size_t i;

  for (i = 0; i < _maxleny; i++)
    {
      free (_graph[i]);
    }
  free (_graph);
  return super_dtor(Plotter(), self);
}


% TrendPlotter setX { // static void setX (void * int isint)
%casts
int i;
for (i = 0; i < GRIDSIZE; i++)
{
  if (_doLogplot)
  {
    // the same scale is used for all mutation rate scalars 
    _xy[i].x = exp (_plotrange.min + (i + 0.5) * _plotrescale); 
  }
  else
  {
    if (isint)
      _xy[i].x = (double) i;
    else
      self ->xy [i].x = _plotrange.min 
                        + ((i + 0.5) 
                           * (_plotrange.max 
                              * _plotrescale 
                              - _plotrange.min)) 
                        / GRIDSIZE;
  }
}
} // set_x 


// See init_value_record
// and init_g_rec
% TrendPlotter ctor { // void * ctor (void * va_list * app)
  struct TrendPlotter * self = super_ctor(TrendPlotter(), app);
  int isint;
  double * trend;

  _str = strdup (va_arg(* app, char *));
  _strshort = strdup (va_arg(* app, char *));
  _doXYplot = va_arg(* app, int);
  _doLogplot = va_arg(* app, int);
  _doTrend = va_arg(* app, int);
  _doAutoc = va_arg(* app, int);
  _beforemin = va_arg(* app, int);
  _aftermax = va_arg(* app, int);
  _plotrescale = va_arg(* app, double);
  _plotrange.min = va_arg(* app, double);
  _plotrange.max = va_arg(* app, double);
  trend = va_arg(* app, double *);
  isint = va_arg(* app, int);

  if (_doXYplot)
    {
      _xy = calloc (GRIDSIZE, sizeof (struct plotpoint));
      setX (self, isint);
    }
  else
    {
      _xy = NULL;
    }

  if (_doTrend)
    {
      _trend = calloc (TRENDDIM, sizeof (double));
      memcpy (_trend, trend, TRENDDIM * sizeof (double));
    }
  else
    {
      _trend = NULL;
    }
  return self;
}

% TrendPlotter dtor { // void * dtor (void * _self)
%casts
  size_t i;

  free (_str);
  free (_strshort);
  if (_trend != NULL)
    free (_trend);
  if (_xy != NULL)
    free (_xy);
  return super_dtor(TrendPlotter(), self);
}

// We copy the most of function asciitrend.
% TrendPlotter draw { // void draw (const void * _self)
%casts
  int trenddoublepoint; // first argument
  int trendspot;        // second argument

  char **graph;
  char tc[20];
  double yt, ymax = -1e200, ymin = 1e200;
  double rescalerbelow, rescalerabove;
  double *y;
  double logscale;
  int i, xspot, xtemp, xmax, yspot, notplot = 0, rescaledoublepoint;
  int xlen, ylen, dim, localdoublepoint;

  trenddoublepoint = va_arg(* app, int);
  trendspot = va_arg(* app, int);

  y = _trend;
  if (_doLogplot)
    logscale = UMAX;
  xlen = DEFAULTLENX;
  ylen = DEFAULTLENY;
  if (trendspot < TRENDDIM)
  {
    dim = trendspot;
    localdoublepoint = trendspot;
  }
  else
  {
    dim = TRENDDIM;
    localdoublepoint = trenddoublepoint;
  }
  //for (i = 0; i < TRENDDIM; i++)
  for (i = 0; i < dim; i++)
  {
    yt = y[i];
    if (ymax < yt)
      ymax = yt;
    if (ymin > yt)
      ymin = yt;
  }
  if (_doLogplot)
  {
    if (ymax > (double) logscale)
      ymax = (double) logscale;
    if (ymin < 1 / (double) logscale)
      ymin = 1 / (double) logscale;
  }
  graph = graph(self); // We get the graph.
  strcpy (graph[0], _str);
  strcat (graph[0], " trend");
  if (_doLogplot)
    strcat (graph[0], " - log scale");
  sprintf (tc, "%8.4g", ymax);
  strcpy (graph[1], tc);
  while ((int) strlen (graph[1]) < xlen - 1)
    strcat (graph[1], " ");
  sprintf (tc, "%8.4f", ymin);
  strcpy (graph[ylen - 2], tc);
  while ((int) strlen (graph[ylen - 2]) < xlen - 1)
    strcat (graph[ylen - 2], " ");
  strcpy (graph[ylen - 1], "          ");
  while ((int) strlen (graph[ylen - 1]) < xlen - 1)
    strcat (graph[ylen - 1], "-");
  for (i = 2; i < ylen - 2; i++)
  {
    graph[i][0] = '\0';
    while ((int) strlen (graph[i]) < xlen - 1)
      strcat (graph[i], " ");
  } 

  for (i = 1; i < ylen - 1; i++)
    graph[i][10] = '|';

  xmax = (int) (xlen - 12);
  //rescaledoublepoint =  INTEGERROUND (((float) (xmax * trenddoublepoint) / TRENDDIM));
  rescaledoublepoint =  INTEGERROUND (((float) (xmax * localdoublepoint) / dim));
  rescalerbelow = (2 * (float) xmax) / (float) (rescaledoublepoint + xmax);
  rescalerabove = rescalerbelow / 2;

  //for (i = 0; i < TRENDDIM; i++)
  for (i = 0; i < dim; i++)
  {
    //      assert(y[i] != 0);
    if (y[i] >= ymin && y[i] <= ymax)
    {
      if (_doLogplot)
        yspot = (int) 1 + (ylen - 2) - (int) ((ylen - 2) * (log (y[i]) - log (ymin)) / (log (ymax) - log (ymin)));

      else
        yspot = (int) 1 + (ylen - 2) - (int) ((ylen - 2) * (y[i] - ymin) / (ymax - ymin));
    }
    else
    {
      yspot = -1;
      notplot = 1;
    }
    //xtemp = INTEGERROUND (((float) (xmax * i) / TRENDDIM));
    xtemp = INTEGERROUND (((float) (xmax * i) / dim));
    //xspot = (int) 11 + (int) (((xlen - 12) * i) / TRENDDIM); // the old method
    if (i <= localdoublepoint)
      xspot = (int) (xtemp * rescalerbelow);
    else
      xspot = (int) (rescaledoublepoint * rescalerbelow + (xtemp - rescaledoublepoint) * rescalerabove);
    xspot += (int) 11;
    if (xspot < xlen - 1 && yspot >= 1)
      graph[yspot][xspot] = '*';
  }

  // add indicator of point along trend where density changes 
  //xspot = (int) 11 + (int) ((xlen - 12) * trenddoublepoint / TRENDDIM);
  //graph[ylen - 1][xspot] = '!';

  for (i = 0; i < ylen; i++)
    fprintf (stdout, "%s \n", graph[i]);
  if (notplot)
    fprintf (stdout, "    - not all values plotted, some exceed bounds: %5.4f - %5.0f \n", ymin, ymax);
  fprintf (stdout, "\n");
}

// We copy the most of function asciitrend.
// void asciicurve (FILE * outfile, struct plotpoint *a, char *qlabel,
//                 int logscale, int recordstep)
% CurvePlotter draw { // void draw (const void * _self)
%casts
  // The original local variables
  char ** graph;
  char tc[13];
  double ymax = -1e10, ymin = 1e10;
  int xmax;
  int i, xspot, yspot;

  // The original function parameter
  FILE * outfile;
  struct plotpoint *a;
  char *qlabel;
  int logscale;
  int recordstep;
  outfile = va_arg(* app, FILE *);
  a = va_arg(* app, struct plotpoint *);
  qlabel = va_arg(* app, char *);
  logscale = va_arg(* app, int);
  recordstep = va_arg(* app, int);

  graph = graph(self); // We get the graph.
  for (i = 0; i < ACYMAX; i++)
    graph[i][0] = '\0';
  for (i = 0; i < GRIDSIZE; i++)
  {
    if (ymax < a[i].y)
      ymax = a[i].y;
    if (ymin > a[i].y)
      ymin = a[i].y;
  }
  ymax /= recordstep;
  ymin = 0;                     // don't shift plot on y axis 
  if (logscale)
  {
    xmax = GRIDSIZE - 1;
  }
  else
  {
    xmax = -1;
    i = GRIDSIZE - 1;
    while (xmax == -1)
    {
      if (fabs (a[i].y) > ASCIICURVEMINVAL)
        xmax = i;
      i--;
    }
  }
  assert (xmax >= 0 && xmax < GRIDSIZE);
  // set up plot name line 
  strcat (graph[0], qlabel);
  strcat (graph[0], " curve");
  while (strlen (graph[0]) < ACXMAX)
    strcat (graph[0], " ");
  //set up the upper y axis label
  sprintf (tc, "%8.4g", ymax);
  strcpy (graph[1], tc);
  while (strlen (graph[1]) < ACXMAX)
    strcat (graph[1], " ");
  //set up the lower y axis label
  sprintf (tc, "%8.4f", ymin);
  strcpy (graph[ACYPLOT], tc);
  while (strlen (graph[ACYPLOT]) < ACXMAX)
    strcat (graph[ACYPLOT], " ");
  //set up the horizontal line on the x axis
  for (i = 0; i < ACXLEFTSPACE; i++)
    strcat (graph[ACYPLOT + 1], " ");
  while (strlen (graph[ACYPLOT + 1]) < ACXMAX)
    strcat (graph[ACYPLOT + 1], "-");
  // set up the x axis label line
  for (i = 0; i < ACXLEFTSPACE; i++)
    strcat (graph[ACYPLOT + 2], " ");
  sprintf (tc, "%8.4f", a[0].x);
  strcat (graph[ACYPLOT + 2], tc);
  sprintf (tc, "%8.4f", a[xmax].x);
  if (logscale)
    strcat (graph[ACYPLOT + 2], "           Log Scale");
  while (strlen (graph[ACYPLOT + 2]) < ACXMAX - strlen (tc) - 1)
    strcat (graph[ACYPLOT + 2], " ");
  strcat (graph[ACYPLOT + 2], tc);
  while (strlen (graph[ACYPLOT + 2]) < ACXMAX)
    strcat (graph[ACYPLOT + 2], " ");
  // fill the plot with empty space
  for (i = 2; i < ACYPLOT; i++)
    while (strlen (graph[i]) < ACXMAX)
      strcat (graph[i], " ");
  // set up the vertical line on the Y axis
  for (i = 1; i < ACYPLOT + 1; i++)
    graph[i][ACXLEFTSPACE] = '|';
  i = 0;
  while (i <= xmax)
  {
    yspot = (int) 1 + ACYPLOT - (int) (ACYPLOT * (a[i].y / recordstep - ymin) / (ymax - ymin));
    if (logscale)
      xspot = (int) ACXLEFTSPACE + 1 + (int) ((ACXPLOT - 2) * (log (a[i].x) - log (a[0].x)) / (2 * log (a[xmax].x)));
    else
      xspot = (int) ACXLEFTSPACE + 1 + (int) ((ACXPLOT - 2) * (a[i].x - a[0].x) / (a[xmax].x - a[0].x));
    assert (xspot < ACXMAX);
    assert (yspot < ACYMAX);
    if (xspot < ACXMAX && xspot >= (ACXLEFTSPACE + 1) && yspot < ACYMAX && yspot >= 1)
      graph[yspot][xspot] = '*';
    i++;
  }
  for (i = 0; i < ACYMAX; i++)
    fprintf (outfile, "%s \n", graph[i]);
  fprintf (outfile, "\n");
}                               /* asciicurve */
//#undef ACXLEFTSPACE 
//#undef ACXPLOT  
//#undef ACXMAX 
//#undef ACYPLOT
//#undef ACYBOTSPACE
//#undef ACYMAX
//#undef ASCIICURVEMINVAL

<<Plotter-t.c>>=
#include <ctype.h>
#include <stdlib.h>
#include "Plotter.hh"

int main (int argc, char ** argv)
{	
  void * p;
  void * c;
  double *xp;
  struct plotpoint *yp;
  size_t i;
  <<Plotter-t 500 points>>
  <<Plotter-t 1000 points for curve>>

  xp = malloc (500 * sizeof (double));
  memcpy (xp, x, 500 * sizeof (double));
  yp = malloc (1000 * sizeof (struct plotpoint));
  memcpy (yp, y, 1000 * sizeof (struct plotpoint));
  p = new (TrendPlotter(), 
           MAXLENY, // ylim
           MAXLENX, // xlim
           "Assignment", // name of the plot
           "Asn",        // short name
           0,            // do_xyplot
           0,            // do_logplot
           1,            // do_trend
           0,            // do_autoc
           -5,            // beforemin
           5,            // aftermax
           1.0,          // plotrescale
           -5.0,           // plotrange.min
           5.0,            // plotrange.max
           xp,            // trend
           0);           // isint
  draw (p, TRENDDIM, TRENDDIM);
  delete (p);

  c = new (CurvePlotter(), 
           ACYMAX,     // ylim
           ACXMAX + 1  // xlim
          );
  draw (c, stdout, yp, "q", 0, 100);
  delete (c);

  free (xp);
  free (yp);

  return 0;
}

<<Plotter-t 500 points>>=
double x[500] = {
0.1300829,-1.292555,-0.5608595,-0.2479882,0.1032885,-0.6506925,-0.5197978,0.2982203,-0.1162761,1.355007,-0.8902047,0.7182759,1.205968,1.517761,-0.7988456,-2.421170,0.8592597,-1.613956,-0.7538069,1.577303,0.07585538,0.2837327,-0.2897066,1.734103,-0.5215988,-0.09577339,0.086954,-2.870653,0.8241368,1.173251,0.6750138,-1.176989,-0.1200343,0.904115,-0.5597672,0.9375125,-1.982809,-0.5263391,1.504122,0.2301173,-0.1535874,0.5116241,0.6649796,0.02689182,0.1638086,0.2261379,-0.9979893,-1.096616,0.9442495,-0.1193349,-0.04202606,-0.1261479,-0.08009703,0.06166573,0.9159949,-0.8782882,-0.3639888,0.005966317,-0.3349718,-0.1233174,0.1531090,1.376006,0.7348637,-0.7921062,-1.020494,0.617309,-1.191368,-1.260992,-0.6518176,-0.6507306,-1.930593,-0.4145563,0.3838527,-0.8538168,-2.284528,-0.7924444,-2.542139,0.4360017,0.4552893,1.315604,0.1373802,-0.5019128,-0.2054746,0.1269611,-0.3312238,-1.170944,0.8141832,0.9929292,0.8087109,0.5131257,-1.705521,-0.3672682,-1.713239,0.72615,-1.439864,0.8224547,-0.4694658,-0.6744962,0.6946409,-1.018571,-0.5085392,-2.053404,1.572563,-1.185115,0.1671484,-0.8644931,-2.309384,1.897642,1.320756,-2.026314,0.2949796,0.3991844,0.2430655,1.726813,2.165104,0.6552947,1.383521,1.282169,-0.8335939,0.5558455,-1.44403,-1.171170,-0.2187563,0.6481459,0.3081222,-0.07144514,-0.6264947,1.415506,-0.3623853,-1.552741,0.2016703,1.523049,-0.9943646,1.069527,-0.0918967,-0.3812067,1.992233,0.05631208,-0.5681806,-0.008958769,0.5006191,-0.3061415,0.3938573,-0.1438599,1.839227,-0.5981737,-0.4435984,1.127975,-0.7149181,1.398715,0.2605696,-1.256757,0.05689832,-0.8005943,-0.04525858,-0.3916473,0.458779,0.5446987,0.07260897,0.4845345,0.4592434,-1.769498,-0.02545963,-0.4254341,0.3726062,-1.495142,1.032989,1.197953,0.6812511,0.3024485,0.1982953,0.575408,-0.01169079,1.335749,-0.5792839,0.9829571,1.475861,0.4733507,-1.818929,-0.1353798,-0.3021254,-1.403903,-0.4895003,-1.444301,1.009450,0.3368083,1.544861,-1.562781,1.040113,-0.330378,0.270638,1.387089,-0.5939651,-0.5955047,0.3323085,-0.4843979,0.2039388,0.04474187,-0.8160513,-1.695247,-0.2789294,0.03575477,2.303554,0.9633097,0.934784,0.6041016,-0.3068644,-0.08205514,0.8138734,-0.5719189,-0.841689,0.2864306,-1.109693,1.796552,-0.3308295,-1.349280,-0.6038099,0.2685291,-2.093157,-0.8099963,-0.6070999,0.8860605,-1.455443,0.09328102,-1.645221,0.7738675,2.379159,-0.1957408,1.882591,1.290537,-0.896855,1.300489,-0.2381771,0.2929339,-1.144395,0.2532855,-0.7088076,0.1549414,0.6553722,0.04985787,0.1982831,-0.1627127,0.9109488,1.187616,1.594519,1.263148,1.553729,1.3628,-0.6549997,-0.9253803,-0.9192204,0.8904144,0.1330845,-0.00860628,-1.972272,-0.1713118,1.33908,-0.1482918,-0.9346452,1.347887,1.258955,-0.3753617,2.315318,-1.378186,-0.838808,0.63828,-1.189433,0.656653,-0.4277013,-0.3574802,-0.7566613,1.218125,0.5933212,-1.205418,-0.4635624,0.7047393,0.8598526,-1.483785,1.559570,1.269425,0.5303165,0.8990694,-0.02692518,-0.19727,-0.9449063,-0.5182348,-0.6849807,1.433971,-0.4483665,-0.1689202,-0.4396225,-1.240424,2.278638,0.6423843,-0.01416299,-1.904820,-1.906889,0.8380791,-1.352315,0.2503581,0.5050334,0.1394698,1.233784,-0.0718518,1.184062,1.127216,0.5839365,-3.602559,-0.2610197,-0.8454812,-0.5325018,-0.6467388,0.1859213,0.8268903,-1.288991,-0.3051259,-0.917619,-0.6411966,0.5432483,0.981743,-0.7659599,-0.1855815,-0.5516082,-0.4638706,-1.076778,0.0442001,0.4833777,-0.7419273,0.292458,-1.165073,-1.420183,-2.388790,0.1785624,0.1436549,0.3843602,0.1207221,1.430970,-0.2552926,-0.4338495,-1.130507,0.007056293,-1.089821,-0.6509322,-0.7050451,0.5410918,-0.6153706,-0.3952428,-0.7752478,-0.1610057,0.2908046,-0.41779,-0.5536038,-1.84833,0.3799008,0.2978928,-0.7998818,-0.4559525,-0.7348822,-0.8382227,0.511489,1.080040,-0.8558681,-0.0566776,0.7498101,1.52835,0.4811632,-1.528163,-1.208010,0.5164893,-1.112533,-1.891425,0.7027114,-0.2065748,-0.4596598,0.5631027,-1.077107,-0.4324672,-1.166792,1.270860,0.4518006,-1.066788,1.184381,1.759166,-0.08646671,1.418811,1.166231,-0.4829302,-0.02810602,-0.0821539,-0.7556715,0.1926665,1.487419,-2.195480,-0.08440665,-1.383508,-1.62281,1.945762,0.886608,1.148374,1.769577,0.04571793,-0.4862028,-0.6748704,1.250101,-1.135018,2.993145,-1.540274,-0.5844245,-0.6722567,1.139906,-2.735197,-0.5141523,-0.3787218,-2.417974,-0.4889248,1.381917,-1.625001,-0.8667258,-0.3305504,0.2569129,0.1760864,0.4247333,-0.3920418,-0.385723,0.236141,-0.8866355,-0.8538794,-1.627449,0.08992657,-0.689435,0.6291883,0.7218435,0.5474933,1.183475,-0.837282,1.107235,-0.5409342,1.009360,-1.005483,-0.4230763,-1.179169,0.9558503,-0.3706829,-0.97741,2.268087,0.5015108,0.03398904,-0.1325515,-1.113471,1.477427,-0.5795936,1.048352,1.215237,-1.156915,-0.1359801,-1.561227,0.333634,-2.253244,1.759811,0.8735104,-0.05214871,-0.6755968,1.361642,-0.5226806,-1.316219,0.1071252,3.024612,0.6586963,2.106085,1.517398,0.0239772,-1.445285,-0.1170975,-0.09703962,-0.4629158,0.3288004,0.007933592,0.1693711,0.2747161,2.336899,-0.3061105,-0.6701602,0.5818247,1.00034,-1.898191,-2.000853,1.299735,-0.070177,-0.3126982,0.3649064,-0.6150602,1.001510,0.5755047,1.233152,-1.195779,-0.3045395,0.3405841,0.2941253,-0.797797,0.2798389
};

<<Plotter-t 1000 points for curve>>=
struct plotpoint y[1000] = {
{-3.61823824078101,0.000136734078887963}, {-3.61067753553723,0.000146242726256671}, {-3.60311683029345,0.000156273646043671}, {-3.59555612504967,0.000166845096672083}, {-3.58799541980588,0.000178101215625158}, {-3.5804347145621,0.000190141095553649}, {-3.57287400931832,0.000202820251430565}, {-3.56531330407454,0.000216160080464527}, {-3.55775259883076,0.000230335354668397}, {-3.55019189358697,0.000245463735930684}, {-3.54263118834319,0.000261367928912908}, {-3.53507048309941,0.000278072750611181}, {-3.52750977785563,0.000295788300377695}, {-3.51994907261184,0.000314653013243552}, {-3.51238836736806,0.000334451218127538}, {-3.50482766212428,0.000355211398908703}, {-3.4972669568805,0.00037718396437425}, {-3.48970625163671,0.000400530306023184}, {-3.48214554639293,0.000424990338556643}, {-3.47458484114915,0.000450596411490962}, {-3.46702413590537,0.000477644438728128}, {-3.45946343066159,0.000506320866841855}, {-3.45190272541780,0.000536314752016542}, {-3.44434202017402,0.000567662445409999}, {-3.43678131493024,0.000600710681102079}, {-3.42922060968646,0.000635672905543683}, {-3.42165990444268,0.000672180559238416}, {-3.41409919919889,0.00071027405477747}, {-3.40653849395511,0.000750356270279839}, {-3.39897778871133,0.000792669372275688}, {-3.39141708346755,0.000836780233761822}, {-3.38385637822376,0.00088273330083384}, {-3.37629567297998,0.000930992804832431}, {-3.3687349677362,0.000981831059278281}, {-3.36117426249242,0.00103474336440723}, {-3.35361355724864,0.00108977807562425}, {-3.34605285200485,0.00114746574041744}, {-3.33849214676107,0.00120810989047075}, {-3.33093144151729,0.00127112735478826}, {-3.32337073627351,0.00133657017295377}, {-3.31581003102972,0.00140503979145578}, {-3.30824932578594,0.00147687162347743}, {-3.30068862054216,0.00155139740844132}, {-3.29312791529838,0.00162867254395206}, {-3.28556721005460,0.00170937344877091}, {-3.27800650481081,0.00179386763499725}, {-3.27044579956703,0.00188139559328206}, {-3.26288509432325,0.00197201565692959}, {-3.25532438907947,0.00206648266216693}, {-3.24776368383568,0.00216519597021796}, {-3.2402029785919,0.00226729929911045}, {-3.23264227334812,0.00237285340913994}, {-3.22508156810434,0.00248269426982774}, {-3.21752086286056,0.00259725237148794}, {-3.20996015761677,0.00271556993526986}, {-3.20239945237299,0.0028377095675142}, {-3.19483874712921,0.00296459027842731}, {-3.18727804188543,0.00309667251215136}, {-3.17971733664164,0.00323289321188584}, {-3.17215663139786,0.00337331619429533}, {-3.16459592615408,0.00351894455545561}, {-3.1570352209103,0.00367026709381637}, {-3.14947451566652,0.00382611275213342}, {-3.14191381042273,0.00398654588612568}, {-3.13435310517895,0.00415265383283721}, {-3.12679239993517,0.00432495176415073}, {-3.11923169469139,0.00450215904031615}, {-3.11167098944760,0.00468433986833635}, {-3.10411028420382,0.00487266508691566}, {-3.09654957896004,0.00506767392824385}, {-3.08898887371626,0.00526797577442974}, {-3.08142816847248,0.00547363399618462}, {-3.07386746322869,0.00568590131402754}, {-3.06630675798491,0.00590533842336387}, {-3.05874605274113,0.00613044553045804}, {-3.05118534749735,0.00636128449451701}, {-3.04362464225356,0.00659918744137605}, {-3.03606393700978,0.00684473368847976}, {-3.028503231766,0.00709631624886207}, {-3.02094252652222,0.00735399481310734}, {-3.01338182127844,0.00761917760277075}, {-3.00582111603465,0.00789245949627499}, {-2.99826041079087,0.00817212943888708}, {-2.99069970554709,0.00845824431148906}, {-2.98313900030331,0.0087522843004019}, {-2.97557829505952,0.00905485656666427}, {-2.96801758981574,0.0093641502113145}, {-2.96045688457196,0.00968021867012904}, {-2.95289617932818,0.0100046091305611}, {-2.94533547408440,0.0103379375180096}, {-2.93777476884061,0.0106782983734983}, {-2.93021406359683,0.0110257410398423}, {-2.92265335835305,0.0113818738655391}, {-2.91509265310927,0.0117473177341697}, {-2.90753194786549,0.0121200789568150}, {-2.89997124262170,0.0125002020988552}, {-2.89241053737792,0.0128893498712232}, {-2.88484983213414,0.0132881439518294}, {-2.87728912689036,0.0136945098192373}, {-2.86972842164657,0.0141084865130272}, {-2.86216771640279,0.0145317832283798}, {-2.85460701115901,0.0149650178325045}, {-2.84704630591523,0.0154060435041254}, {-2.83948560067145,0.0158548929183784}, {-2.83192489542766,0.0163133126425455}, {-2.82436419018388,0.0167819116017093}, {-2.8168034849401,0.0172584804613082}, {-2.80924277969632,0.0177430445823578}, {-2.80168207445253,0.0182373773831764}, {-2.79412136920875,0.0187420731173083}, {-2.78656066396497,0.0192548711434413}, {-2.77899995872119,0.0197757884377228}, {-2.77143925347741,0.0203066131637345}, {-2.76387854823362,0.0208479185354898}, {-2.75631784298984,0.021397405433033}, {-2.74875713774606,0.0219550812613246}, {-2.74119643250228,0.0225227350879649}, {-2.73363572725849,0.0231009120888729}, {-2.72607502201471,0.0236872893311379}, {-2.71851431677093,0.0242818633716451}, {-2.71095361152715,0.0248864085096922}, {-2.70339290628337,0.0255014343263722}, {-2.69583220103958,0.0261246107800795}, {-2.6882714957958,0.0267559222591293}, {-2.68071079055202,0.0273971107824608}, {-2.67315008530824,0.0280486423699534}, {-2.66558938006445,0.0287081987641887}, {-2.65802867482067,0.0293757508901456}, {-2.65046796957689,0.0300529892430326}, {-2.64290726433311,0.030740328135684}, {-2.63534655908933,0.0314354822360126}, {-2.62778585384554,0.0321384078262948}, {-2.62022514860176,0.0328507231536382}, {-2.61266444335798,0.0335727828082527}, {-2.60510373811420,0.0343023577028697}, {-2.59754303287041,0.0350393885184585}, {-2.58998232762663,0.0357853994567509}, {-2.58242162238285,0.0365406778781289}, {-2.57486091713907,0.0373030762041614}, {-2.56730021189529,0.0380725188905572}, {-2.55973950665150,0.0388504137930621}, {-2.55217880140772,0.0396369744699365}, {-2.54461809616394,0.0404301616375171}, {-2.53705739092016,0.0412298833501199}, {-2.52949668567638,0.042037409033771}, {-2.52193598043259,0.0428528732540257}, {-2.51437527518881,0.0436743727072183}, {-2.50681456994503,0.0445017994197593}, {-2.49925386470125,0.0453362633654725}, {-2.49169315945746,0.0461778167410019}, {-2.48413245421368,0.0470247199905447}, {-2.4765717489699,0.0478768501150486}, {-2.46901104372612,0.0487351386016853}, {-2.46145033848233,0.0495995540970413}, {-2.45388963323855,0.0504685476580447}, {-2.44632892799477,0.0513419829380178}, {-2.43876822275099,0.0522205968452911}, {-2.43120751750721,0.0531042757811722}, {-2.42364681226342,0.0539916862670499}, {-2.41608610701964,0.0548826809668041}, {-2.40852540177586,0.0557777899771459}, {-2.40096469653208,0.0566768214119159}, {-2.39340399128830,0.0575786789229621}, {-2.38584328604451,0.0584832071810472}, {-2.37828258080073,0.0593907219089491}, {-2.37072187555695,0.0603009595610157}, {-2.36316117031317,0.0612130782406032}, {-2.35560046506938,0.0621269181686223}, {-2.3480397598256,0.06304257843954}, {-2.34047905458182,0.0639597329983738}, {-2.33291834933804,0.0648778063141596}, {-2.32535764409426,0.0657966381105109}, {-2.31779693885047,0.0667161143115563}, {-2.31023623360669,0.0676358577107098}, {-2.30267552836291,0.068555564770273}, {-2.29511482311913,0.0694750789014017}, {-2.28755411787534,0.0703940821543497}, {-2.27999341263156,0.0713121592682435}, {-2.27243270738778,0.0722292774202367}, {-2.26487200214400,0.0731452879211188}, {-2.25731129690022,0.0740596839044779}, {-2.24975059165643,0.0749720262986846}, {-2.24218988641265,0.075882544515534}, {-2.23462918116887,0.0767911017865117}, {-2.22706847592509,0.0776970224626775}, {-2.21950777068130,0.0785998583734761}, {-2.21194706543752,0.0795000855526823}, {-2.20438636019374,0.0803975827680064}, {-2.19682565494996,0.0812915301321648}, {-2.18926494970618,0.0821814848439123}, {-2.18170424446239,0.0830681472626596}, {-2.17414353921861,0.083951414709355}, {-2.16658283397483,0.084830351010269}, {-2.15902212873105,0.0857045322681263}, {-2.15146142348726,0.0865748550000439}, {-2.14390071824348,0.0874412373440385}, {-2.1363400129997,0.0883026570308937}, {-2.12877930775592,0.0891587210563301}, {-2.12121860251214,0.0900104891842778}, {-2.11365789726835,0.0908579017782298}, {-2.10609719202457,0.0916998816538693}, {-2.09853648678079,0.0925360766598495}, {-2.09097578153701,0.0933676735233436}, {-2.08341507629322,0.0941946353464296}, {-2.07585437104944,0.0950158609631837}, {-2.06829366580566,0.0958310466913569}, {-2.06073296056188,0.0966414680797}, {-2.05317225531810,0.0974471106137493}, {-2.04561155007431,0.0982468787043815}, {-2.03805084483053,0.0990405222902694}, {-2.03049013958675,0.099829367289011}, {-2.02292943434297,0.100613420438770}, {-2.01536872909919,0.101391618976947}, {-2.00780802385540,0.102163769231698}, {-2.00024731861162,0.102931210188621}, {-1.99268661336784,0.103693968082361}, {-1.98512590812406,0.104451037248555}, {-1.97756520288027,0.105202281061335}, {-1.97000449763649,0.105949016693674}, {-1.96244379239271,0.106691287690215}, {-1.95488308714893,0.107428166419295}, {-1.94732238190515,0.108159572276773}, {-1.93976167666136,0.108886769142259}, {-1.93220097141758,0.109609815475352}, {-1.9246402661738,0.110327879242066}, {-1.91707956093002,0.111040933700529}, {-1.90951885568623,0.111750161978849}, {-1.90195815044245,0.112455635075783}, {-1.89439744519867,0.113156631030897}, {-1.88683673995489,0.113853174272102}, {-1.87927603471111,0.114546343970616}, {-1.87171532946732,0.11523622151986}, {-1.86415462422354,0.115922206967792}, {-1.85659391897976,0.116604373281515}, {-1.84903321373598,0.117283676561661}, {-1.84147250849219,0.117960206858709}, {-1.83391180324841,0.118633496366586}, {-1.82635109800463,0.119303664546788}, {-1.81879039276085,0.119971528893758}, {-1.81122968751707,0.120637186905850}, {-1.80366898227328,0.121300312110173}, {-1.7961082770295,0.121961069399164}, {-1.78854757178572,0.122620124910502}, {-1.78098686654194,0.123277582964447}, {-1.77342616129815,0.123933267503632}, {-1.76586545605437,0.124587388991550}, {-1.75830475081059,0.125240451272002}, {-1.75074404556681,0.125892565426080}, {-1.74318334032303,0.126543715526954}, {-1.73562263507924,0.127194158973916}, {-1.72806192983546,0.127844227162719}, {-1.72050122459168,0.128494038348378}, {-1.71294051934790,0.129143747613829}, {-1.70537981410411,0.129793661696017}, {-1.69781910886033,0.130443929208697}, {-1.69025840361655,0.131094676312777}, {-1.68269769837277,0.131746241390479}, {-1.67513699312899,0.132398983573413}, {-1.66757628788520,0.133052857406286}, {-1.66001558264142,0.13370799780147}, {-1.65245487739764,0.134364940048362}, {-1.64489417215386,0.135024098843935}, {-1.63733346691007,0.135685221944166}, {-1.62977276166629,0.136348453736690}, {-1.62221205642251,0.137014540895138}, {-1.61465135117873,0.137683956317962}, {-1.60709064593495,0.138356226710698}, {-1.59952994069116,0.139031506296405}, {-1.59196923544738,0.139710767689712}, {-1.5844085302036,0.140394543402831}, {-1.57684782495982,0.141082123587922}, {-1.56928711971603,0.141773672076658}, {-1.56172641447225,0.142470400984602}, {-1.55416570922847,0.143172901968712}, {-1.54660500398469,0.143880212593209}, {-1.53904429874091,0.144592505304060}, {-1.53148359349712,0.145311243002915}, {-1.52392288825334,0.146037073588245}, {-1.51636218300956,0.146768766544597}, {-1.50880147776578,0.14750650105359}, {-1.50124077252199,0.148251998445298}, {-1.49368006727821,0.149005957139454}, {-1.48611936203443,0.149766864947503}, {-1.47855865679065,0.150534904986421}, {-1.47099795154687,0.151312059683476}, {-1.46343724630308,0.152099069281498}, {-1.45587654105930,0.152894129743263}, {-1.44831583581552,0.153697424450022}, {-1.44075513057174,0.154511193460031}, {-1.43319442532795,0.155336207256645}, {-1.42563372008417,0.156170364739662}, {-1.41807301484039,0.157013845152537}, {-1.41051230959661,0.157869135715757}, {-1.40295160435283,0.158737023043336}, {-1.39539089910904,0.159615110135473}, {-1.38783019386526,0.160503567185768}, {-1.38026948862148,0.161405110636677}, {-1.37270878337770,0.162320527200764}, {-1.36514807813391,0.16324713266143}, {-1.35758737289013,0.164185083026939}, {-1.35002666764635,0.165137298553912}, {-1.34246596240257,0.166104548912041}, {-1.33490525715879,0.167083879606715}, {-1.32734455191500,0.168075427431526}, {-1.31978384667122,0.169082284094387}, {-1.31222314142744,0.170105184930414}, {-1.30466243618366,0.171140930592961}, {-1.29710173093988,0.172189634082732}, {-1.28954102569609,0.173254520253436}, {-1.28198032045231,0.174336273690445}, {-1.27441961520853,0.175431483774725}, {-1.26685890996475,0.176540235917031}, {-1.25929820472096,0.177665845327267}, {-1.25173749947718,0.178808931308733}, {-1.2441767942334,0.179965912793799}, {-1.23661608898962,0.181136844872093}, {-1.22905538374584,0.182325087643889}, {-1.22149467850205,0.18353118337621}, {-1.21393397325827,0.18475142717542}, {-1.20637326801449,0.185985842356357}, {-1.19881256277071,0.187237787792015}, {-1.19125185752692,0.188507720437019}, {-1.18369115228314,0.189791862101958}, {-1.17613044703936,0.191090204266850}, {-1.16856974179558,0.192406059889972}, {-1.16100903655180,0.193739796249973}, {-1.15344833130801,0.195087614096716}, {-1.14588762606423,0.196449474414613}, {-1.13832692082045,0.197828602957774}, {-1.13076621557667,0.199225276997723}, {-1.12320551033288,0.200635727817008}, {-1.11564480508910,0.202059888532223}, {-1.10808409984532,0.203500861484899}, {-1.10052339460154,0.204958837423422}, {-1.09296268935776,0.206430126813204}, {-1.08540198411397,0.207914638596601}, {-1.07784127887019,0.209415321819752}, {-1.07028057362641,0.210932287459397}, {-1.06271986838263,0.212461968807072}, {-1.05515916313884,0.214004255069655}, {-1.04759845789506,0.215561919123813}, {-1.04003775265128,0.217135001352417}, {-1.03247704740750,0.218720094864573}, {-1.02491634216372,0.220317073920582}, {-1.01735563691993,0.221928519404037}, {-1.00979493167615,0.223554411637730}, {-1.00223422643237,0.225191532814101}, {-0.994673521188587,0.226839746947358}, {-0.987112815944805,0.228501433527144}, {-0.979552110701023,0.230176523494005}, {-0.97199140545724,0.231862009270319}, {-0.964430700213458,0.233557748790115}, {-0.956869994969676,0.235265915902052}, {-0.949309289725893,0.236986401736020}, {-0.941748584482112,0.238716422313794}, {-0.93418787923833,0.24045583270495}, {-0.926627173994547,0.242206600198836}, {-0.919066468750765,0.243968583402074}, {-0.911505763506983,0.245739228599878}, {-0.9039450582632,0.247518389914812}, {-0.896384353019418,0.249307828242503}, {-0.888823647775636,0.251107373672340}, {-0.881262942531854,0.252914704444423}, {-0.873702237288072,0.254729674105693}, {-0.86614153204429,0.256553835921998}, {-0.858580826800507,0.258386991470606}, {-0.851020121556725,0.260227049931404}, {-0.843459416312943,0.262073862979209}, {-0.83589871106916,0.263928771094027}, {-0.828338005825378,0.265791542979533}, {-0.820777300581596,0.267660317654495}, {-0.813216595337814,0.269534941977468}, {-0.805655890094032,0.271416532236315}, {-0.79809518485025,0.273304815570041}, {-0.790534479606467,0.275198162409053}, {-0.782973774362685,0.277096410371137}, {-0.775413069118903,0.279000431969760}, {-0.76785236387512,0.280909900214380}, {-0.760291658631338,0.282823423854812}, {-0.752730953387556,0.284740825670687}, {-0.745170248143774,0.286662705315601}, {-0.737609542899992,0.288588666086856}, {-0.73004883765621,0.290517569620887}, {-0.722488132412427,0.292449217518124}, {-0.714927427168645,0.294383897409986}, {-0.707366721924863,0.296321125485087}, {-0.699806016681081,0.29826004025906}, {-0.692245311437298,0.300200415590624}, {-0.684684606193517,0.302142178132763}, {-0.677123900949734,0.304084739223377}, {-0.669563195705952,0.306027548696986}, {-0.66200249046217,0.307970346464674}, {-0.654441785218387,0.309912640630769}, {-0.646881079974605,0.311853721220709}, {-0.639320374730823,0.313793394418073}, {-0.631759669487041,0.315731360928363}, {-0.624198964243259,0.317666646173536}, {-0.616638258999477,0.319598405344861}, {-0.609077553755694,0.321526855790233}, {-0.601516848511912,0.323451655259501}, {-0.59395614326813,0.325371278622268}, {-0.586395438024348,0.327284737218129}, {-0.578834732780566,0.329192722405825}, {-0.571274027536783,0.331094847222237}, {-0.563713322293001,0.332988967826907}, {-0.556152617049219,0.334873948537394}, {-0.548591911805437,0.336751022971801}, {-0.541031206561654,0.338619760060453}, {-0.533470501317872,0.340477332670328}, {-0.52590979607409,0.342322461783978}, {-0.518349090830308,0.344156993566102}, {-0.510788385586526,0.345980456036531}, {-0.503227680342743,0.347789281795655}, {-0.495666975098961,0.349582059624668}, {-0.488106269855179,0.351361316664300}, {-0.480545564611397,0.353126545869542}, {-0.472984859367615,0.35487339414856}, {-0.465424154123832,0.356600336771722}, {-0.45786344888005,0.358310644243633}, {-0.450302743636268,0.360003782834669}, {-0.442742038392486,0.361674583465764}, {-0.435181333148703,0.363321433752531}, {-0.427620627904922,0.364948399712128}, {-0.420059922661139,0.366554931558902}, {-0.412499217417357,0.368135032041282}, {-0.404938512173575,0.369687033263438}, {-0.397377806929792,0.371215834734518}, {-0.38981710168601,0.372720883048705}, {-0.382256396442228,0.374195360873752}, {-0.374695691198446,0.375637581918917}, {-0.367134985954664,0.377053299601263}, {-0.359574280710881,0.37844197056974}, {-0.352013575467099,0.379795986979845}, {-0.344452870223317,0.381113684569770}, {-0.336892164979535,0.382401670894201}, {-0.329331459735753,0.383659426912605}, {-0.321770754491971,0.384878605452634}, {-0.314210049248188,0.386057606105093}, {-0.306649344004406,0.387203868940326}, {-0.299088638760624,0.388316913360332}, {-0.291527933516841,0.389387724723272}, {-0.283967228273059,0.390414807675143}, {-0.276406523029277,0.391406390742259}, {-0.268845817785495,0.392362045073579}, {-0.261285112541713,0.393272179117498}, {-0.253724407297931,0.394135441158424}, {-0.246163702054148,0.394960782224258}, {-0.238602996810366,0.39574783703143}, {-0.231042291566584,0.396486543495802}, {-0.223481586322802,0.397175727662062}, {-0.215920881079020,0.397824976856595}, {-0.208360175835237,0.398433999134126}, {-0.200799470591455,0.398992380455931}, {-0.193238765347673,0.399499152722530}, {-0.185678060103891,0.399964435756343}, {-0.178117354860109,0.400388018232339}, {-0.170556649616326,0.400759260810078}, {-0.162995944372544,0.401077422125872}, {-0.155435239128762,0.401353036584060}, {-0.147874533884980,0.401585977986703}, {-0.140313828641197,0.401765512037096}, {-0.132753123397415,0.401891137027391}, {-0.125192418153633,0.401973674026209}, {-0.117631712909851,0.402013083575993}, {-0.110071007666069,0.401998666084972}, {-0.102510302422286,0.401930164196775}, {-0.0949495971785042,0.40181855219796}, {-0.0873888919347219,0.40166387614263}, {-0.0798281866909396,0.401455596001804}, {-0.0722674814471578,0.401193695455676}, {-0.0647067762033755,0.400889167604399}, {-0.0571460709595932,0.400542140154468}, {-0.049585365715811,0.400142349056934}, {-0.0420246604720287,0.399690008358467}, {-0.0344639552282464,0.399195999009783}, {-0.0269032499844646,0.398660524229713}, {-0.0193425447406823,0.398073700950983}, {-0.0117818394969000,0.39743595659013}, {-0.00422113425311776,0.396757936409963}, {0.00333957099066451,0.396039911178041}, {0.0109002762344468,0.395272470207065}, {0.0184609814782291,0.394456232269218}, {0.0260216867220109,0.393601494188067}, {0.0335823919657932,0.392708585019926}, {0.0411430972095754,0.391768642914679}, {0.0487038024533577,0.390782452448145}, {0.05626450769714,0.389759862631139}, {0.0638252129409222,0.388701250808713}, {0.0713859181847045,0.387598364995277}, {0.0789466234284864,0.386452128015267}, {0.0865073286722686,0.385271856800910}, {0.094068033916051,0.384057966790686}, {0.101628739159833,0.382802861760200}, {0.109189444403615,0.381507574701673}, {0.116750149647398,0.380180822156311}, {0.12431085489118,0.378823047761313}, {0.131871560134962,0.377427342794365}, {0.139432265378744,0.375994823128606}, {0.146992970622526,0.374533552556996}, {0.154553675866309,0.373043993737541}, {0.162114381110091,0.371519944534745}, {0.169675086353873,0.369962578292754}, {0.177235791597655,0.368379268908681}, {0.184796496841437,0.366770489914515}, {0.192357202085220,0.365130754040038}, {0.199917907329002,0.363461269360504}, {0.207478612572784,0.361768696587334}, {0.215039317816566,0.360053513210986}, {0.222600023060349,0.35831094631726}, {0.230160728304130,0.356542219121518}, {0.237721433547913,0.354753267930324}, {0.245282138791695,0.352944568592814}, {0.252842844035477,0.351112055268261}, {0.260403549279260,0.349256950039643}, {0.267964254523042,0.347384463622397}, {0.275524959766824,0.345495065917015}, {0.283085665010606,0.343585385960709}, {0.290646370254388,0.341656631641609}, {0.298207075498170,0.33971329482365}, {0.305767780741953,0.337755836329400}, {0.313328485985735,0.335781564555272}, {0.320889191229517,0.333791663007923}, {0.328449896473300,0.331789917352512}, {0.336010601717081,0.329776777199559}, {0.343571306960864,0.327750212706021}, {0.351132012204646,0.325711375193134}, {0.358692717448428,0.323663360907649}, {0.366253422692211,0.321606606883941}, {0.373814127935993,0.319539726224537}, {0.381374833179775,0.317463832065052}, {0.388935538423557,0.315381350678187}, {0.396496243667340,0.313292705687613}, {0.404056948911122,0.311197133601594}, {0.411617654154903,0.309095704580799}, {0.419178359398686,0.30699019594205}, {0.426739064642468,0.304881017362388}, {0.43429976988625,0.302768008652702}, {0.441860475130032,0.300652192876704}, {0.449421180373815,0.298534720280068}, {0.456981885617597,0.296415986155199}, {0.464542590861379,0.294296412849017}, {0.472103296105161,0.292176972428353}, {0.479664001348944,0.290058210466450}, {0.487224706592726,0.287940507375094}, {0.494785411836508,0.285824846328349}, {0.50234611708029,0.283712144402519}, {0.509906822324072,0.281602365355236}, {0.517467527567854,0.279495874060361}, {0.525028232811636,0.277394191497444}, {0.532588938055419,0.275298175490295}, {0.540149643299201,0.273207231459074}, {0.547710348542983,0.271121707871123}, {0.555271053786766,0.269043638795007}, {0.562831759030548,0.266973818231774}, {0.57039246427433,0.264911117659918}, {0.577953169518112,0.262855868058238}, {0.585513874761895,0.260810589844233}, {0.593074580005677,0.258776008390135}, {0.600635285249459,0.256750486892201}, {0.608195990493241,0.254734337580467}, {0.615756695737023,0.252730538225534}, {0.623317400980805,0.250739740680866}, {0.630878106224587,0.248759827107439}, {0.63843881146837,0.246791089607094}, {0.645999516712152,0.244836931935824}, {0.653560221955934,0.242897927647059}, {0.661120927199716,0.240971506949969}, {0.668681632443499,0.23905794038751}, {0.676242337687281,0.237161023957273}, {0.683803042931063,0.235281248434681}, {0.691363748174846,0.233415623141119}, {0.698924453418628,0.23156439564172}, {0.70648515866241,0.229731718139511}, {0.714045863906192,0.227917994620422}, {0.721606569149974,0.226119846595186}, {0.729167274393756,0.224337497290666}, {0.736727979637538,0.222575416920465}, {0.74428868488132,0.220833919243813}, {0.751849390125103,0.219109272986794}, {0.759410095368885,0.217401675759177}, {0.766970800612667,0.215715875570742}, {0.77453150585645,0.214052093131547}, {0.782092211100232,0.21240628122791}, {0.789652916344014,0.210778610652084}, {0.797213621587797,0.209174065077888}, {0.804774326831579,0.207592769932777}, {0.812335032075361,0.206030400571894}, {0.819895737319142,0.204487099820656}, {0.827456442562925,0.202968042997641}, {0.835017147806707,0.201473258525017}, {0.84257785305049,0.199998184361416}, {0.850138558294272,0.198542934222342}, {0.857699263538054,0.197112829105758}, {0.865259968781836,0.195707799109353}, {0.872820674025618,0.194323086273034}, {0.8803813792694,0.192958774013279}, {0.887942084513183,0.191620280948582}, {0.895502789756965,0.190307437830542}, {0.903063495000747,0.189015333698135}, {0.91062420024453,0.187744020386143}, {0.918184905488311,0.186498963767988}, {0.925745610732093,0.185279894453213}, {0.933306315975876,0.184081792922674}, {0.940867021219658,0.182904678023269}, {0.94842772646344,0.181754009974772}, {0.955988431707222,0.18062941866696}, {0.963549136951005,0.179525822152297}, {0.971109842194787,0.178443204759473}, {0.97867054743857,0.177386965403828}, {0.986231252682352,0.176356632977342}, {0.993791957926134,0.175347111128609}, {1.00135266316992,0.174358348051606}, {1.00891336841370,0.173395622873446}, {1.01647407365748,0.172458363694536}, {1.02403477890126,0.171541509884478}, {1.03159548414504,0.170644971881926}, {1.03915618938883,0.169773847802227}, {1.04671689463261,0.168927465934522}, {1.05427759987639,0.168100853736607}, {1.06183830512017,0.167293882394201}, {1.06939901036396,0.166511405396817}, {1.07695971560774,0.165752653360293}, {1.08452042085152,0.165012796450298}, {1.09208112609530,0.164291665393139}, {1.09964183133908,0.163593803712788}, {1.10720253658287,0.162918348099920}, {1.11476324182665,0.162260668110915}, {1.12232394707043,0.161620553297492}, {1.12988465231421,0.161002171173412}, {1.13744535755800,0.160404570347287}, {1.14500606280178,0.159823378063550}, {1.15256676804556,0.159258342694266}, {1.16012747328934,0.158713190383826}, {1.16768817853312,0.158186890068208}, {1.17524888377691,0.157675385839104}, {1.18280958902069,0.157178385814610}, {1.19037029426447,0.156699111839922}, {1.19793099950825,0.156236464560918}, {1.20549170475204,0.155786763857946}, {1.21305240999582,0.155349679654960}, {1.2206131152396,0.154927871045544}, {1.22817382048338,0.154520185031222}, {1.23573452572716,0.154123374600964}, {1.24329523097095,0.153737074844856}, {1.25085593621473,0.15336333040109}, {1.25841664145851,0.153000952660689}, {1.26597734670229,0.152647181724214}, {1.27353805194608,0.152301622619031}, {1.28109875718986,0.151965662956958}, {1.28865946243364,0.151638099860056}, {1.29622016767742,0.151316709300263}, {1.30378087292120,0.151001072462349}, {1.31134157816499,0.15069188885753}, {1.31890228340877,0.150387965674601}, {1.32646298865255,0.150087656205275}, {1.33402369389633,0.149790525414363}, {1.34158439914011,0.149496567330276}, {1.34914510438390,0.149204625980074}, {1.35670580962768,0.148913664013442}, {1.36426651487146,0.148623239062365}, {1.37182722011524,0.14833263785528}, {1.37938792535903,0.148040769668191}, {1.38694863060281,0.147747227135102}, {1.39450933584659,0.147451570476504}, {1.40207004109037,0.147152394271614}, {1.40963074633416,0.146848702085947}, {1.41719145157794,0.146540723983466}, {1.42475215682172,0.146228033412290}, {1.4323128620655,0.145908565723049}, {1.43987356730928,0.145581447264002}, {1.44743427255307,0.145247538392034}, {1.45499497779685,0.144906436750145}, {1.46255568304063,0.144555469249229}, {1.47011638828441,0.144193911682311}, {1.47767709352819,0.143823232066793}, {1.48523779877198,0.143443063092253}, {1.49279850401576,0.143050191216353}, {1.50035920925954,0.142644065191785}, {1.50791991450332,0.142226722246020}, {1.51548061974711,0.141797840378096}, {1.52304132499089,0.141353749316656}, {1.53060203023467,0.140894089876784}, {1.53816273547845,0.140421414565164}, {1.54572344072223,0.139935455889683}, {1.55328414596602,0.139432184091074}, {1.5608448512098,0.138911445608537}, {1.56840555645358,0.138376239847287}, {1.57596626169736,0.137826361513783}, {1.58352696694115,0.137257529215481}, {1.59108767218493,0.136669802125172}, {1.59864837742871,0.136066545429905}, {1.60620908267249,0.135447621826629}, {1.61376978791627,0.134808613296816}, {1.62133049316006,0.134149791781099}, {1.62889119840384,0.133474796739008}, {1.63645190364762,0.132783562448760}, {1.64401260889140,0.132071652572502}, {1.65157331413519,0.131339544497083}, {1.65913401937897,0.130591052929204}, {1.66669472462275,0.129826184921417}, {1.67425542986653,0.129040603371693}, {1.68181613511031,0.128234976529586}, {1.68937684035410,0.127413191084056}, {1.69693754559788,0.126575325582715}, {1.70449825084166,0.125717254926292}, {1.71205895608544,0.124839816857473}, {1.71961966132923,0.123946866055839}, {1.72718036657301,0.123038548866697}, {1.73474107181679,0.122111056363902}, {1.74230177706057,0.121165368465796}, {1.74986248230435,0.120205206691547}, {1.75742318754814,0.119230779249992}, {1.76498389279192,0.118238685583144}, {1.7725445980357,0.117230015674713}, {1.78010530327948,0.116208263006397}, {1.78766600852327,0.115173689776961}, {1.79522671376705,0.114123381241165}, {1.80278741901083,0.113058501948557}, {1.81034812425461,0.111982231858003}, {1.81790882949839,0.110894877739470}, {1.82546953474218,0.109794071317444}, {1.83303023998596,0.108681014384075}, {1.84059094522974,0.107558499921891}, {1.84815165047352,0.106426868773494}, {1.85571235571730,0.105284341788379}, {1.86327306096109,0.104132120483839}, {1.87083376620487,0.102972551476449}, {1.87839447144865,0.101805998608483}, {1.88595517669243,0.100631296147493}, {1.89351588193622,0.099449609215916}, {1.90107658718,0.0982627940723792}, {1.90863729242378,0.0970712264239703}, {1.91619799766756,0.0958743603548584}, {1.92375870291135,0.0946732913263025}, {1.93131940815513,0.0934693572364618}, {1.93888011339891,0.0922629349471626}, {1.94644081864269,0.0910540880815875}, {1.95400152388647,0.0898438132623412}, {1.96156222913026,0.0886329178689882}, {1.96912293437404,0.0874217700637633}, {1.97668363961782,0.0862110179014726}, {1.98424434486160,0.0850015350243557}, {1.99180505010538,0.083793601149747}, {1.99936575534917,0.0825875670922213}, {2.00692646059295,0.081384627719036}, {2.01448716583673,0.0801855152011223}, {2.02204787108051,0.0789899980433457}, {2.02960857632430,0.0777984025232759}, {2.03716928156808,0.0766124228023776}, {2.04472998681186,0.0754326370057365}, {2.05229069205564,0.0742583305832918}, {2.05985139729942,0.0730897996900016}, {2.06741210254321,0.0719291830888045}, {2.07497280778699,0.0707768981263305}, {2.08253351303077,0.0696317848614469}, {2.09009421827455,0.068494105381492}, {2.09765492351834,0.0673663838457799}, {2.10521562876212,0.0662488755512352}, {2.1127763340059,0.0651400199767838}, {2.12033703924968,0.064040042774047}, {2.12789774449347,0.0629517922281261}, {2.13545844973725,0.0618753651444945}, {2.14301915498103,0.0608088500192331}, {2.15057986022481,0.0597524351276912}, {2.15814056546859,0.0587092316555892}, {2.16570127071238,0.057679185491399}, {2.17326197595616,0.056660086308387}, {2.18082268119994,0.0556520852780381}, {2.18838338644372,0.0546584970004135}, {2.19594409168750,0.0536791271209957}, {2.20350479693129,0.0527115192443815}, {2.21106550217507,0.0517557886677525}, {2.21862620741885,0.0508153968953265}, {2.22618691266263,0.049890022162408}, {2.23374761790642,0.0489770137226662}, {2.24130832315020,0.0480764529138929}, {2.24886902839398,0.0471918953945683}, {2.25642973363776,0.0463229060899123}, {2.26399043888154,0.0454666893399793}, {2.27155114412533,0.0446232948598419}, {2.27911184936911,0.0437963238449871}, {2.28667255461289,0.0429852424971999}, {2.29423325985667,0.0421871565538598}, {2.30179396510046,0.0414020866314847}, {2.30935467034424,0.0406336350102257}, {2.31691537558802,0.0398811836168895}, {2.32447608083180,0.0391417823003781}, {2.33203678607558,0.0384154251017936}, {2.33959749131937,0.0377056748836205}, {2.34715819656315,0.0370118431652022}, {2.35471890180693,0.0363309628783718}, {2.36227960705071,0.0356630038787137}, {2.36984031229450,0.0350114526999374}, {2.37740101753828,0.034375563485826}, {2.38496172278206,0.033752387585476}, {2.39252242802584,0.0331418728539251}, {2.40008313326962,0.0325473957763169}, {2.40764383851341,0.0319681652377724}, {2.41520454375719,0.0314012829743427}, {2.42276524900097,0.0308466768073603}, {2.43032595424475,0.0303075822961192}, {2.43788665948854,0.0297831743359888}, {2.44544736473232,0.0292706340058911}, {2.4530080699761,0.0287698708798243}, {2.46056877521988,0.0282839513320332}, {2.46812948046366,0.0278120268616684}, {2.47569018570745,0.0273513841792482}, {2.48325089095123,0.0269019162937811}, {2.49081159619501,0.0264664947017255}, {2.49837230143879,0.0260442576545995}, {2.50593300668258,0.0256326213888178}, {2.51349371192636,0.0252314640268892}, {2.52105441717014,0.0248434392027495}, {2.52861512241392,0.0244676818627685}, {2.53617582765770,0.0241017594175053}, {2.54373653290149,0.0237455368851300}, {2.55129723814527,0.0234014300870287}, {2.55885794338905,0.0230685806021716}, {2.56641864863283,0.0227447264133698}, {2.57397935387661,0.0224297214191356}, {2.5815400591204,0.0221257271910263}, {2.58910076436418,0.0218319019995903}, {2.59666146960796,0.0215461713868974}, {2.60422217485174,0.0212683803950251}, {2.61178288009553,0.0210004239956754}, {2.61934358533931,0.0207414873552440}, {2.62690429058309,0.0204896978511418}, {2.63446499582687,0.0202448942529709}, {2.64202570107066,0.0200086972715202}, {2.64958640631444,0.0197803292277643}, {2.65714711155822,0.0195581304980745}, {2.664707816802,0.0193419364856806}, {2.67226852204578,0.0191330912213159}, {2.67982922728957,0.0189308642892444}, {2.68738993253335,0.0187338166640153}, {2.69495063777713,0.0185417835689040}, {2.70251134302091,0.0183558356068293}, {2.71007204826469,0.0181752992805929}, {2.71763275350848,0.0179989597548628}, {2.72519345875226,0.0178266554567131}, {2.73275416399604,0.0176591927249301}, {2.74031486923982,0.0174959638064153}, {2.74787557448361,0.0173359772679138}, {2.75543627972739,0.0171790782034842}, {2.76299698497117,0.0170258237627884}, {2.77055769021495,0.0168756795183195}, {2.77811839545873,0.0167278720247694}, {2.78567910070252,0.0165822564425778}, {2.7932398059463,0.0164391614474829}, {2.80080051119008,0.0162981318618355}, {2.80836121643386,0.0161586021147124}, {2.81592192167765,0.0160204406119605}, {2.82348262692143,0.0158837733604324}, {2.83104333216521,0.0157482283276085}, {2.83860403740899,0.0156134331349132}, {2.84616474265277,0.01547927223544}, {2.85372544789656,0.0153456990474725}, {2.86128615314034,0.0152124262565625}, {2.86884685838412,0.0150792557753085}, {2.8764075636279,0.0149460903846994}, {2.88396826887169,0.0148127442280041}, {2.89152897411547,0.0146790137750437}, {2.89908967935925,0.0145448526725288}, {2.90665038460303,0.0144101836694301}, {2.91421108984681,0.0142747169662971}, {2.92177179509060,0.0141383293224304}, {2.92933250033438,0.0140011006604580}, {2.93689320557816,0.0138629746116942}, {2.94445391082194,0.0137235934665508}, {2.95201461606573,0.0135829083042216}, {2.95957532130951,0.0134410978720665}, {2.96713602655329,0.0132981268280292}, {2.97469673179707,0.0131536049389711}, {2.98225743704085,0.0130075493848639}, {2.98981814228464,0.0128602093047930}, {2.99737884752842,0.0127115697571842}, {3.0049395527722,0.0125612414293908}, {3.01250025801598,0.0124092974852769}, {3.02006096325977,0.0122560290968595}, {3.02762166850355,0.0121014403697388}, {3.03518237374733,0.0119451732393551}, {3.04274307899111,0.0117873452946599}, {3.05030378423489,0.0116282624958192}, {3.05786448947868,0.0114679459983317}, {3.06542519472246,0.0113060952085125}, {3.07298589996624,0.0111428596695963}, {3.08054660521002,0.0109785349635593}, {3.08810731045380,0.0108131567710850}, {3.09566801569759,0.0106465033331107}, {3.10322872094137,0.0104787433334528}, {3.11078942618515,0.0103101397243974}, {3.11835013142893,0.0101407398007597}, {3.12591083667272,0.0099704166540839}, {3.1334715419165,0.0097993455237231}, {3.14103224716028,0.00962773806147656}, {3.14859295240406,0.0094556500344366}, {3.15615365764785,0.00928305984260413}, {3.16371436289163,0.00911013746293973}, {3.17127506813541,0.00893702862234691}, {3.17883577337919,0.00876379434692584}, {3.18639647862297,0.00859052330731963}, {3.19395718386676,0.00841736964100953}, {3.20151788911054,0.00824440282217266}, {3.20907859435432,0.00807168600426268}, {3.2166392995981,0.00789941790817212}, {3.22420000484188,0.00772772787916289}, {3.23176071008567,0.00755660314137539}, {3.23932141532945,0.00738610606320186}, {3.24688212057323,0.00721654054035873}, {3.25444282581701,0.00704800407298923}, {3.26200353106080,0.00688039979900197}, {3.26956423630458,0.0067137867234798}, {3.27712494154836,0.00654856508204593}, {3.28468564679214,0.00638479553488995}, {3.29224635203592,0.00622229911048945}, {3.29980705727971,0.00606112929364078}, {3.30736776252349,0.00590177067633363}, {3.31492846776727,0.005744244182297}, {3.32248917301105,0.00558829402725601}, {3.33004987825484,0.00543396649652436}, {3.33761058349862,0.00528181627779264}, {3.3451712887424,0.00513182368969265}, {3.35273199398618,0.0049836641533109}, {3.36029269922996,0.00483737557854945}, {3.36785340447375,0.00469356709033004}, {3.37541410971753,0.00455217939417575}, {3.38297481496131,0.00441282919467583}, {3.39053552020509,0.00427554534982309}, {3.39809622544888,0.00414097520508721}, {3.40565693069266,0.00400902246044959}, {3.41321763593644,0.00387925655968321}, {3.42077834118022,0.00375169710212863}, {3.42833904642400,0.00362701363907215}, {3.43589975166779,0.00350507678739493}, {3.44346045691157,0.00338542089833914}, {3.45102116215535,0.00326805652488716}, {3.45858186739913,0.00315366026197492}, {3.46614257264291,0.00304207454771810}, {3.4737032778867,0.00293281090747249}, {3.48126398313048,0.00282587141304728}, {3.48882468837426,0.00272192591473505}, {3.49638539361804,0.00262079421564806}, {3.50394609886183,0.00252197684278728}, {3.51150680410561,0.00242546822920206}, {3.51906750934939,0.00233191944869099}, {3.52662821459317,0.0022411335212608}, {3.53418891983696,0.00215261092144909}, {3.54174962508074,0.00206633948375318}, {3.54931033032452,0.00198294147397495}, {3.5568710355683,0.00190220898625523}, {3.56443174081208,0.00182365216943572}, {3.57199244605587,0.00174725341944600}, {3.57955315129965,0.00167359827639237}, {3.58711385654343,0.00160247351004755}, {3.59467456178721,0.00153340722122771}, {3.60223526703099,0.00146637757478936}, {3.60979597227478,0.00140192757884893}, {3.61735667751856,0.00133984381392893}, {3.62491738276234,0.00127967903470887}, {3.63247808800612,0.00122140836676563}, {3.64003879324991,0.00116552849210347}, {3.64759949849369,0.00111183031484109}, {3.65516020373747,0.00105989633659604}, {3.66272090898125,0.00100969976779648}, {3.67028161422503,0.000961689007820388}, {3.67784231946882,0.000915663074037193}, {3.6854030247126,0.000871237746310519}, {3.69296372995638,0.00082838533678739}, {3.70052443520016,0.000787505615590411}, {3.70808514044395,0.000748408730628983}, {3.71564584568773,0.000710745820690382}, {3.72320655093151,0.000674489182134912}, {3.73076725617529,0.00063999095950488}, {3.73832796141907,0.000607074672849458}, {3.74588866666286,0.000575427608185565}, {3.75344937190664,0.000545022778898958}, {3.76101007715042,0.000516166785712138}, {3.76857078239420,0.000488698021536035}, {3.77613148763799,0.000462339604252785}, {3.78369219288177,0.000437065842581069}, {3.79125289812555,0.000413140684715879}, {3.79881360336933,0.000390418220528312}, {3.80637430861311,0.000368656184501062}, {3.8139350138569,0.000347830608421776}, {3.82149571910068,0.000328166236801298}, {3.82905642434446,0.000309533088739456}, {3.83661712958824,0.000291721605665412}, {3.84417783483203,0.00027470983034202}, {3.85173854007581,0.000258687083951333}, {3.85929924531959,0.000243539052118132}, {3.86685995056337,0.000229086475599564}, {3.87442065580715,0.000215309571774067}, {3.88198136105094,0.000202366156226174}, {3.88954206629472,0.000190156924790497}, {3.8971027715385,0.000178530191175386}, {3.90466347678228,0.000167468405256003}, {3.91222418202607,0.000157101772786925}, {3.91978488726985,0.000147345049429180}, {3.92734559251363,0.000138071233220770}, {3.93490629775741,0.00012926497843907}};




@
\subsection{Ltree.hh}
Class [[Ltree]] is the key class for a sample of population tree that are
summarized by a list of genealogies underlying the population tree.  The class
is somewhat simpler than we could thought it to be.  The two main methods are
the constructors and computes.  The main constructor takes [[Ptree]] to build a
[[Ltree]].  We use [[Ptree]] to read in all of the gweights and integrates and
copy those to [[_ledge]].  Note that [[_ledge]]'s setEp links [[EdgeIMParameter]]
of [[Ptree]] to one in [[Ltree]].  This allows [[Ledge]] to look up the current
values of demographic parameters.  As we have two version of [[compute]] method
in [[Lmode]], we have the same kind of [[compute]] methods for [[Ltree]].
<<Ltree.hh>>=
<<im3 copyright>>
#ifndef _LTREE_HH_
#define _LTREE_HH_
#include <iostream>
#include <vector>
#include "Ptree.hh"
#include "EdgeIMParameter.hh"
#include "Ledge.hh"

using std::vector;

class Ltree {
  friend std::ostream& operator<<(std::ostream& os, const Ltree& lt);
  vector<Ledge> _ledge;
  double _v;
  double _vhold;
public:
  Ltree (Ptree &ptree);
  Ltree (const Ltree &r) : _ledge (r._ledge), _v (r._v), _vhold (r._vhold) {}
  Ltree& operator=(const Ltree &r)
  {
    if (&r != this)
      {
        _ledge = r._ledge;
        _v = r._v;
        _vhold = r._vhold;
      }
    return *this;
  }

  double compute ()
  {
    int j = 0;
    _v = .0L;
    for (vector<Ledge>::iterator i = _ledge.begin();
         i != _ledge.end();
         i++, j++)
      {
        _v += i->compute ();
      }
    return _v;
  }

  double compute (const int pi, const int qi)
  {
    _vhold = _v;
    _v += _ledge[pi].compute (qi); // Difference is added.
    return _v;
  }

  double computeMarginal (const int pi, const int qi)
  {
    return _ledge[pi].computeMarginal (qi);
  }

  void revert (const int pi, const int qi)
  {
    _v = _vhold;
    _ledge[pi].revert (qi);
  }
};
#endif /* _LTREE_HH_ */

<<Ltree.cc>>=
<<im3 copyright>>
#include <vector>
#include "Ledge.hh"
#include "Ltree.hh"
#include "Ptree.hh"
#include "Pedge.hh"

using std::vector;

Ltree::Ltree (Ptree &p)
{
  int np = p.getNp ();
  int ngtree = p.getNgtree ();

  _ledge.resize (np);
  for (int i = 0; i < np; i++)
    {
      _ledge[i].initialize (np);
      _ledge[i].setCc (p.PtreeGetGweightCc (i, ngtree));
      _ledge[i].setHcc (p.PtreeGetGweightHcc (i, ngtree));
      _ledge[i].setFc (p.PtreeGetGweightFc (i, ngtree));
      _ledge[i].setQI (p.getIntegrateQ (i));
      _ledge[i].setEp (p.getEp(i));
      
      for (int j = 0; j < np; j++)
        {
          if (p.PtreeNoMigrateTo (i, j))
            continue;
          _ledge[i].setMc (j, p.PtreeGetGweightMc (i, j, ngtree));
          _ledge[i].setFm (j, p.PtreeGetGweightFm (i, j, ngtree));
          _ledge[i].setMI (j, p.getIntegrateM (i, j));
        }
    }
}

<<Ltree-t.cc>>=
#include <iostream>
#include <vector>
#include "imdef.h"
#include "imenum.h"
#define GLOBVARS
#include "imglobal.h"
#include "imtools.h"
#include "Ltree.hh"
#include "Ptree.hh"

using std::vector;

int main (int argc, char* argv[])
{
  double v;

  Ptree t;
  t.Initialize (5, 1, -1, "(2,((3,4):6,(0,1):5):7):8;"); // 40
  t.setGweightT (0, 2, 2.5L, 3.5L);
  t.setGweightT (1, 2, 2.5L, 3.5L);
  t.setGweightT (2, 2, 2.5L, 3.5L);
  t.setGweightT (3, 2, 2.5L, 3.5L);
  t.setGweightT (4, 2, 2.5L, 3.5L);
  t.setGweightT (5, 2, 2.5L, 3.5L);
  t.setGweightT (6, 2, 2.5L, 3.5L);
  t.setGweightT (7, 2, 2.5L, 3.5L);
  t.setGweightT (8, 2, 2.5L, 3.5L);
  t.setGweightM (0, 1, 1, 1.5L);
  t.setGweightM (0, 2, 1, 1.5L);
  t.setGweightM (0, 3, 1, 1.5L);
  t.setGweightM (0, 4, 1, 1.5L);
  t.setGweightM (1, 0, 1, 1.5L);
  t.setGweightM (1, 2, 1, 1.5L);
  t.setGweightM (1, 3, 1, 1.5L);
  t.setGweightM (1, 4, 1, 1.5L);

  t.setPriorQ (3.0L);
  t.setPriorM (.5L);

  Ltree lt(t);
  
  v = lt.compute ();
  std::cout << "v: " << v << std::endl; 
  return 0; 
}

@
\subsection{Ledge.hh}
Class [[Ledge]] has the detailed function for $\pi(\theta|G)$.  Members [[_cc]],
[[_hcc]], [[_fc]], [[_mc]], [[_fm]] are called gweights, and [[_qI]] and [[_mI]]
are called integrates.  [[_q]] and [[_m]] are the computed values
$\pi(\theta|G)$ for the corresponding demographics.  Important!  Method
[[revert]] only does for its value, or [[_q]] or [[_m]].  We separately call
[[revert]] for the popultion tree, and we must not call [[_ep]]'s revert.  We
already called it [[Lmode]]'s revert.  Anoter important!! Method [[computeMi]]
must be called for a valid population migration.  When a particular migration
rate is not allowed, the parameter value must have been set to a negative value.
[[computeMi]] returns 0.

<<Ledge.hh>>=
<<im3 copyright>>
#ifndef _LEDGE_HH_
#define _LEDGE_HH_
#include <iostream>
#include <cmath>
#include <cassert>
#include "imdef.h"
#include "EdgeIMParameter.hh"
#include "IMParameter.hh"
#include "Ledge.hh"

class Ledge {
  friend std::ostream& operator<<(std::ostream& os, const Ledge& lg);
  int _cc;
  double _hcc;
  double _fc;
  vector<int> _mc;
  vector<double> _fm;
  double _qI;
  vector<double> _mI;
  double _q;
  vector<double> _m;
  double _qhold;
  vector<double> _mhold;
  EdgeIMParameter * _ep;
public:
  Ledge () {}
  void initialize (const int n) 
  {
    _mc.resize (n);
    _fm.resize (n);
    _mI.resize (n);
    _m.resize (n);
    _mhold.resize (n);
  }
  Ledge (const Ledge &r) : _cc (r._cc), 
                           _hcc (r._hcc), 
                           _fc (r._fc), 
                           _mc (r._mc), 
                           _fm (r._fm), 
                           _qI (r._qI), 
                           _mI (r._mI),
                           _q (r._q), 
                           _qhold (r._qhold), 
                           _m (r._m), 
                           _mhold (r._mhold),
                           _ep (r._ep) {}
  Ledge& operator=(const Ledge &r)
  {
    if (&r != this)
      {
        _cc = r._cc;
        _hcc = r._hcc;
        _fc = r._fc;
        _mc = r._mc;
        _fm = r._fm;
        _qI = r._qI;
        _mI = r._mI;
        _q = r._q;
        _qhold = r._qhold;
        _m = r._m;
        _mhold = r._mhold;
        _ep = r._ep;
      }
    return *this;
  }

  void setEp (EdgeIMParameter * ep) { _ep = ep; }

  // For all parameter, it is called by Ltree's compute
  double compute ()
  {
    return computeTheta () + computeM ();
  }

  double compute (const int qi)
  {
    if (qi == -1)
      {
        _q = computeTheta ();
        return _q - _qhold;
      }
    else
      {
        assert (_ep->getM (qi) > -0.5L);
        _m[qi] = computeMi (qi);
        return _m[qi] - _mhold[qi];
      }
  }

  double computeMarginal (const int qi)
  {
    if (qi == -1)
      {
        return computeTheta ();
      }
    else
      {
        assert (_ep->getM (qi) > -0.5L);
        return computeMi (qi);
      }
  }

  void revert (const int qi)
  {
    if (qi == -1)
      {
        _q = _qhold;
      }
    else
      {
        _m[qi] = _mhold[qi];
      }
    //_ep->revert (qi); NOTE: ***
  }
  void setCc (const int x) { _cc = x; }
  void setHcc (const double x) { _hcc = x; }
  void setFc (const double x) { _fc = x; }
  void setMc (const int qi, const int x) { _mc[qi] = x; }
  void setFm (const int qi, const double x) { _fm[qi] = x; }
  void setQI (const double x) { _qI = x; }
  void setMI (const int qi, const double x) { _mI[qi] = x; }

private:
  double computeTheta ()
  {
    double x = _ep->getTheta ();
    _qhold = _q;
    _q = -_qI + _cc * (LOG2 - log(x)) - _hcc - 2.0L * _fc / x;
    return _q;
  }
  double computeMi (int w)
  {
    double x = _ep->getM (w);
    if (x < 0.0L)
      return 0.0L;
    _mhold[w] = _m[w];
    _m[w] = -_mI[w] + _mc[w] * log(x) - _fm[w] * x;
    return _m[w];
  }
  double computeM ()
  {
    double v = .0L;
    for (int i = 0; i < _m.size(); i++)
      {
        v += computeMi (i); 
      }
    return v;
  }
};
#endif /* _LEDGE_HH_ */

<<Ledge.cc>>=
<<im3 copyright>>
#include <iostream>
#include "VectorOperation.hh"
#include "Ledge.hh"

using std::endl;
using std::cout;
using std::for_each;

std::ostream&
operator <<(std::ostream& os, const Ledge& l) 
{
  os << "Ledge:" << endl
     << "\tcc: " << l._cc << endl
     << "\thcc: " << l._hcc << endl
     << "\tfc: " << l._fc << endl
     << "\tqI: " << l._qI << endl
     << "\tq: " << l._q << endl;
  os << "\tmc: ";
  for_each (l._mc.begin(), l._mc.end(), PrintVector<int>());
  os << endl;
  os << "\tfm: ";
  for_each (l._fm.begin(), l._fm.end(), PrintVector<double>());
  os << endl;
  os << "\tmI: ";
  for_each (l._mI.begin(), l._mI.end(), PrintVector<double>());
  os << endl;
  os << "\tm: ";
  for_each (l._m.begin(), l._m.end(), PrintVector<double>());
  os << endl;
  return os;
}

<<Ledge-t.cc>>=
#include <iostream>
#include "Ledge.hh"
#include "EdgeIMParameter.hh"

int main (int argc, char* argv[])
{
  double v;
  Ledge l(2);

  l.setCc (2);
  l.setHcc (2.5L);
  l.setFc (3.5L);
  l.setMc (0, 1);
  l.setFm (0, 1.5L);
  l.setMc (1, 2);
  l.setFm (2, 4.5L);

  EdgeIMParameter e(2);
  IMParameter a(0, -1, 1);
  e.setTheta (a); 
  a.initialize (0, 1, 3);
  e.setM (0, a);
  a.initialize (0, 2, 7, 1);
  e.setM (1, a);

  l.setEp (&e);
  v = l.compute ();
  std::cout << "v: " << v << std::endl;
 
  return 0;
}

@
\section{IMa3 - Population Tree using C++ classes}

\subsection{Ptree.hh}
Class [[Ptree]] represents a population tree that can be used for [[IMa2]] and
[[IMa3]].  Hey's [[IMa2]] does not change the topology of a population tree
whereas [[IMa3]] allows its update in MCMC.  The class is seemingly large. The
tree accommodates two kinds of information: tree topology and some attributes
for edges.  Most of members inherit the structure [[chain]] from [[IMa2]].   
\begin{enumerate}
\item [[_npops]] is the number of sampled populations,
\item [[_ngtree]] is the number of loci,
\item [[_poptreestring]] represents the labeled history of the population.
Numbered internal nodes are in the string as well as the external nodes.
\item [[_newickstring]] is a Newick format of the population tree, which should
be displayed using any phylogenetic drawing tools such as ``FigTree.''
\item [[_indexLH]] is the rank of the population tree,
\end{enumerate}
Additional members help [[IMa2]] use to update genealogy, split time, and
mutation rates.  These are documented by J. Hey.  We simply copy those documents
into here.
\begin{enumerate}
\item [[_periodset]]: periodset summarizes information on the structure of the
poptree.   For each period i, periodset[i]is of type SET , which behaves like a
set, and contains the numbers for the populations present in that period,
\item [[_addpop]]: One value for each period.  It is the number of the
population number that first appears in that period.  addpop[0]== -1,
\item [[_droppops]]: Two values for each period.  They are the population
numbers of the two populations that come together in that period.
droppops[0][0]==droppops[0][1]== -1,
\item [[_plist]]: plist[][]is a 2d array, one row for each period. In row i the
elements are the population numbers that exist during that period,  in order
from low to high.  These are the same population numbers that are in
periodset[i], with the elements in order from lowest to highest. 
\item [[_popndown]]: allows us to know population label at a particular period
given a population whether it is a sampled or an ancestor. For example, a tree
((0,1):3,2):4 has five populations. There are five elements in [[_popndown]].
Each element is a vector of size three.  Population 0 will have a vector of 0,
3, and 4: if a genealogical lineage starts at population 0 and ends in the last
period, then the population label of the lineage will be 0 during period 0, 3
during period 1, and 4 during period 2.
\item [[_popnmig]]: allows us to know what migration events are allowed.  For
all populations including ancestors, each element is a vector of variable size
depending on the number of populations to which a genealogical lineage can
migrate from a population.
\end{enumerate}
The internal nodes should be ordered in time: or ((0,1):3,2):4 is allowed while 
((0,1):4,2):3 is not.  [[_orderedEdge]] should allow us to know which ancestor
is supposed to be which ancestor if the internal nodes were ordered.  During
MCMC we do not care whether the internal nodes are ordered or not.  We are
careful though when we record the current population tree and all its gweights
and integrates.  We enforce the output of population tree to be an strictly
ordered in their internal nodes. We discuss [[Pedge]] later in its part.

\paragraph{Ptree constructor:}
Method [[Ptree]] needs the number of sampled populations [[ns]], 
the number of loci [[nl]], and the index of a labeled history [[iLH]], or
population tree string [[treestring]].  Method [[Initialize]] does the actual
job of creating a thing of [[Ptree]].  We use [[iLH]] or [[treestring]] to
create the tree structure that relates [[Pedge]]: [[PtreeCreatePoptreestring]]
or [[PedgeCreate]].  Subsequently we call several methods in order.  Note that a
method can depend on its predecessor methods.  Keep the order of methods:
[[Tvals]], [[AddDroppops]], [[Periodset]], [[Plist]], [[Popndown]], [[Popnmig]],
[[PtreeMakenewickstring]], [[PtreeMakepoptreestring]], and
[[PtreeBlockMigration]].  

\paragraph{Tvals methods:}
[[PtreeGetTval]] gets the [[k]]-th splitting time.  [[PtreeSetTval]] sets the
[[k]]-th splitting time to [[t]].  [[PtreeCopyTvals]] sets the parameter [[t]]
to [[_tvals]].  [[PtreeFindperiod]] returns the period at time [[t]].  

\paragraph{Addpop and droppops methods:}
[[PtreeGetAddpop]], [[PtreeGetLeftDroppop]], and [[PtreeGetRightDroppop]] return
the corresponding population with respect to the [[k]]-th internal node of a
population tree.  The index [[k]] is kin to the period, and starts with 1 not 0.
The first split time event involves one addpop and two droppops at 1-st internal
node.  The 0-th addpop and droppops means nothing.  

\paragraph{Plist methods:}
[[PtreeGetPlist]] return the [[i]]-th population during period [[k]].
[[PtreePicktopop]] and [[PtreePicktopop2]] draw a population during period [[k]]
and the drawn population is different from the parameter [[nowpop]] or
additionally [[notother]].  

\paragraph{Popndown methods:}
[[PtreePopndown]] returns the population state during period [[k]] of which is
in [[nowpop]].  If the population is -1 (this happens when the input [[nowpop]]
does not exist during period [[k]].  If this is the case, we return the
[[nowpop]] with referencing [[_popndown]].

\paragraph{Popnmig methods:}
[[PtreeNoMigrateTo]] checks if no migration events from [[pi]] to [[qi]] should
be enforced.  Note that it returns true when there must not be unidirectional 
migration events from [[pi]] to [[qi]].
[[PtreeBlockMigration]] sets the value of migration rate to a negative value 
when the migration is not allowed ``a priori''.

\paragraph{Ordered edges methods:}
The internal node label's ordered version using [[_orderedEdge]] can be found.  

\paragraph{Pedge methods:}
[[PtreePedgeB]] returns edge [[x]]'s beginning period, and [[PtreePedgeE]]
returns its ending period.  [[PtreePedgeDown]] returns the down edge of node
[[x]]. 
[[PtreePedgeSetTime]] sets the down time of edge [[x]] to [[v]].
[[PtreePedgeGetTime]] gets the down time of edge [[n]].
[[PtreeGetTopTime]] gets the top time of edge [[n]], and [[PtreeSetTopTime]]
sets the top time of edge [[n]] to [[x]].  Time at the top of an edge is refered
to using the two daughters of the edge.  
[[PtreePedgeSister]] finds the sister of edge [[pi]].  
[[PtreeFindRoot]] finds the root of the population tree.

\paragraph{Gweight and integrates methods:}
There are too many functions to describe them all.  Their names should be
self-explanatory.

\paragraph{Input and output methods:}
[[PtreeSaveSampInf]] prints out gweights and integrates in ``.p'' file.
[[PtreeRestoreSampInf]] reads in ``.p'' file.

\paragraph{Ptree parameter methods:}
[[proposeTheta]] draws a new value for a demographic parameter that is specified
by [[pi]] and [[qi]].  [[revert]] replaces the new value with the previous one.
[[setPriorQ]] sets the maximum of population size for all edges.  [[setPriorM]]
does that for all migration rates between populations if the migrations are
allowed.  [[getEp]] returns the pointer of [[EdgeIMParameter]] from a population.
[[getTheta]] returns the size of population [[pi]] (when [[qi]] is -1) or
migraiton rates from [[pi]] to [[qi]] (when [[qi]] is a valid population label).
[[setWp]] sets the array of pairs of populations.  The number of elments of the
array is equal to the number of total demographic parameters including
population size and migration rates.  We could easily enumerate all of the
demographic parameters using the array.  
<<Ptree.hh>>=
<<im3 copyright>>
#ifndef _PTREE_HH_
#define _PTREE_HH_
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cassert>
#include <cmath>
#include <cstdarg>
#include "imdef.hh"
#include "imconstants.hh"
#include "imset.hh"
#include "imglobal.hh"
#include "imrng.hh"
#include "imptools.hh"
#include "Pedge.hh"

//#include "imdef.h" 
//#include "imenum.h"
//#undef GLOBVARS
//#include "imglobal.h"
//#include "imtools.h"

using std::vector;
using std::pair;
using std::make_pair;
using std::sort;
using std::cout;
using std::for_each;
using std::string;

typedef pair<pair<int,int>,double> splitEvent;

class DecreasingSplitEvent {
public:
  bool operator()(const splitEvent &s1, const splitEvent &s2)
  {
    return s1.second > s2.second;
  }
};

class Ptree {
  friend std::ostream& operator<<(std::ostream& os, const Ptree& p);
  int _npops; // not ns or sampled populations only 
  int _ngtree;
  string _poptreestring;
  string _newickstring;
  int _indexLH;
  vector<double> _tvals;
  vector<int> _addpop;
  vector< vector<int> > _droppops;
  vector<SET> _periodset;
  vector< vector<int> > _plist;
  int _rootpop;
  vector< vector<int> > _popndown;
  vector< vector<int> > _popnmig;
  vector<int> _orderedEdge;
  vector<Pedge> _pedge;

public:
  ///////////////////////////////////////////////////////////////
  // Constructor
  ///////////////////////////////////////////////////////////////
  void construct ();
  Ptree () {}
  Ptree (int ns, int nl, int iLH, const char * treestring = "");
  void Initialize (int ns, int nl, int iLH, const char * treestring = "");
  void PtreeNewickstring () { std::cout << _newickstring << std::endl; }

  ///////////////////////////////////////////////////////////////
  // Update by sliding
  ///////////////////////////////////////////////////////////////
  void wchSlide (); // FIXME: implement it!
  double wchSlideWeight (); // FIXME: implement it!
  void wchSlideBack (); // FIXME: implement it!

  ///////////////////////////////////////////////////////////////
  // Basic numbers
  ///////////////////////////////////////////////////////////////
  int getNparam () { return 2 * _npops - 1 + 2 * (_npops - 1) * (_npops - 1); }
  int getNpops () { return _npops; }
  int getNp () { return 2 * _npops - 1; }
  int getNgtree () { return _ngtree; }
  void print ();
  void printNewickstring () 
  { 
    std::cout << "Newick: " << _newickstring << std::endl; 
  }
  void printPoptreestring () { 
    std::cout << "Poptree: " << _poptreestring << std::endl; 
  }

  ///////////////////////////////////////////////////////////////
  // periodset
  ///////////////////////////////////////////////////////////////
  SET PtreeGetPeriodset (int k) { return _periodset[k]; }
  int PtreeExistPopAtTime (int pop, double t)
  {
    int k;
    k = PtreeFindperiod (t);
    return (ISELEMENT (pop, _periodset[k]));
  }

  ///////////////////////////////////////////////////////////////
  // Tvals methods
  ///////////////////////////////////////////////////////////////
  double PtreeGetTval (int k) { return _tvals[k]; }
  void PtreeSetTval (int k, double t) { _tvals[k] = t; }
  void PtreeCopyTvals (double * t)
  {
    int i;
    assert (IMGlobal::lastperiodnumber == _npops - 1);
    for (i = 0; i < _npops; i++)
      {
        t[i] = _tvals[i];
      }
  }
  int PtreeFindperiod (double t)
  {
    int k = 0;
    assert (t >= 0.0);
    while (k < _npops - 1 && _tvals[k] <= t)
      k++;
    return k;
  }
  void printHeaderSplitTime (const string &tFile)
  {
    std::ofstream os(tFile.c_str(), std::ios::out);
    os << "gen";
    for (int i = 0; i < _npops - 1; i++)
      {
        os << "\tT" << i;
      }
    os << std::endl;
    os.close ();
  }
  void printSplitTime (const string &tFile, const int gen)
  {
    std::ofstream os(tFile.c_str(), std::ios::out | std::ios::app);
    os << gen;
    for (int i = 0; i < _npops - 1; i++)
      {
        os << "\t" << _tvals[i];
      }
    os << std::endl;
    os.close ();
  }


  ///////////////////////////////////////////////////////////////
  // addpop and droppops methods
  ///////////////////////////////////////////////////////////////
  int PtreeGetAddpop (int k) { return _addpop[k]; }
  int PtreeGetLeftDroppop (int k) { return _droppops[k][0]; }
  int PtreeGetRightDroppop (int k) { return _droppops[k][1]; }

  ///////////////////////////////////////////////////////////////
  // plist method
  ///////////////////////////////////////////////////////////////
  int PtreeGetPlist (int k, int i) { return _plist[k][i]; }
  int PtreePicktopop (int nowpop, int k)
  {
    int topop;
    do
      {
        topop = randposint (_npops - k);
      } while (_plist[k][topop] == nowpop);
    assert (topop < _npops - k);
    return _plist[k][topop];
  }
  int PtreePicktopop2 (int nowpop, int k, int notother)
  {
    int topop;
    do
      {
        topop = randposint (_npops - k);
      } while (_plist[k][topop] == nowpop 
               || _plist[k][topop] == notother);
    assert (topop < _npops - k);
    return _plist[k][topop];
  }

  ///////////////////////////////////////////////////////////////
  // popndown methods
  ///////////////////////////////////////////////////////////////
  int PtreePopndown (int nowpop, int k)
  {
    int v = _popndown[nowpop][k];
    if (v == -1)
      {
        v = nowpop;
      }
    return v;
  }

  ///////////////////////////////////////////////////////////////
  // orderedEdge methods
  ///////////////////////////////////////////////////////////////
  void PtreeOrderEdge ()
  {
    for (int i = 0; i < _npops; i++)
      {
        _orderedEdge[i] = i;
      }
    for (int i = _npops; i < 2 * _npops - 1; i++)
      {
        int v = _addpop[i - _npops + 1];
        _orderedEdge[v] = i;
      }
    return;
  }

  ///////////////////////////////////////////////////////////////
  // pedge
  ///////////////////////////////////////////////////////////////
  int PtreePedgeB (int x) { return _pedge[x].PedgeGetB(); }
  int PtreePedgeE (int x) { return _pedge[x].PedgeGetE(); }
  int PtreePedgeDown (int x) { return _pedge[x].PedgeGetDown(); }
  double PtreePedgeGetTime (int n) { return _pedge[n].PedgeGetT (); }
  void PtreePedgeSetTime (int x, double v) { _pedge[x].PedgeSetT (v); }
  double PtreeGetTopTime (int n) 
  {
    int up;
    double t;
    up = _pedge[n].PedgeGetLeft();
    if (up == -1)
      {
        t = 0.0;
      }
    else
      {
        t = _pedge[up].PedgeGetT();
      }
    return t;
  }
  void PtreeSetTopTime (int n, double x) 
  {
    int left;
    int right;
    left = _pedge[n].PedgeGetLeft ();
    right = _pedge[n].PedgeGetRight ();
    _pedge[left].PedgeSetT (x);
    _pedge[right].PedgeSetT (x);
  }

  int PtreePedgeSister (int pi)
  {
    int v;
    int down;
    int left;
    int right;

    down = _pedge[pi].PedgeGetDown ();
    assert (IMGlobal::npops <= down && down < 2 * IMGlobal::npops - 1); /* down must be an internal edge. */
    left = _pedge[down].PedgeGetLeft ();
    right = _pedge[down].PedgeGetRight ();
    assert (-1 < left && left < 2 * IMGlobal::npops - 1);
    assert (-1 < right && right < 2 * IMGlobal::npops - 1);

    if (left == pi)
      v = right;
    else
      v = left;
    return v; 
  }
  int PtreeFindRoot ()
  {
    int v = -1;
    for (int i = 0; i < _npops * 2 - 1; i++)
      {
        if (PtreePedgeDown (i) == -1)
          {
            v = i;
            break;
          }
      }
    assert (v > -1);
    return v;
  }

  ///////////////////////////////////////////////////////////////
  // pedge's gweight
  ///////////////////////////////////////////////////////////////
  void setGweightT (const int pi, const int cc, const double hcc, const double fc)
  {
    _pedge[pi].setGweightT (cc, hcc, fc);
  }

  void setGweightM (const int pi, const int qi, const int mc, const double fm)
  {
    _pedge[pi].setGweightM (qi, mc, fm);
  }

  void PtreeResetGweight (int gi)
  {
    int pi;
    for (pi = 0; pi < 2 * _npops - 1; pi++)
      {
        _pedge[pi].PedgeGweightReset (gi);
      }
    return;
  }
  void PtreeResetAllgweight () { PtreeResetGweight (_ngtree); }
  void PtreeGweightCcAddto (int p, int gi, int x)
  {
    _pedge[p].PedgeGweightCcAddto (gi, x); 
  }
  void PtreeGweightHccAddto (int p, int gi, double x)
  {
    _pedge[p].PedgeGweightHccAddto (gi, x); 
  }
  void PtreeGweightFcAddto (int p, int gi, double x)
  {
    _pedge[p].PedgeGweightFcAddto (gi, x); 
  }
  void PtreeGweightMcAddto (int p, int q, int gi, int x)
  {
    _pedge[p].PedgeGweightMcAddto (gi, q, x); 
  }
  void PtreeGweightFmAddto (int p, int q, int gi, double x)
  {
    _pedge[p].PedgeGweightFmAddto (gi, q, x); 
  }

  int PtreeGetGweightCc (int p, int gi) 
  { 
    return _pedge[p].PedgeGetGweightCc (gi); 
  }

  double PtreeGetGweightHcc (int p, int gi) 
  { 
    return _pedge[p].PedgeGetGweightHcc (gi); 
  }

  double PtreeGetGweightFc (int p, int gi)
  {
    return _pedge[p].PedgeGetGweightFc (gi); 
  }

  int PtreeGetGweightMc (int p, int q, int gi) 
  { 
    return _pedge[p].PedgeGetGweightMc (q, gi); 
  }

  double PtreeGetGweightFm (int p, int q, int gi) 
  { 
    return _pedge[p].PedgeGetGweightFm (q, gi); 
  }

  void PtreeStoreWeight (int gi)
  {
    int pi;
    for (pi = 0; pi < 2 * _npops - 1; pi++)
      {
        _pedge[pi].PedgeStoreGweight (gi);
      }
    return;
  }
  void PtreeRestoreWeight (int gi)
  {
    int pi;
    for (pi = 0; pi < 2 * _npops - 1; pi++)
      {
        _pedge[pi].PedgeRestoreGweight (gi);
      }
    return;
  }
  void PtreeSumSubtractWeight (int gi)
  {
    int pi;
    for (pi = 0; pi < 2 * _npops - 1; pi++)
      {
        _pedge[pi].PedgeSumSubtractGweight (gi);
      }
    return;
  }
  void PtreeAddWeight (int gi)
  {
    int pi;
    for (pi = 0; pi < 2 * _npops - 1; pi++)
      {
        _pedge[pi].PedgeAddGweight (gi);
      }
    return;
  }

  ///////////////////////////////////////////////////////////////
  // pedge's integrate
  ///////////////////////////////////////////////////////////////
  void PtreeStoreProbCalc ()
  {
    int pi;
    for (pi = 0; pi < 2 * _npops - 1; pi++)
      {
        _pedge[pi].PedgeStoreIntegrate ();
      }
    return;
  }
  void PtreeRestoreProbCalc ()
  {
    int pi;
    for (pi = 0; pi < 2 * _npops - 1; pi++)
      {
        _pedge[pi].PedgeRestoreIntegrate ();
      }
    return;
  }
  double PtreeIntegrateTreeProb ()
  {
    int pi;
    double sum;
    sum = 0.0;
    for (pi = 0; pi < 2 * _npops - 1; pi++)
      {
        _pedge[pi].PedgeIntegrateProbg (_popnmig[pi]); 
        sum += _pedge[pi].PedgeGetIntegrate (_popnmig[pi]);
      }
    return sum;
  }

  double getIntegrateQ (int pi)
  {
    return _pedge[pi].getIntegrateQ ();
  }

  double getIntegrateM (int pi, int qi)
  {
    return _pedge[pi].getIntegrateM (qi);
  }

  ///////////////////////////////////////////////////////////////
  // popnmig
  ///////////////////////////////////////////////////////////////
  void PtreeBlockMigration ()
  {
    vector<int>::iterator itor;
    for (int pi = 0; pi < _npops * 2 - 1; pi++)
      {
        for (int qi = 0; qi < _npops * 2 - 1; qi++)
          {
            itor = find (_popnmig[pi].begin(), _popnmig[pi].end(), qi);
            if (itor == _popnmig[pi].end())
              _pedge[pi].setNegativeM (qi);
          }
      }
  }
  bool PtreeNoMigrateTo (const int pi, const int qi)
  {
    vector<int>::iterator itor = find (_popnmig[pi].begin(), _popnmig[pi].end(), qi);
    if (itor == _popnmig[pi].end())
      {
        return true;
      }
    else
      {
        return false;
      }
  }

  ///////////////////////////////////////////////////////////////
  // I/O for Ptree
  ///////////////////////////////////////////////////////////////
  void PtreeSaveSampInf (const char * fn);
  int PtreeRestoreSampInf (std::ifstream& s, int iLH);

  ///////////////////////////////////////////////////////////////
  // IMParameters in Pedge
  ///////////////////////////////////////////////////////////////
  void setTheta (const int pi, const int qi, const double x)
  {
    _pedge[pi].setTheta (qi, x);
  }
  void proposeTheta (const int pi, const int qi)
  {
    _pedge[pi].proposeTheta (qi);
  }
  void revert (const int pi, const int qi)
  {
    _pedge[pi].revert (qi);
  }

  double getThetaPrior (const int pi, const int qi)
  {
    return _pedge[pi].getThetaPrior (qi);
  }
 
  void setPriorQ (const double x)
  {
    for (vector<Pedge>::iterator i = _pedge.begin();
         i != _pedge.end();
         i++)
      {
        i->setPriorQ (x);
      }
  }
  void setPriorM (const double x)
  {
    for (vector<Pedge>::iterator i = _pedge.begin();
         i != _pedge.end();
         i++)
      {
        i->setPriorM (x);
      }
  }
  EdgeIMParameter * getEp (const int pi)
  {
    return _pedge[pi].getEp ();
  }
  double getTheta (const int pi, const int qi)
  {
    if (qi == -1)
      return _pedge[pi].getTheta ();
    else
      return _pedge[pi].getM (qi);
  }
  void setWp (vector< pair<int,int> > &wp)
  {
    wp.clear ();
    for (int pi = 0; pi < 2 * _npops - 1; pi++)
      {
        wp.push_back (std::make_pair(pi,-1)); 
        for (vector<int>::const_iterator i = _popnmig[pi].begin(); 
             i != _popnmig[pi].end(); 
             i++)
          {
            wp.push_back (std::make_pair(pi,*i)); 
          }
      }
  }

  ///////////////////////////////////////////////////////////////
  // Ptree update helpers
  ///////////////////////////////////////////////////////////////
  int PtreeMoveI (int rperiod, int popx, int popa, int popb, int popc);
  int PtreeMoveII (int rperiod, int popal, int popbl, int popcl, int popau, int popbu, int popcu);
  int PhylogenyTptChooseAnIngroup (int rperiod, int * popx, int * popa);
  int PhylogenyTptChooseAllPopulations (int rperiod, int * popal, int * popbl, int * popcl, int * popau, int * popbu, int * popcu);
  void PtreeMakenewickstring (int curpop);
  void PtreeMakepoptreestring (int curpop);
  int PtreeGetIofLHistory ();
  void PtreeAccept ();
  void PtreeRecord (const string &fn, int s);
  void PtreeRecordHeader (const string &fn);
  void PtreeRecordFooter (const string &fn);

private:
  void PedgeCreate (const int ns, const int ngtree, const int iLH);
  void PtreePedgeCreate (const int down, const char * poptreestring);
  void PtreeCreatePoptreestring (const int ns, const int ngtree, const char * poptreestring);
  void PtreeAllocTvals ();
  void PtreeSetTvalsToPedge ();
  void PtreeAllocAddDroppops ();
  void PtreeAllocPeriodset ();
  void PtreeAllocPlist ();
  void PtreeAllocPopndown ();
  void PtreeAllocPopnmig ();
  void PtreeSetPopndown ();
  void PtreeSetPopnmig ();
};

#endif /* _PTREE_HH_ */

<<Ptree.cc>>=
<<im3 copyright>>
#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include "imptools.hh"
#include "Ptree.hh"
#include "ParserPoptreestring.hh"
#include "VectorOperation.hh"

using std::cout;
using std::endl;


void 
Ptree::wchSlide () // FIXME: implement it!
{

}

double 
Ptree::wchSlideWeight () // FIXME: implement it!
{
  return .0L;
}

void 
Ptree::wchSlideBack () // FIXME: implement it!
{

}

void
Ptree::print ()
{
  cout << "Tree --------------------------" << endl
     << "  #_pops: " << _npops << endl
     << "  #_loci or #_gtree: " << _ngtree << endl
     << "  poptreestring: " << _poptreestring << endl
     << "  newickstring: " << _newickstring << endl
     << "  indexLH: " << _indexLH << endl;
   
  cout << "  Tvals: ";
  for_each (_tvals.begin(), _tvals.end(), PrintVector<double>());
  cout << endl;

  cout << "  Addpop: ";
  for_each (_addpop.begin(), _addpop.end(), PrintVector<int>());
  cout << endl;

  cout << "  Droppops: \n";
  for_each (_droppops.begin(), _droppops.end(), PrintVector2<int>());
  cout << endl;

  cout << "  Plist: \n";
  for_each (_plist.begin(), _plist.end(), PrintVector2<int>());
  cout << endl;

  cout << "  Popdown: \n";
  for_each (_popndown.begin(), _popndown.end(), PrintVector2<int>());
  cout << endl;

  cout << "  Popmig: \n";
  for_each (_popnmig.begin(), _popnmig.end(), PrintVector2<int>());
  cout << endl;
  return;
}

std::ostream&
operator <<(std::ostream& os, const Ptree& pt) 
{
  os << "Tree --------------------------" << endl
     << "  #_pops: " << pt._npops << endl
     << "  #_loci or #_gtree: " << pt._ngtree << endl
     << "  poptreestring: " << pt._poptreestring << endl
     << "  newickstring: " << pt._newickstring << endl
     << "  indexLH: " << pt._indexLH << endl;
   
  os << "  Tvals: ";
  for_each (pt._tvals.begin(), pt._tvals.end(), PrintVector<double>());
  os << endl;

  os << "  Addpop: ";
  for_each (pt._addpop.begin(), pt._addpop.end(), PrintVector<int>());
  os << endl;

  os << "  Droppops: \n";
  for_each (pt._droppops.begin(), pt._droppops.end(), PrintVector2<int>());
  os << endl;

  os << "  Plist: \n";
  for_each (pt._plist.begin(), pt._plist.end(), PrintVector2<int>());
  os << endl;

  os << "  Popdown: \n";
  for_each (pt._popndown.begin(), pt._popndown.end(), PrintVector2<int>());
  os << endl;

  os << "  Popmig: \n";
  for_each (pt._popnmig.begin(), pt._popnmig.end(), PrintVector2<int>());
  os << endl;

#if 0
  // Print Pedge
  for (vector<Pedge>::const_iterator itor = pt._pedge.begin();
       itor != pt._pedge.end();
       itor++)
    {
      os << *itor;
    }

  vector<SET> _periodset;
  int _rootpop;
  vector<int> _orderedEdge;
  vector<Pedge> _pedge;
#endif

  return os;
}

///////////////////////////////////////////////////////////////
// output
///////////////////////////////////////////////////////////////
void 
Ptree::PtreeSaveSampInf (const char * fn)
{
  static int si = 0;

  si++;

  PtreeOrderEdge ();
  std::ofstream os(fn, std::ios::out | std::ios::app);
  if (!os)
    {
      std::cerr << "Error: file " << fn << "could not be opened";
      exit (1);
    }

  os << si << "\t" << _indexLH
     << "\t" << _newickstring
     << "\t" << _poptreestring;
  for (int pii = 1; pii < _npops; pii++)
    {
      os << "\t" << _addpop[pii];
    }
  for (int pii = 0; pii < _npops - 1; pii++)
    {
      os << "\t" << _tvals[pii];
    }

  for (int pii = 0; pii < 2 * _npops - 1; pii++)
    {
      int pij = pii;
      if (pii >= _npops)
        {
          pij = _addpop[pii - _npops + 1];
        }
      _pedge[pij].PedgeWrite (os, pij,
                             _popnmig[pij], 
                             _orderedEdge);
    }

  os << std::endl;
  os.close ();
  return; 
}

// This is called Lmode::load.
int
Ptree::PtreeRestoreSampInf (std::ifstream& is, int iLH)
{
  int i;
  int pi;
  int si;
  //char c;
  int previndexLH;
  int idummy;

  // Start from here 
  if (is.eof())
  {
    return -1;
  }
  is >> si;
  if (is.eof())
  {
    return -1;
  }
  is >> i;
  if (is.eof())
  {
    return -1;
  }
  if (i != iLH)
  {
    if (is.fail())
      {
        return -1;
      }
    ima::readToEndl (is);
    if (is.eof())
      return -1;
    else
      return 0;
  }
  previndexLH = _indexLH;
  _indexLH = i;

  is >> _newickstring;
  is >> _poptreestring;
  for (int pii = 1; pii < _npops; pii++)
    {
      //is >> _addpop[pii];
      is >> idummy; // internal nodes were already ordered.
    }
  for (int pii = 0; pii < _npops - 1; pii++)
    {
      is >> _tvals[pii];
    }
  _tvals[_npops - 1] = IMConstants::TIMEMAX;

  // we should already know npopo, and nloci.
  if (previndexLH != _indexLH)
    construct ();

  for (int pii = 0; pii < 2 * _npops - 1; pii++)
    {
      pi = ima::readTiQ (is, "qt");
      assert (pi == pii);
      _pedge[pii].read (is, pii,
                        _popnmig[pii], 
                        _orderedEdge);
    }

  // We have read in a sample of genealogy given a population tree.
  // We could either implement L-mode of IMa2 or generate a ti file for IMa2.
  // I am not sure which one is better one. 
  // I would change the L-mode code.
  // STOP HERE

  return 1; 
}


// This function is too similar to Initialize. We may factor them out.
void
Ptree::construct ()
{
  assert (_npops > 0);
  assert (_ngtree > 0);
  assert (_indexLH > 0);

  PedgeCreate (_npops, _ngtree, _indexLH);

  _orderedEdge.resize(2 * _npops - 1);
  for (size_t i = 0; i < _orderedEdge.size(); i++)
    {
      _orderedEdge[i] = i;
    }

  PtreeSetTvalsToPedge ();
  assert (PtreePedgeGetTime (2 * _npops - 2) == IMConstants::TIMEMAX);
  PtreeAllocAddDroppops ();
  PtreeAllocPeriodset ();
  PtreeAllocPlist ();
  PtreeAllocPopndown ();
  PtreeAllocPopnmig ();
  PtreeMakenewickstring (-1);
  PtreeMakepoptreestring (-1);
  //std::cout << _indexLH << std::endl;
  //std::cout << _newickstring << std::endl;
  //std::cout << _poptreestring << std::endl;
  PtreeBlockMigration ();
}

///////////////////////////////////////////////////////////////
// ptree's record
///////////////////////////////////////////////////////////////
void 
Ptree::PtreeRecordHeader (const string &fn)
{
  int pi;
  string treefilename;

  treefilename = fn + ".nex.t"; 
  std::ofstream os(treefilename.c_str(), std::ios::out);
  if (!os)
    {
      std::cerr << "Error: file " << treefilename << "could not be opened";
      exit (1);
    }

  os << "#NEXUS\n"
     << "[ID: 777]\n"
     << "begin trees;\n"
     << "   translate\n";
  for (pi = 0; pi < _npops; pi++)
    {
      os << "      " << pi + 1 << " " << IMGlobal::popnames[pi];
      if (pi == _npops - 1)
        {
          os << ";";
        }
      else
        {
          os << ",";
        }
      os << std::endl;
    }
  os.close (); 
  return;
}

void 
Ptree::PtreeRecord (const string &fn, int s)
{
  string treefilename;
  static int gen = 0;

  /////////////////////////////////////////////////////////////////////////////
  // nex.t file for tree summary
  treefilename = fn + ".nex.t"; 
  std::ofstream os(treefilename.c_str(), std::ios::out | std::ios::app);
  if (!os)
    {
      std::cerr << "Error: file " << treefilename << "could not be opened";
      exit (1);
    }

  // Note that newickstring and popntreestring are in different format. 
  // Check it out in build_poptree.c. 
  os <<  "   tree rep." << s << " = " << _newickstring << std::endl;
  os.close ();

  /////////////////////////////////////////////////////////////////////////////
  // nex.t file for tree summary
  treefilename = fn + ".ti";

  int i = PtreeGetIofLHistory ();
  assert (_indexLH == i);

  PtreeSaveSampInf (treefilename.c_str());

  gen++;
  return;
}

void 
Ptree::PtreeRecordFooter (const string &fn)
{
  string treefilename;

  treefilename = fn + ".nex.t"; 
  std::ofstream os(treefilename.c_str(), std::ios::out | std::ios::app);
  if (!os)
    {
      std::cerr << "Error: file " << treefilename << "could not be opened";
      exit (1);
    }
  os << "end;\n";
  os.close ();
  return;
}

void
Ptree::PtreePedgeCreate (const int down, const char * poptreestring)
{
  int left;
  int right;
  int node;

  ParserPoptreestring p(poptreestring);
  left = p.ParserPoptreestringGetLeft ();
  right = p.ParserPoptreestringGetRight ();
  node = p.ParserPoptreestringGetNode ();
  if (left > -1 && right > -1)
    {
      PtreePedgeCreate (node, p.ParserPoptreestringGetLeftString ()); 
      PtreePedgeCreate (node, p.ParserPoptreestringGetRightString ()); 
    }
  _pedge[node].PedgeSetLeft (left);
  _pedge[node].PedgeSetRight (right);
  _pedge[node].PedgeSetDown (down);
  return;
}

void 
Ptree::PtreeCreatePoptreestring (const int ns, const int ngtree, const char * poptreestring)
{
  int np;
  double t;
  //int rootnode;
  int i;
  int left;
  int right;
  int k;

  np = ns * 2 - 1;
  _pedge.resize (np);
  for (i = 0; i < np; i++)
    {
      _pedge[i].Initialize (i, np, ngtree);
    }

  PtreePedgeCreate (-1, poptreestring); 
  for (i = 0; i < ns; i++)
    {
      _pedge[i].PedgeSetB (0);
    }

  t = 0.0;
  for (i = ns, k = 1; i < np; i++, k++)
    {
      t += 0.5;
      left = _pedge[i].PedgeGetLeft ();
      right = _pedge[i].PedgeGetRight ();
      _pedge[left].PedgeSetT (t);
      _pedge[right].PedgeSetT (t);
      _pedge[left].PedgeSetE (k);
      _pedge[right].PedgeSetE (k);
      _pedge[i].PedgeSetB (k);
    }
  _pedge[np - 1].PedgeSetT (IMConstants::TIMEMAX);
  _pedge[np - 1].PedgeSetE (-1);

  return;
}

/*
* Yang and Rannala (1997) Bayesian Phylogenetic Inference Using DNA Sequences:
* A Markov Chain Monte Carlo Method. Mol. Biol. Evol. 14(7):717--724
*/
void 
Ptree::PedgeCreate (const int ns, const int ngtree, const int iLH)
{
  int np;  /* np is 2 * ns - 1 */
  double t;
  int rootnode;
  int i;
  int k;
  int inode;
  int nodea[IMConstants::MAXPOPS];
  int s1;
  int s2;
  int it;
  int d0;
  int d1;

  np = ns * 2 - 1;
  if (_pedge.size() != size_t (np))
    {
      _pedge.resize (np);
    }
  for (i = 0; i < np; i++)
    {
      _pedge[i].Initialize (i, np, ngtree);
    }

  t = 0.0;
  for (i = 0; i < ns; i++) 
    {
      nodea[i] = i;
    }
  it = iLH;
  for (i = ns, inode = ns; i >= 2; i--, inode++)  
    {
      k = it%(i*(i-1)/2);  
      it /= (i*(i-1)/2); 
      s2 = (int)(sqrt(1.+8*k)-1)/2+1;  
      s1 = k-s2*(s2-1)/2; /* s1<s2, k=s2*(s2-1)/2+s1 */
      assert (s1 < s2);
      if (s1 >= s2)
      {
        //IM_errloc (AT, "Tree Generation Error using index %d", iLH);
      }
      //t += expo (1.0);
      t += 0.5;
      d0 = nodea[s1];
      d1 = nodea[s2];
      _pedge[d0].PedgeSetDown(inode);
      _pedge[d0].PedgeSetE(inode - ns + 1);
      _pedge[d0].PedgeSetT(t); /* e.g., See Gernhard (2009) */
      _pedge[d1].PedgeSetDown(inode);
      _pedge[d1].PedgeSetE(inode - ns + 1);
      _pedge[d1].PedgeSetT(t);
      _pedge[inode].PedgeSetLeft(d0);
      _pedge[inode].PedgeSetRight(d1);
      _pedge[inode].PedgeSetB(inode - ns + 1);
      nodea[s1] = inode;
      nodea[s2] = nodea[i-1]; 
  }
  rootnode = inode - 1;
  _pedge[rootnode].PedgeSetDown(-1);
  _pedge[rootnode].PedgeSetE(-1);
  _pedge[rootnode].PedgeSetT(IMConstants::TIMEMAX);

  return;
}


void
Ptree::PtreeAccept ()
{
  PtreeMakenewickstring (-1);
  PtreeMakepoptreestring (-1);
  _indexLH = PtreeGetIofLHistory ();
  return;
}


// Yang and Rannala (1997) Bayesian Phylogenetic Inference Using DNA Sequences:
// A Markov Chain Monte Carlo Method. Mol. Biol. Evol. 14(7):717--724
int
Ptree::PtreeGetIofLHistory () 
{
  // Get the index of the labelled history (rooted tree with nodes ordered
  // according to time).  
  // Numbering of nodes: node # increases as the node gets older:
  // node d corresponds to time 2 times ns-2-d; tree.root=ns * 2-2;
  // t0=1 > t1 > t2 > ... > t[ns-2]
  int v, i, j, k[IMConstants::MAXPOPS+1], inode, nnode, s[2];
  int ancestor;
  int daughter;
  int ns;

  PtreeOrderEdge ();

  ns = _npops;
  assert (ns < IMConstants::MAXPOPS); /* We cannot handle big integers. */

  // Internal nodes should be ordered in time. 
  for (i = 1, inode = _npops, nnode = _npops; 
       inode < _npops * 2 - 1; 
       i++, inode++, nnode--) 
  {
      ancestor = _addpop[i];
      for (j = 0; j < 2; j++)
      {
          daughter = _droppops[i][j];
          s[j] = _orderedEdge[daughter];
      }
      k[nnode] = IMAX(s[0],s[1]); 
      s[0] = IMIN(s[0],s[1]); 
      s[1] = k[nnode];
      k[nnode] = s[1]*(s[1]-1)/2 + s[0];
      _orderedEdge[ancestor] = s[0];

      for (j = 0; j < _npops - i; j++)
        {
          int pi = _plist[i][j];
          if (_npops - i - 1 < _orderedEdge[pi])  
            _orderedEdge[pi] = s[1];
        }
  }
  v = 0;
  for (nnode=2; nnode <= _npops; nnode++)
  {
      v = nnode*(nnode-1)/2*v + k[nnode];
  }
  return v;
}

void
Ptree::PtreeMakenewickstring (int curpop)
{
  //int i;
  //int ndaughter;
  int left;
  int right;
  int down;
  //char numString[100];
  std::stringstream sout;

  if (curpop == -1)
  {
    _newickstring.clear();
    curpop = PtreeFindRoot ();
  }

  left = _pedge[curpop].PedgeGetLeft ();
  right = _pedge[curpop].PedgeGetRight ();
  down = _pedge[curpop].PedgeGetDown ();
  assert ((left == -1 && right == -1) || (left > -1 && right > -1));

  if (left > -1 && right > -1)
    {
      _newickstring += "(";
      PtreeMakenewickstring (left);
      _newickstring += ",";
      PtreeMakenewickstring (right);
      _newickstring += ")";
    }
  else
    {
      sout.str("");
      sout << curpop + 1;  
      _newickstring += sout.str();
    }

  if (down < 0)
    {
      _newickstring += ";";
    }
  else
    {
      sout.str("");
      if (left < 0)
        {
          sout << ":" << PtreePedgeGetTime (curpop);
        }
      else
        {
          sout << ":" << PtreePedgeGetTime (curpop) - PtreePedgeGetTime (left);
        }
      _newickstring += sout.str();
    }
  return;
}

void
Ptree::PtreeMakepoptreestring (int curpop)
{
  //int i;
  //int ndaughter;
  int left;
  int right;
  int down;
  std::stringstream sout;

  if (curpop == -1)
  {
    _poptreestring.clear();
    curpop = PtreeFindRoot ();
  }

  left = _pedge[curpop].PedgeGetLeft ();
  right = _pedge[curpop].PedgeGetRight ();
  down = _pedge[curpop].PedgeGetDown ();
  assert ((left == -1 && right == -1) || (left > -1 && right > -1));

  if (left > -1 && right > -1)
    {
      _poptreestring += "(";
      PtreeMakepoptreestring (left);
      _poptreestring += ",";
      PtreeMakepoptreestring (right);
      _poptreestring += "):";
    }
  sout.str("");
  sout << curpop;
  _poptreestring += sout.str();

  if (down < 0)
    {
      _poptreestring += ";";
    }
  return;
}

int
Ptree::PhylogenyTptChooseAllPopulations (int rperiod, int * popal, int * popbl, int * popcl, int * popau, int * popbu, int * popcu)
{
  *popau = _droppops[rperiod][0];
  *popbu = _droppops[rperiod][1];
  *popcu = _addpop[rperiod];
  *popal = _droppops[rperiod + 1][0];
  *popbl = _droppops[rperiod + 1][1];
  *popcl = _addpop[rperiod + 1];
  return 0;
}

int
Ptree::PhylogenyTptChooseAnIngroup (int rperiod, int * popx, int * popa)
{
  assert (0 < rperiod && rperiod < _npops - 1);
  if (bitran ())
    {
      *popx = _droppops[rperiod][0];
      *popa = _droppops[rperiod][1];
    }
  else
    {
      *popx = _droppops[rperiod][1];
      *popa = _droppops[rperiod][0];
    }
  return _addpop[rperiod];
}


int 
Ptree::PtreeMoveII (int rperiod, int popal, int popbl, int popcl, int popau, int popbu, int popcu)
{
  SET set1;
  int j, k;
  double upt, dnt;

  upt = PtreeGetTval (rperiod - 1);
  dnt = PtreeGetTval (rperiod);

  set1 = _periodset[rperiod];
  set1 = SETREMOVE (set1, popal);
  set1 = SETREMOVE (set1, popbl);
  set1 = SETREMOVE (set1, popcu);
  set1 = SETADD (set1, popau);
  set1 = SETADD (set1, popbu);
  set1 = SETADD (set1, popcl);
  _periodset[rperiod] = set1;

  /* Change droppops and addpop. */
  _droppops[rperiod][0] = popal;
  _droppops[rperiod][1] = popbl;
  _addpop[rperiod] = popcl;
  _droppops[rperiod + 1][0] = popau;
  _droppops[rperiod + 1][1] = popbu;
  _addpop[rperiod + 1] = popcu;

  /* Change plist. */
  j = 0; 
  FORALL (k, _periodset[rperiod])
    {
      _plist[rperiod][j] = k;
      j++;
    }

  /* Change poptree. */
  _pedge[popal].PedgeSetE (rperiod);
  _pedge[popal].PedgeSetT (upt);
  _pedge[popbl].PedgeSetE (rperiod);
  _pedge[popbl].PedgeSetT (upt);
  _pedge[popcl].PedgeSetB (rperiod);

  _pedge[popau].PedgeSetE (rperiod + 1);
  _pedge[popau].PedgeSetT (dnt);
  _pedge[popbu].PedgeSetE (rperiod + 1);
  _pedge[popbu].PedgeSetT (dnt);
  _pedge[popcu].PedgeSetB (rperiod + 1);
#if 0 /* SANGCHUL: tree */
  ptree = _poptree;
  ptree[popal].e = rperiod;
  ptree[popal].time = upt;
  ptree[popbl].e = rperiod;
  ptree[popbl].time = upt;
  ptree[popcl].b = rperiod;

  ptree[popau].e = rperiod + 1;
  ptree[popau].time = dnt;
  ptree[popbu].e = rperiod + 1;
  ptree[popbu].time = dnt;
  ptree[popcu].b = rperiod + 1;
#endif

  PtreeMakepoptreestring (-1);
  PtreeMakenewickstring (-1);

  /* No change to rootpop */
  /* No change to tvals */

  /* popndown and popnmig were a part of assignment project. We place the same
   * thing under struct Chain. */
  PtreeSetPopndown ();

  /* Search this document for "popnmig tree model" as a reference. I am not sure
   * whether we need this one.  Until then, we turn it off.  
   * In "popmig tree model" we use plist to create and set popnmig.  The memory
   * of the variable changes, and therefore make sure free and malloc.
   * int ***popnmig; --- per period, per popn, list of popn's ---
   */
  //assert (_popnmig == NULL);
  PtreeSetPopnmig ();
  return 0;
}

int
Ptree::PtreeMoveI (int rperiod, int popx, int popa, int popb, int popc)
{
  SET set1;
  int j, k; //int i, j, k;
  int pope;
  double upt, dnt;

  upt = PtreeGetTval (rperiod - 1);
  dnt = PtreeGetTval (rperiod);

  set1 = _periodset[rperiod];
  set1 = SETREMOVE (set1, popb);
  set1 = SETADD (set1, popa);
  _periodset[rperiod] = set1;

  /* No change to addpop. */
  /* Change droppops. */
  _droppops[rperiod][0] = popx;
  _droppops[rperiod][1] = popb;
  _droppops[rperiod + 1][0] = popa;
  _droppops[rperiod + 1][1] = popc;

  /* Change plist. */
  j = 0; 
  FORALL (k, _periodset[rperiod])
    {
      assert (j < _npops - rperiod);
      _plist[rperiod][j] = k;
      j++;
    }

  /* Change poptree. */
  pope = _pedge[popc].PedgeGetDown ();
  _pedge[popa].PedgeSetDown (pope);
  _pedge[popa].PedgeSetE (rperiod + 1);
  _pedge[popa].PedgeSetT (dnt);
  _pedge[popb].PedgeSetDown (popc);
  _pedge[popb].PedgeSetE (rperiod);
  _pedge[popb].PedgeSetT (upt);
  assert (_pedge[popc].PedgeGetLeft () == popa 
          || _pedge[popc].PedgeGetRight () == popa); 
  _pedge[popc].PedgeSetLeft (popx); 
  _pedge[popc].PedgeSetRight (popb); 
  _pedge[pope].PedgeSetLeft (popa); 
  _pedge[pope].PedgeSetRight (popc); 
#if 0 /* SANGCHUL: tree */
  ptree = _poptree;
  pope = ptree[popc].down;
  ptree[popa].down = pope;
  ptree[popa].e = rperiod + 1;
  ptree[popa].time = dnt;
  ptree[popb].down = popc;
  ptree[popb].e = rperiod;
  ptree[popb].time = upt;
  assert (ptree[popc].up[0] == popa || ptree[popc].up[1] == popa); 
  ptree[popc].up[0] = popx;
  ptree[popc].up[1] = popb;
  ptree[pope].up[0] = popa;
  ptree[pope].up[1] = popc;
#endif

  PtreeMakepoptreestring (-1);
  PtreeMakenewickstring (-1);

  /* No change to rootpop */
  /* No change to tvals */

  /* popndown and popnmig were a part of assignment project. We place the same
   * thing under struct Chain. */
  PtreeSetPopndown ();

  /* Search this document for "popnmig tree model" as a reference. I am not sure
   * whether we need this one.  Until then, we turn it off.  
   * In "popmig tree model" we use plist to create and set popnmig.  The memory
   * of the variable changes, and therefore make sure free and malloc.
   * int ***popnmig; --- per period, per popn, list of popn's ---
   */
  /* assert (_popnmig == NULL); */
  PtreeSetPopnmig ();
  return 0;
}

// 
// ptree = new (Ptree(), npops, nloci, iLH)
// ptree = new (Ptree(), npops, nloci, -1, "((((0,1):4,2):5,3):6;")

Ptree::Ptree (int ns, int nl, int iLH, const char * treestring)
{
  Initialize (ns, nl, iLH, treestring);
}

void
Ptree::Initialize (int ns, int nl, int iLH, const char * treestring)
{
  _npops = ns;
  _ngtree = nl;
  _indexLH = iLH;
  if (_indexLH == -1)
    {
      // We parse treestring to create the population tree of it.
      PtreeCreatePoptreestring (_npops, _ngtree, treestring);
    }
  else
    {
      PedgeCreate (_npops, _ngtree, _indexLH);
    }
  _orderedEdge.clear ();
  for (int i = 0; i < 2 * _npops - 1; i++)
    _orderedEdge.push_back (i);

  PtreeAllocTvals ();
  PtreeAllocAddDroppops ();
  PtreeAllocPeriodset ();
  PtreeAllocPlist ();
  PtreeAllocPopndown ();
  PtreeAllocPopnmig ();
  if (_indexLH == -1)
    {
      _indexLH = PtreeGetIofLHistory ();
    }
  PtreeMakenewickstring (-1);
  PtreeMakepoptreestring (-1);

  PtreeBlockMigration ();
}

/* tvals must be recycled when Ptree is destructed. */
void
Ptree::PtreeAllocTvals ()
{
  if (_tvals.size() != size_t (_npops))
    {
      _tvals.resize(_npops);
    }
  for (int pi = _npops; pi < 2 * _npops - 1; pi++)
    {
      _tvals[pi - _npops] = PtreeGetTopTime (pi);
    }
  _tvals[_npops - 1] = IMConstants::TIMEMAX;
  sort (_tvals.begin(), _tvals.end());
  return;
}

/* tvals must be recycled when Ptree is destructed. */
void
Ptree::PtreeSetTvalsToPedge ()
{
  // We assume that internal nodes are ordered in time.
  for (int pi = _npops; pi < 2 * _npops - 1; pi++)
    {
      PtreeSetTopTime (pi, _tvals[pi - _npops]);
    }
  _tvals[_npops - 1] = IMConstants::TIMEMAX;
  return;
}


// We set add and droppops. We also set the b and e of all edges.
void 
Ptree::PtreeAllocAddDroppops () 
{
  int i;
  int j;
  int pi;
  int left;
  int right;
  vector<splitEvent> a; 
  double t;
  vector<splitEvent>::iterator itor;

  for (pi = _npops; pi < 2 * _npops - 1; pi++)
    {
      t = PtreeGetTopTime (pi);
      a.push_back (make_pair(make_pair(pi,pi),t));
    }
  sort (a.begin(), a.end(), DecreasingSplitEvent()); 

  if (_addpop.size() != size_t (_npops + 1))
    _addpop.resize (_npops + 1);
  if (_droppops.size() != size_t (_npops + 1))
    _droppops.resize (_npops + 1);
  for (i = 0; i < _npops + 1; i++)
    {
      if (_droppops[i].size() != 2)
        _droppops[i].resize (2);
    }
  _addpop[0] = -1;
  _droppops[0][0] = -1;
  _droppops[0][1] = -1;
  _addpop[_npops] = -1; /* This was 0. Why? */
  _droppops[_npops][0] = -1; /* This was 0. Why? */
  _droppops[_npops][1] = -1; /* This was 0. Why? */

  for (itor = a.begin(), i = _npops - 1, j = 2 * _npops - 2;
       itor != a.end();
       itor++, i--, j--)
  {
    pi = itor->first.first;
    _addpop[i] = pi;
    left = _pedge[pi].PedgeGetLeft ();
    right = _pedge[pi].PedgeGetRight ();
    _droppops[i][0] = left;
    _droppops[i][1] = right;
    //_pedge[pi].PedgeSetI (j--); // FIXME: ??? I do not ...
    _pedge[pi].PedgeSetB (i);
    if (i == _npops - 1)
      _pedge[pi].PedgeSetE (-1); // root branch ends in nowhere.
    _pedge[left].PedgeSetE (i);
    _pedge[right].PedgeSetE (i);
  }
  return;
}

void
Ptree::PtreeAllocPeriodset ()
{
  int i;
  SET tempset;
  int left;
  int right;
  int node;

  if (_periodset.size() != size_t (_npops))
    _periodset.resize (_npops);

  _periodset[0] = EMPTYSET;
  for (i = 0; i < _npops; i++)
  {
    _periodset[0] = UNION (_periodset[0], SINGLESET (i));
  }
  tempset = _periodset[0];
  for (i = 1; i < _npops; i++)
    {
      left = _droppops[i][0]; 
      right = _droppops[i][1];
      node = _addpop[i];
      tempset = SETREMOVE (tempset, left); 
      tempset = SETREMOVE (tempset, right); 
      tempset = SETADD (tempset, node); 
      _periodset[i] = tempset;
    }
  return;
}

void
Ptree::PtreeAllocPlist () 
{
  int i;
  int k;

  // Need to check!
  /* Set plist. */
  _plist.clear();
  for (i = 0; i < _npops; i++)
    {
      vector<int> a;
      FORALL (k, _periodset[i])
        {
          a.push_back (k);
        }
      _plist.push_back (a);
    }
  return;
}

void
Ptree::PtreeAllocPopndown () 
{
  _popndown.clear();
  assert (_popndown.empty());
  for (int pi = 0; pi < 2 * _npops - 1; pi++)
    {
      vector<int> a(_npops, -1);
      _popndown.push_back (a);
    }
  PtreeSetPopndown ();
  return;
}

void 
Ptree::PtreeSetPopndown ()
{
  int pi;
  int ti;
  int i;
  int prevti;
  int ns;

  ns = _npops;
  for (pi = 0; pi < 2 * ns - 1; pi++)
    {
      for (ti = 0; ti < ns; ti++)
        {
          _popndown[pi][ti] = -1;
        }
    }
  for (prevti = ns - 1; prevti > 0; prevti--)
    {
      ti = prevti - 1; 
      _popndown[_addpop[prevti]][prevti] = _addpop[prevti];
      _popndown[_droppops[prevti][0]][ti] = _droppops[prevti][0];
      _popndown[_droppops[prevti][1]][ti] = _droppops[prevti][1];
      for (i = prevti; i < ns; i++)
        {
          _popndown[_droppops[prevti][0]][i] = 
            _popndown[_addpop[prevti]][i];
          _popndown[_droppops[prevti][1]][i] = 
            _popndown[_addpop[prevti]][i];
        }
      for (i = 0; i < 2 * ns - 1; i++)
        {
          if (i == _droppops[prevti][0] || i == _droppops[prevti][1])
            {
              continue;
            }
          if (ISELEMENT (i, _periodset[ti]))
            {
              _popndown[i][ti] = _popndown[i][prevti];
            }
        }
    }
  return;
}

void
Ptree::PtreeAllocPopnmig ()
{
  //int pi;
  //int qi;
  //int ns;

  _popnmig.clear();
  assert (_popnmig.empty());
  for (int pi = 0; pi < 2 * _npops - 1; pi++)
    {
      vector<int> a;
      _popnmig.push_back (a);
    }
 
  PtreeSetPopnmig ();
  return;
}

void
Ptree::PtreeSetPopnmig () 
{
  int pi;
  int qi;
  int ns;
  int ki;
  //int k;
  int ii;

  ns = _npops;
  _popnmig.clear();
  for (pi = 0; pi < 2 * ns - 1; pi++)
    {
      vector<int> a;
      _popnmig.push_back (a);
    }

  for (pi = 0; pi < ns; pi++)
    {
      for (qi = 0; qi < ns; qi++)
        {
          if (pi == qi)
            {
              continue;
            }
          _popnmig[pi].push_back (qi);
        }
    }
  for (ki = 1; ki < ns - 1; ki++)
    {
      pi = _addpop[ki];
      for (ii = 0; ii < ns - ki; ii++)
        {
          qi = _plist[ki][ii];
          if (pi == qi) 
            {
              continue;
            }
          _popnmig[pi].push_back (qi);
          _popnmig[qi].push_back (pi);
        }
    }
  return;
}

<<Ptree-t.cc>>=
#include <iostream>
#include "imconstants.hh"
#include "Ptree.hh"
//#include "imdef.h"
//#include "imenum.h"
//#define GLOBVARS
//#include "imglobal.h"
//#include "imptools.h"

int main (int argc, char ** argv)
{	
  /* We create Figure 5 of Yang and Rannala (1997). */
  Ptree t;
  
  //t.Initialize (5, 1, -1, "(((0,1):6,2):7,(3,4):5):8;"); // 69
  //t.Initialize (5, 1, 69);

  //t.Initialize (5, 1, -1, "((((0,1):5,3):6,4):7,2):8;"); // 30
  //t.Initialize (5, 1, 30);

  //t.Initialize (5, 1, -1, "((0,1):5,(2,(3,4):6):7):8;"); // 160
  //t.Initialize (5, 1, 160);

  t.Initialize (5, 1, -1, "(2,((3,4):6,(0,1):5):7):8;"); // 40

  std::cout << t << std::endl;


  return 0;
}

@
\subsection{Population tree edge - Pedge.hh}

A class [[Pedge]] has the following roles:

[[n]]: number of total populations or $2 \times npops - 1$ that will be used to
allocate memory of [[mc]], [[fm]], and [[mintegrate]].
<<Pedge.hh>>=
<<im3 copyright>>
///
/// \file Pedge.hh
/// \brief Represents a single population edge of a population tree.
/// 
/// \author Sang Chul Choi
///

#ifndef _PEDGE_HH_
#define _PEDGE_HH_ 

#include <iostream>
#include <vector>
#include "Weight.hh"
#include "Integrate.hh"
#include "EdgeIMParameter.hh"
#include "immath.hh"

using std::vector;

class Pedge {
  friend std::ostream& operator<<(std::ostream& os, const Pedge& p);
  int _i;  // index of this edge
  int _np; // Total number of popualtions including ancestors
  int _ngtree;
  vector<int> _up;
  int _down;
  double _t;
  int _b;
  int _e;
  vector<Weight> _gweight;
  vector<Weight> _holdgweight;
  Integrate _integrate;
  Integrate _holdintegrate;
  EdgeIMParameter _ep;
public:
  
  void setTheta (const int qi, const double x)
  {
    _ep.setTheta (qi, x);
  }

  void proposeTheta (const int qi)
  {
    _ep.propose (qi);
  }

  void revert (const int qi)
  {
    _ep.revert (qi);
  }

  ///////////////////////////////////////////////////////////////
  // EdgeIMParameter's information
  ///////////////////////////////////////////////////////////////
  double getTheta ()
  {
    return _ep.getTheta ();
  }
  double getM (const int qi)
  {
    return _ep.getM (qi);
  }
  EdgeIMParameter * getEp ()
  {
    return &_ep;
  }
  void setNegativeQ ()
  {
    _ep.setNegativeQ ();
  }
  void setNegativeM (const int qi)
  {
    _ep.setNegativeM (qi);
  }


  Pedge () {}
  void Initialize (int id, int ns, int nl);

  ///////////////////////////////////////////////////////////////
  // _pedge's information
  ///////////////////////////////////////////////////////////////
  int PedgeGetNp () { return _np; }
  int PedgeGetLeft () { return _up[0]; }
  int PedgeGetRight () { return _up[1]; }
  int PedgeGetDown () { return _down; }
  double PedgeGetT () { return _t; }
  int PedgeGetB () { return _b; }
  int PedgeGetE () { return _e; }
  int PedgeGetNgtree () { return _ngtree; }
  //int PedgeSetI (int x) { _i = x; }
  void PedgeSetNp (int x) { _np = x; }
  void PedgeSetLeft (int x) { _up[0] = x; }
  void PedgeSetRight (int x) { _up[1] = x; }
  void PedgeSetDown (int x) { _down = x; }
  void PedgeSetT (double x) { _t = x; }
  void PedgeSetB (int x) { _b = x; }
  void PedgeSetE (int x) { _e = x; }


  ///////////////////////////////////////////////////////////////
  // _gweight
  ///////////////////////////////////////////////////////////////
  void setGweightT (const int cc, const double hcc, const double fc)
  {
    _gweight[_ngtree].WeightSetCc (cc);
    _gweight[_ngtree].WeightSetHcc (hcc);
    _gweight[_ngtree].WeightSetFc (fc); 
  }

  void setGweightM (const int qi, const int mc, const double fm)
  {
    _gweight[_ngtree].WeightSetMc (qi, mc);
    _gweight[_ngtree].WeightSetFm (qi, fm); 
  }

  void PedgeWeightReset () 
  {
    for (int i = 0; i < _ngtree + 1; i++)
      {
        _gweight[i].WeightReset ();
      }
    return;
  }

  void PedgeTweightReset () 
  {
    _gweight[_ngtree].WeightReset ();
    return;
  }

  void PedgeGweightReset (int i)
  {
     _gweight[i].WeightReset ();
     return;
  }

  void PedgeGweightCcAddto (int gi, int x)
  {
    _gweight[gi].WeightCcAddto (x);
  }

  void PedgeGweightMcAddto (int gi, int q, int x)
  {
    _gweight[gi].WeightMcAddto (q, x);
  }

  void PedgeGweightFmAddto (int gi, int q, double x)
  {
    _gweight[gi].WeightFmAddto (q, x);
  }

  void PedgeGweightHccAddto (int gi, double x)
  {
    _gweight[gi].WeightHccAddto (x);
  }

  void PedgeGweightFcAddto (int gi, double x)
  {
    _gweight[gi].WeightFcAddto (x);
  }

  int PedgeGetGweightCc (int gi)
  {
    return _gweight[gi].WeightGetCc ();
  }
  
  double PedgeGetGweightHcc (int gi)
  {
    return _gweight[gi].WeightGetHcc ();
  }

  double PedgeGetGweightFc (int gi) 
  {
    return _gweight[gi].WeightGetFc ();
  }

  int PedgeGetGweightMc (int q, int gi)
  {
    return _gweight[gi].WeightGetMc (q);
  }

  double PedgeGetGweightFm (int q, int gi)
  {
    return _gweight[gi].WeightGetFm (q);
  }

  void PedgeStoreGweight (int gi)
  {
    _holdgweight[gi] = _gweight[gi];
  }

  void PedgeRestoreGweight (int gi)
  {
    _gweight[gi] = _holdgweight[gi];
  }

  void PedgeAddGweight (int gi)
  {
    _gweight[_ngtree] += _gweight[gi];
  }

  void PedgeSumSubtractGweight (int gi)
  {
    _gweight[_ngtree] += _gweight[gi];
    _gweight[_ngtree] -= _holdgweight[gi];
  }


  ///////////////////////////////////////////////////////////////
  // _integrate
  ///////////////////////////////////////////////////////////////
  void PedgeStoreIntegrate ()
  {
    _holdintegrate = _integrate;
  }
  void PedgeRestoreIntegrate ()
  {
    _integrate = _holdintegrate;
  }

  double PedgeGetIntegrate (const vector<int> &popnmig) 
  {
    int qi;
    double s;
    s = _integrate.IntegrateGetQ ();

    for (vector<int>::const_iterator i = popnmig.begin(); 
         i != popnmig.end(); 
         i++)
      {
        qi = *i;
        s += _integrate.IntegrateGetM (qi);
      }
    return s;
  }

  double getIntegrateQ () 
  {
    return _integrate.IntegrateGetQ ();
  }

  double getIntegrateM (int qi) 
  {
    return _integrate.IntegrateGetM (qi);
  }

  ///////////////////////////////////////////////////////////////
  // input and output
  ///////////////////////////////////////////////////////////////
  void PedgeWrite (std::ofstream& os, 
                   const int id,
                   const vector<int> &popnmig, 
                   const vector<int> &orderedEdge)
  {
    assert (id == _i);
    _integrate.IntegrateWrite (os, _i, popnmig, orderedEdge);
    _gweight[_ngtree].WeightWrite (os, _i, popnmig, orderedEdge); 
    return;
  }

  void read (std::ifstream& s, 
             const int id,
             const vector<int> &popnmig, 
             const vector<int> &orderedEdge)
  {
    assert (id == _i);
    _integrate.read (s, _i, popnmig, orderedEdge);
    _gweight[_ngtree].read (s, _i, popnmig, orderedEdge); 
    return;
  }

 
  ///////////////////////////////////////////////////////////////
  // _itheta and _imig
  ///////////////////////////////////////////////////////////////

  void setPriorM (const double x)
  {
    for (int qi = 0; qi < _np; qi++)
      {
        _ep.setPriorM (qi, x);
      }
  }

  void setPriorQ (const double x)
  {
    _ep.setPriorQ (x);
  }

  double getThetaPrior (const int qi)
  {
    return _ep.getThetaPrior (qi);
  }

  void PedgeIntegrateProbg (vector<int> &popnmig)
  {
    int c;
    int qi;
    double f;
    double hc;
    double v;
    double qmax;
    double qmin;
    double mmax;
    double mmin;

    c = _gweight[_ngtree].WeightGetCc ();
    f = _gweight[_ngtree].WeightGetFc ();
    hc = _gweight[_ngtree].WeightGetHcc ();
    qmax = _ep.getQMax();
    qmin = _ep.getQMin();

    v = integrate_coalescent_term (c, f, hc, qmax, qmin);
    _integrate.IntegrateSetQ (v);

    //assert (modeloptions[SPLITTINGRATEPARAMETER] == 0);

    for (vector<int>::const_iterator i = popnmig.begin(); 
         i != popnmig.end(); 
         i++)
      {
        qi = *i;
        c = _gweight[_ngtree].WeightGetMc (qi);
        f = _gweight[_ngtree].WeightGetFm (qi);
        mmax = _ep.getMMax (qi);
        mmin = _ep.getMMin (qi);
        v = integrate_migration_term (c, f, mmax, mmin);
        _integrate.IntegrateSetM (qi, v);
      } 
    return;
  }
};

#endif /* _PEDGE_HH_ */

<<Pedge.cc>>=
<<im3 copyright>>
#include <iostream>
#include <vector>
#include "immath.hh"
#include "EdgeIMParameter.hh"
#include "Pedge.hh"

std::ostream&
operator <<(std::ostream& os, const Pedge& p) 
{
  os << p._integrate << std::endl;
  os << p._gweight[p._ngtree] << std::endl;
  return os;
}

void
Pedge::Initialize (int id, int ns, int nl)
{
  _i = id;
  _np = ns * 2 - 1;
  _ngtree = nl;

  _up.resize (2);
  _up[0] = -1;
  _up[1] = -1;
  _b = 0;
  _e = 0;

  _integrate.Initialize (_np);
  _holdintegrate.Initialize (_np);

  _gweight.resize (_ngtree + 1);
  _holdgweight.resize (_ngtree + 1);

  for (int i = 0; i < _ngtree + 1; i++)
    {
      _gweight[i].Initialize (_np);
      _holdgweight[i].Initialize (_np);
    }

  _ep.Initialize (_np);
}

<<Pedge-t.cc>>=
#include <iostream>
#include "Pedge.hh"

int step;
using std::cout;

int main (int argc, char ** argv)
{	
  size_t i;
  Pedge e;

  e.Initialize (7, 7, 7);
  cout << e << std::endl;

  return 0;
}

@
\subsection{Weight.hh}

<<Weight.hh>>=
<<im3 copyright>>
#ifndef _WEIGHT_H_
#define _WEIGHT_H_
#include <vector>
#include <iostream>
#include <algorithm>
#include <cassert>
#include "VectorOperation.hh"

using std::vector;

class Weight {
  friend std::ostream& operator<<(std::ostream& os, const Weight& pt);

  int _n;
  int _cc;
  double _hcc;
  double _fc;
  vector<int> _mc;
  vector<double> _fm;

public:
  Weight ();
  Weight (const Weight &r)
  {
    _cc = r._cc;
    _hcc = r._hcc;
    _fc = r._fc;
    _n = r._n;
    _mc = r._mc;
    _fm = r._fm;
  }

  Weight& operator=(const Weight &r)
  {
    if (&r != this)
      {
        _cc = r._cc;
        _hcc = r._hcc;
        _fc = r._fc;
        _n = r._n;
        _mc = r._mc;
        _fm = r._fm;
      }
    return *this;
  }

  Weight& operator+=(const Weight &r)
  {
    assert (_n == r._n);
    _cc += r._cc;
    _hcc += r._hcc;
    _fc += r._fc;
    transform (_mc.begin(), _mc.end(), r._mc.begin(), 
               _mc.begin(), VectorSum<int>);
    transform (_fm.begin(), _fm.end(), r._fm.begin(), 
               _fm.begin(), VectorSum<double>);
    return *this;
  }

  Weight& operator-=(const Weight &r)
  {
    assert (_n == r._n);
    _cc -= r._cc;
    _hcc -= r._hcc;
    _fc -= r._fc;
    transform (_mc.begin(), _mc.end(), r._mc.begin(), 
               _mc.begin(), VectorDifference<int>);
    transform (_fm.begin(), _fm.end(), r._fm.begin(), 
               _fm.begin(), VectorDifference<double>);
    return *this;
  }



  ///////////////////////////////////////////////////////////////
  // wieght's information
  ///////////////////////////////////////////////////////////////
  void WeightSetCc (int x) { _cc = x; }
  void WeightSetHcc (double x) { _hcc = x; }
  void WeightSetFc (double x) { _fc = x; }
  void WeightSetMc (int i, int x) { _mc[i] = x; }
  void WeightSetFm (int i, double x) { _fm[i] = x; }
  int WeightGetCc () { return _cc; }
  double WeightGetHcc () { return _hcc; }
  double WeightGetFc () { return _fc; }
  int WeightGetMc (int i) { return _mc[i]; }
  double WeightGetFm (int i) { return _fm[i]; }
  void WeightCcAddto (int x) { _cc += x; }
  void WeightFcAddto (double x) { _fc += x; }
  void WeightHccAddto (double x) { _hcc += x; }
  void WeightMcAddto (int q, int x) { _mc[q] += x; }
  void WeightFmAddto (int q, double x) { _fm[q] += x; }
  void WeightReset ()
  {
    _cc = 0;
    _hcc = .0;
    _fc = .0;
    _mc.assign (_n, 0);
    _fm.assign (_n, .0);
  }

  void WeightWrite (std::ofstream& os, const int ii, 
                    const vector<int> &popnmig, 
                    const vector<int> &orderedEdge);
  void read (std::ifstream& s, const int ii, 
             const vector<int> &popnmig, 
             const vector<int> &orderedEdge);
  void Initialize (int np);
};

#endif /* _WEIGHT_H_ */

<<Weight.cc>>=
<<im3 copyright>>
#include <iostream>
#include <fstream>
#include <vector>
#include "Weight.hh"
#include "imptools.hh"

using std::vector;

Weight::Weight ()
  : _n (0), _cc (0), _hcc (.0L), _fc (.0L)
{
  _mc.clear ();
  _fm.clear ();
}

void
Weight::Initialize (int np)
{
  _n = np;
  _mc.resize (np);
  _fm.resize (np);
}

std::ostream&
operator <<(std::ostream& os, const Weight& w) {

  os << "[qc]"
     << "\t" << w._cc 
     << "\t" << w._hcc 
     << "\t" << w._fc;

  for (int i = 0; i < w._n; i++)
    {
      os << "\t[mc-" << i << "]"
         << "\t" << w._mc[i]
         << "\t" << w._fm[i];
    }
 
  return os;
}

void 
Weight::WeightWrite (std::ofstream& os, const int ii, 
                     const vector<int> &popnmig, 
                     const vector<int> &orderedEdge)
{
  int pi = orderedEdge[ii];

  os << "\tqc-" << pi
     << "\t" << _cc 
     << "\t" << _hcc 
     << "\t" << _fc;

  for (vector<int>::const_iterator i = popnmig.begin(); 
       i != popnmig.end(); 
       i++)
    {
      int ji = *i;
      int qi = orderedEdge[ji];

      os << "\tmc-" << pi << ">" << qi 
         << "\t" << _mc[ji]
         << "\t" << _fm[ji];
    }

  return;
}

void 
Weight::read (std::ifstream& is, const int ii, 
             const vector<int> &popnmig, 
             const vector<int> &orderedEdge)
{
  int pi;
  int ji;
  std::pair<int,int> pqi;

  pi = ima::readTiQ (is, "qc");
  assert (pi == ii);
  is >> _cc;
  is >> _hcc;
  is >> _fc;

  for (size_t i = 0; i < popnmig.size(); i++)
    {
      pqi = ima::readTiM (is, "mc");
      assert (pqi.first == ii);
      ji = pqi.second;
      is >> _mc[ji];
      is >> _fm[ji];
    }

  return;
}
<<Weight-t.cc>>=
#include "Weight.hh"

using std::cout;
using std::endl;

int main (int argc, char ** argv)
{	
  Weight w1;

  w1.Initialize (3);

  w1.WeightSetCc (3);
  w1.WeightSetHcc (.5);
  w1.WeightSetFc (3.7);
  w1.WeightSetMc (0, 2);
  w1.WeightSetFm (0, .8);
  //w1.WeightWrite (cout, 4, pM, oE);
  cout << w1 << endl;

  Weight w2;
  w2 = w1;
  cout << w2 << endl;
  w2 -= w1;
  cout << w2 << endl;
  w2 += w1;
  w2 += w1;
  cout << w2 << endl;

  return 0;
}

@
\subsection{Integrate.hh}

<<Integrate.hh>>=
<<im3 copyright>>
#ifndef _INTEGRATE_HH_
#define _INTEGRATE_HH_

#include <iostream>
#include <vector>
#include <cassert>
#include <string>
#include <algorithm>
#include "VectorOperation.hh"

using std::vector;
using std::cout;
using std::string;

class Integrate {
  friend std::ostream& operator<<(std::ostream& os, const Integrate& it);
  double _qintegrate;
  vector<double> _mintegrate;
public:
  Integrate () {};
  Integrate (const Integrate &r) : _qintegrate (r._qintegrate), 
                                   _mintegrate (r._mintegrate) {}
  void Initialize (int n)
  {
    _qintegrate = .0L;
    _mintegrate.assign (n, .0L);
  }
  void IntegrateReset ()
  {
    _qintegrate = .0L;
    transform (_mintegrate.begin(), _mintegrate.end(), 
               _mintegrate.begin(), VectorZero<double>); // Error?
  }

  Integrate& operator=(const Integrate &r)
  {
    if (&r != this)
      {
        _qintegrate = r._qintegrate;
        _mintegrate = r._mintegrate;
      }
    return *this;
  }

  Integrate& operator+=(const Integrate &r)
  {
    assert (_mintegrate.size() == r._mintegrate.size());
    _qintegrate += r._qintegrate;
    transform (_mintegrate.begin(), _mintegrate.end(), r._mintegrate.begin(), 
               _mintegrate.begin(), VectorSum<double>);
    return *this;
  }

  Integrate& operator-=(const Integrate &r)
  {
    assert (_mintegrate.size() == r._mintegrate.size());
    _qintegrate -= r._qintegrate;
    transform (_mintegrate.begin(), _mintegrate.end(), r._mintegrate.begin(), 
               _mintegrate.begin(), VectorDifference<double>);
    return *this;
  }

  double IntegrateGetQ () { return _qintegrate; }
  double IntegrateGetM (int i) { return _mintegrate[i]; }
  void IntegrateSetQ (double x) { _qintegrate = x; }
  void IntegrateSetM (int i, double x) { _mintegrate[i] = x; }

  void IntegrateWrite (std::ofstream& os, 
                       const int ii, 
                       const vector<int> &popnmig, 
                       const vector<int> &orderedEdge);
  void read (std::ifstream& s, 
             const int ii, 
             const vector<int> &popnmig, 
             const vector<int> &orderedEdge);
};

#endif /* _INTEGRATE_HH_ */

<<Integrate.cc>>=
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <utility>
#include "imptools.hh"
#include "Integrate.hh"

using std::string;

std::ostream&
operator <<(std::ostream& os, const Integrate& it) {

  os << "[it]"
     << "\t" << it._qintegrate;

  for (size_t i = 0; i < it._mintegrate.size(); i++)
    {
      os << "\t[mt-" << i << "]"
         << "\t" << it._mintegrate[i];
    }
 
  return os;
}

void 
Integrate::IntegrateWrite (std::ofstream& os, const int ii, 
                           const vector<int> &popnmig, 
                           const vector<int> &orderedEdge)
{
  int pi = orderedEdge[ii];

  os << "\tqt-" << pi << "\t" << _qintegrate;

  for (vector<int>::const_iterator i = popnmig.begin(); 
       i != popnmig.end(); i++)
    {
      int ji = *i;
      int qi = orderedEdge[ji];

      os << "\tmt-" << pi << ">" << qi
         << "\t" << _mintegrate[ji];
    }
 
  return;
}

void 
Integrate::read (std::ifstream& is, const int ii, 
                 const vector<int> &popnmig, 
                 const vector<int> &orderedEdge)
{
  int ji;
  std::pair<int,int> pqi;

  // We already have read in qt-xxx.
  is >> _qintegrate;

  for (size_t i = 0; i < popnmig.size(); i++)
    {
      pqi = ima::readTiM (is, "mt");
      assert (pqi.first == ii);
      ji = pqi.second;
      is >> _mintegrate[ji];
    }

  return;
}


<<Integrate-t.cc>>=
#include "Integrate.hh"

using std::endl;
using std::cout;
int main (int argc, char ** argv)
{	
  Integrate w1;

  w1.Initialize (3);

  w1.IntegrateSetQ (3.0);
  w1.IntegrateSetM (0, 2.0);
  cout << w1 << endl;

  Integrate w2;
  w2 = w1;
  cout << w2 << endl;
  w2 -= w1;
  cout << w2 << endl;
  w2 += w1;
  w2 += w1;
  cout << w2 << endl;


  return 0;
}

@
\subsection{EdgeIMParameter.hh}
<<EdgeIMParameter.hh>>=
<<im3 copyright>>
#ifndef _EDGEPARAMETER_HH_
#define _EDGEPARAMETER_HH_
#include <iostream>
#include <vector>
#include "IMParameter.hh"

using std::vector;

class EdgeIMParameter {
  friend std::ostream& operator<<(std::ostream& os, const EdgeIMParameter& e);
  IMParameter _theta;
  vector<IMParameter> _m;
public:
  EdgeIMParameter (const int n = 1) 
    : _theta ()
  {
    _m.clear ();
    for (int i = 0; i < n; i++)
      {
        IMParameter p;
        _m.push_back (p);
      }
  }
  EdgeIMParameter (const EdgeIMParameter &r) : _theta (r._theta), _m (r._m) {}
  EdgeIMParameter& operator=(const EdgeIMParameter &r)
  {
    if (&r != this)
      {
        _theta = r._theta;
        _m = r._m;
      }
    return *this;
  }

  void Initialize (const int n)
  {
    _m.resize (n);
  }

  void setTheta (const int qi, const double x) 
  { 
    if (qi == -1)
      _theta.setV (x); 
    else
      _m[qi].setV (x);
  }

  void setTheta (const IMParameter &x) { _theta = x; }
  void setM (const vector<IMParameter> &x) { _m = x; }
  void setM (const int qi, const IMParameter &x) { _m[qi] = x; }
  double getTheta () { return _theta.getV (); }
  double getM (const int i) { return _m[i].getV (); }

  void setNegativeQ () { _theta.setV (-1.0L); }
  void setNegativeM (const int qi) { _m[qi].setV (-1.0L); }

  void setPriorQ (const double u, const double l = .0L, const double w = .2L) 
  {
    _theta.setMax (u); 
    _theta.setMin (l); 
    _theta.setWidth ((u - l)*w); 
  }

  void setPriorM (const int qi, const double u, const double l = .0L, 
                  const double w = .2L) 
  {
    _m[qi].setMax (u); 
    _m[qi].setMin (l); 
    _m[qi].setWidth ((u - l)*w); 
  }

  double getThetaPrior (const int qi) 
  {
    if (qi == -1)
      return _theta.getMax ();
    else
      return _m[qi].getMax ();
  }

  double getQMax ()
  {
    return _theta.getMax ();
  }

  double getQMin ()
  {
    return _theta.getMin ();
  }

  double getMMax (const int qi)
  {
    return _m[qi].getMax ();
  }

  double getMMin (const int qi)
  {
    return _m[qi].getMin ();
  }

  void propose (const int qi)
  {
    if (qi == -1)
      _theta.propose ();
    else
      _m[qi].propose ();
  }

  void revert (const int qi)
  {
    if (qi == -1)
      _theta.revert ();
    else
      _m[qi].revert ();
  }
};
#endif /* _EDGEPARAMETER_HH_ */

<<EdgeIMParameter.cc>>=
#include <iostream>
#include <algorithm>
#include "EdgeIMParameter.hh"
#include "VectorOperation.hh"

using std::endl;

std::ostream&
operator <<(std::ostream& os, const EdgeIMParameter& e)
{
  os << e._theta;
  os << "m:\n";
  for_each (e._m.begin(), e._m.end(), PrintVector<IMParameter>());
  os << endl;
  return os;
}

<<EdgeIMParameter-t.cc>>=
#include "EdgeIMParameter.hh"

int main (int argc, char* argv[])
{
  EdgeIMParameter e(2);

  IMParameter a(0, -1, 1);
  e.setTheta (a); 

  a.initialize (0, 1, 3);
  e.setM (0, a);

  a.initialize (0, 2, 7, 1);
  e.setM (1, a);

  std::cout << e;
  
  return 0;
}

@
\subsection{IMParameter.hh}

<<IMParameter.hh>>=
<<im3 copyright>>
#ifndef _PARAMETER_HH_
#define _PARAMETER_HH_
#include <iostream>
#include "imrng.hh"

class IMParameter {
  friend std::ostream& operator<<(std::ostream& os, const IMParameter& p);
  int _pi;       // population index
  int _qi;       // -1 for theta, nonnegative for migration
  double _v;     // current value
  double _vhold;
  double _min;   // minimum of the prior of the parameter
  double _max;   // maximum of the prior of the parameter
  double _width; // width of the proposal
public:
  IMParameter () 
    : _pi (0), _qi (-1), _min (.0L), _max (1.0L), _width (_max/10.0) 
  {
    _v = uniform() * (_max - _min);
  }
  IMParameter (int pi, int qi, double max, double min = 0) 
    : _pi (pi), _qi (qi), _min (min), _max (max), _width ((max - min)/10.0) 
  {
    _v = uniform() * (_max - _min);
  }
  IMParameter (const IMParameter &r) : _pi (r._pi), 
                                   _qi (r._qi),
                                   _v (r._v),
                                   _vhold (r._vhold),
                                   _min (r._min),
                                   _max (r._max),
                                   _width (r._width) {}
  void initialize (int pi, int qi, double max, double min = 0) 
  {
    _v = uniform() * (_max - _min);
    _pi = pi;
    _qi = qi;
    _min = min;
    _max = max;
    _width = (max - min)/10.0;
  }
  IMParameter& operator=(const IMParameter &r)
  {
    if (&r != this)
      {
        _pi = r._pi;
        _qi = r._qi;
        _v = r._v;
        _vhold = r._vhold;
        _min = r._min;
        _max = r._max;
        _width = r._width;
      }
    return *this;
  }
  double propose ()
  {
    _vhold = _v;
    _v = (_v - _width / 2.0L) + uniform() * _width;
    while ((_v >= _max) || (_v <= _min))
      {
        if (_v >= _max)
          _v = 2.0 * _max - _v;
        else
          _v = 2.0 * _min - _v;
      }
    return _v;
  }
  void revert ()
  {
    _v = _vhold;
  }
  int getPi () { return _pi; }
  int getQi () { return _qi; }
  double getV () { return _v; }
  double getMin () { return _min; }
  double getMax () { return _max; }
  double getWidth () { return _width; }
  void setPi (int x) { _pi = x; }
  void setQi (int x) { _qi = x; }
  void setV (double x) { _vhold = _v; _v = x; }
  void setMin (double x) { _min = x; }
  void setMax (double x) { _max = x; }
  void setWidth (double x) { _width = x; }
  void print ();
};
#endif /* _PARAMETER_HH_ */

<<IMParameter.cc>>=
<<im3 copyright>>
#include <iostream>
#include "IMParameter.hh"

using std::endl;
using std::cout;

std::ostream&
operator <<(std::ostream& os, const IMParameter& p) 
{
  os << "IMParameter:" << endl
     << "\tpi: " << p._pi << endl
     << "\tqi: " << p._qi << endl
     << "\tv: " << p._v << endl
     << "\tvhold: " << p._vhold << endl
     << "\tmin: " << p._min << endl
     << "\tmax: " << p._max << endl
     << "\twidth: " << p._width << endl;
  return os;
}

void 
IMParameter::print ()
{
  static int i = 0;
  cout << i++ << "\t" << _v << endl;
}

<<IMParameter-t.cc>>=
#include <iostream>
#include "IMParameter.hh"

int main (int argc, char* argv[])
{
  IMParameter p (0, -1, 5);
  for (int i = 0; i < 100000; i++)
    {
      p.propose ();
      if (i % 100 == 0)
        p.print ();
    }
  return 0;
}

@
\subsection{Vector elementwise operation - VectorOperation.hh}

<<VectorOperation.hh>>=
#ifndef _VECTOROPERATION_HH_
#define _VECTOROPERATION_HH_ 
#include <iostream>
#include <vector>

using std::vector;
using std::cout;

#if 0
template <class T>
T
VectorSum (const T a, const T b);

template <class T>
T
VectorDifference (const T a, const T b);

template <class T>
T
VectorZero (const T a);
#endif

template <class elem>
class PrintVector {
public:
  void operator()(const elem &s)
  {
    std::cout << s << "\t";
  }
};

template <class elem>
class PrintVector2 {
public:
  void operator()(const vector<elem> &s)
  {
    std::cout << "\t\t"; 
    for_each (s.begin(), s.end(), PrintVector<elem>());
    std::cout << std::endl;
  }
};


template <class T>
T
VectorSum (const T a, const T b)
{
  return a + b;
}

template <class T>
T
VectorDifference (const T a, const T b)
{
  return a - b;
}

template <class T>
T
VectorZero (const T a)
{
  T b;
  b = a;
  return 0;
}

#endif /* _VECTOROPERATION_HH_ */

<<VectorOperation.cc>>=
#include "VectorOperation.hh"

template <class T>
T
VectorSum (const T a, const T b)
{
  return a + b;
}

template <class T>
T
VectorDifference (const T a, const T b)
{
  return a - b;
}

template <class T>
T
VectorZero (const T a)
{
  return 0;
}

@
\subsection{Prob.hh}

<<Prob.hh>>=
<<im3 copyright>>
#ifndef _PROB_HH_
#define _PROB_HH_
#include <iostream>

class Prob {
  friend std::ostream& operator<<(std::ostream& os, const Prob& pt);
  double _pdg;
  double _probg;
  double _qhidden;
public:
  Prob () : _pdg (.0L), _probg (.0L), _qhidden (.0L) {}
  void ProbReset () { _pdg = .0L; _probg = .0L; }
  void ProbCopy (const Prob &s) { _pdg = s._pdg; _probg = s._probg; }
  void ProbCopyProbgOnly (const Prob &s) { _probg = s._probg; }
  void ProbCopyExceptPdg (const Prob &s) 
  { 
    _probg = s._probg; 
    _qhidden = s._qhidden; 
  }

  double ProbGetPdg () { return _pdg; }
  double ProbGetProbg () { return _probg; }
  double ProbGetQhidden () { return _qhidden; }
  void ProbSetPdg (double x) { _pdg = x; }
  void ProbSetProbg (double x) { _probg = x; }
  void ProbSetQhidden (double x) { _qhidden = x; }
  void ProbPdgAddto (double x) { _pdg += x; }

  double ProbGetPdgAndProbg () { return _probg + _pdg; }
};

#endif /* _PROB_HH_ */

<<Prob.cc>>=
<<im3 copyright>>
#include <iostream>
#include "Prob.hh"

std::ostream&
operator <<(std::ostream& os, const Prob& p) {
  os << "Prob --- " << std::endl;
  os << "Pdg: " << p._pdg << std::endl;
  os << "Probg: " << p._probg << std::endl;
  return os;
}

<<Prob-t.cc>>=
#include "Prob.hh"

int main (int argc, char ** argv)
{	
  Prob p1;
  p1.ProbSetPdg (0.1);
  p1.ProbSetProbg (0.3);
  std::cout << p1 << std::endl;
  return 0;
}

@
\subsection{Iparam.hh}

<<Iparam.hh>>=
<<im3 copyright>>
#include <iostream>
#include <vector>

#ifndef GRIDSIZE
#define GRIDSIZE 1000
#endif

using std::vector;
using std::cout;

class Iparam {
  friend std::ostream& operator<<(std::ostream& os, const Iparam& pt);
  double _min;
  double _max;
  double _mean;
  vector<double> _x;
  vector<double> _y;

public:
  Iparam () 
  {
    _min = 0.0;
    _max = 1.0;
    _mean = 0.5;
    _x.resize (GRIDSIZE);
    _y.resize (GRIDSIZE);
    SetX ();
  }
  Iparam (double min, double max, double mean)
    : _min (min), _max (max), _mean (mean)
  {
    _x.resize (GRIDSIZE);
    _y.resize (GRIDSIZE);
    SetX ();
  }
  Iparam (const Iparam &r)
  {
    _min = r._min;
    _max = r._max;
    _mean = r._mean;
    _x = r._x;
    _y = r._y;
  }
  Iparam& operator=(const Iparam &r)
  {
    int i;
    if (&r != this)
      {
        _min = r._min;
        _max = r._max;
        _mean = r._mean;
        _x = r._x;
        _y = r._y;
      }
    return *this;
  }
  void SetMin (double x) { _min = x; }
  void SetMax (double x) { _max = x; }
  void SetMean (double x) { _mean = x; }
  double GetMin () { return _min; }
  double GetMax () { return _max; }
  double GetMean () { return _mean; }
  void SetX ()
  {
    for (int i = 0; i < _x.size(); i++)
      {
        _x[i] = _min + ((i + 0.5) * (_max - _min)) / double (_x.size());
      }
    return;
  }
};

<<Iparam.cc>>=
<<im3 copyright>>
#include "Iparam.hh"

using std::vector;

std::ostream&
operator <<(std::ostream& os, const Iparam& p) {
  os << "Min: " << p._min << std::endl;
  os << "Max: " << p._max << std::endl;
  os << "Mean: " << p._mean << std::endl;
  os << "Plotpoint: " << std::endl;
  os << "Size: " << p._x.size() << std::endl;
  os << "Values: ";
  for (int i = 0; i < p._x.size(); i++)
    {
      os << "(" << p._x[i] << ", " << p._y[i];
      if (i == p._x.size() - 1)
        {
          os << ")\n";
        }
      else
        {
          os << "), ";
        }
    }
  
  return os;
}


<<Iparam-t.cc>>=
#include "Iparam.hh"

int main (int argc, char ** argv)
{	
  Iparam p;

  std::cout << p;
  return 0;
}


@
\subsection{ParserPoptreestring.hh}
    
<<ParserPoptreestring.hh>>=
<<im3 copyright>>
#ifndef _PARSERPOPTREESTRING_HH_
#define _PARSERPOPTREESTRING_HH_
///
/// \file ParserPoptreestring.hh
/// \brief Parse a string for a population tree.
/// 
/// We parse a string e.g., ((0,1):4,(2,3):5):6 to find the left and right
/// substrings and its corresponding node numbers.
///
/// \author Sang Chul Choi
///

#include <iostream>
class ParserPoptreestring {
  friend std::ostream& operator<<(std::ostream& os, const ParserPoptreestring& cs);
  int left;
  int right;
  int node;
  char * leftstring;
  char * rightstring;
  char * inputstring;
public:
  ParserPoptreestring (const char *);
  ~ParserPoptreestring ();
  int ExtractNodeNumber (char * s);

  int ParserPoptreestringGetLeft () { return left; }
  int ParserPoptreestringGetRight () { return right; }
  int ParserPoptreestringGetNode () { return node; }
  char * ParserPoptreestringGetLeftString () { return leftstring; }
  char * ParserPoptreestringGetRightString () { return rightstring; }
};

#endif /* _PARSERPOPTREESTRING_HH_ */
<<ParserPoptreestring.cc>>=
<<im3 copyright>>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include "ParserPoptreestring.hh"

int ParserPoptreestring::ExtractNodeNumber (char * s)
{
  int l;
  int level;
  int i;
  char * node;

  l = strlen (s);

  level = 0;
  for (i = 0; i < l; i++)
    {
      switch (s[i])
        {
        case '(':
          level++;
          break;
        case ')':
          level--;
          if (level == 0)
            {
              i++;
              continue;
            }
          break;
        }
      if (level == 0)
        {
          node = &s[i];
          break;
        }
    }
  return atoi (node);
}


ParserPoptreestring::ParserPoptreestring (const char * s) {
  int level;
  int i;
  int l;
  int isleft;
  int j;
  char * nodestring;
  int nleft;
  int nright;
  char * comma;

  l = strlen (s);
  inputstring = new char [l + 1];
  strcpy (inputstring, s);

  comma = strstr (inputstring, ",");
  if (comma == NULL)
    {
      left = -1;
      right = -1;
      leftstring = NULL;
      rightstring = NULL;
      node = atoi (inputstring);
      return;
    }

  l = strlen (inputstring);

  leftstring = new char [l + 1];
  rightstring = new char [l + 1];

  level = 0;
  isleft = 1;
  j = 0;
  for (i = 0; i < l; i++)
    {
      switch (inputstring[i])
        {
        case '(':
          level++;
          if (level == 1)
            {
              continue;
            }
          break;
        case ')':
          level--;
          break;
        case ',':
          if (level == 1)
            {
              isleft = 0;
              nleft = j;
              j = 0;
              continue;
            }
          break;
        }
      if (level > 0 && isleft == 1)
        {
          leftstring[j++] = inputstring[i];
        }
      if (level > 0 && isleft == 0)
        {
          rightstring[j++] = inputstring[i];
        }
      if (level == 0)
        {
          nright = j;
          nodestring = &inputstring[i + 2];
          break;
        }
    }
  node = atoi (nodestring);
  leftstring[nleft] = '\0';  
  rightstring[nright] = '\0';
  assert (nleft > 0 && nright > 0);
  left = ExtractNodeNumber (leftstring);
  right = ExtractNodeNumber (rightstring);

  return;
}

ParserPoptreestring::~ParserPoptreestring () {
  delete[] inputstring;
  delete[] leftstring;
  delete[] rightstring;
}

std::ostream&
operator <<(std::ostream& os, const ParserPoptreestring& p) {
  os << "Input: " << p.inputstring << std::endl;
  os << "Left: " << p.leftstring << std::endl;
  os << "Right: " << p.rightstring << std::endl;
  os << "Node #: " << p.node << std::endl;
  os << "Left #: " << p.left << std::endl;
  os << "Right #: " << p.right << std::endl;
  return os;
}

<<ParserPoptreestring-t.cc>>=
#include "ParserPoptreestring.hh"

int main (int argc, char ** argv)
{	
  ParserPoptreestring p ("(((0,1):4,2):5,3):6");
  ParserPoptreestring p2 ("((0,1):4,(2,3):5):6");
  ParserPoptreestring p3 ("(3,7):9");
  ParserPoptreestring p4 ("((0,1):5,((2,3):6,4):7):8");

  std::cout << p << std::endl;
  std::cout << p2 << std::endl;
  std::cout << p3 << std::endl;
  std::cout << p4 << std::endl;

  return 0;
}


@
\section{IMa3 - IMa2 with C++}

\begin{enumerate}
\item [[imdef.h]]
\item [[imenum.h]]
\item [[imstruct.hh]]
\item [[imglobal.h]]
\item [[output.hh]]
\item [[mcmcfiles.hh]]
\item [[swapchains.hh]]
\item [[ginfo.hh]]
\item [[gtree.h]]
\item [[calcprobdata.hh]]
\item [[updatemcparams.hh]]
\item [[updategtreecommon.hh]]
\item [[initialize.hh]]
\item [[buildgtree.hh]]
\item [[autoc.hh]]
\item [[updatetRY.hh]]
\item [[updatetNW.hh]]
\item [[updategenealogy.hh]]
\item [[readata.h]]
\item [[freemem.hh]]
\item [[immath.h]]
\item [[imtools.h]]
\item [[immalloc.h]]
\item [[imalgorithm.h]]
\end{enumerate}

\subsection{imglobal - imglobal.hh}

<<imglobal.hh>>=
<<im3 copyright>>
#ifndef _IMGLOBAL_HH_
#define _IMGLOBAL_HH_ 
#include <vector>
#include <string>
<<imglobal>>
#endif /* _IMGLOBAL_HH_ */

<<imglobal>>=
class IMGlobal
{
public:
  static int npops;
  static int lastperiodnumber;
  static std::vector<std::string> popnames;
};

<<imglobal.cc>>=
#include "imglobal.hh"

std::vector<std::string> IMGlobal::popnames;

@
\subsection{constants - imconstants.hh}

<<imconstants.hh>>=
<<im3 copyright>>
#ifndef _IMCONSTANTS_HH_
#define _IMCONSTANTS_HH_ 
<<imconstants>>
#endif /* _IMCONSTANTS_HH_ */

<<imconstants>>=
class IMConstants 
{
public:
  static const int MAXLOCI;
  static const int MAXCHAINS;
  static const int MAXGENES;
  static const int MAXLENGENENAME; 
  static const int MAXPOPS;
  static const int MAXPERIODS;
  static const int TIMEMAX; 
};

<<imconstants.cc>>=
<<im3 copyright>>
#include "imconstants.hh"

const int IMConstants::MAXLOCI = 200;
const int IMConstants::MAXCHAINS = 1000;
const int IMConstants::MAXGENES = 1000;
const int IMConstants::MAXLENGENENAME = 12;
const int IMConstants::MAXPOPS = 10;
const int IMConstants::MAXPERIODS = IMConstants::MAXPOPS + 1;
const int IMConstants::TIMEMAX = 1000000.0;

@
\subsection{imdef.hh}
<<imdef.hh>>=
<<im3 copyright>>
#ifndef _IMDEF_HH_
#define _IMDEF_HH_
#include <algorithm>
#include <cmath>
<<imdef min max>>
#endif /* _IMDEF_HH_ */

<<imdef min max>>=
#define SQR(a) std::pow((a),2.0L)
#define DMAX(a,b) std::max((a),(b))
#define DMIN(a,b) std::min((a),(b))
#define FMAX(a,b) std::max((a),(b))
#define FMIN(a,b) std::min((a),(b))
#define LMAX(a,b) std::max((a),(b))
#define LMIN(a,b) std::min((a),(b))
#define IMAX(a,b) std::max((a),(b))
#define IMIN(a,b) std::min((a),(b))


<<imdef-t.cc>>=
#include "imdef.hh"

int main (int argc, char ** argv)
{
  
  return 0;
}



@
\subsection{Macros and definitions - imdef.h}

<<imdef.h>>=
<<im3 copyright>>
#ifndef _IMDEF_H_
#define _IMDEF_H_
<<c decls>>
<<c begin decls>>
#include <float.h>
<<imdef conditional compilation>>
<<imdef constant>>
<<c end decls>>
#endif /* _IMDEF_H_ */


<<imdef conditional compilation>>=
#ifdef _MSC_VER
#include <io.h>
#include "msdirent.h"
#include <errno.h>              /* _findfirst and _findnext set errno iff they return -1 so these must be included */
//#elif  __GNUC__
#else /*  */
#include <dirent.h>
#endif /*  */

<<imdef constant>>=
/***********************************************/
/******** SIMPLE DEFINITIONS MACROS ************/
/***********************************************/

/* CONSTANTS */
#define MAXLOCI  200            //100
#define MAXCHAINS 1000          //201

#define MAXGENES 1000
#define MAXLENGENENAME 12       /* a gene name can be up to 10, plus 11-th can be @ for diploid */
#define LENGENENAME 10          /* a gene name can be up to 10 */
#define MAXPOPS  10             // MAXPOPS cannot exceed 10 because the treestring functions assume populations and nodes are represented by single integers
#define MAXPERIODS MAXPOPS+1
#define MAXTREEPOPS  (2*MAXPOPS - 1)
#define FNSIZE    500           // max file name length
#define POPTREESTRINGLENGTHMAX  100
#define NAMELENGTH 151          // max length of population names
#define MAXLINKED 15            // largest number of linked loci with the same genealogy - each neads its own mutation rate
#define TIMEMAX 1000000.0       // no branch can have a bottom time greater than this
#define MINPARAMVAL 0.0000001   //0.0001      // smallest parameter value for parameters that are in the MCMC
#define STARTMIGMAX 1000        /* max number per edge when trees are first built */
#define ADDMIGMAX 1000          /* max of number of mirgrations that can be added by poisson generator */
#define ABSMIGMAX  5000         /* absolute maximum # of migration events allowed  -  is 5000 too large? */
#define PARAMSTRLEN  12         /* length of string of parameter name */
#define PARAMSTRLENSHORT  7     /* length of string of parameter name */
#define UPDATELABELLEN 18       /* length of string for an update name */
#define MPRIORMIN 0.000001      /* small value for setting upper bound on migration to (near) zero */
#define BFMPRIORMIN 1.01        /* small value for setting upper bound on migration to (near) zero */
#define KAPPAMAX  100           /* maximum value of HKY parameter */

/* changed this from 20 to 5 on 4/3/08 */
#define MIGINC 5                // 20 /* number of possbile migration events to add to branch migration array at a time */
#define DEFCHAINS  1            // default # chains
#define RECORDINTDEFAULT 10     // default # of steps between recording values of things - used to call record()
#define SAVEGENEALOGYDEFAULT 100  // default # of steps between recording information about the genealogies
#define MINSTRLENGTH  4         // minimum allowed number of STR repeats, so users don't use data that doesn't fit 
#define GRIDSIZE 1000           // # of bins in histogram
#define TRENDDIM 500            // number of points saved for the trendline plots
#define MARGIN2DGRIDSIZE 50     // # of bins on each axis in 2D histograms
#define PROFILEGRIDSIZE 50      // 100 //30  // # points along single dimension profile curve
#define MAXGENEALOGIESTOSAVE 300000 // the max to save in ram during a run - some bug,  setting this to 500,000 caseus memory management errors
#define PRINTINTDEFAULT 10000   // default # steps between writing to the screen
#define MAXLOADFILES 500        // max # of files with genealogy information that can be loaded
#define UMAX  10000.0           // highest value for u scalars  - can differ by UMAX^2 fold
#define HMAX  20                // highest value for h scalars, if HMAX=20 it gives a range of ratios for h scalars from 1/20  to 20  (i.e. they can differ by up to 400 fold)
#define DEFAULTBURNTRENDSTEP 10000      // default # steps between writing burn trend file,  if not given on command line
#define TIMEPRIORMULTIPLIER 10  // sets the time priors to be this many times the splitrate prior, when splitrate model is used
#define TIMERECORDPRIORFRAC  0.2        //  used to set the upper limit on the interval over which t values are recorded in the histogram
#define EXPOMIGPLOTSCALE    20 //with exponential prior on migration, this number times the given prior mean value sets peak search interval and plot scale
/* SANGCHUL: Tue Dec 23 15:31:13 EST 2008
 * Large negative values may be appropriate.
 * */
#define REJECTINFINITESITESCONSTANT  -1000000000.0      // just some value not likelily to turn up in a calculation, indicates failure of IS model
#define NUMTARRAYBINS  100      // number of bins for multidimensional peak estimation of splitting times

/* autocorrelation estimation constants */
#define AUTOCTERMS 12           // the number of lag values for which autocorrelations are recorded
#define CHECKAUTOCWAIT 10000   /* 100000 */     // number of steps before recording autocorrelation values
#define AUTOCINT 1000           // interval between measurements for autocorrelations - cannot be changed easily
#define AUTOCNEXTARRAYLENGTH 1000       /*  = (largest value in autoc_checkstep[] divided by AUTOCINT) */
#define AUTOCCUTOFF 100  /*500 */       /* minimum number of measurements to have for autocorrelation before printing results */
#define AUTOCSTEPSCALAR 1//50//5       /* scale over which autocorrelation is measured, 1 means the scale is steps */



/* MACROS  */
#define  MYDBL_MAX DBL_MAX/1e10 // these avoid some over- under-flow issues, I think.  Not used much. May not be necessary
#define  MYDBL_MIN DBL_MIN * 1e10

/* very small value that would rejct any update with stepwise muation model */
#define IM_BESSI_MIN (-1e+100) 
#ifdef _MSC_VER
# define rint(x) floor((x) + 0.5)
#endif /*  _MSC_VER*/

#define POSROUND(a) (long) ((a)+0.5)    // simple rounding to positive integers
#define INTEGERROUND(x) ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))        // simple rounding to integer
#define ODD(a) ( (((a) & 1) == 1) ? 1 : 0 )     /* for nonnegative integers , if odd returns 1, else 0 */
#define FP fprintf(outfile,     // handy way to avoid retyping the same thing again and again
#define SP *fpstri += sprintf(&fpstr[*fpstri],  // used to add text to the long string (called 'fpstr') that goes at the beginning of the output files
//#define SP *fpstri += sprintf(&fpstr[*fpstri],   // same but use a pointer for the length
#define f_close(a)  fclose(a); (a) = NULL       //regular close() does not make the pointer null,  but it is useful to have this set to null
// these was decomisioned  4/16/09 #define err(a,b,c) errr((a),(b),(c),(0),(0))    //usually simplest to call err(), but if more info is needed to close with,  can call errr()
#define XFREE(p) do { free((p)); (p) = NULL; } while(0)

#define LOG10  2.3025850929940456840
#define LOG2 0.69314718055994530941723212146
#define LOG_DBL_MAX 7.0978271289338397e+02

/* these are supposedly bulletproof macros suggested by Melissa Hibnuz
 * but still, do not nest calls to these min and max macros */
static double sqrarg;

#define SQR(a) ((sqrarg=(a)) == 0.0 ? 0.0 : sqrarg*sqrarg)
static double dmaxarg1, dmaxarg2;

#define DMAX(a,b) (dmaxarg1=(a),dmaxarg2=(b),(dmaxarg1) > (dmaxarg2) ? (dmaxarg1) : (dmaxarg2))
static double dminarg1, dminarg2;

#define DMIN(a,b) (dminarg1=(a),dminarg2=(b),(dminarg1) < (dminarg2) ? (dminarg1) : (dminarg2))
static float maxarg1, maxarg2;

#define FMAX(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ? (maxarg1) : (maxarg2))
static float minarg1, minarg2;

#define FMIN(a,b) (minarg1=(a),minarg2=(b),(minarg1) < (minarg2) ? (minarg1) : (minarg2))
static long lmaxarg1, lmaxarg2;

#define LMAX(a,b) (lmaxarg1=(a),lmaxarg2=(b),(lmaxarg1) > (lmaxarg2) ? (lmaxarg1) : (lmaxarg2))
static long lminarg1, lminarg2;

#define LMIN(a,b) (lminarg1=(a),lminarg2=(b),(lminarg1) < (lminarg2) ? (lminarg1) : (lminarg2))
static int imaxarg1, imaxarg2;

#define IMAX(a,b) (imaxarg1=(a),imaxarg2=(b),(imaxarg1) > (imaxarg2) ? (imaxarg1) : (imaxarg2))
static int iminarg1, iminarg2;

#define IMIN(a,b) (iminarg1=(a),iminarg2=(b),(iminarg1) < (iminarg2) ? (iminarg1) : (iminarg2))

/**************/
/* SET MACROS */
/**************/
/* below are some routines for using sets ala pascal.
	I got this from "C reference manual" by Harbison p 175. useful for sets
	of small numbers from 0(inclusive) to the size of an unsigned long
	integer (32, exclusive). A number is in the set if the bit in the place
	position of that number (plus 1, because we permit the number 0 to be in
	the set) is a 1. If the bit is zero then it is not in the set.  Thus
	the numbers 0-31 can be in the set. */
/* any program using this must also declare typedef unsigned long set; */
/* changed to unsigned short to save memory - won't need more than 16 populations */
typedef unsigned int SET;

#define SET_BITS 32             // make sure this is correct for the compiler
#define EMPTYSET   ((SET) 0)    /* produces a SET of value 0 */
#define ISEMPTY(setj)  ((setj) == 0)    /*true if setj has no elements */
#define SINGLESET(i)  (((SET) 1) << (i))        /* makes a set of the integer i */
#define SETADD(setj,i)  ((setj) | SINGLESET (i))        /* setj with i added to it */
#define ISELEMENT(i,setj)   (SINGLESET((i))  & (setj) ) /*true if i in the setj */
#define INTERSECT(set1,set2)   ((set1) & (set2))
#define UNION(set1,set2)   ((set1) | (set2))
#define SETDIFF(set1,set2)   ((set1) ^ (set2))
#define SETREMOVE(setj,i)  ((setj) ^ SINGLESET(i))      /* setj with i removed from it , be sure that is is aleady in it */

#define NUMSPECIES 9
#define FOR(i,n) for((i) = 0; (i) < (n); (i)++)

#define FORALL(i,setj) \
  for ((i) = 0; (i) < SET_BITS; ++(i)) \
  if (ISELEMENT ((i), (setj)))

      /* forall : permits an action to be applied to all members of a set
         for example
         int k;
         forall(k,z) printf("%d ",k);   */

#define GETLOW(setj)  ( (setj) & -(setj) )
      /*returns the lowest member of the set, as a set 
         can be used in conjuntion with setdiff to reduce sets an item at a time */

/* Macro LogDiff approximately computes the value of v of the following
 * equation:
 * exp(v) = exp(a) - exp(b) 
 * where a > b. */
#define LogDiff(v,a,b) \
    if ((a) <= (b)) \
      IM_err (IMERR_LOGDIFF, " inside LogDiff() macro, a %lf  b %lf",(a),(b)); \
    if ((a) - (b) < 7.0978271289338397e+02) \
      (v) = (b) + log (exp ((a) - (b)) - 1.0); \
    else \
      (v) = (a)

/* Macro LogSum2 approximately computes the value of v of the following
 * equation:
 * exp(v) = exp(a) + exp(b) */
#define LogSum2(v,a,b) \
    if ((a) > (b)) \
      if ((a) - (b) < 7.0978271289338397e+02) \
        (v) = (b) + log (exp ((a) - (b)) + 1.0); \
      else \
        (v) = (a); \
    else \
      if ((b) - (a) < 7.0978271289338397e+02) \
        (v) = (a) + log (exp ((b) - (a)) + 1.0); \
      else \
        (v) = (b)

<<imset.hh>>=
<<im3 copyright>>
#ifndef _IMSET_HH_
#define _IMSET_HH_
<<imset macro>>
#endif /* _IMSET_HH_ */

<<imset macro>>=
/**************/
/* SET MACROS */
/**************/
/* below are some routines for using sets ala pascal.
	I got this from "C reference manual" by Harbison p 175. useful for sets
	of small numbers from 0(inclusive) to the size of an unsigned long
	integer (32, exclusive). A number is in the set if the bit in the place
	position of that number (plus 1, because we permit the number 0 to be in
	the set) is a 1. If the bit is zero then it is not in the set.  Thus
	the numbers 0-31 can be in the set. */
/* any program using this must also declare typedef unsigned long set; */
/* changed to unsigned short to save memory - won't need more than 16 populations */
typedef unsigned int SET;

#define SET_BITS 32             // make sure this is correct for the compiler
#define EMPTYSET   ((SET) 0)    /* produces a SET of value 0 */
#define ISEMPTY(setj)  ((setj) == 0)    /*true if setj has no elements */
#define SINGLESET(i)  (((SET) 1) << (i))        /* makes a set of the integer i */
#define SETADD(setj,i)  ((setj) | SINGLESET (i))        /* setj with i added to it */
#define ISELEMENT(i,setj)   (SINGLESET((i))  & (setj) ) /*true if i in the setj */
#define INTERSECT(set1,set2)   ((set1) & (set2))
#define UNION(set1,set2)   ((set1) | (set2))
#define SETDIFF(set1,set2)   ((set1) ^ (set2))
#define SETREMOVE(setj,i)  ((setj) ^ SINGLESET(i))      /* setj with i removed from it , be sure that is is aleady in it */

#define NUMSPECIES 9
#define FOR(i,n) for((i) = 0; (i) < (n); (i)++)

#define FORALL(i,setj) \
  for ((i) = 0; (i) < SET_BITS; ++(i)) \
  if (ISELEMENT ((i), (setj)))

      /* forall : permits an action to be applied to all members of a set
         for example
         int k;
         forall(k,z) printf("%d ",k);   */

#define GETLOW(setj)  ( (setj) & -(setj) )
      /*returns the lowest member of the set, as a set 
         can be used in conjuntion with setdiff to reduce sets an item at a time */


@
\subsection{Enumerations - imenum.h}

<<imenum.h>>=
<<im3 copyright>>
#ifndef _IMENUM_H_
#define _IMENUM_H_
<<c decls>>
<<c begin decls>>
<<imenum>>
<<c end decls>>
#endif /* _IMENUM_H_ */

<<imenum>>=
/******************************************/
/****** ENUMERATED THINGS ************/
/******************************************/
/*  jhey personal options using -jh flag
	SWINPUTOPTION   alternate way of inputing SW data when there is just one SW portion for a given genealogy 
    WRITEMIGRATIONNAME  -jh1filename  (i.e. the numberid symbol for WRITEMIGRATIONNAME is immediately followed by 
    two integers,  the from and to population numbers,  and then immediately followed by the filename.
    e.g. '-jh104migrate0to4.out')
    */
enum
{ SWINPUTOPTION = 0,WRITEMIGRATIONNAME=1,JHOPTIONNUMBER };

/* assignment related options 
 * Usage:
 *   -a1: assignment only
 *   -a2: DNA barcoding only
 *   -a1 -j6 : Assignment with no-migration
 *   -a2 -j6 : DNA Barcoding with no-migration
 *   -a13 : Assignment with island model
 *   -a23 : DNA Barcoding with island model
 *
 *   -a12: relabel update of assignment with population tree model
 *   -a012: turn on checking genealogy integrity additional to option 1,2
 *   -a124: print assignment proportion of a single unknown gene
 *   -a125: relabel update of assignment with island model
 *   -a127: print out the STRUCTURAMA input file additional to option 1,2
 * assignmentoptions[POPULATIONASSIGNMENT_NUMBER + 1];
 * POPULATIONASSIGNMENTASN
 * POPULATIONASSIGNMENTBAR
 *
 * POPULATIONASSIGNMENTCHECKPOINT: turns on genealogy integrity checks,
 * POPULATIONASSIGNMENT: turns on assignment,
 * POPULATIONASSIGNMENTRELABEL: relabel update
 * POPULATIONASSIGNMENTBF: Beerli and Felsenstein update
 * POPULATIONASSIGNMENTASSIGNED: for DNA Barcoding (only with single-locus data)
 * POPULATIONASSIGNMENTINFINITE: Island model
 * PRINTSTRUCTURAMA: generates an input file for Structurama */
enum
{
  POPULATIONASSIGNMENTCHECKPOINT     = 0,
  POPULATIONASSIGNMENTASN            = 1,
  POPULATIONASSIGNMENTBAR            = 2,
  POPULATIONASSIGNMENTINFINITE       = 3,
  POPULATIONASSIGNMENT               = 4,
  POPULATIONASSIGNMENTRELABEL        = 5,
  POPULATIONASSIGNMENTBF             = 6,
  POPULATIONASSIGNMENTASSIGNED       = 7,
  POPULATIONASSIGNMENTLOCAL          = 8,
  PRINTSTRUCTURAMA                   = 9,
  JCMODEL                            = 10,
  POPULATIONTREEWCH                  = 11,
  POPULATIONASSIGNMENT_NUMBER
};

/* assignment related options 
 * Usage:
 *   --with-tree-inference: we infer population tree.
 *   --outgroup
 */
enum
{
  POPULATIONTREE = 1,
  POPULATIONTREEOUTGROUP,
  POPULATIONTREEBDPRIOR,
  POPULATIONTREE_NUMBER
};

/* imcmdoptions
 * It is for handling long optoins of a command line, e.g., --beta 0.7
 */
enum
{
  IMCMD_BETA,                /* --beta: a beta value for a heated chain. It requires Hfp == 0 */
  IMCMD_GBETA,               /* --gbeta: the global beta value for model comparison. */
  IMCMD_TRUE_ASSIGNMENT,     /* --true-assignment . */
  IMCMD_NLOCI,               /* --nloci . */
  IMCMD_LOCUS,               /* --locus. */
  IMCMD_TPT,                 /* --three-point-turn. */
  IMCMD_SAMPLE_PHYLOGENY,    /* --sample-phylogeny */
  IMCMD_WITH_TREE_INFERENCE, /* --with-tree-inference */
  IMCMD_OUTGROUP,            /* --outgroup */
  IMCMD_WITH_BD_PRIOR,       /* --with-bd-prior */
  IMCMD_NUMBER 
};

/* calcoptions -c
    DONTCALCLIKELIHOODMUTATION - don't calculate p(Data|G)  if set to 1 then data likelihood functions return a constant
	MUTATIONPRIORRANGE - include pior ranges on mutation rate scalrs, as included in input file
    FINDJOINTPOSTERIOR - find joint posterior for full model and/or nested models loaded in nestedmodelfile
    USEPRIORFILE - read a file with prior's for each parameter 
    CALCLEVINELIKELIHOOD  calculate the likelihood of diploid genotypes using levene's formula
*/
enum
{ 
  DONTCALCLIKELIHOODMUTATION = 0, 
  MUTATIONPRIORRANGE = 1,
  FINDJOINTPOSTERIOR = 2,
  USEPRIORFILE = 3,
  CALCLEVINELIKELIHOOD=4,
  CALOPTIONSNUMBER = 5
  /*, FINDJOINTPEAK, PRINTPEAKFINDDETAILS */  
};

/*  modeloptions  using the -j flag
    SPLITTINGRATEPARAMETER
	NOMIGBETWEENNONSISTERS  - set migration to zero between non-sister populations
	SINGLEMIGRATIONBOTHDIRECTIONS
	MIGRATIONBETWEENSAMPLED  - migration only between sampled populations
	ADDGHOSTPOP - add a non-sampled ghost population to the model 
	PARAMETERSBYPERIOD  - every population size and migratino parameter applies for only 1 period
	NOMIGRATION  - no migration
	EXPOMIGRATIONPRIOR - exponential distribution on migration prior -m gives mean value 
    ANCESTRALPOPSIZESSETTOLARGESTSAMPLED - ancestral population size parameter is set to be the same as its largest sampled descendant population
	SINGLEPOPULATION - single population, no migration, no population tree, just a single theta
     ---> replaced by npops == 1
	*/
enum
{ 
  SPLITTINGRATEPARAMETER = 0, 
  NOMIGBETWEENNONSISTERS, 
  SINGLEMIGRATIONBOTHDIRECTIONS,
  MIGRATIONBETWEENSAMPLED, 
  ADDGHOSTPOP, 
  PARAMETERSBYPERIOD,
  NOMIGRATION, 
  EXPOMIGRATIONPRIOR, 
  ANCESTRALPOPSIZESSETTOLARGESTSAMPLED,
  MODELOPTIONSNUMBER
};


/* outputoptions -p
   DONTPRINTASCIITREND - don't print ascii trend lines
   DONTPRINTASCIICURVE - don't print ascii curves
   PRINTTMRCA - print a table of the TMRCA distribution 
   PRINTDEMOGHIST - print out distributions on demographic scales - requires mutation rates and generation times 
   THISTDIVIDEBYPRIOR - print histogram table of splittime values, divided by the prior - only used when splitting rate parameter is not used 
   POPMIGPARAMHIST - print the histograms and plots for the population migration rate parameters 
   PARAMGREATERTHAN - print probabilities of pairwise greater than probabilities 
   MIGRATEHIST - print out distributions of numbers and times of migration events
   PRINTJOINTTEST  - print the joint estimate for splitting times,  for more then 1 splitting time,  not in LOADRUN mode

 
*/
enum
{ 
  DONTPRINTASCIITREND, 
  DONTPRINTASCIICURVE, 
  PRINTTMRCA, 
  PRINTDEMOGHIST,
  THISTDIVIDEBYPRIOR, 
  POPMIGPARAMHIST, 
  PARAMGREATERTHAN,
  MIGRATEHIST,
  PRINTJOINTTEST,
  OUTPUTOPTIONSNUMBER
};


/* runoptions -r 
	LOADRUN  - load genealogy and t information saved in a previous run 
	DONTSAVEGENEALOGIES  - save gtree information for analytical integration  
 SAVEMCSTATEFILE - save the state of the markvon chain in a file
 LOADMCSTATE - load a previously saved markov chain state 
 PRINTMUTATIONUPDATESTOSCREEN - print all of the mutation related updates (scalars, kappas, A values) and values to stdout during the run 
    PRINTBURNTREND - print trend blot during burnin
*/
enum
{ 
  LOADRUN = 0,
  DONTSAVEGENEALOGIES,
  SAVEMCSTATEFILE,
  LOADMCSTATE,
  PRINTMUTATIONUPDATESTOSCREEN,
  PRINTBURNTREND,
  SKIPSTRUCTURAMA, // What is this? 
  RUNOPTIONS_NUMBER
};

/* mutation models 
 * ---------------
 * INFINITESITES
 * HKY
 * STEPWISE    - one or more linked stepwise loci, no IS portion
 * JOINT_IS_SW - one IS portion and one or more STEPWISE portions
 * JC          - Jukes-Cantor model
 */
enum
{ 
  INFINITESITES, 
  HKY, 
  STEPWISE, 
  JOINT_IS_SW,
  JC,
  IM_MODEL_NUMBER
};

/*  different ways that the length of the run can be specified using the '-L' flag
	TIMESTEPS - time counted in # of steps
    TIMEINF  - run until first charcater in 'IMrun' is not 'y' 
	INDEFINITE - used for burnin */
enum
{ 
  TIMESTEPS, 
  TIMEINF, 
  INDEFINITE 
};

/* heating modes */
enum
{ 
  HLINEAR, 
  HTWOSTEP, 
  /*HADAPT,  stop using this option,  general idea is not too bad but it never was fully developed */
  HGEOMETRIC 
};

/* kinds of acceptance of genealogy update */
enum
{
  IM_UPDATE_GENEALOGY_ANY,
  IM_UPDATE_GENEALOGY_TOPOLOGY,
  IM_UPDATE_GENEALOGY_TMRCA,
  /* IM_UPDATE_GENEALOGY_COVAR,  stopped using 12/15/09 JH */ 
  IM_UPDATE_GENEALOGY_NUMBER
};

/* update method of split time */
enum
{
  IM_UPDATE_TIME_NW,
  IM_UPDATE_TIME_RY1,
  IM_UPDATE_TIME_NUMBER
};

/* update method of tree */
enum
{
  IM_UPDATE_TREE_WCH,
  IM_UPDATE_TREE_NUMBER
};

/* update method of assingment */
enum
{
  IM_UPDATE_ASSIGNMENT_RELABEL,
  IM_UPDATE_ASSIGNMENT_BF,
  IM_UPDATE_ASSIGNMENT_NUMBER
};

/* update method of tree inference */
enum
{
  IM_UPDATE_TREE_TPT_TYPE1,
  IM_UPDATE_TREE_TPT_NUMBER
};

/* update method of assingment */
enum
{
  IM_ASSIGNRECORDINTERVAL = 10, /* interval to record assignment: -l# * 10 */
  IM_WINDOWSIZE_ASSIGNSPLITA = 20,      /* window size for changet_A: two periods / 20 */
  IM_WINDOWSIZE_ASSIGNSPLITAO = 10,     /* window size for changet_Ao: two periods / 10 */
  IM_NDELAYASSIGNMENTGENEALOGY = 200,   /* 200 for slide */
  IM_NDELAYASSIGNMENTSPLIT = 1,
  IM_SWD_BOTH = 0,
  IM_SWD_LEFT = 1,
  IM_SWD_RIGHT = 2,
  IM_SWD_NEITHER = 3,
  IM_COPYEDGE_EDGE = 0,
  IM_COPYEDGE_SISEDGE = 1,
  IM_COPYEDGE_DOWNEDGE = 2,
  IM_EDGE_LEFT = 0,
  IM_EDGE_RIGHT = 1,
  IM_EDGE_DOWN = 2,
  IM_MAXTRIES_RELABEL = 100
};

/* IUPAC Nucleotide Code */
enum
{
  DNA_A,
  DNA_C,
  DNA_G,
  DNA_T, /* DNA_U */
  DNA_R, /* A or G */
  DNA_Y, /* C or T */
  DNA_S, /* G or C */
  DNA_W, /* A or T */
  DNA_K, /* G or T */
  DNA_M, /* A or C */
  DNA_B, /* C or G or T */
  DNA_D, /* A or G or T */
  DNA_H, /* A or C or T */
  DNA_V, /* A or C or G */
  DNA_N, /* any base */
  DNA_NUMBER
};

typedef char strn[PARAMSTRLEN];
typedef char strnl[UPDATELABELLEN];

@
\subsection{Structures - imstruct.hh}


<<imstruct.hh>>=
<<im3 copyright>>
#ifndef _IMSTRUCT_H_
#define _IMSTRUCT_H_
#include "imdef.h"
#include "imenum.h"
#include "autoc.hh"
#include "Ptree.hh"
#include "Prob.hh"
#include "gtree.h"
#include "ginfo.hh"
#include "readata.hh"
<<imstruct>>
#endif /* _IMSTRUCT_H_ */

<<imstruct>>=
/******************************************/
/***** STRUCTURES  ************/
/******************************************/

/* extendnum is used for calls to eexp() */
struct extendnum
{
  double m;
  int z;
}; 



struct upairlist
{
  int l;
  int u;
};

typedef struct upairlist im_upairlist;

struct plotpoint                /* (x axis are the possible values,  y axis is the counts) */
{
  double x;
  double y;
};

typedef struct plotpoint im_plotpoint;

struct update_rate_calc
{
  double accp;
  double tries;
};

typedef struct update_rate_calc im_update_rate_calc;

struct acceptancerate
{
  struct update_rate_calc *au_perturb;
};

typedef struct acceptancerate acceptancerate_t;

/* weightposition holds information on which values in the cc, fc, mc 
 * and fm arrays of genealogy_weights to sum for doing the integration */
struct weightposition
{
  int n;                        /* # of terms summed to calculate the weight                 */
  int *p;                       /* period - array of length n                                */
  int *r;                       /* row  - array of length n                                  */
  int *c;                       /* col  - array of length n (only use for migration weights) */
};

typedef struct weightposition im_weightposition;

struct i_param
{
  struct priorvalues pr;
  struct plotpoint *xy;         /* if used points to an array of gridize 
                                 * elements, each a plotpoint */
  strn str;
  int b;                        /* period when this parameter first appears */
  int e;                        /* period when this ends */
  struct weightposition wp;     /* info on where the weights are for 
                                 * calculating the integration */
};

typedef struct i_param im_i_param;

struct popedge
{
  int numup;                    /* number of descendant nodes                 */
  int *up;                      /* the > 2 identities of the descendant nodes */
  int down;                     /* the down node                              */

  /* int ti; the time interval at the bottom of the branch    */
  double time;                  /* the time on the branch to the down node    */
  int b;                        /* time period in which the population starts */
  int e;                        /* time period that begins where the population 
                                 * ends, e > b    e == -1  if the population is 
                                 * the root */
};

typedef struct popedge im_popedge;



typedef struct genealogy_weights im_genealogy_weights;

/* renamed form struct locus to struct genealogy  on 1/9/09
 moved a bunch of stuff out to the new struct locus

*gtree  pointer to the genealogy
root - edge number of root 
mignum - current # of migration events in gtree
roottime - time of root
length - length of gtree
tlength -  length of gtree for part with time < t
pdg - current total P(X|G)
pdg_a array of P(X|G) for each part of locus
plg - current total P(D|G)
*gtree  pointer to array of branch info
genealogy_weights - array of info that is saved when the genealogy is sampled
pi - used for HKY model
*/

struct genealogy
{
  /* genealogy stuff - different for each chain */
  struct edge *gtree;
  int root;             /* Should be updated in each genealogy update.                            */
  int mignum;           /* Is computed in treeweight.                                             */
  double roottime;      /* Should be updated in each genealogy update.                            */
  double length;        /* Is computed in treeweight.                                             */
  double tlength;       /* Is computed in treeweight.                                             */
  double pdg;           /* the total probability of the data given the genealogy (sum of pdg_a)   */
  //double plg;           /* the total probability of diploid given the genealogy                   */
  double *pdg_a;        /* points to an array of of length nlinked  used for multiple linked loci */
  double *uvals;        /* points to an array of length nlinkded - the mutation scalar values     */
  double kappaval;      /* value of HKY parameter if needed */
  double pi[4];         /* for HKY model */
  double hilike;
  struct genealogy_weights gweight;
  double asn;
  int *mut;

#if 0
  /* This is for computing Levine's likelihood. */
  UByteP *Pi;
  UByteP *N;
  UByteP *Nl;
  UByteP *Nr;
  UByteP **UV;
  UByteP **Ui;
  UByteP **Vi;
  UByteP **Ni;
  UByteP **Ri;
  UByteP **Zi;
  UByteP **URi;
#endif
};

typedef struct genealogy im_genealogy;

struct chain
{
#if 0 /* SANGCHUL: tree - ptree is used for most of chain members. */
  char poptreestring[POPTREESTRINGLENGTHMAX];
  char * newickstring; /* the Newick formatted string */
  size_t nnewickstring;
  SET periodset[MAXPERIODS];
  int addpop[MAXPERIODS];
  int droppops[MAXPERIODS][2];
  int **plist;
  int **popndown; /* for assignment and population tree */
  int ***popnmig; /* per period, per popn, list of popn's */
  struct popedge *poptree;
  int rootpop;
  double *tvals;                // array of time values
  char name[10];                /* chain name or id */

  struct genealogy_weights allgweight;  // accumulated stuff used to calculate p(G) 
  struct probcalc allpcalc;     // prob(Data|G,T) and prob(G|T) stuff

  // removed  1/9/09
  //struct mc_param *t;           // array of split time info
  // added 1/9/09  just a simple array of time splittimes 
#endif

  char name[10];                /* chain name or id */
  Ptree ptree;  /* Population tree: tau (topology) and t (divergence time) */
  struct genealogy *Gh; /* points to an array of hidden genealogy          */
  struct genealogy *G;  /* points to an array of genealogy                 */
                /* genealogy, kappa, u, pdg for each unlined locus         */
  Prob prob;  /* pdg and probg */
  Prob holdprob;  /* pdg and probg */

  double bdr;   /* mu/lambda                                               */
  double bdx;   /* 1/(lambda - mu)                                         */
  /* ASSIGNMENT: nasn - the number of individuals assigned to populations. */
  int *nasn;
};

typedef struct chain im_chain;


@
\subsection{Global variables - imglobal.h}

<<imglobal.h>>=
<<im3 copyright>>
#ifndef _IMGLOBAL_H_
#define _IMGLOBAL_H_
<<c decls>>
<<c begin decls>>
<<imglobal variables>>
<<c end decls>>
#endif /* _IMGLOBAL_H_ */

<<imglobal struct variables>>=
#ifdef GLOBVARS
#define gextern
#else /*  */
#define gextern extern
#endif /*  */

gextern struct i_param *itheta;
gextern struct i_param *imig;
gextern struct i_param isplit;
gextern struct chain **C;       //points to an array of pointers to chains 

//added 3/10/09: r=lambda-mu ~ Uniform(0,1), and x=mu/lambda ~ 1/Uniform(0,100)
// chainstate_record_updates_and_values contains value_record.
struct chainstate_record_updates_and_values *gBDr;
struct chainstate_record_updates_and_values *gBDx;
//struct chainstate_record_updates_and_values *gBDlambda;
//struct chainstate_record_updates_and_values *gBDmu;
//added 1/9/09 
struct chainstate_record_updates_and_values *T;
//added 1/9/09 
im_chainstate_updateonly *Cupinf;
struct locus *L;
        // record for likelihood measurements
struct value_record *lpgpd_v;
  // used if outputoptions[MIGRATEHIST]
struct value_record **migration_counts_times;
//added 3/17/09
gextern struct weightposition nomigrationchecklist;
gextern struct extendnum *eexpsum; 
gextern struct upairlist ul[2 * MAXLOCI];       /* listing of mutation rate scalars  not clear how big to make it,  because not clear how many portions each locus will have */


<<imglobal variables>>=
/******************************************/
/*******     GLOBAL VARIABLES     *********/
/******************************************/

/* SC: I would like to prefix global variable names with `g' later. */
 
/* if GLOBVARS is defined then gextern is ignored. This
causes the corresponding variable declarations to be definitions.
GLOBVARS is only defined in front.c.  If GLOBVARS is not defined,
as is the case at the beginning of the other files, then gextern
gets replaced by extern and the variable declarations are simply
declarations */

#ifdef GLOBVARS
#define gextern
#else /*  */
#define gextern extern
#endif /*  */

#ifdef GLOBVARS
gextern char popnames[IMConstants::MAXPOPS][NAMELENGTH];
#else
gextern char popnames[][NAMELENGTH];
#endif
gextern int lastgenealogysaved; 
gextern double thetaprior, mprior, splitprior, tprior;
gextern double tperiodpriors[IMConstants::MAXPOPS-1];
gextern int step;
gextern int nurates;
gextern int nkappas; 
gextern int numchains;
gextern int nloci;
gextern int npops;
gextern int numtreepops;        /* number of distinct populations in the tree */
gextern int numpopsizeparams;   /* number of distinct population size parameters in the model */
gextern int nummigrateparams;   /* number of distinct migration rate parameters in the model */
gextern int imcmdoptions[IMCMD_NUMBER];
gextern int jheyoptions[JHOPTIONNUMBER];
gextern int assignmentoptions[POPULATIONASSIGNMENT_NUMBER];
gextern int treeoptions[POPULATIONTREE_NUMBER];
gextern int modeloptions[MODELOPTIONSNUMBER];
gextern int calcoptions[CALOPTIONSNUMBER];
gextern int outputoptions[OUTPUTOPTIONSNUMBER];
gextern int runoptions[RUNOPTIONS_NUMBER];
gextern double beta[MAXCHAINS];
gextern double gbeta;
gextern double gloglikelihood;
gextern double glogprobg;
gextern int genealogiessaved;
gextern int somestepwise;
gextern int countuprior;
gextern int counturateperyear;
gextern int lastperiodnumber;   // just numsplittimes, but it comes up a lot 
gextern int numsplittimes;      // same as lastperiodnumber, but it comes up a lot
gextern float **gsampinf;
/* position markers for gsampinf */
gextern int gsamp_ccp;
gextern int gsamp_fcp;
gextern int gsamp_hccp;
gextern int gsamp_mcp;
gextern int gsamp_fmp;
gextern int gsamp_qip;
gextern int gsamp_mip;
gextern int gsamp_sip;
gextern int gsamp_pdgp;
//gextern int gsamp_plgp;
gextern int gsamp_probgp;
gextern int gsamp_tp;
//gextern struct update_rate_calc *NW_t_upinf;
//gextern struct update_rate_calc *RY2_t_upinf;
gextern double logfact[100 * ABSMIGMAX + 1];
/* g for global and i for integer type */
gextern int gi_largestngenes; /* the largest number of genes among all loci */
gextern int gi_largestnumsites; /* the largest number of sites among all loci */
gextern int total_numgenes;  /* sum of sample sizes across all loci */ 


@
\subsection{IM Math - immath.h}

<<immath.hh>>=
<<im3 copyright>>
#ifndef _IMMATH_HH_
#define _IMMATH_HH_
<<immath header>>
#endif /* _IMMATH_HH_ */

<<immath header>>=
double integrate_coalescent_term (int cc, double fc, double hcc,
                                         double max, double min);
double integrate_migration_term (int cm, double fm, double max,
                                        double min);
double mylogcosh (double x);
double mylogsinh (double x);
double bessi (int n, double x);
double expint (int n, double x, int *islog);
double uppergamma (int a, double x);
double lowergamma (int a, double x);
void setlogfact (void);

<<immath.cc>>=
double 
integrate_coalescent_term (int cc, double fc, double hcc,
                           double max, double min)
{
  return .0L;
}

double integrate_migration_term (int cm, double fm, double max,
                                        double min)
{
  return .0L;
}

double mylogcosh (double x)
{
  return .0L;
}

double mylogsinh (double x)
{
  return .0L;
}

double bessi (int n, double x)
{
  return .0L;
}

double expint (int n, double x, int *islog)
{
  return .0L;
}

double uppergamma (int a, double x)
{
  return .0L;
}

double lowergamma (int a, double x)
{
  return .0L;
}

void setlogfact (void)
{
  return;
}


<<immath-t.cc>>=
#include "immath.hh"

int main (int argc, char ** argv)
{
  return 0;
}




<<immath.c>>=
#include <cmath>
#include <cfloat>
#include <cstdlib>
#include <cstring>
#include <cassert>
//#include "imdef.h"
//#include "imtools.h"
#include "immath.hh"
//#include "xtrapbits.h"

#define MORESTABLE

double logfact[100 * ABSMIGMAX + 1];
double loghalffact[50 * ABSMIGMAX];
int BITNUMBERTRUE[256];

extern int step;

static double bessi0 (double x);
static double bessi1 (double x);
static double gammln (double xx);
static void gcf (double *gammcf, double a, double x, double *gln);
static void gcflog (double *gammcflog, double a, double x, double *gln);
static void gser (double *gamser, int a, double x, double *gln);
static void gserlog (double *gamserlog, int a, double x, double *gln);


double
integrate_coalescent_term (int cc, double fc, double hcc, double max,
                           double min)
{                               /* note fc includes inheritance scalar, i.e. it is fc/h  - see treeweight  
                                   the hcc term is cc*log(h) */
  double p;
  double a, b, c, d;
  double ug,lg,ugalt, fullg;
  if (cc > 0)
  {
    assert (fc > 0);
    if (min == 0)
    {
      ug = uppergamma ((int) cc - 1, 2 * fc / max);
      if (cc > 1)
      {
        fullg = logfact[cc-2];
/* if uppergamma is too small or too close to the full integral  (fullg) then use lowergamma */
        if (fullg - ug < 1e-15 || fullg - ug  > 7.0978271289338397e+02)
        {
          lg  = lowergamma ((int) cc - 1, 2 * fc / max);
          if (fullg > lg)
          {
            LogDiff(ugalt,fullg,lg);
            if (fabs(ugalt-ug) > 1e-10)
              ug=ugalt;
          }
        }
      }
      p = ug + LOG2 - hcc + (1 - cc) * log (fc);
    }
    else
    {
#ifdef MORESTABLE
      a = uppergamma ((int) cc - 1, 2 * fc / max);
      b = uppergamma ((int) cc - 1, 2 * fc / min);
      if (a <= b)
        IM_err (IMERR_LOGDIFF, " pos1 in integrate_coalescent_term() cc %d, fc %lf, hcc %lf, max %lf, min %lf, a %lf  b %lf",cc,fc,hcc,max,min,a,b); 
      LogDiff (p, a, b);
      p += (LOG2 - hcc + (1 - cc) * log (fc));
#else
      p = log (exp (uppergamma ((int) cc - 1, 2 * fc / max)) 
               - exp (uppergamma ((int) cc - 1, 2 * fc / min))) 
          + LOG2 - hcc + (1 - cc) * log (fc);
#endif /* MORESTABLE */
    }
  }
  else
  {
    assert (fabs (hcc) < 1e-10);
    if (2 * fc / max > 0)       /* cc == 0 */
    {
      if (min == 0)
      {
//  fc values coming out very large.  this deals with it,  but why so large ????
//  SC: I also hit this error more often than not when I run IMa2 with large 
//      number of loci.  The case is where no coalescent with the population for
//      which we are computing this integrate, and many lineages just pass
//      through it.
#ifdef MORESTABLE
        a = log (max) - 2.0 * fc / max;
        b = LOG2 + log (fc) + uppergamma (0, 2.0 * fc / max);
        if (a <= b)
          IM_err (IMERR_LOGDIFF, " pos2 in integrate_coalescent_term() cc %d, fc %lf, hcc %lf, max %lf, min %lf, a %lf  b %lf",cc,fc,hcc,max,min,a,b); 
        LogDiff (p, a, b);
#else
        p = log (max * exp (-2 * fc / max) - 2 * fc * exp (uppergamma (0, 2 * fc / max)));
#endif /* MORESTABLE */
      }
      else
      {
#ifdef MORESTABLE
        a = uppergamma (0, 2 * fc / max);
        b = uppergamma (0, 2 * fc / min);
        if (a <= b)
          IM_err (IMERR_LOGDIFF, " pos3 in integrate_coalescent_term() cc %d, fc %lf, hcc %lf, max %lf, min %lf, a %lf  b %lf",cc,fc,hcc,max,min,a,b); 
        LogDiff (c, a, b);
        c += LOG2 + log (fc);
        a = log (max) - 2.0 * fc / max;
        b = log (min) - 2.0 * fc / min;
        if (a <= b)
          IM_err (IMERR_LOGDIFF, " pos4 in integrate_coalescent_term() cc %d, fc %lf, hcc %lf, max %lf, min %lf, a %lf  b %lf",cc,fc,hcc,max,min,a,b); 
        LogDiff (d, a, b);
        if (d <= c)
          IM_err (IMERR_LOGDIFF, " pos5 in integrate_coalescent_term() cc %d, fc %lf, hcc %lf, max %lf, min %lf, d %lf  c %lf",cc,fc,hcc,max,min,d,c); 
        LogDiff (p, d, c);
#else
        p = log (max * exp (-2 * fc / max) - min * exp (-2 * fc / min)
                 - 2 * fc * (exp (uppergamma (0, 2 * fc / max)) -
                             exp (uppergamma (0, 2 * fc / min))));
#endif /* MORESTABLE */
      }
    }
    else
    {
      p = log (max - min);
    }
  }

  return p;
}                               /* integrate_coalescent_term */

double
integrate_migration_term (int cm, double fm, double max, double min)
{
  double p;
  double a, b, c;

  double ug,lg, lgalt, fullg;
  if (cm > 0)
  {
    assert (fm > 0);
    if (min == 0)
    {
      lg =lowergamma ((int) cm + 1, fm * max);
      fullg = logfact[cm];
      /* if lowergamma is too small or too close to the full integral  (fullg) then use uppergamms */
      if (fullg - lg < 1e-15 || fullg - lg  > 7.0978271289338397e+02)
      {
        ug = uppergamma ((int) cm + 1, fm * max);
        if (fullg > ug)
        {
          LogDiff(lgalt,fullg,ug);
          if (fabs(lgalt-lg) > 1e-12)
            lg=lgalt;
        }
      }
      p = (-1 - cm) * log (fm) + lg;
    }
    else
    {

#ifdef MORESTABLE
      a = uppergamma (cm + 1, fm * min);
      b = uppergamma (cm + 1, fm * max);
      if (a<=b)
          IM_err (IMERR_LOGDIFF, " pos 1 in integrate_migration_term() cm %d, fm %lf, max %lf, min %lf, a %lf  b %lf",cm,fm,max,min,a,b); 
      LogDiff (c, a, b);
      p = (-1 - cm) * log (fm) + c;
#else
      p = (-1 - cm) * log (fm) 
          + log (exp (uppergamma (cm + 1, fm * min)) 
                 - exp (uppergamma (cm + 1, fm * max)));
#endif /* MORESTABLE */
    }
  }
  else
  {
    if (fm > MPRIORMIN)                 /* cm == 0   use a cutoff, because sometimes the value that comes in is very low, when it should be zero */
    {
      if (min == 0)
      {
        if (max == MPRIORMIN)
        {
          p = 0;
        }
        else
        {
#ifdef MORESTABLE
          a = 0.0;
          b = -fm * max;
          if (a<=b)
            IM_err (IMERR_LOGDIFF, " pos 2 in integrate_migration_term() cm %d, fm %lf, max %lf, min %lf, a %lf  b %lf",cm,fm,max,min,a,b); 
          LogDiff (c, a, b);
          p = c - log (fm);
#else
          p = log ((1 - exp (-fm * max)) / fm);
#endif /* MORESTABLE */
        }
      }
      else
      {
#ifdef MORESTABLE
        a = -fm * min;
        b = -fm * max;
        if (a<=b)
         IM_err (IMERR_LOGDIFF, " pos 3 in integrate_migration_term() cm %d, fm %lf, max %lf, min %lf, a %lf  b %lf",cm,fm,max,min,a,b); 
        LogDiff (c, a, b);
        p = c - log (fm);
#else
        p = log ((exp (-fm * min) - exp (-fm * max)) / fm);
#endif /* MORESTABLE */
      }
    }
    else
    {
      p = log (max - min);
    }
  }

//      assert(p > -1e200 && p < 1e200);
  return p;
}                               /* integrate_migration_term */


/* for a large value x,  cosh[x] = sinh[x] 
also (cosh[x] + sinh[x] = exp[x]  so for a large value of x  cosh[x] = sinh[x] = Exp[x]/2
so rather than return floating error,  for the log of a cosh of a large number  just return x - log[2]  */
double
mylogcosh (double x)
{
  if (x < 100)
    return log (cosh (x));
  else
    return x - LOG2;
}

double
mylogsinh (double x)
{
  if (x < 100)
    return log (sinh (x));
  else
    return x - LOG2;
}



#define ACC 40.0
#define BIGNO 1.0e10
#define BIGNI 1.0e-10
double
bessi (int n, double x)
{
  int j;
  double bi, bim, bip, tox, ans;
  assert (x >= 0);
  n = abs (n);
  if (x > 700)
    return (MYDBL_MAX);
  if (n == 0)
    return bessi0 (x);
  if (n == 1)
    return bessi1 (x);
  if (x == 0.0)
  {
    return 0.0;
  }
  else
  {
    tox = 2.0 / fabs (x);
    bip = ans = 0.0;
    bi = 1.0;
    for (j = 2 * (n + (int) sqrt (ACC * n)); j > 0; j--)
    {
      bim = bip + j * tox * bi;
      bip = bi;
      bi = bim;
      if (fabs (bi) > BIGNO)
      {
        ans *= BIGNI;
        bi *= BIGNI;
        bip *= BIGNI;
      }
      if (j == n)
        ans = bip;
    }
    ans *= bessi0 (x) / bi;
    return x < 0.0 && (n & 1) ? -ans : ans;
  }
}


#undef ACC
#undef BIGNO
#undef BIGNI

double
bessi0 (double x)
{
  double ax, ans;
  double y;
  if ((ax = fabs (x)) < 3.75)
  {
    y = x / 3.75;
    y *= y;
    ans = 1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492
                                                       + y * (0.2659732 +
                                                              y *
                                                              (0.360768e-1 +
                                                               y *
                                                               0.45813e-2)))));
  }
  else
  {
    y = 3.75 / ax;
    ans = (exp (ax) / sqrt (ax)) * (0.39894228 + y * (0.1328592e-1
                                                      + y * (0.225319e-2 +
                                                             y *
                                                             (-0.157565e-2 +
                                                              y *
                                                              (0.916281e-2
                                                               + y *
                                                               (-0.2057706e-1
                                                                +
                                                                y *
                                                                (0.2635537e-1
                                                                 +
                                                                 y *
                                                                 (-0.1647633e-1
                                                                  + y *
                                                                  0.392377e-2))))))));
  }
  return ans;
}

double
bessi1 (double x)
{
  double ax, ans;
  double y;
  if ((ax = fabs (x)) < 3.75)
  {
    y = x / 3.75;
    y *= y;
    ans = ax * (0.5 + y * (0.87890594 + y * (0.51498869 + y * (0.15084934
                                                               + y *
                                                               (0.2658733e-1
                                                                +
                                                                y *
                                                                (0.301532e-2
                                                                 +
                                                                 y *
                                                                 0.32411e-3))))));
  }
  else
  {
    y = 3.75 / ax;
    ans = 0.2282967e-1 + y * (-0.2895312e-1 + y * (0.1787654e-1
                                                   - y * 0.420059e-2));
    ans = 0.39894228 + y * (-0.3988024e-1 + y * (-0.362018e-2
                                                 + y * (0.163801e-2 +
                                                        y * (-0.1031555e-1 +
                                                             y * ans))));
    ans *= (exp (ax) / sqrt (ax));
  }
  return x < 0.0 ? -ans : ans;
}


/***********************************/
/* GAMMA DISTRIBUTION FUNCTIONS */
/***********************************/
/* this is not used as of 1/4/10 
also not likely to be needed as we only take full gammas of positive integers and logfact[] can be used for that */
double
gammln (double xx)
{
  double x, y, tmp, ser;
  static double cof[6] =
    { 76.18009172947146, -86.50532032941677, 24.01409824083091,
    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
  };
  int j;
  y = x = xx;
  tmp = x + 5.5;
  tmp -= (x + 0.5) * log (tmp);
  ser = 1.000000000190015;
  for (j = 0; j <= 5; j++)
    ser += cof[j] / ++y;
  return -tmp + log (2.5066282746310005 * ser / x);
}


/* (C) Copr. 1986-92 Numerical Recipes Software '$&'3$. */

#define ITMAX 1000
#define EPS 3.0e-7
#define FPMIN 1.0e-30
void
gcf (double *gammcf, double a, double x, double *gln)
{
  int i;
  double an, b, c, d, del, h;
  *gln = logfact[(int) a - 1];
  b = x + 1.0 - a;
  c = 1.0 / FPMIN;
  d = 1.0 / b;
  h = d;
  for (i = 1; i <= ITMAX; i++)
  {
    an = -i * (i - a);
    b += 2.0;
    d = an * d + b;
    if (fabs (d) < FPMIN)
      d = FPMIN;
    c = b + an / c;
    if (fabs (c) < FPMIN)
      c = FPMIN;
    d = 1.0 / d;
    del = d * c;
    h *= del;
    if (fabs (del - 1.0) < EPS)
      break;
  }
  if (i > ITMAX)
    IM_err (IMERR_LOWERGAMMA, " too many iterations within gcf()");
  *gammcf = exp (-x + a * log (x) - (*gln)) * h;
}


// gcflog is the same as gcf but returns the logarithm of gammcf
// saves a little time and stops some underflows
void
gcflog (double *gammcflog, double a, double x, double *gln)
{
  int i;
  double an, b, c, d, del, h;
  *gln = logfact[(int) a - 1];
  b = x + 1.0 - a;
  c = 1.0 / FPMIN;
  d = 1.0 / b;
  h = d;
  for (i = 1; i <= ITMAX; i++)
  {
    an = -i * (i - a);
    b += 2.0;
    d = an * d + b;
    if (fabs (d) < FPMIN)
      d = FPMIN;
    c = b + an / c;
    if (fabs (c) < FPMIN)
      c = FPMIN;
    d = 1.0 / d;
    del = d * c;
    h *= del;
    if (fabs (del - 1.0) < EPS)
      break;
  }
  if (i > ITMAX)
    IM_err (IMERR_UPPERGAMMA, " too many iterations within gcflog()");

  //*gammcf=exp(-x+a*log(x)-(*gln))*h;
  *gammcflog = (-x + a * log (x) - (*gln)) + log (h);
}                               //gcflog


#undef FPMIN

/* (C) Copr. 1986-92 Numerical Recipes Software '$&'3$. */
void
gser (double *gamser, int a, double x, double *gln)
{
  int n;
  double sum, del, ap;
  *gln = logfact[a - 1];
  if (x <= 0.0)
  {
    if (x < 0.0)
      IM_err (IMERR_UPPERGAMMA,
              " gser() called with negative x value, x: %lf ", x);
    *gamser = 0.0;
    return;
  }
  else
  {
    ap = a;
    del = sum = 1.0 / a;
    for (n = 1; n <= ITMAX; n++)
    {
      ++ap;
      del *= x / ap;
      sum += del;
      if (fabs (del) < fabs (sum) * EPS)
      {
        *gamser = sum * exp (-x + a * log (x) - (*gln));
        return;
      }
    }
    IM_err (IMERR_UPPERGAMMA, " too many iterations within gser() ");
    return;
  }
}


// gserlog is the same as gser but returns the logarith of gamser
// saves a little time and stops some underflows
void
gserlog (double *gamserlog, int a, double x, double *gln)
{
  int n;
  double sum, del, ap;
  *gln = logfact[a - 1];
  if (x <= 0.0)
  {
    if (x < 0.0)
      IM_err (IMERR_LOWERGAMMA,
              " function gserlog() called from lowergamma() with negative x value, x: %lf",
              x);
    *gamserlog = 0.0;
    return;
  }
  else
  {
    ap = a;
    del = sum = 1.0 / a;
    for (n = 1; n <= ITMAX; n++)
    {
      ++ap;
      del *= x / ap;
      sum += del;
      if (fabs (del) < fabs (sum) * EPS)
      {
        //*gamser=sum*exp(-x+a*log(x)-(*gln));
        *gamserlog = log (sum) + (-x + a * log (x) - (*gln));
        return;
      }
    }
    IM_err (IMERR_LOWERGAMMA, " too many iterations within gserlog() ");
    return;
  }
}


#undef ITMAX
/* (C) Copr. 1986-92 Numerical Recipes Software '$&'3$. */

#define MAXIT 100
#define EULER 0.5772156649
#define FPMIN 1.0e-30
double
expint (int n, double x, int *islog)
{
  int i, ii, nm1;
  double a, b, c, d, del, fact, h, psi, ans;
  *islog = 0;
  nm1 = n - 1;
  if (n < 0 || x < 0.0 || (x == 0.0 && (n == 0 || n == 1)))
  {
    IM_err (IMERR_UPPERGAMMA,
            " expint() called from uppergamma() with bad value(s). n %d  x %lf",
            n, x);
  }
  else
  {
    if (n == 0)
    {
      ans = exp (-x) / x;
    }
    else
    {
      if (x == 0.0)
      {
        ans = 1.0 / nm1;
      }
      else
      {
        if (x > 1.0)
        {
          b = x + n;
          c = 1.0 / FPMIN;
          d = 1.0 / b;
          h = d;
          for (i = 1; i <= MAXIT; i++)
          {
            a = -i * (nm1 + i);
            b += 2.0;
            d = 1.0 / (a * d + b);
            c = b + a / c;
            del = c * d;
            h *= del;
            if (fabs (del - 1.0) < EPS)
            {
              *islog = 1;

              //ans = h*exp(-x);
              ans = log (h) - x;
              return ans;
            }
          }

          IM_err (IMERR_UPPERGAMMA,
                  " too many iterations in expint() called from uppergamma()");
        }
        else
        {
          ans = (nm1 != 0 ? 1.0 / nm1 : -log (x) - EULER);
          fact = 1.0;
          for (i = 1; i <= MAXIT; i++)
          {
            fact *= -x / i;
            if (i != nm1)
            {
              del = -fact / (i - nm1);
            }
            else
            {
              psi = -EULER;
              for (ii = 1; ii <= nm1; ii++)
                psi += 1.0 / ii;
              del = fact * (-log (x) + psi);
            }
            ans += del;
            if (fabs (del) < fabs (ans) * EPS)
              return ans;
          }
          IM_err (IMERR_UPPERGAMMA,
                  " too many iterations in expint() called from uppergamma()");
        }
      }
    }
  }
  return ans;
}                               //expint


#undef MAXIT
#undef EPS
#undef FPMIN
#undef EULER
/* (C) Copr. 1986-92 Numerical Recipes Software '$&'3$. */
double
uppergamma (int a, double x)
/*  Returns the log of what Mathematica calls the incomplete gamma function.   */
{
  int logindicator;
  double gamser, gammcf, gln, p;
  double temp;
  if (x < 0.0 || a < 0.0)
    IM_err (IMERR_UPPERGAMMA, "  step %d, uppergamma arguments: a  %d, x %lf",
            step, a, x);
  if (a == 0)
  {
    temp = expint (1, x, &logindicator);
    if (!logindicator)
      p = log (temp);

    else
      p = temp;
  }
  else
  {
    if (x < (a + 1.0))
    {
      gser (&gamser, a, x, &gln);
      p = gln + log (1.0 - gamser);
    }
    else
    {
      //gcf(&gammcf,a,x,&gln);
      //p = gln + log(gammcf);
      gcflog (&gammcf, (double) a, x, &gln);
      p = gln + gammcf;
    }
  }
  if (p < -1e200)
    p = -1e200;
  return p;
}                               //uppergamma

double
lowergamma (int a, double x)
/*  modified numrec functions to return the log of  what mathematica would call the complement of 
 the incomplete gamma function.  */
{
  double gamser, gammcf, gln, p;
  if (x < 0.0 || a < 0.0)
    IM_err (IMERR_LOWERGAMMA, "  step %d, lowergamma arguments: a  %d, x %lf",
            step, a, x);
  if (a == 0)
  {
    IM_err (IMERR_LOWERGAMMA, "  step %d, lowergamma arguments: a  %d, x %lf",
            step, a, x);
  }
  if (x < (a + 1.0))
  {

    //gser(&gamser,a,x,&gln);
    //p = gln + log(gamser);
    gserlog (&gamser, a, x, &gln);
    p = gln + gamser;
  }
  else
  {
    gcf (&gammcf, (double) a, x, &gln);
    p = gln + log (1 - gammcf);
  }
  if (p < -1e200)
    p = -1e200;
  return p;
}

/** 
 * logfact is absurdly large, but this is because it must be usable 
 * for all of the migration events in a * data set, which might be very large
 * for a large data set with large upper bounds on migration rates.
 * We need log factorial of n + 1/2 where n a is nonnegative integer.
 * loghalffact (n) := log (n + 1/2)! where n starts from 0 to 50 * ABSMIGMAX.
 */
/* copy to utilities.h
#ifndef M_LNPI
#  define M_LNPI 1.14472988584940017414342735135
#endif
#ifndef M_LN2
#  define M_LN2 0.69314718055994530941723212146
#endif */
void
setlogfact (void)
{
  int i;
  UByteP a;
  // int bitj;
  int ic;
  logfact[0] = 0;
  for (i = 1; i <= 100 * ABSMIGMAX; i++)
    logfact[i] = ((double) logfact[i - 1]) + log ((double) i);
  for (i = 0; i < 50 * ABSMIGMAX; i++)
  {
    loghalffact[i] = M_LNPI / 2
      + logfact[2 * i + 2] - logfact[i + 1] - (2 * i + 2) * M_LN2;
  }
  a = (UByteP) malloc (sizeof (unsigned char));
  for (ic = 0; ic < 256; ic++)
  {
    BitZero (a, 1);
    a[0] = (unsigned char) ic;
    BITNUMBERTRUE[ic] = 0;
    for (i = 0; i < 8; i++)
    {
      if (BitIsTrue (a, i))
      {
        BITNUMBERTRUE[ic] += 1;
      }
    }
  }
  XFREE (a);
  a = NULL;
}


@
\subsection{IM Random Number Generator - imrng.h}

<<imrng.hh>>=
<<im3 copyright>>
#ifndef _IMRNG_HH_
#define _IMRNG_HH_
#include <iostream>
#include <fstream>
#include <ctime>
#include <cmath>
#include <boost/random/linear_congruential.hpp>
#include <boost/random/mersenne_twister.hpp>
#include <boost/random/uniform_int.hpp>
#include <boost/random/uniform_real.hpp>
#include <boost/random/variate_generator.hpp>
<<imrng use boost random>>
#endif /* _IMRNG_HH_ */

<<imrng use boost random>>=
#define bitran() uniform() > .5L ? 0 : 1
#define randposint(a) static_cast<int>(floor (uniform () * (a)))

typedef boost::mt19937 base_generator_type;
extern boost::variate_generator<base_generator_type&, boost::uniform_real<> > uniform;
void setseeds (unsigned seed);

<<imrng.cc>>=
<<im3 copyright>>
#include "imrng.hh"
base_generator_type generator;
boost::uniform_real<> uni_dist;
boost::variate_generator<base_generator_type&, boost::uniform_real<> > uniform(generator, uni_dist);

void 
setseeds (unsigned seed)
{
  generator.seed (seed);
}

<<imrng-t.cc>>=
#include "imrng.hh"

int main (int argc, char ** argv)
{
  setseeds (123U);
  for (int i = 0; i < 3; i++)
  {
    std::cout << uniform () << std::endl;
  }

  for (int i = 0; i < 100; i++)
  {
    std::cout << randposint (10) << std::endl; 
  }

  for (int i = 0; i < 100; i++)
  {
    if (bitran())
      {
        std::cout << 1 << std::endl;
      }
    else
      {
        std::cout << 0 << std::endl;
      }
  }

  return 0;
}

<<imrng.h>>=
<<im3 copyright>>
#ifndef _IMRNG_H_
#define _IMRNG_H_
<<c decls>>
<<c begin decls>>
<<imrng>>
<<c end decls>>
#endif /* _IMRNG_H_ */

<<imrng>>=
void setseeds (int seed);
void resetseeds (int seed);     /* use for debugging, provides control over sequence of random numbers */
void unsetseeds ();
double uniform ();
double expo (double c);
double normprob (double mean, double stdev, double val);
double normdev (double mean, double stdev);
int poisson (double param, int condition);
int geometric (double p);
extern int bitran (void);
extern int randposint (int lessthanval);

<<imrng.c>>=
#include <math.h>
#include <limits.h>
#include <stdlib.h>
#include "imdef.h"

static unsigned long *iseed; /* SC: Why was this global? */

/***********************************/
/* RANDOM NUMBER RELATED FUNCTIONS */
/***********************************/
static int z_rndu = 137;
static int x_rndu = 11, y_rndu = 23;    // these had been in uniform() but I moved them out to make it easier to reset the random number generator 
void
resetseeds (int seed)           // use for debugging
{
  z_rndu = 137;
  x_rndu = 11;
  y_rndu = 23;
  z_rndu = 170 * (seed % 178) + 137;
  iseed = malloc (sizeof (unsigned long));
  *iseed = ULONG_MAX / 2 + (unsigned long) seed;        // just set it so that iseed points to a large number - probably not necessary
}

void
setseeds (int seed)
{
  z_rndu = 170 * (seed % 178) + 137;
  iseed = malloc (sizeof (unsigned long));
  *iseed = ULONG_MAX / 2 + (unsigned long) seed;        // just set it so that iseed points to a large number - probably not necessary
}

void
unsetseeds ()
{
  XFREE (iseed);
  iseed = NULL;
  return;
}

double
uniform ()
{

/* Rasmus Note:
    U(0,1): AS 183: Appl. Stat. 31:188-190
   Wichmann BA & Hill ID.  1982.  An efficient and portable
   pseudo-random number generator.  Appl. Stat. 31:188-190

   x, y, z are any numbers in the range 1-30000.  Integer operation up
   to 30323 required.

   Suggested to me by Z. Yang who also provided me with
   the source code used here.
*/
/* different compilers were giving slightly diffferent numbers unless there are float casts */
  // turn this back on  static int x_rndu=11, y_rndu=23;
  double r;
  x_rndu = 171 * (x_rndu % 177) - 2 * (x_rndu / 177);
  y_rndu = 172 * (y_rndu % 176) - 35 * (y_rndu / 176);
  z_rndu = 170 * (z_rndu % 178) - 63 * (z_rndu / 178);
  if (x_rndu < 0)
    x_rndu += 30269;
  if (y_rndu < 0)
    y_rndu += 30307;
  if (z_rndu < 0)
    z_rndu += 30323;
  r = x_rndu / 30269.0 + y_rndu / 30307.0 + z_rndu / 30323.0;
  return (r - (long) r);
}

/* $\lambda e^{-\lambda t}$ where $\lambda$ equal to c */
double
expo (double c)
{
  /*float temp;d
     temp = log(uniform());
     temp = (1.0/(float) c) * temp;
     return (double) - temp; */
  return -log (uniform ()) / c;
}
#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
//__forceinline int
int
#else
__inline__ int
#endif
randposint (int lessthanval)    // actually should be rand_nonneg_int 
{
  return (int) floor (uniform () * lessthanval);
}

/* for binary random numbers  -	quick - based on Press et al irbit2() */
#define IB1 1
#define IB18 131072
#define MASK 19
#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
//__forceinline int
int
#else
__inline__ int
#endif
bitran (void)
{
  if (*iseed & IB18)
  {
    *iseed = ((*iseed ^ MASK) << 1) | IB1;
    return 1;
  }
  else
  {
    *iseed <<= 1;
    return 0;
  }
}


#undef MASK
#undef IB18
#undef IB1

#define ONEOVERSQRT2PI  0.3989422803
double
normprob (double mean, double stdev, double val)
{
  return ONEOVERSQRT2PI * exp (-SQR ((val - mean) / stdev) / 2) / stdev;
}


#undef ONEOVERSQRT2PI
double
normdev (double mean, double stdev)
{
  static int iset = 0;
  static double gset;
  double fac, rsq, v1, v2;
  double rescale;
  if (iset == 0)
  {
    do
    {
      v1 = 2.0 * uniform () - 1.0;
      v2 = 2.0 * uniform () - 1.0;
      rsq = v1 * v1 + v2 * v2;
    }
    while (rsq >= 1.0 || rsq == 0.0);
    fac = sqrt (-2.0 * log (rsq) / rsq);
    gset = v1 * fac;
    iset = 1;
    rescale = ((v2 * fac * stdev) + mean);
    return rescale;
  }
  else
  {
    iset = 0;
    rescale = ((gset * stdev) + mean);
    return rescale;
  }
}                               /* normdev */


/* gets a poisson random variable.  checked it out with simulations 
if condition is 0, pick an even number
if condition is 1, pick an odd number
if condition is 2,  pick any number other than 0 (because they must be different)
if condition is 3, pick any number other than 1
if condition is -1 pick any number 
If param > minpp the normal distribution is used as an approximation

Also stuck in some stuff to deal with the case when condition is 1 and param << 1
*/

#define USENORMAL  25.0
#define MINPP 0.25
int
poisson (double param, int condition)
{
  long double randnum, raised, rcheck;
  int i;
  int stop;
  if (param < MINPP && condition == 1)  /* i.e. need an odd number but the parameter is a small value */
  {
    randnum = uniform ();
    rcheck = param / sinh (param);
    if (randnum < rcheck)       /* param / sinh(param) is prob of # being 1, given it must be odd */
      i = 1;
    else

    {
      rcheck = param * (6 + param * param) / (6 * sinh (param));
      if (randnum < rcheck)
        i = 3;

      else
        i = 5;
    }
    return (i);
  }

  /*if (param < 0.25 && condition == 2)  a function for cases when  need any number not zero,  but the parameter is a small value  */
  /* seems to work - check  file Poisson_low_value_parameter_simulation_check.nb */
  if (param < MINPP && condition == 2)
  {
    raised = exp (-param);
    rcheck = raised = param * raised / (1 - raised);
    randnum = uniform ();
    i = 1;
    while (randnum > rcheck)
    {
      raised *= param / (i + 1);
      rcheck += raised;
      i++;
    }
    return (i);
  }

  do
  {
    if (param >= USENORMAL)     // used normal approximation
    {
      i = IMAX (0, POSROUND (normdev (param, param)));

      // maybe should not cast as (int) before POSROUND ??
      //i = IMAX(0,POSROUND((int) normdev(param,param)));
    }
    else
    {
      raised = exp (-param);
      randnum = uniform ();
      for (i = 0; randnum > raised; i++)
        randnum *= uniform ();
    }

    switch (condition)
    {
    case -1:
      stop = 1;
      break;
    case 0:
      stop = !ODD (i);
      break;
    case 1:
      stop = ODD (i);
      break;
    case 2:
      stop = (i != 0);
      break;                    //*
    case 3:
      stop = (i != 1);
      break;
    }
  } while (!stop); 

  if (i > ADDMIGMAX)            /* trap numbers that get too large to handle (and that don't make sense) */
  {
    if (condition == 1)
      i = ADDMIGMAX - 1;
    else
      i = ADDMIGMAX;
  }
  return (i);
}                               /* pickpoisson */


#undef USENORMAL
#undef MINPP
int
geometric (double p)
/* returns a geometrically distributed random integer variable >= 0 */
/* this distribution is given by prob(k) = p*(1-p)^(k-1)  where k = 1,2,...  which has a mode of 1 and an expectation of 1/p */
/* it is a bit different from prob(k) = p*(1-p)^k   where k  = 0,1, 2... , which has a mode of 0 and an expectation of (1-p)/p */
/* the variance of these two different versions is the same, i.e. (1-p)/p^2 */
/* checked this in various ways - seems ok */
{
  return (int) ceil (log (uniform ()) / log (1.0 - p));
}



@
\subsection{IM Tools - imtools.h}

<<imtools.h>>=
<<im3 copyright>>
#ifndef _IMTOOLS_H_
#define _IMTOOLS_H_
<<c decls>>
<<c begin decls>>
<<imtools>>
<<c end decls>>
#endif /* _IMTOOLS_H_ */

<<imtools>>=
#include <stdarg.h>
#include <stdio.h>

enum
{
  IMERR_SUCCESS = 0,
  IMERR_READFILEOPENFAIL = 1,
  IMERR_MEM = 2,
  IMERR_TIFILE = 3,
  IMERR_CREATEFILEFAIL = 4,
  IMERR_APPENDFILEFAIL = 5,
  IMERR_OUTPUTFILECHECK = 6,

  IMERR_COMMANDLINEINCOMPAT = 8,
  IMERR_MISSINGCOMMANDINFO = 9,
  IMERR_COMMANDLINEFORMAT = 10,
  IMERR_COMMANDLINEHEATINGTERMS = 11,

  IMERR_MISSINGPOPSTRING = 12,
  IMERR_POPTREESTRINGFAIL = 13,

  IMERR_INFILEFAIL_NLOCI = 15,
  IMERR_NESTEDMODELLSPECIFYLFAIL = 16,

  IMERR_MUTSCALARPRIORRANGEFAIL = 18,
  IMERR_MUTSCALEPRODUCTFAIL = 19,

  IMERR_TOOMANYMIG = 21,
  IMERR_MIGARRAYTOOBIG = 22,
  IMERR_HPD95 = 23,

  IMERR_DATAREADOVERRUN = 25,
  IMERR_DATAERROR = 26,

  IMERR_MCFREADFAIL = 28,
  IMERR_MCFSPLITTIMEPROB = 29,

  IMERR_ROOTTIMEMAXFAIL = 33,

  IMERR_INPUTFILEINVALID = 35,
  IMERR_INFINITESITESFAIL = 36,
  
  IMERR_SWCHECK = 38,

  IMERR_LOWERGAMMA = 41,
  IMERR_UPPERGAMMA = 42,
  IMERR_LOGDIFF = 43,

  IMERR_MULTITPRIOR = 45,
  IMERR_PRIORFILEVALS = 46,

  IMERR_NUMERICALRECIPES = 51,
  IMERR_GSL = 52,
  IMERR_ASSERT = 55,
  IMERR_GENENAME = 56,
  IMERR_ASN = 57
};

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#define AT __FILE__ ":" TOSTRING(__LINE__)
void IM_err (int i, const char *fmt, ...);
/* Print error located at a source file. 
 * IM_errloc (AT, "Error %d", d);
 */
void IM_errloc (const char *loc, const char *fmt, ...);

/* void skip_a_line (FILE * f); */
int comma_exists (char *s);
double logsum (int n, ...);
double logsuma (int n, double *d); 
double cumnorm(double ox, double mean, double sd);
int gsl_fcmp (const double x1, const double x2, const double epsilon);
int imaDirBase (const char *a, char **b);
char *shorten_e_num (char *s);

int isemptystring(char *s);
void strdelete (char *s, int pos, int len);
void strinsert (char *dest, char *source, int pos);
void strremove (char *s, char c);
void strtrunc (char *s, char c);
char *nextwhite (char *c);
char *nextnonspace (char *textline);
int put_spaces_in_filepaths(char *pathstr);

int skip_a_line (FILE *fp);
int read_int (FILE *fp);
double read_double (FILE *fp);
void nrerror (const char error_text[]);

#ifndef M_LNPI
#  define M_LNPI 1.14472988584940017414342735135
#endif
#ifndef M_LN2
#  define M_LN2 0.69314718055994530941723212146
#endif

<<imtools.c>>=
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include "imdef.h"
#include "imenum.h"
#undef GLOBVARS
#include "imglobal.h"
#include "imtools.h"

/* Here is how to add an error message.
 * 1. Add an element to enum in utilities.h with prefix of "IMERR_XXX"
 * 2. Add the corresponding error message string to simerrmsg.
 * 3. Call function IM_err (IMERR_XXX, ...) where ... is like the way that
 *    printf function arguments are used.
 */
static const char *simerrmsg[] = {
  /* 0 */ "",
  /* 1 */ "cannot open a file for reading",
  /* 2 */ " memory error ",
  /* 3 */ "problem finding .ti file(s)",
  /* 4 */ "cannot create file",
  /* 5 */ "cannot open file for appending",
  /* 6 */ " problem with opening or closing output file",
  /* 7 */ "",
  /* 8 */ "incompatibility on command line",
  /* 9 */ "not enough information provided on command line",
  /* 10 */ "problem with command line formatting ",
  /* 11 */ "problem with heating terms in command line",
  /* 12 */ "missing population string in input file",
  /* 13 */ "some problem in the population tree string ",
  /* 14 */ "",
  /* 15 */ "problem w/ number of loci indicated in data file",
  /* 16 */ "problem in specifying nested models for LLR tests",
  /* 17 */ "",
  /* 18 */ "mutation range priors to constraining - not able to set starting values",
  /* 19 */ "product of mutation scalars not equal to 1",
  /* 20 */ "",
  /* 21 */ "Too many migration events found when storing edges",
  /* 22 */ "to much migration called for in checkmig - reduce maximum value of migration parameter",
  /* 23 */ "problem in calculating HPD interval",
  /* 24 */ "",
  /* 25 */ "error reading data, too many lines or line too long",
  /* 26 */ "error in data",
  /* 27 */ "",
  /* 28 */ "problem reading mcf file",
  /* 29 */ "cannot load mcf file, split times in file not compatiable with t prior",
  /* 30 */ "",
  /* 31 */ "",
  /* 32 */ "",
  /* 33 */ "problem with root ",
  /* 34 */ "",
  /* 35 */ "input file invalid ",
  /* 36 */ "data not compatible with infinite sites model",
  /* 37 */ "",
  /* 38 */ "likelihoods do not add up for stepwise model",
  /* 39 */ "",
  /* 40 */ "",
  /* 41 */ "error in lowergamma function",
  /* 42 */ "error in uppergamma function",
  /* 43 */ "error using LogDiff macro,  difference is non-positive",
  /* 44 */ "",
  /* 45 */ "error calculating prior of t  in multi_t_prior_func",
  /* 46 */ "problem in the values specified in a file with parameter priors",
  /* 47 */ "",
  /* 48 */ "",
  /* 49 */ "",
  /* 50 */ "",
  /* 51 */ "error in NR functions",
  /* 52 */ "GSL error",
  /* 53 */ "",
  /* 54 */ "",
  /* 55 */ "Potential bug",
  /* 56 */ "Invalid input file: gene name",
  /* 57 */ "Assignment Error"
};

void
IM_err (int i, const char *fmt, ...)
{
  va_list args;
  va_start (args, fmt);
  fprintf (stderr, "IMa2: %s - ", simerrmsg[i]);
  vfprintf (stderr, fmt, args);
  fprintf (stderr, "\n");
  va_end (args);
  exit (i);
}

void
IM_errloc (const char *loc, const char *fmt, ...)
{
  va_list args;
  va_start (args, fmt);
  /* fprintf (stderr, "IMamp at %s: %s - ", loc, simerrmsg[i]); */
  fprintf (stderr, "IMamp at %s - ", loc);
  vfprintf (stderr, fmt, args);
  fprintf (stderr, "\n");
  va_end (args);
  exit (1);
}



void
nrerror (const char error_text[])
/* Numerical Recipes standard error handler */
{
  IM_err (IMERR_NUMERICALRECIPES, " error text: %s", error_text);
}

/* Function logsum approximately computes the value of v of the following
 * equation:
 * exp(v) = exp(a_1) + exp(a_2) + ...
 * The first arguement is the number of elements of the sum, and the rest of the
 * argements are the n elements. For example, we can compute 
 * exp(3.0) + exp(1.5) + exp(2.5), which is exp(3.604131) by using function call
 * logsum (3, 3.0, 1.5, 2.5). The returned value should be 3.604131.
 */
#define LOG_DBL_MAX    7.0978271289338397e+02
double logsum (int n, ...)
{
  register int i;
  double a;
  double b;
  va_list ap;

  assert (n > 1);
  va_start (ap, n);
  a = va_arg (ap, double);
  for (i = 1; i < n; i++)
  {
    b = va_arg (ap, double);

    if (a > b)
    {
      if (a - b < LOG_DBL_MAX)
        a = b + log (exp (a - b) + 1.0);
    }
    else
    {
      if (b - a < LOG_DBL_MAX)
        a = a + log (exp (b - a) + 1.0);
      else
        a = b;
    }
  }
  va_end (ap);
  return a;
}

double logsuma (int n, double *d) 
{
  register int i;
  double a;
  double b;

  assert (n > 1);
  a = d[0];
  for (i = 1; i < n; i++)
  {
    b = d[i];

    if (a > b)
    {
      if (a - b < LOG_DBL_MAX)
        a = b + log (exp (a - b) + 1.0);
    }
    else
    {
      if (b - a < LOG_DBL_MAX)
        a = a + log (exp (b - a) + 1.0);
      else
        a = b;
    }
  }
  return a;
}

#undef LOG_DBL_MAX

/* SASNGCHUL: Wed Apr 15 2009
 * I borrowed some codes from MICSAT for computing cumulative normal distribution. 
 * This is for implementing their Branch-Swapping algorithm. I have not decided this 
 * would be included or not. */
/* Frequently used numerical constants: */
#define OneUponSqrt2Pi .39894228040143267794
#define twopi 6.283195307179587
#define LnSqrt2Pi -0.9189385332046727417803296 
#define SQRT2 1.414213562373095049
#define SQRTPI 1.772453850905516027

/* ---------------------------------------------------------------------------

   UNIVARIATE NORMAL PROBABILITY

   ---------------------------------------------------------------------------*/

#define UPPERLIMIT 100.0 
/* I won't return either of univariate normal density or 
	probability when x < -UPPERLIMIT  or x > UPPERLIMIT. */

#define P10 242.66795523053175
#define P11 21.979261618294152
#define P12 6.9963834886191355
#define P13 -.035609843701815385
#define Q10 215.05887586986120
#define Q11 91.164905404514901
#define Q12 15.082797630407787
#define Q13 1.0

#define P20 300.4592610201616005
#define P21 451.9189537118729422
#define P22 339.3208167343436870
#define P23 152.9892850469404039
#define P24 43.16222722205673530
#define P25 7.211758250883093659
#define P26 .5641955174789739711
#define P27 -.0000001368648573827167067
#define Q20 300.4592609569832933
#define Q21 790.9509253278980272
#define Q22 931.3540948506096211
#define Q23 638.9802644656311665
#define Q24 277.5854447439876434
#define Q25 77.00015293522947295
#define Q26 12.78272731962942351
#define Q27 1.0

#define P30 -.00299610707703542174
#define P31 -.0494730910623250734
#define P32 -.226956593539686930
#define P33 -.278661308609647788
#define P34 -.0223192459734184686
#define Q30 .0106209230528467918
#define Q31 .191308926107829841
#define Q32 1.05167510706793207
#define Q33 1.98733201817135256
#define Q34 1.0

double cumnorm(double ox, double mean, double sd)
{
	int sn;
	double R1, R2,/* R3,*/ y, y2, y3, y4, y5, y6, y7;
	double erfValue, erfcValue, z, z2, z3, z4;
	double phi,x;

        x = (ox-mean)/sd;

	if (x < -UPPERLIMIT) return 0.0;
	if (x > UPPERLIMIT) return 1.0;

	y = x / SQRT2;
	if (y < 0) {
		y = -y;
		sn = -1;
	}
	else
		sn = 1;

	y2 = y * y;
	y4 = y2 * y2;
	y6 = y4 * y2;

	if(y < 0.46875) {
		R1 = P10 + P11 * y2 + P12 * y4 + P13 * y6;
		R2 = Q10 + Q11 * y2 + Q12 * y4 + Q13 * y6;
		erfValue = y * R1 / R2;
		if (sn == 1)
			phi = 0.5 + 0.5*erfValue;
		else 
			phi = 0.5 - 0.5*erfValue;
	}
	else 
		if (y < 4.0) {
			y3 = y2 * y;
			y5 = y4 * y;
			y7 = y6 * y;
			R1 = P20 + P21 * y + P22 * y2 + P23 * y3 + 
			    P24 * y4 + P25 * y5 + P26 * y6 + P27 * y7;
			R2 = Q20 + Q21 * y + Q22 * y2 + Q23 * y3 + 
			    Q24 * y4 + Q25 * y5 + Q26 * y6 + Q27 * y7;
			erfcValue = exp(-y2) * R1 / R2;
			if (sn == 1)
				phi = 1.0 - 0.5*erfcValue;
			else
				phi = 0.5*erfcValue;
		}
		else {
			z = y4;
			z2 = z * z;
			z3 = z2 * z;
			z4 = z2 * z2;
			R1 = P30 + P31 * z + P32 * z2 + P33 * z3 + P34 * z4;
			R2 = Q30 + Q31 * z + Q32 * z2 + Q33 * z3 + Q34 * z4;
			erfcValue = (exp(-y2)/y) * (1.0 / SQRTPI + R1 / (R2 * y2));
			if (sn == 1)
				phi = 1.0 - 0.5*erfcValue;
			else 
				phi = 0.5*erfcValue;
		}

	return phi;
}

int
gsl_fcmp (const double x1, const double x2, const double epsilon)
{
  int exponent;
  double delta, difference;

  /* Find exponent of largest absolute value */

  {
    double max = (fabs (x1) > fabs (x2)) ? x1 : x2;

    frexp (max, &exponent);
  }

  /* Form a neighborhood of size  2 * delta */

  delta = ldexp (epsilon, exponent);

  difference = x1 - x2;

  if (difference > delta)       /* x1 > x2 */
    {
      return 1;
    }
  else if (difference < -delta) /* x1 < x2 */
    {
      return -1;
    }
  else                          /* -delta <= difference <= delta */
    {
      return 0;                 /* x1 ~=~ x2 */
    }
}


int
imaDirBase (const char *a, char **b)
{
  int len;
  int i;
  
  len = strlen (a);
  for (i = len - 1; i >= 0; i--)
    {
      if (a[i] == '/' || a[i] == '\\' )
        {
          break;
        }
    }
  if (i < 0)
    {
      *b = malloc (3 * sizeof (char));
      strcpy (*b, "./");
    }
  else
    {
      *b = malloc ((i+2) * sizeof (char));
      strncpy (*b, a, i + 1);      
      (*b)[i+1] = '\0';
    }
  
  return 0;
}
/* paths that have a space (' ') in the file system cannot be read on the command line
instead the user must change all spaces to "%20" when preparing the command line.  
This function puts the space back */ 
int put_spaces_in_filepaths(char *pathstr)
{
  char *c;
  while (c = strstr(pathstr,"%20"))
  {
    *c = ' ';
    strdelete(pathstr,c-pathstr + 2,2);
  }
  return 0;
}


char *
shorten_e_num (char *s)
{
  char *pos;
  char e = 'e';
  int i;
  pos = strchr (s, e);
  // old form strdelete (s, (int) (pos - s) + 2, 3);
  // hopefully this is a bit more robust
  i = pos-s;
  while (s[i+1] == '0' ||s[i+1] == '+')
  {
    strdelete (s, i+2,1);
  }
  return s;
}

int
skip_a_line (FILE *fp)
{
  char c;
  c = 'x';
  while (c != '\n')
    {
      c = fgetc(fp);
    }
  return 0;
}

int
read_int (FILE *fp)
{
  int v;
  char c;
  char *buf;
  int len;
  int i;
  
  len = 5;
  buf = malloc (len * sizeof (char));
  
  c = fgetc (fp);
  i = 0;
  while (c != '\t' && c != '\n')
    {
      buf[i++] = c;
      if (i == len)
        {
          len += 5;
          buf = realloc (buf, len * sizeof (char));
        }
      c = fgetc (fp);
    }
  buf[i] = '\0';
  v = atoi (buf);
  
  free (buf);
  buf = NULL;
  return v;
}

double 
read_double (FILE *fp)
{
  double v;
  char c;
  char *buf;
  int len;
  int i;
  
  len = 5;
  buf = malloc (len * sizeof (char));
  
  c = fgetc (fp);
  i = 0;
  while (c != '\t' && c != '\n')
    {
      buf[i++] = c;
      if (i == len)
        {
          len += 5;
          buf = realloc (buf, len * sizeof (char));
        }
      c = fgetc (fp);
    }
  buf[i] = '\0';
  v = atof (buf);
  
  free (buf);
  buf = NULL;
  
  return v;
}

/***********************************/
/* TEXT, CHARACTER RELATED FUNCTIONS */
/***********************************/

int isemptystring(char *s)
{
  return s[0] == '\0';
}

/* Delete the substring of length "len" at index "pos" from "s". Delete less if out-of-range. */
/* note the counting for pos starts at 1,  not 0,  so might have to call with pos being 1 higher than you think */ 
void
strdelete (char *s, int pos, int len)
{
  int slen;
  if (--pos < 0)
    return;
  slen = (int) (strlen (s) - pos);
  if (slen <= 0)
    return;
  s += pos;
  if (slen <= len)
  {
    *s = 0;
    return;
  }
  while ((*s = s[len]))
    s++;
}


/* insert source into dest at pos */
void
strinsert (char *dest, char *source, int pos)
{
  char temp[POPTREESTRINGLENGTHMAX];
  temp[0] = '\0';
  if (pos > 0)
    strncpy (temp, dest, (size_t) pos);
  temp[pos] = '\0';
  strcat (temp, source);
  if ((int) strlen (dest) > pos)
    strcat (temp, &dest[pos - 1]);
  strcpy (dest, temp);
}


/* remove all characters, c, from a string */
void
strremove (char *s, char c)
{
  char *cspot;
  while ((cspot = strchr (s, c)) != NULL)
  {
    *cspot = '\0';
    strcat (s, cspot + 1);
  }
}

/* truncate a string at the first instance of c */
void
strtrunc (char *s, char c)
{
  char *cspot;
  if (strchr (s, c))
  {
    cspot = strchr (s, c);
    *cspot = '\0';
  }
}


/* find next whitespace, after next non-whitespace */
char *
nextwhite (char *c)
{
  int nonw;
  nonw = !isspace (*c);
  while (*c != '\0')
  {
    while ((nonw == 1 && !isspace (*c)) || (nonw == 0 && isspace (*c)))
    {
      c++;
      if (nonw == 0 && !isspace (*c))
        nonw = 1;
    }
    return c;
  }
  return c;
}                               /* nextwhite */


/* finds the next non-space character after the next space */
char *
nextnonspace (char *textline)
{
  char *cc;
  if (textline == NULL)
    return NULL;
  cc = textline;
  while (*cc != ' ' && *cc != '\0')
    cc++;
  while (*cc == ' ')
    cc++;
  if (*cc == '\0')
    return NULL;
  else
    return cc;
}

/*
void
skip_a_line (FILE * f)
{
  int c;
  c = 'x';
  while (c != '\n')
  {
    c = fgetc (f);
  }
  return;
}
*/

int
comma_exists (char *s)
{
  int l;
  int i;
  int v;

  v = 0;
  l = strlen (s);
  for (i = 0; i < l; i++)
  {
    if (s[i] == ',' || s[i] == ';')
    {
      v = 1;
    }
  }
  return v;
}

/* remove spaces and count parentheses */
void
checktreestring (char *t)
{
  int closepcheck, openpcheck, i;

  for (closepcheck = 0, openpcheck = 0, i = 0; (unsigned) i < strlen (t); i++)  // check if the number of open parenthese match the close parentheses
  {
    closepcheck += t[i] == ')';
    openpcheck += t[i] == '(';
    if ((t[i] == ' ') || (t[i] == '\t') || (t[i] == '\n') || (t[i] == '\r'))    // remove spaces
    {
      t[i] = '\0';
      strcat (t, &(t[i + 1]));
      i--;
    }
  }
  if (closepcheck != openpcheck)
  {
    //  errr (-1, -1, 17, closepcheck, openpcheck);
    IM_err (IMERR_POPTREESTRINGFAIL,
            " wrong number of parentheses, string %s,  open '(' %d  close ')' , step %d",
            t, openpcheck, closepcheck, step);
  }
}                               /* checktreestring */

@
\subsection{IM Tools using C++ - imptools.hh}

<<imptools.hh>>=
<<im3 copyright>>
#ifndef _IMPTOOLS_HH_
#define _IMPTOOLS_HH_
<<imptools c++ header>>
#endif /* _IMPTOOLS_HH_ */

<<imptools c++ header>>=
namespace ima {
  std::pair<int,int> readTiM (std::ifstream &is, const char * m);
  int readTiQ (std::ifstream &is, const char * q);
  bool readTill (std::ifstream &is);
  bool readToEndl (std::ifstream &is);
  int readNpopsFromTi (const std::string &s);
  double readPriorFromTiFile (const std::string &s, const std::string &p);
}

<<imptools.cc>>=
<<im3 copyright>>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <utility>
#include <cstdlib>
#include <cstring>
#include "imptools.hh"

using std::string;
using std::cout;
using std::endl;

namespace ima {

  double readPriorFromTiFile (const string &s, const string &p)
  {
    double v;
    string n;
    string line;
    string l2;
    string::size_type pos2; 

    std::ifstream is(s.c_str(), std::ios::in);
    if (!is)
      {
        std::cerr << "Error: file " << s << "could not be opened";
        exit (1);
      }
    getline (is, line);
    while (!is.eof())
      {
        string::size_type pos = line.find ("Command line string");
        if (pos != string::npos)
          {
            pos = line.find (" -" + p);
            if (pos == string::npos)
              {
                std::cerr << "Error: file " << s << " do not have q prior";
                exit (1);
              }
            l2 = line.substr (pos + 3); 
            pos2 = l2.find (" ");
            n = l2.substr (0, pos2);
            v = atof (n.c_str());
            break; 
          }
        getline (is, line);
      }
    is.close ();
    return v;
  }

  int readNpopsFromTi (const string &s)
  {
    int v;
    string n;
    string line;
    std::ifstream is(s.c_str(), std::ios::in);
    if (!is)
      {
        std::cerr << "Error: file " << s << "could not be opened";
        exit (1);
      }
    getline (is, line);
    while (!is.eof())
      {
        string::size_type pos = line.find ("Number of sampled populations given in input file:");
        if (pos != string::npos)
          {
            n = line.substr (50); 
            v = atoi (n.c_str());
            break; 
          }
        getline (is, line);
      }
    is.close ();
    return v;
  }

  std::pair<int,int> readTiM (std::ifstream &is, const char * m)
  {
    int v1;
    int v2;
    string numerics ("0123456789");
    string arrow (">");
    string s;
    string n;
    is >> s;
    string::size_type pos = s.find (m);
    if (pos == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return std::make_pair(-1,-1);
      }

    pos = s.find_first_of (numerics);
    if (pos == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return std::make_pair(-1,-1);
      }
    string::size_type posArrow = s.find_first_of (arrow);
    if (posArrow == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return std::make_pair(-1,-1);
      }
    n = s.substr (pos, posArrow - pos); 
    v1 = atoi (n.c_str());
    n = s.substr (posArrow + 1);
    v2 = atoi (n.c_str());
    return std::make_pair(v1,v2);
  }

  int readTiQ (std::ifstream &is, const char * q)
  {
    int v;
    string numerics ("0123456789");
    string s;
    string n;
    is >> s;
    string::size_type pos = s.find (q);
    if (pos == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return -1;
      }

    pos = s.find_first_of (numerics);
    if (pos == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return -1;
      }
    n = s.substr(pos); 
    v = atoi (n.c_str());
    return v;
  }

  bool readToEndl (std::ifstream &is)
  {
    char c = is.get ();
    while (c != '\n') { 
      c = is.get ();
    }
    return true;
  }

  bool readTill (std::ifstream &is)
  {
    char c;
    bool notFound = true;
    string w;

    while (notFound)
      {
        c = is.get ();
        switch (c)
          {
          case 'V':
            w = c;
          break;
          case 'A':
            if (w == "V" || w == "VALUESST")
              w += c;
            else
              w = "";
          break;
          case 'L':
            if (w == "VA")
              w += c;
            else
              w = "";
          break;
          case 'U':
            if (w == "VAL")
              w += c;
            else
              w = "";
          break;
          case 'E':
            if (w == "VALU")
              w += c;
            else
              w = "";
          break;
          case 'S':
            if (w == "VALUE" || w == "VALUES")
              w += c;
            else
              w = "";
          break;
          case 'T':
            if (w == "VALUESS")
              w += c;
            else if (w == "VALUESSTAR")
              notFound = false;
            else
              w = "";
          break;
          case 'R':
            if (w == "VALUESSTA")
              w += c;
            else
              w = "";
          break;
          }
      }
    return !notFound;
  }
}

<<imptools-t.cc>>=
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <utility>
#include <cstdlib>
#include "imptools.hh"

using std::endl;
using std::cout;
using std::string;

int main (int argc, char ** argv)
{
  int si;
  int _indexLH;
  int pi;
  double qt;
  double mt;
  int qc;
  double hcc;
  double fc;
  int mc;
  double fm;
  std::pair<int,int> pqi;

  char c;
  string s = "t5-1.out.ti";
  std::ifstream is(s.c_str(), std::ios::in);

  // Read until we hit "VALUESSTART"
  if (!ima::readTill (is))
  {
    std::cerr << "Not found VALUESSTART\n";
    return 0;
  }

  is >> si;
  is >> _indexLH;

  pi = ima::readTiQ (is, "qt");
  is >> qt;
  pqi = ima::readTiM (is, "mt");
  is >> mt;
  pqi = ima::readTiM (is, "mt");
  is >> mt;
  pqi = ima::readTiM (is, "mt");
  is >> mt;
  pqi = ima::readTiM (is, "mt");
  is >> mt;
  pi = ima::readTiQ (is, "qc");
  is >> qc;
  is >> hcc;
  is >> fc;
  pqi = ima::readTiM (is, "mc");
  is >> mc;
  is >> fm;


  std::cout << si << std::endl;
  std::cout << _indexLH << std::endl;
  std::cout << "qt-" << pi << " " << qt << std::endl;
  std::cout << "mt-" << pqi.first << ">" << pqi.second 
            << " " << mt << std::endl;
  std::cout << "qc-" << pi << " " << qc << " " 
            << hcc << " " << fc << std::endl;
  std::cout << "mc-" << pqi.first << ">" << pqi.second 
            << " " << mc << " " << fm << std::endl;

  is.close ();

  std::cout << "npops: " << ima::readNpopsFromTi (s) << std::endl;
  std::cout << "q prior: " << ima::readPriorFromTiFile (s, "q") << std::endl;
  std::cout << "m prior: " << ima::readPriorFromTiFile (s, "m") << std::endl;
  return 0;
}

@
\subsection{immalloc.h}

<<immalloc.h>>=
<<im3 copyright>>
#ifndef _IMMALLOC_H_
#define _IMMALLOC_H_ 
<<c decls>>
<<c begin decls>>
<<immalloc header>>
<<c end decls>>
#endif /* _IMMALLOC_H_ */

<<immalloc header>>=
double ****alloc4Ddouble (int d1, int d2, int d3, int d4);
int ****alloc4Dint (int d1, int d2, int d3, int d4);
void free4D (void ****a, int d1, int d2, int d3);
double ***alloc3Ddouble (int layers, int rows, int cols);
int ***alloc3Dint (int layers, int rows, int cols);
void free3D (void ***a, int layers, int rows);
int **alloc2Dint (int rows, int cols);
double **orig2d_alloc2Ddouble (int rows, int cols);
void orig2d_free2D (void **a, int rows);
double **alt2d_alloc2Ddouble(long m, long n);
void alt2d_free2D(double **x/*, long m , long n */);

<<immalloc.c>>=
<<im3 copyright>>
#include <stdlib.h>
#include <string.h>
#include "imdef.h"
#include "imtools.h"
#include "immalloc.h"

extern int step;

double ****
alloc4Ddouble (int d1, int d2, int d3, int d4)
{
  double ****a;
  int i, j, k;

  if ((a = (double ****) malloc (d1 * sizeof (double ***))) == NULL)
    IM_err (IMERR_MEM, "  alloc4Ddouble main malloc did not work.  step %d",
            step);
  for (i = 0; i < d1; i++)
  {
    if ((a[i] = (double ***) malloc (d2 * sizeof (double **))) == NULL)
      IM_err (IMERR_MEM,
              "  alloc4Ddouble first loop malloc did not work. d1 %d,  d2 %d, step %d",
              d1, d2, step);
    for (j = 0; j < d2; j++)
    {
      if ((a[i][j] = (double **) malloc (d3 * sizeof (double *))) == NULL)
        IM_err (IMERR_MEM,
                "  alloc4Ddouble second loop malloc did not work. d2 %d,  d3 %d, step %d",
                d2, d3, step);
      for (k = 0; k < d3; k++)
        if ((a[i][j][k] = (double *) malloc (d4 * sizeof (double))) == NULL)
          IM_err (IMERR_MEM,
                  "  alloc4Ddouble third loop malloc did not work. d3 %d,  d4 %d, step %d",
                  d3, d4, step);
    }
  }
  return a;
}

int ****
alloc4Dint (int d1, int d2, int d3, int d4)
{
  int ****a;
  int i, j, k;

  if ((a = (int ****) malloc (d1 * sizeof (int ***))) == NULL)
    IM_err (IMERR_MEM, "  alloc4Dint main malloc did not work.  step %d",
            step);
  for (i = 0; i < d1; i++)
  {
    if ((a[i] = (int ***) malloc (d2 * sizeof (int **))) == NULL)
      IM_err (IMERR_MEM,
              "  alloc4Dint first loop malloc did not work. d1 %d,  d2 %d, step %d",
              d1, d2, step);
    for (j = 0; j < d2; j++)
    {
      if ((a[i][j] = (int **) malloc (d3 * sizeof (int *))) == NULL)
        IM_err (IMERR_MEM,
                "  alloc4Dint second loop malloc did not work. d2 %d,  d3 %d, step %d",
                d2, d3, step);
      for (k = 0; k < d3; k++)
        if ((a[i][j][k] = (int *) malloc (d4 * sizeof (int))) == NULL)
          IM_err (IMERR_MEM,
                  "  alloc4Dint third loop malloc did not work. d3 %d,  d4 %d, step %d",
                  d3, d4, step);
    }
  }
  return a;
}

void
free4D (void ****a, int d1, int d2, int d3)
{
  int i, j, k;
  for (i = 0; i < d1; i++)
  {
    for (j = 0; j < d2; j++)
    {
      for (k = 0; k < d3; k++)
      {
        XFREE (a[i][j][k]);
        a[i][j][k] = NULL;
      }
      XFREE (a[i][j]);
      a[i][j] = NULL;
    }
    XFREE (a[i]);
    a[i] = NULL;
  }
  XFREE (a);
  a = NULL;
}

double ***
alloc3Ddouble (int layers, int rows, int cols)
{
  double ***a;
  int i, j;
  if ((a = malloc (layers * sizeof (*a))) == NULL)
    IM_err (IMERR_MEM, "  alloc3Ddouble main malloc did not work.  step %d",
            step);
  for (i = 0; i < layers; i++)
  {
    if ((a[i] = malloc (rows * sizeof (*a[i]))) == NULL)
      IM_err (IMERR_MEM,
              "  alloc3Ddouble first loop malloc did not work. layers %d,  rows %d, step %d",
              layers, rows, step);
    for (j = 0; j < rows; j++)
      if ((a[i][j] = malloc (cols * sizeof (*a[i][j]))) == NULL)
        IM_err (IMERR_MEM,
                "  alloc3Ddouble second loop malloc did not work. rows %d,  cols %d, step %d",
                rows, cols, step);
  }
  return a;
}

int ***
alloc3Dint (int layers, int rows, int cols)
{
  int ***a;
  int i, j;
  if ((a = malloc (layers * sizeof (*a))) == NULL)
    IM_err (IMERR_MEM, "  alloc3Dint main malloc did not work.  step %d",
            step);
  for (i = 0; i < layers; i++)
  {
    if ((a[i] = malloc (rows * sizeof (*a[i]))) == NULL)
      IM_err (IMERR_MEM,
              "  alloc3Dint first loop malloc did not work. layers %d,  rows %d, step %d",
              layers, rows, step);
    for (j = 0; j < rows; j++)
      if ((a[i][j] = malloc (cols * sizeof (*a[i][j]))) == NULL)
        IM_err (IMERR_MEM,
                "  alloc3Dint second loop malloc did not work. rows %d,  cols %d, step %d",
                rows, cols, step);
  }
  return a;
}

void
free3D (void ***a, int layers, int rows)
{
  int i, j;
  for (i = 0; i < layers; i++)
    for (j = 0; j < rows; j++)
      XFREE (a[i][j]);
  XFREE (a[i]);
  XFREE (a);
}

int **
alloc2Dint (int rows, int cols)
{
  int **a;
  int i;
  if ((a = malloc (rows * sizeof (*a))) == NULL)
    IM_err (IMERR_MEM, "  alloc2Dint main malloc did not work.  step %d",
            step);
  for (i = 0; i < rows; i++)
    if ((a[i] = malloc (cols * sizeof (*a[i]))) == NULL)
      IM_err (IMERR_MEM,
              "  alloc2Dint loop malloc did not work. rows %d,  cols %d, step %d",
              rows, cols, step);
  return a;
}

double **
orig2d_alloc2Ddouble (int rows, int cols)
{
  double **a;
  int i;
  if ((a = malloc (rows * sizeof (*a))) == NULL)
    IM_err (IMERR_MEM, "  alloc2Ddouble main malloc did not work.  step %d",
            step);
  for (i = 0; i < rows; i++)
    if ((a[i] = malloc (cols * sizeof (*a[i]))) == NULL)
      IM_err (IMERR_MEM,
              "  alloc2Ddouble loop malloc did not work. rows %d,  cols %d, step %d",
              rows, cols, step);
  return a;
} 

double **alt2d_alloc2Ddouble(long m, long n)
// got this from http://www.materialography.de/Book/sourcecodes/malloc2d.c 
/* a double matrix x[0..m-1][0..n-1] is allocated */ 
{  long i;
   double **x;
   
   x=(double **)malloc((size_t)(m*sizeof(double *)));
   x[0]=(double *)malloc((size_t)(m*n*sizeof(double)));
   for(i=1l;i<m;i++) x[i]=x[i-1]+n;
   return x;
}

void
orig2d_free2D (void **a, int rows)
{
  int i;
  for (i = 0; i < rows; i++)
    XFREE (a[i]);
  XFREE (a);
} 

void alt2d_free2D(double **x/*, long m , long n */)
// modified this from http://www.materialography.de/Book/sourcecodes/malloc2d.c 
/* free the double matrix x[0..m-1][0..n-1] */ 
{  XFREE(x[0]); XFREE(x); } 


@
\subsection{Sort algorithm - imalgorithm.h}

<<imalgorithm.h>>=
<<im3 copyright>>
#ifndef _IMALGORITHM_HH_
#define _IMALGORITHM_HH_
#include "gtree.h"
<<c decls>>
<<c begin decls>>
<<imalgorithm struct>>
<<imalgorithm header>>
<<c end decls>>
#endif /* _IMALGORITHM_HH_ */

<<imalgorithm struct>>=
/* struct gtreeevent  is used in treeweight() which sorts all of the events in a genealogy */
struct gtreeevent
{
  double time;
  int pop;     /* population the edge is in when the event happens        */
  int topop;   /* population the edge goes to if it is a migration event  */
  int cmt;     /* coalesce =0 or  migrate=1  or process reaches divT = -1 */
  int periodi; /* period the event is in                                  */
               /* noticed 2/16/09  could probably delete periodi as it    */
               /* seems not to get used                                   */
};

typedef struct gtreeevent im_gtreeevent;

// used for calculating 90% HPD intervals 
struct hlists
{
  double v;
  double p;
};

typedef struct hlists im_hlists;

<<imalgorithm header>>=
void hpsort (struct gtreeevent *lptr, int n);
void hpsortreg (double list[], int n);
void hpsortmig (struct migstruct *lptr, int n);
void shellhist (struct hlists *hptr, int length);
void indexx (unsigned long n, struct gtreeevent *arr, unsigned long *indx);
void sort (double arr[], unsigned long n);

<<imalgorithm.c>>=
#include <math.h>
#include <stdlib.h>
#include "imdef.h"
#include "imalgorithm.h"
#include "imtools.h"

static int *ivector (long nl, long nh);
static void free_ivector (int *v, long nl/* , long nh*/);
static unsigned long *lvector (long nl, long nh);
static void free_lvector (unsigned long *v, long nl/* , long nh*/);

// stuff called by indexx() - sorting an index,  from NR 
#define NRANSI
#define NR_END 1l
#define FREE_ARG char*
int *
ivector (long nl, long nh)
/* allocate an int vector with subscript range v[nl..nh] */
{
  int *v;
  v = (int *) malloc ((size_t) ((nh - nl + 1 + NR_END) * sizeof (int)));
  if (!v)
  {
    nrerror ("allocation failure in ivector()");
  }
  return v - nl + NR_END;
}

void
free_ivector (int *v, long nl/*, long nh*/)
/* free an int vector allocated with ivector() */
{
  free ((FREE_ARG) (v + nl - NR_END));
} 

unsigned long *
lvector (long nl, long nh)
//long nh,nl;
/* allocate an unsigned long vector with subscript range v[nl..nh] */
{
  unsigned long *v;
  v =
    (unsigned long *)
    malloc ((unsigned int) ((nh - nl + 1 + NR_END) * sizeof (long)));
  if (!v)
    nrerror ("allocation failure in lvector()");
  return v - nl + NR_END;
}

void
free_lvector (unsigned long *v, long nl/*, long nh*/)
/* XFREE an unsigned long vector allocated with lvector() */
{
  free ((FREE_ARG) (v + nl - NR_END));
}

/***********************************/
/* SORTING FUNCTIONS */
/***********************************/

/* heap sort is slightly faster than shell sort */
void
hpsort (struct gtreeevent *lptr, int n)
{
  unsigned long i, ir, j, l;
  struct gtreeevent t;
  if (n < 2)
    return;
  l = (n >> 1) + 1;
  ir = n;
  for (;;)
  {
    if (l > 1)
    {
      t = *(lptr + --l);
    }
    else
    {
      t = *(lptr + ir);
      *(lptr + ir) = *(lptr + 1);
      if (--ir == 1)
      {
        *(lptr + 1) = t;
        break;
      }
    }
    i = l;
    j = l + l;
    while (j <= ir)
    {
      if (j < ir && (lptr + j)->time < (lptr + (j + 1))->time)
        j++;
      if (t.time < (lptr + j)->time)
      {
        *(lptr + i) = *(lptr + j);
        i = j;
        j <<= 1;
      }
      else
        j = ir + 1;
    }
    *(lptr + i) = t;
  }
}                               /*hpsort */


/* heap sort is slightly faster than shell sort */
void
hpsortreg (double list[], int n)
{
  unsigned long i, ir, j, l;
  double t;
  if (n < 2)
    return;
  l = (n >> 1) + 1;
  ir = n;
  for (;;)
  {
    if (l > 1)
    {
      t = list[--l];
    }
    else
    {
      t = list[ir];
      list[ir] = list[1];
      if (--ir == 1)

      {
        list[1] = t;
        break;
      }
    }
    i = l;
    j = l + l;
    while (j <= ir)
    {
      if (j < ir && list[j] < list[j + 1])
        j++;
      if (t < list[j])

      {
        list[i] = list[j];
        i = j;
        j <<= 1;
      }
      else
        j = ir + 1;
    }
    list[i] = t;
  }
}                               /*hpsort */


/* heap sort is slightly faster than shell sort */
void
hpsortmig (struct migstruct *lptr, int n)
{
  unsigned long i, ir, j, l;
  double t;
  if (n < 2)
    return;
  l = (n >> 1) + 1;
  ir = n;
  for (;;)
  {
    if (l > 1)
    {
      t = (lptr + --l)->mt;
    }
    else
    {
      t = (lptr + ir)->mt;
      (lptr + ir)->mt = (lptr + 1)->mt;
      if (--ir == 1)

      {
        (lptr + 1)->mt = t;
        break;
      }
    }
    i = l;
    j = l + l;
    while (j <= ir)
    {
      if (j < ir && (lptr + j)->mt < (lptr + (j + 1))->mt)
        j++;
      if (t < (lptr + j)->mt)
      {
        (lptr + i)->mt = (lptr + j)->mt;
        i = j;
        j <<= 1;
      }
      else
      {
        j = ir + 1;
      }
    }
    (lptr + i)->mt = t;
  }
}                               /*hpsortmig */
void
shellhist (struct hlists *hptr, int length)
{
  double aln = 1.442695022, tiny = 1.0e-5;
  struct hlists h;
  static int nn, m, lognb2, i, j, k, l;
  lognb2 = (int) floor (log ((double) length) * aln + tiny);
  m = length;
  for (nn = 1; nn <= lognb2; nn++)
  {
    m = m / 2;
    k = length - m;
    for (j = 0; j <= k - 1; j++)
    {
      i = j;
    reloop:l = i + m;
      if (((hptr + l)->p < (hptr + i)->p)
          || (((hptr + l)->p == (hptr + i)->p)
              && (((hptr + l)->v < (hptr + i)->v))))
      {
        h = *(hptr + i);
        *(hptr + i) = *(hptr + l);
        *(hptr + l) = h;
        i = i - m;
        if (i >= 0)
          goto reloop;
      }
    }
  }
}                               /* shellhist */


/* quicksort of an index of locations */
#define SWAP(a,b) itemp=(a);(a)=(b);(b)=itemp
#define M 7
#define NSTACK 50
void
indexx (unsigned long n, struct gtreeevent *arr, unsigned long *indx)
{
  unsigned long i, indxt, ir = n, itemp, j, k, l = 1;
  int jstack = 0, *istack;
  double a;
  istack = ivector (1, NSTACK);
  for (j = 1; j <= n; j++)
    indx[j] = j;
  for (;;)
  {
    if (ir - l < M)
    {
      for (j = l + 1; j <= ir; j++)
      {
        indxt = indx[j];
        a = arr[indxt].time;
        for (i = j - 1; i >= l; i--)
        {
          if (arr[indx[i]].time <= a)
            break;
          indx[i + 1] = indx[i];
        }
        indx[i + 1] = indxt;
      }
      if (jstack == 0)
        break;
      ir = istack[jstack--];
      l = istack[jstack--];
    }
    else
    {
      k = (l + ir) >> 1;
      SWAP (indx[k], indx[l + 1]);
      if (arr[indx[l]].time > arr[indx[ir]].time)
      {
        SWAP (indx[l], indx[ir]);
      }
      if (arr[indx[l + 1]].time > arr[indx[ir]].time)
      {
        SWAP (indx[l + 1], indx[ir]);
      }
      if (arr[indx[l]].time > arr[indx[l + 1]].time)
      {
        SWAP (indx[l], indx[l + 1]);
      }
      i = l + 1;
      j = ir;
      indxt = indx[l + 1];
      a = arr[indxt].time;
      for (;;)
      {
        do
          i++;
        while (arr[indx[i]].time < a);

        do
          j--;
        while (arr[indx[j]].time > a);

        if (j < i)
          break;
        SWAP (indx[i], indx[j]);
      }
      indx[l + 1] = indx[j];
      indx[j] = indxt;
      jstack += 2;
      if (jstack > NSTACK)
        nrerror ("NSTACK too small in indexx.");
      if (ir - i + 1 >= j - l)
      {
        istack[jstack] = ir;
        istack[jstack - 1] = i;
        ir = j - 1;
      }
      else
      {
        istack[jstack] = j - 1;
        istack[jstack - 1] = l;
        l = i;
      }
    }
  }
  free_ivector (istack, 1/*, NSTACK*/);
}


#undef SWAP

#define SWAP(a,b) temp=(a);(a)=(b);(b)=temp
//regular quicksort
//void sort(unsigned long n, float arr[]) line from nr  
// slightly modified,  works on array of doubles 
void
sort (double arr[], unsigned long n)
{
  unsigned long i, ir = n, j, k, l = 1, *istack;
  int jstack = 0;
  double a, temp;
  istack = lvector (1, NSTACK);
  for (;;)
  {
    if (ir - l < M)
    {
      for (j = l + 1; j <= ir; j++)
      {
        a = arr[j];
        for (i = j - 1; i >= l; i--)
        {
          if (arr[i] <= a)
            break;
          arr[i + 1] = arr[i];
        }
        arr[i + 1] = a;
      }
      if (jstack == 0)
        break;
      ir = istack[jstack--];
      l = istack[jstack--];
    }
    else
    {
      k = (l + ir) >> 1;
      SWAP (arr[k], arr[l + 1]); 
      if (arr[l] > arr[ir])
      {
        SWAP (arr[l], arr[ir]);
      }
      if (arr[l + 1] > arr[ir])
      {
        SWAP (arr[l + 1], arr[ir]);
      }
      if (arr[l] > arr[l + 1])
      {
        SWAP (arr[l], arr[l + 1]);
      }
      i = l + 1;
      j = ir;
      a = arr[l + 1];
      for (;;)
      {

        do
          i++;
        while (arr[i] < a);

        do
          j--;
        while (arr[j] > a);
        if (j < i)
          break;
        SWAP (arr[i], arr[j]);
      }
      arr[l + 1] = arr[j];
      arr[j] = a;
      jstack += 2;
      if (jstack > NSTACK)
        nrerror ("NSTACK too small in sort.");
      if (ir - i + 1 >= j - l)
      {
        istack[jstack] = ir;
        istack[jstack - 1] = i;
        ir = j - 1;
      }
      else
      {
        istack[jstack] = j - 1;
        istack[jstack - 1] = l;
        l = i;
      }
    }
  }
  free_lvector (istack, 1/*, NSTACK*/);
}


#undef SWAP
#undef M
#undef NSTACK
#undef SWAP




@
\subsection{output.hh}

<<output.hh>>=
<<im3 copyright>>
#ifndef _OUTPUT_H_
#define _OUTPUT_H_
<<output header>>
#endif /* _OUTPUT_H_ */

<<output header>>=
void closeopenout (FILE ** p_to_file, char fname[]);
void checkoutfileclosed (FILE ** outfile, char outfilename[]);

void printrunbasics (FILE * outfile, int loadrun, char fpstr[],
                     int burnsteps, int recordint, int recordstep,
                     int savegenealogyint, time_t endtime, time_t starttime,
                     double hilike, double hiprob/*, int step*/);
void checkhighs (int ci, int printint, double *hilike, double *hiprob,
                 double *like/*, int step*/);

void asciitrend (FILE * outfile, struct value_record *v, int trenddoublepoint,int trendspot);
void asciicurve (FILE * outfile, struct plotpoint *a, char *qlabel,
                 int logscale, int recordstep);
void printacceptancerates (FILE * outto, int numrec,
                           struct chainstate_record_updates_and_values *rec[],
                           const char *printstring);
void printacceptancerates_multichain (FILE * outto);
void printcurrentvals (FILE * outto);

void savegenealogyfile (char genealogyinfosavefilename[], FILE * genealogyinfosavefile,
                   int *lastgenealogysavedvalue, int gsampinflength);
void preparehistogram (FILE * outfile, int mode, long int recordstep,
                       double scaleumeaninput, double generationtime);
void printmigratehist (FILE * outfile, int recordstep);
void printtmrcahist (FILE * outfile, int recordstep);
void print_means_variances_correlations (FILE * outfile);

@
\subsection{mcmcfiles.hh}

<<mcmcfiles.hh>>=
<<im3 copyright>>
#ifndef _MCMCFILES_H_
#define _MCMCFILES_H_
<<mcmcfiles header>>
#endif /* _MCMCFILES_H_ */

<<mcmcfiles header>>=
void readmcf (char mcffilename[]);
void writemcf (char mcffilename[]);


@
\subsection{swapchains.hh}

<<swapchains.hh>>=
<<im3 copyright>>
#ifndef _SWAPCHAINS_H_
#define _SWAPCHAINS_H_
<<swapchains header>>
#endif /* _SWAPCHAINS_H_ */

<<swapchains header>>=
void setheat (double hval1, double hval2, int heatmode);
int swapchains (int swaptries, int heatmode, int adaptcheck,
                double hval1, double hval2);
void printchaininfo (FILE * outto, int heatmode, 
                     double hval1, double hval2);

@
\subsection{ginfo.hh}

<<ginfo.hh>>=
<<im3 copyright>>
#ifndef _GINFO_H_
#define _GINFO_H_
<<ginfo struct>>
<<ginfo header>>
#endif /* _GINFO_H_ */

<<ginfo struct>>=
struct probcalc
{
  double *qintegrate;           /*  integration of theta terms                   */
  double *mintegrate;           /* integration of migration terms                */
  double sintegrate;            /* integration of split term for split rate      */
  double pdg;                   /* probability of data given all genealogies     */
  //double plg;                   /* probability of diploid given genealogy        */
  double probg;                 /* prior prob of current genealogy  based on 
                                 * integration over parameter                    */
};

typedef struct probcalc im_probcalc;

/* genealogy_weights holds the information needed to do integrations 
 * of p(Genealogy) for the coalescent-related quantities (cc, hcc, fc),  
 * there is just an array with positions corresponding to population numbers 
 * for the migration-related quantitites there is a 3d array,  
 * with each layer being a period in the poptree, and within each period 
 * there is a 2D array of migration rates.   
 * The indexing of these does not follow population numbers,  
 * but rather follows the position of the population numbers that is 
 * given in plist */
struct genealogy_weights
{
  int **cc;                     /* coalescent counts for pops in period i            */
  double **hcc;                 /* inheritance weights for population in period i    */
  double **fc;                  /*coalescent weights for pops in period i            */
  int ***mc;                    /* migration counts between populations in period i, 
                                 * the positions in layer k of mc (i.e. mc[k] follow 
                                 * the same order and listing in plist[k]            */
  double ***fm;                 /* migration weights between populations in period i */
};

<<ginfo header>>=
void init_genealogy_weights (struct genealogy_weights *gweight);
void setzero_genealogy_weights (struct genealogy_weights *gweight);
void setzero_pcalc (struct probcalc *pcalc);
void free_genealogy_weights (struct genealogy_weights *gweight);
void init_probcalc (struct probcalc *pcalc);
void free_probcalc (struct probcalc *pcalc);
void copy_treeinfo (struct genealogy_weights *dest,
                    struct genealogy_weights *srce);
void clear_treeinfo (struct genealogy_weights *dest);
void copy_probcalc (struct probcalc *dest, struct probcalc *srce);
void sum_subtract_treeinfo (struct genealogy_weights *addup,
                            struct genealogy_weights *addtoplus,
                            struct genealogy_weights *addtominus);
int calc_gsampinf_length (void);
void savegsampinf (float *g);
void sum_treeinfo (struct genealogy_weights *addup,
                   struct genealogy_weights *addto);




@
\subsection{gtree.h}

<<gtree.h>>=
<<im3 copyright>>
#ifndef _GTREE_H_
#define _GTREE_H_
<<c decls>>
<<c begin decls>>
<<gtree struct>>
<<gtree header>>
<<c end decls>>
#endif /* _GTREE_H_ */

<<gtree struct>>=
struct migstruct
{
  double mt; /* for the time                                                */
  int    mp; /* for the population a migration went to (in the coalescent); */
  //double it; /* time for fictitious migration event                         */
  //int    ip; /* population label of the fictitious migration event          */
};

typedef struct migstruct im_migstruct;

// terms needed for loci with HKY mutation model
struct hkyinfo
{
  double **frac;
  double **newfrac;
  double *scalefactor;
  double *oldscalefactor;
};

typedef struct hkyinfo im_hkyinfo;

/*Main data structures: edge, locus, parameter */
/* an edge is a branch in the genealogy
each edge gets a number.  the n sequences are numbers 0 thru n-1.  The remaining n-1 edges are numbered after that.
For edge i.
up[2] - contains the numbers of the edges to which edge i connects to  (i.e. the numbers of its descendants in the genealogy).
down - contains the number of the edge to which edge i connects down to  (i.e. the immediate ancestor in the genealogy
time - contains the time at the bottom of the edge, that is the time at the top of the ancestral edge (down). 
      the root edge has a negative value for time. 
*mig - pointer to arrya that contains the times of migration, and identity of pops migrated to, on edge i, these times are on the same scale as time, 
   and thus must be less than the population splitting time
cmm - current length of the memory available to hold migration times 
mut - used for labeling under INFINITESITES
A - an allele state for stepwise or other allelic model.  This is the state of the node at the top.
dlike - the likelihood of the distance between A, the allele state at the top of the node, and the allele state at the top
of the down edge 
pop - contains the population that the edge is in at its top, which may be different than 
    the one it is in at the bottom, depending on migration.
frac, newfrac, scalefactor, oldscalefactor - used for the HKY mutation model
struct migstruct
{
  double mt;
  int    mp;
  double it;
  int    ip; 
};
*/

/* struct edgmiginfo holds info about the genealogy edges being updated 
 * info is different than what is easily available in the genealogy itself
 * particularly in the arrays mtimeavail and mp which hold the times and number
 * of migration events in each period for the branch.
 * Comment on [[e]]: time period in which the edge ends  e >= b,  DO NOT CONFUSE
 * these values with poptree b and e  which refer to populations.
 *
 * When we move a branch, we could move either only the branch or the branch
 * with its sister. We may know whether a sister branch is involved in a branch
 * using member edgeid. If edgeid for a sister branch is negative, then we may
 * assume that the moving branch is not attached to a root.
 *
 * We may set the following members before using an edgemiginfo variable: li,
 * sisid, edgeid, upt, dnt, pop, temppop, fpop. By calling function 
 * [[fillmiginfoperiods]] we determine the values of b, e, mtimeavail, and 
 * mtall. We set mp, mpall, and mig by migration simulation. */
struct edgemiginfo
{
  /* by manual */
  int li;
  int sisid;
  int edgeid;
  double upt;
  double dnt;
  int pop;
  int temppop;
  int fpop;
  /* by fillmiginfoperiods */
  int b;                        /* time period in which the edge begins */
  int e;
  double *mtimeavail;
  double mtall;
  /* by migration simulation or copying */
  int *mp;
  int mpall;
  struct migstruct mig[ABSMIGMAX];
};

typedef struct edgemiginfo im_edgemiginfo;

struct edge
{
  /* key edge members */
  int up[2];             /* daughter edge IDs: -1 for leaves       */
  int down;              /* down edge ID: -1 for root edge         */
  double time;           /* time at the top of edge                */
  struct migstruct *mig; /* migration events                       */
  int cmm;               /* current size of mig array              */
  /* supplementary members */
  int pop;               /* population the edge is in at its top   */
  int mut;               /* number of mutations on the edge        */
  int *A;
  double *dlikeA;
  struct hkyinfo hkyi;   /* only use if the mutation model for the */
                         /* locus is HKY                           */
  int nmig;              /* the number of migration events in mig  */
  int i;                 /* identifier of individual whose         */
  int ei;                /* index at gtree for saving purposes     */
                         /* changed from gi to ei  1/9/09 is this  */
                         /* used?                                  */
  char exist;            /* 'F' if edge is detached from a         */
                         /* genealogy                              */
  /* variables used for assignment */
  int *seq;              /* sequences at the top of edge           */
  /* Variable population tree due to Yong's */
  im_migstruct *fmig;    /* with fictitious migration events       */
  int fcmm;
  int fpop;
};

typedef struct edge im_edge;


<<gtree header>>=
void checkmig (int i, struct migstruct **mig, int *nmig);

<<gtree.c>>=
#include <stdlib.h>
#include <assert.h>
#include "imdef.h"
#include "imtools.h"
#include "gtree.h"

/* realloc memory for migration arrays, as needed */
#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
//__forceinline void
void
#else
__inline__ void
#endif
checkmig (int i, struct migstruct **mig, int *nmig)
{
  assert (*nmig >= MIGINC);
  if (i + 2 > *nmig)
  {
    *nmig += MIGINC;
    if (*nmig > ABSMIGMAX)
    {
      IM_err(IMERR_MIGARRAYTOOBIG," too many migrations in array %d ",*nmig);
    }
    *mig = realloc (*mig, *nmig * sizeof (struct migstruct));
  }
}

@
\subsection{calcprobdata.hh}

<<calcprobdata.hh>>=
<<im3 copyright>>
#ifndef _CALCPROBDATA_HH_
#define _CALCPROBDATA_HH_
<<calcprobdata header>>
#endif /* _CALCPROBDATA_HH_ */

<<calcprobdata header>>=
void labelgtree (int ci, int li, int edge);
double likelihoodHKY (int ci, int li, double mutrate, double kappa, int e1,
                      int e2, int e3, int e4);

void calc_sumlogk (int ci, int li, double *sumlogk);
void free_sumlogk (void);
double likelihoodIS (int ci, int li, double mutrate);
double likelihoodSW (int ci, int li, int ai, double u, double tr);
void checklikelihoodSW (int ci, int li, int ai, double u);

@
\subsection{updatemcparams.hh}

<<updatemcparams.hh>>=
<<im3 copyright>>
#ifndef _UPDATEMCPARAMS_HH_
#define _UPDATEMCPARAMS_HH_
<<updatemcparams header>>
#endif /* _UPDATEMCPARAMS_HH_ */

<<updatemcparams header>>=
void init_update_mc_params (void);
void free_update_mc_params (void);
int changeu (int ci, int j, int *k);
int changekappa (int ci);

@
\subsection{updategtreecommon.hh}

<<updategtreecommon.hh>>=
<<im3 copyright>>
#ifndef _UPDATEGTREECOMMON_HH_
#define _UPDATEGTREECOMMON_HH_
<<updategtreecommon struct>>
<<updategtreecommon header from imamp>>
<<updategtreecommon header>>
#endif /* _UPDATEGTREECOMMON_HH_ */

<<updategtreecommon struct>>=

<<updategtreecommon header from imamp>>=
/* SANGCHUL: tree
 * We change all findperiod using macro. */
#define findperiod(a,b) C[(a)]->ptree.PtreeFindperiod((b))

/* updating ancestral alleles at nodes,  under stepwise model */
#define updateAfrac 0.05        // inverse of updateAi, just a useful proportion,  don't need to do all of the nodes every step
#define updateAi  20
void init_update_assignment (void);
void free_update_assignment (void);

/* prototypes */



double likelihoodDG (int ci, int li);
int findperiod_Assignment (int ci, double t);
void treeweight_Assignment (int ci, int li);
void integrate_tree_prob_Assignment (int ci,
                                     struct genealogy_weights *gweight,
                                     struct probcalc *pcalc);
void copyfraclike_Assignment (int ci, int li);
void storescalefactors_Assignment (int ci, int li);
void restorescalefactors_Assignment (int ci, int li);
double finishSWupdateA_Assignment (int ci, int li, int ai, int edge,
                                   int downedge, int sisedge, int newsisedge,
                                   double u, double *Aterm);
double updateA_Assignment (int ci, int li, int ai, double u, int *count);
void init_gtreecommon (void);
void free_gtreecommon (void);
double calcmrate (int mc, double mt);
void joinsisdown (int ci, int li, int sis, int *tmrcachange);
void splitsisdown (int ci, int li, int slidingedge, int down, int newsis);
void getm (int ci, double mrate, struct edgemiginfo *edgem,
           struct edgemiginfo *sisem);
void slider (int ci, int li, int slidingedge, int *sis, double *timepoint,
             double *slidedist);
void slider_nomigration (int ci, int li, int slidingedge, int *sis,
                         double *timepoint, double *slidedist);
void IMA_reset_edgemiginfo (struct edgemiginfo *em);
void storeoldedges (int ci, int li, int edge, int sisedge, int downedge);
void restoreedges (int ci, int li, int edge, int sisedge, int downedge,
                   int newsisedge);
double getmprob (int ci, double mrate, struct edgemiginfo *edgem,
                 struct edgemiginfo *sisem);
void storeAinfo (int li, struct edge *gtree, int edge, int sisedge,
                 int downedge);
void fillmiginfoperiods (int ci, struct edgemiginfo *em);
void fillmiginfo (int ci, int li, struct edge *gtree, int edge, int sisedge);
void copynewmig_to_gtree (int ci, int li);
void storegenealogystats (int ci, int li, int mode);
int picktopop (int nowpop, int plist[], int numpops);
int picktopop2 (int nowpop, int plist[], int numpops, int notother);
int mwork (int ci, struct edgemiginfo *edgem, int lastmigperiod,
           double mrate);
double pathcondition (int issame, int moves, int popsless1);

double getnewt (int timeperiod, double t_u_prior, double t_d_prior,
                double oldt, int whichupdate);


<<updategtreecommon header>>=
int nowedgepop (int ci, struct edge *gtree, double ptime);
void init_treeweight (void);
void free_treeweight (void);
void init_holdgtree (struct genealogy *g, int numgenes);
void free_holdgtree (struct genealogy *g, int numgenes);

void treeweight (int ci, int li);
void initialize_integrate_tree_prob (int ci,
                                     struct genealogy_weights *gweight,
                                     struct probcalc *pcalc);
void integrate_tree_prob (int ci, struct genealogy_weights *gweight,
                          struct genealogy_weights *holdgweight,
                          struct probcalc *pcalc, struct probcalc *holdpcalc,
                          double *holdt);
void copyfraclike (int ci, int li);
void storescalefactors (int ci, int li);
double finishSWupdateA (int ci, int li, int ai, int edge, int downedge,
                        int sisedge, int newsisedge, double u, double *Aterm);
double finishSWupdateAD (int ci, int li, int ai, int edge, int downedge,
                         int sisedge, int newsisedge, double u,
                         double *Aterm);
double updateA (int ci, int li, int ai, double u, int *count);
double updateAD (int ci, int li, int ai, double u, int *count);
void restorescalefactors (int ci, int li);


@
\subsection{initialize.hh}

<<initialize.hh>>=
<<im3 copyright>>
#ifndef _INITIALIZE_HH_
#define _INITIALIZE_HH_
<<initialize header>>
#endif /* _INITIALIZE_HH_ */

<<initialize header>>=
void setup (char infilename[], int *fpstri, char fpstr[], char priorfilename[]);

@
\subsection{buildgtree.hh}

<<buildgtree.hh>>=
<<im3 copyright>>
#ifndef _BUILDGTREE_HH_
#define _BUILDGTREE_HH_
<<buildgtree struct>>
<<buildgtree header>>
#endif /* _BUILDGTREE_HH_ */

<<buildgtree struct>>=

<<buildgtree header>>=
void makeHKY (int ci, int li, int nosimmigration);
void makeIS (int ci, int li, int nosimmigration);
void makeJOINT_IS_SW (int ci, int li, int nosimmigration);
void makeSW (int ci, int li, int nosimmigration);

@
\subsection{autoc.hh}

<<autoc.hh>>=
<<im3 copyright>>
#ifndef _AUTOC_HH_
#define _AUTOC_HH_
#include <stdio.h>
<<autoc struct>>
<<autoc header>>
#endif /* _AUTOC_HH_ */

<<autoc struct>>=
/* eevent contains info needed to calculate the mean and variance, correlations and autocorrelations over course of run */
struct eevent
{
  double s;                     /* sum of times */
  double ss;                    /* in case need to sum a second variable */
  double s2;                    /* sum of squares of times */
  int n;                        /* number of events */
};

typedef struct eevent im_eevent;

/* for calculating autocorrelations */

struct autoc
{
  struct eevent cov;
  struct eevent var[2];
  double vals[AUTOCNEXTARRAYLENGTH];
};

typedef struct autoc im_autoc;


<<autoc header>>=
void init_autoc_pointers (void);
void free_autoc_pointers (void);
void checkautoc (int start_autocorrelations, int burndone, int burnsteps);
void callprintautoctable (FILE * outto/*, int step*/);

@
\subsection{updatetRY.hh}

<<updatetRY.hh>>=
<<im3 copyright>>
#ifndef _UPDATETRY_HH_
#define _UPDATETRY_HH_
<<updatetRY header>>
#endif /* _UPDATETRY_HH_ */

<<updatetRY header>>=
void init_t_RY (void);
void free_t_RY (void);

double getnewt (int timeperiod, double t_u_prior, double t_d_prior,
                double oldt, int whichupdate);
int changet_RY2 (int chain, int timeperiod);
int changet_RY1 (int ci, int p);

@
\subsection{updatetNW.hh}

<<updatetNW.hh>>=
<<im3 copyright>>
#ifndef _UPDATETNW_HH_
#define _UPDATETNW_HH_
<<updatetNW header>>
#endif /* _UPDATETRY_HH_ */

<<updatetNW header>>=
void init_t_NW (void);
void free_t_NW (void);

int changet_NW (int ci, int timeperiod);



@
\subsection{updategenealogy.hh}

<<updategenealogy.hh>>=
<<im3 copyright>>
#ifndef _UPDATEGENEALOGY_HH_
#define _UPDATEGENEALOGY_HH_
<<updategenealogy header>>
#endif /* _UPDATEGENEALOGY_HH_ */

<<updategenealogy header>>=
double findjointime (int ci, int slidepop, int sispop, double edgeuptime,
                     double sisuptime);
double addmigration (int ci, int li, int oldmigcount, double oldtlength,
                     int *newmigcount, double *newtlength);
void init_updategenealogy (void);
void free_updategenealogy (void);
int updategenealogy (int ci, int li, int *topolchange, int *tmrcachange);
int updategenealogywch (int ci, int li, int *topolchange, int *tmrcachange);

@
\subsection{readata.hh}

<<readata.hh>>=
<<im3 copyright>>
#ifndef _READATA_H_
#define _READATA_H_
#include "autoc.hh"
<<readata struct>>
<<readata header>>
#endif /* _READATA_H_ */


<<readata header>>=
void read_datafile_top_lines (char infilename[], int *fpstri, char fpstr[],
                              char startpoptreestring[]);
void readdata (char infilename[], int *fpstri,
               char fpstr[], int **numsitesIS);
int imaInfileNpops (const char *fn);

<<readata struct>>=
struct priorvalues
{
  double min;
  double max;
  double mean;
};

typedef struct priorvalues im_priorrange;


/* 1/8/09  new structure 
struct value_record  for recording stuff needed for posterior plots, trends and ESS
char  str[PARAMSTRLN];  name
struct plotpoint *xy;   recorded values that are can later be plotted,an array of gridize elements, each a plotpoint 
double *trend;    record of trend 
struct  autoc ac[AUTOCTERMS];  autocorrelation calculations
int beforemin;   number of values  below the prior
int aftermax;    number of values  above the prior
*/
struct value_record
{
  strnl str;
  strn strshort;
  int do_xyplot;
  int do_logplot;
  struct plotpoint *xy;
  struct priorvalues plotrange;
  double plotrescale;           // 1 unless needed for some reason
  int do_trend;
  double *trend;
  int do_autoc;
  struct autoc ac[AUTOCTERMS];
  int beforemin;
  int aftermax;
};

typedef struct value_record im_value_record;

/* 
1/9/09
 struct chainstate_record_updates_and_values
 replaces struct mc_param
 it is to be used in a way that allows mc_param  variables to be removed from the struct chain and from struct locus 
 it is intended to allow some simplification of code 

 this structure contains a bunch of stuff related to something that can be measured about the state of the Chain 0 
 examples include splitting times, mutation rate scalars,  assignment, measures of assignment,  features of genealogies etc etc 
 An instance of chainstate_record_updates_and_values can hold:
	info on priors and updating window width
	numbers of update types
	acceptance rates for each type
	pointers to another structure (value_record) that hold information on recorded values 

 components of chainstate_record_updates_and_values:
 char str[PARAMSTRLEN]  name of the thing being update 
 struct priorvalues pr;  
 double win    window width, may be used for updating
 int num_uptypes   number of different update types
 char **upnames   array of length num_uptypes of names of different update types
 struct update_rate_calc *upinf   - array of length num_uptypes of calculations of update rates 
 int num_vals    Number of different measurements made -  for some things this will be zero as often we just want to know about update rates, not values
 struct  value_record  *v    pointer to array of length num_vals 
*/
struct chainstate_record_updates_and_values
{
  strn str;
  struct priorvalues pr;
  double win;
  int num_uptypes;
  strnl *upnames;
  struct update_rate_calc *upinf;
  int num_vals;
  struct value_record *v;
};

typedef struct chainstate_record_updates_and_values
  im_chainstate_record_updates_and_values;

struct chainstate_updateonly
{
  strn str;
  int num_uptypes;
  strnl *upnames;
  struct update_rate_calc *upinf;
};

typedef struct chainstate_updateonly im_chainstate_updateonly;


/*  1/9/09  new struct locus 
*/

struct locus
{
  char name[NAMELENGTH];
  int pairs[MAXGENES];
  char gNames[MAXGENES][MAXLENGENENAME];        /* upto 100 gene names of at most 9-character string */
  int numgenesknown;
  int numgenesunknown;
  int ii[MAXGENES];  // what is this for ??  JH  7/9/09 - used for assignment, contains individual ids
  int numgenes;
  int samppop[IMConstants::MAXPOPS];
  int numlines;
  int model;                    /* the overall mutation model for the locus */
  double hval;
  int nlinked;                  /* # of linked portions  = 1 + # linked SW portions */
  int nAlinked;                 /* # of linked SW portions */
  int **A;                      /* points to microsat allele values, if nlinked > 1,  2D array */
  int maxA[MAXLINKED];          /* array of maximum allele size */
  int minA[MAXLINKED];          /* array of minimum allele size */
  int umodel[MAXLINKED];        /* array of locus specific model */
  int numbases;
  int numsites;
  int totsites;       /* added this 5/15/09,  fixed bad HKY bug, not sure why it was missing*/
  int **seq;
  int *mult;
  int *badsite;

  // mutation rate per year values and priors
  double uperyear_vals[MAXLINKED];
  struct priorvalues uperyear_prior[MAXLINKED];
  int uii[MAXLINKED];

  // records for mutation scalars 
  struct chainstate_record_updates_and_values *u_rec;
  struct chainstate_record_updates_and_values *kappa_rec;

  // records for microsat allele state updates 
  struct chainstate_record_updates_and_values *A_rec;

  // records for genealogy measurements 
  struct chainstate_record_updates_and_values *g_rec;

  struct chainstate_record_updates_and_values *a_rec;
  struct chainstate_record_updates_and_values *t_rec;
};

typedef struct locus im_locus;



@
\subsection{freemem.hh}

<<freemem.hh>>=
<<im3 copyright>>
#ifndef _FREEMEM_H_
#define _FREEMEM_H_
<<freemem header>>
#endif /* _FREEMEM_H_ */

<<freemem header>>=
void freeanymemory (void);


@
\section{C++ Primer - 3rd Edition}

@
\subsection{Vector}

<<vector-t.cc>>=
#include <vector>
#include <iostream>
#include <algorithm>
#include "VectorOperation.hh"

using std::vector;
using std::cout;

template <class elem>
class PrintElem {
public:
  void operator()(const elem &s)
  {
    cout << s << std::endl;
  }
};

class PrintVector {
public:
  void operator()(const vector<int> &s)
  {
    for_each (s.begin(), s.end(), PrintElem<int>());
  }
};

int main (int argc, char ** argv)
{
  vector< vector<int> > a;

  for (int i = 0; i < 5; i++)
    {
      vector<int> aa;
      for (int j = 0; j < 5 - i; j++)
        {
          aa.push_back (j);
        }
      a.push_back (aa);
    }
  for_each (a.begin(), a.end(), PrintVector()); 


  vector<int> b;
  b.resize (10);
  b.assign (2, -1);
  for_each (b.begin(), b.end(), PrintElem<int>());

  vector<int> b1 (100, 1000);
  b1 = b;
  for_each (b1.begin(), b1.end(), PrintElem<int>());

  b1.assign (2, 2);
  transform (b1.begin(), b1.end(), b.begin(), b1.begin(), VectorSum<int>);
  for_each (b1.begin(), b1.end(), PrintElem<int>());

  b1.assign (2, 6);
  transform (b1.begin(), b1.end(), b.begin(), b1.begin(), VectorDifference<int>);
  for_each (b1.begin(), b1.end(), PrintElem<int>());

  transform (b1.begin(), b1.end(), b1.begin(), VectorZero<int>);
  for_each (b1.begin(), b1.end(), PrintElem<int>());

  return 0; 
}

@
\subsection{string}

<<string-t.cc>>=
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <utility>
#include <cstdlib>

using std::string;
using std::cout;
using std::endl;

namespace ima {
  std::pair<int,int> readTiM (std::ifstream &is, const char * m)
  {
    int v1;
    int v2;
    string numerics ("0123456789");
    string arrow (">");
    string s;
    string n;
    is >> s;
    string::size_type pos = s.find (m);
    if (pos == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return std::make_pair(-1,-1);
      }

    pos = s.find_first_of (numerics);
    if (pos == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return std::make_pair(-1,-1);
      }
    string::size_type posArrow = s.find_first_of (arrow);
    if (posArrow == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return std::make_pair(-1,-1);
      }
    n = s.substr (pos, posArrow - pos); 
    v1 = atoi (n.c_str());
    n = s.substr (posArrow + 1);
    v2 = atoi (n.c_str());
    return std::make_pair(v1,v2);
  }

  int readTiQ (std::ifstream &is, const char * q)
  {
    int v;
    string numerics ("0123456789");
    string s;
    string n;
    is >> s;
    string::size_type pos = s.find (q);
    if (pos == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return -1;
      }

    pos = s.find_first_of (numerics);
    if (pos == string::npos)
      {
        std::cerr << "The ti file is corrupted - bye!\n";
        return -1;
      }
    n = s.substr(pos); 
    v = atoi (n.c_str());
    return v;
  }

  bool readTill (std::ifstream &is)
  {
    char c;
    bool notFound = true;
    string w;

    while (notFound)
      {
        c = is.get ();
        switch (c)
          {
          case 'V':
            w = c;
          break;
          case 'A':
            if (w == "V" || w == "VALUESST")
              w += c;
            else
              w = "";
          break;
          case 'L':
            if (w == "VA")
              w += c;
            else
              w = "";
          break;
          case 'U':
            if (w == "VAL")
              w += c;
            else
              w = "";
          break;
          case 'E':
            if (w == "VALU")
              w += c;
            else
              w = "";
          break;
          case 'S':
            if (w == "VALUE" || w == "VALUES")
              w += c;
            else
              w = "";
          break;
          case 'T':
            if (w == "VALUESS")
              w += c;
            else if (w == "VALUESSTAR")
              notFound = false;
            else
              w = "";
          break;
          case 'R':
            if (w == "VALUESSTA")
              w += c;
            else
              w = "";
          break;
          }
      }
    return !notFound;
  }
}

int main (int argc, char ** argv)
{
  int si;
  int _indexLH;
  int pi;
  double qt;
  double mt;
  int qc;
  double hcc;
  double fc;
  int mc;
  double fm;
  std::pair<int,int> pqi;

  char c;
  string s = "../run/t5/o/t5-1.out.ti";
  std::ifstream is(s.c_str(), std::ios::in);

  // Read until we hit "VALUESSTART"
  if (!ima::readTill (is))
  {
    std::cerr << "Not found VALUESSTART\n";
    return 0;
  }

  is >> si;
  is >> _indexLH;

  pi = ima::readTiQ (is, "qt");
  is >> qt;
  pqi = ima::readTiM (is, "mt");
  is >> mt;
  pqi = ima::readTiM (is, "mt");
  is >> mt;
  pqi = ima::readTiM (is, "mt");
  is >> mt;
  pqi = ima::readTiM (is, "mt");
  is >> mt;
  pi = ima::readTiQ (is, "qc");
  is >> qc;
  is >> hcc;
  is >> fc;
  pqi = ima::readTiM (is, "mc");
  is >> mc;
  is >> fm;


  std::cout << si << std::endl;
  std::cout << _indexLH << std::endl;
  std::cout << "qt-" << pi << " " << qt << std::endl;
  std::cout << "mt-" << pqi.first << ">" << pqi.second 
            << " " << mt << std::endl;
  std::cout << "qc-" << pi << " " << qc << " " 
            << hcc << " " << fc << std::endl;
  std::cout << "mc-" << pqi.first << ">" << pqi.second 
            << " " << mc << " " << fm << std::endl;

  is.close ();
  return 0;
}


@
\subsection{Sort pairs}

<<pair.cc>>=
#include <vector>
#include <utility>
#include <algorithm>
#include <iostream>

using std::vector;
using std::pair;
using std::make_pair;
using std::sort;
using std::cout;
using std::for_each;

typedef pair<int,int> PairInt;
typedef pair<pair<int,int>,double> splitEvent;

class DecreasingSplitEvent {
public:
  bool operator()(const splitEvent &s1, const splitEvent &s2)
  {
    return s1.second > s2.second;
  }
};

class PrintSplitEvent {
public:
  void operator()(const splitEvent &s)
  {
    cout << "Node: " << s.first.first << ", "
         << "Time: " << s.second << std::endl;
  }
};

template <class elem>
class PrintElem {
public:
  void operator()(const elem &s)
  {
    cout << s << std::endl;
  }
};


template <class elem>
class PrintPair {
public:
  void operator()(const elem &s)
  {
    cout << s.first << "\t" << s.second << std::endl;
  }
};

class IsPair {
  int i;
public:
  IsPair (int j): i(j) {}
  bool operator()(const PairInt &e)
  {
    return i == e.first;
  }
  bool operator==(const PairInt &e)
  {
    return i == e.first;
  }
};

int main (int argc, char ** argv)
{
  vector<splitEvent> a; 
  a.push_back (make_pair(make_pair(4,0),0.5));
  a.push_back (make_pair(make_pair(5,1),0.7));
  a.push_back (make_pair(make_pair(6,2),0.2));
  sort (a.begin(), a.end(), DecreasingSplitEvent()); 
  for_each (a.begin(), a.end(), PrintSplitEvent()); 


  for (vector<splitEvent>::iterator i = a.begin();
       i != a.end();
       i++)
  {
    cout << i->first.first << std::endl;
  }

  vector<double> b;
  b.push_back (0.2);
  b.push_back (0.5);
  b.push_back (0.3);
  b.push_back (0.1);
  b.push_back (0.7);
  sort (b.rbegin(), b.rend());
  for_each (b.begin(), b.end(), PrintElem<double>());

  vector< pair<int,int> > c;
  c.push_back (make_pair(4,1));
  c.push_back (make_pair(5,3));
  c.push_back (make_pair(1,5));
  c.push_back (make_pair(2,7));
  vector<PairInt>::iterator i = find (c.begin(), c.end(), IsPair(4));
  i->second++;
  //for_each (c.begin(), c.end(), PrintPair<PairInt>());
}

@
\subsection{String}

<<CString.hh>>=
<<im3 copyright>>
///
/// \file CString.hh
/// \brief Provides basic functions of a typical string class.
/// 
/// I have been developing things using C. I experiment C++ using this class.
///
/// \author Sang Chul Choi
///

#include <iostream>

class CString {
  friend std::ostream& operator<<(std::ostream& os, const CString& cs);
  char * text;
  int capacity;
public:
  CString ();
  CString (const char * s);
  CString (const CString &r);
  CString& operator=(const CString &r);
  ~CString ();
  size_t const StringSize ();
  size_t const StringLength ();
  size_t const StringCapacity ();
  char * const StringCStr ();
  char const StringAt (size_t pos);
  bool const StringEmpty ();
  void StringClear ();
  int const StringCompare (const char * s);
  void StringAppend (const char * s);
};

<<CString.cc>>=
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include "CString.hh"

CString::CString () {
  capacity = 0;
  text = NULL;
}

CString::CString (const char * s) {
  capacity = strlen(s) + 1;
  text = (char *) malloc ((capacity + 1) * sizeof (char));
  strcpy ((char *) text, s);
}

CString::~CString () {
  free((void *) text), text = NULL;
}

CString::CString (const CString &r) {
  capacity = r.capacity;
  text = (char *) malloc ((capacity + 1) * sizeof (char));
  strcpy ((char *) text, r.text);
}

CString& 
CString::operator=(const CString &r) {
  if (&r != this)
    {
      if (capacity < r.capacity)
        {
          capacity = r.capacity;
          text = (char *) realloc (text, (capacity + 1) * sizeof (char));
        }
      strcpy ((char *) text, r.text);
    }
  return *this;
}

std::ostream&
operator <<(std::ostream& os, const CString& cs) {
  os << "Text: " << cs.text;
  return os;
}

size_t const
CString::StringSize () {
  return strlen(text);
}

size_t const
CString::StringLength () {
  return StringSize();
}

size_t const
CString::StringCapacity () {
  return capacity;
}

char * const
CString::StringCStr () {
  return text;
}

char const
CString::StringAt (size_t pos) {
  return *(text + pos);
}

bool const
CString::StringEmpty () {
  return strlen (text) == 0;
}

void
CString::StringClear () {
  *text = '\0';
  return;
}

int const
CString::StringCompare (const char * s) {
  return strcmp (text, s);
}

void
CString::StringAppend (const char * s) {
  size_t l;
  size_t l1;
  size_t l2;
  l1 = strlen (text);
  l2 = strlen (s);
  if (!(capacity > l1 + l2))
    {
      capacity = l1 + l2 + 1;
      text = (char *) realloc (text, capacity * sizeof (char)); 
    }
  strcat (text, s);
  return;
}

<<CString-t.cc>>=
#include "CString.hh"

int main (int argc, char ** argv)
{	
  int i;
  CString p("Hello, World!");
  CString p2;

  for (i = 0; i < 1000000; i++)
    {
      p.StringAppend("7");
    }
  return 0;

  p2 = p;
  std::cout << p << std::endl;
  std::cout << "Size of p: " << p.StringSize() << std::endl;
  std::cout << "Length of p: " << p.StringLength() << std::endl;
  std::cout << "Capacity of p: " << p.StringCapacity() << std::endl;
  fprintf (stdout, "C Sting is %s\n", p.StringCStr());
  std::cout << "Character of p at 5 is " << p.StringAt(5) << std::endl;
  if (p.StringEmpty() == false)
    {
      std::cout << "String p is not empty" << std::endl;
    }
  p.StringClear();
  if (p.StringEmpty() == true)
    {
      std::cout << "The string is empty" << std::endl;
    }

  p = p2;
  if (p.StringCompare("Hello, World!") == 0)
    {
      std::cout << "The string p is equal to Hello, World!" << std::endl;
    }

  p.StringAppend(" Sang Chul");

  std::cout << p << std::endl;
  std::cout << p2 << std::endl;

  return 0;
}

<<cc-t.cc>>=
#include <iostream>

int main (int argc, char ** argv)
{
  std::cout << "Hello, World!" << std::endl;
  return 0;
}


@
\subsection{Bookstore}

<<bookstore.cc>>=
#include <iostream> 
#include <assert.h>
void read() { std::cout << "read()\n"; }
void sort() { std::cout << "sort()\n"; } 
void compact() { std::cout << "compact()\n"; }
void write() { std::cout << "write()\n"; }
int main() {
  assert (0);
  read(); 
  sort(); 
  compact(); 
  write(); 
  return 0;
}

<<word.cc>>=
#include <iostream> 
#include <string>

using namespace std;
int main() {
  string word; 
  while ( cin >> word )
    {
      cout << "word read is: " <<  word << '\n'; 
    }
      cout << "ok: no more words to read: bye!\n"; 
  return 0;
}


@
\section{Potential thoughts}
\subsection{IM and XML}


@
\pagebreak{}

\addcontentsline{toc}{section}{References}
\bibliographystyle{philtb}
\bibliography{/Users/goshng/Documents/manuscripts/bibdesk/pritchard}
%\bibliography{/home/goshng/Documents/manuscripts/bibdesk/pritchard}

\end{document}

Some sites
http://ooc-lang.org
github 
http://www.parrot.org
http://rakudo.org
http://www.embedded.com/columns/14700472?_requestid=446413

