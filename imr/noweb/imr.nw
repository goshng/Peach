\documentclass{article}
\usepackage{noweb}
\usepackage{fancyvrb}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage[authoryear]{natbib}
\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}
\pagestyle{noweb}
\begin{document}

\title{Isolation, Migration, and Recombination Model}
\author{Sang Chul Choi\\
\\
Rutgers University, and Cornell University}

\maketitle

\tableofcontents

\newpage{}
\section{History}
\begin{enumerate}
\item Sat Jul  9 00:32:06 EDT 2011: TinyXML packages are used.
\item Tue Jul  5 20:58:13 EDT 2011: A recombinant tree is created using
sequentially sampled gene trees.
\item Wed Jun 22 14:54:40 EDT 2011: I started to focus on infinite-sites
mutation model.
\item Wed Mar  3 18:44:01 EST 2010: I started to code recombinant trees.
\end{enumerate}

\newpage{}

\section{Installation}
How to start the coding
\begin{Verbatim}[frame=lines,framesep=5mm]
$ wcd imr/src/build
$ cd ..; ./c; cd build; cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug; make
\end{Verbatim}

Build a debug version using CMake.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ cd src/imr/src
$ mkdir debug
$ cd debug
$ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
\end{Verbatim}

\section{C++ Resources}

Pass vector arguments to functions:
http://www.cplusplus.com/forum/beginner/26235/

A thread about const to non-const conversion:
http://forums.devx.com/archive/index.php/t-156981.html

A thread about log:
http://stackoverflow.com/questions/696321/best-logging-framework-for-native-c

Virtual functions and abstract class
http://www.learncpp.com/cpp-tutorial/126-pure-virtual-functions-abstract-base-classes-and-interface-classes/

CMake:
http://www-flc.desy.de/ldcoptimization/documents/talks/CMake\_Tutorial.pdf

\subsection{Build imr}
<<CMakeLists.txt>>=
cmake_minimum_required(VERSION 2.8)
PROJECT (imr)
SET (imr_SRCS 
  "SimpleGlob.h"
  "SimpleOpt.h"
  "tinystr.cpp"
  "tinystr.h"
  "tinyxml.cpp"
  "tinyxml.h"
  "tinyxmlerror.cpp"
  "tinyxmlparser.cpp"
  "imr.cpp"
  "imrMultichain.cpp"
  "imrMultichain.h"
  "imrChain.cpp"
  "imrChain.h"
  "imrPriorg.cpp"
  "imrPriorg.h"
  "imrRvTree.cpp"
  "imrRvTree.h"
  "imrTree.cpp"
  "imrTree.h"
  "imrSetup.cpp"
  "imrSetup.h"
  "imrProposal.cpp"
  "imrProposal.h"
  "imrRandomVariable.h"
  "imrEvent.cpp"
  "imrEvent.h"
  "imrEdge.cpp"
  "imrEdge.h"
  "imrSequence.cpp"
  "imrSequence.h"
  "imrType.h"
  "imrHelp.cpp"
  "imrHelp.h"
  "imrXmlFastsimcoal.cpp"
  "imrXmlFastsimcoal.h"
  "imrXmlImrInput.cpp"
  "imrXmlImrInput.h"
  "imrXmlImrOutput.cpp"
  "imrXmlImrOutput.h"
  "imrXmlImrRectree.cpp"
  "imrXmlImrRectree.h"
  "imrXmlImrEvent.cpp"
  "imrXmlImrEvent.h"
  "imrDefault.cpp"
  "imrDefault.h"
  "imrCmdLikelihood.cpp"
  "imrCmdLikelihood.h"
  "imrXml.cpp"
  "imrXml.h"
)
ADD_DEFINITIONS("-DTIXML_USE_STL")
SET (CMAKE_C_FLAGS_DEBUG "-Wall -Wextra -W -Wshadow -Wcast-qual -Wwrite-strings -g3 -ggdb -O0")

ADD_EXECUTABLE (imr ${imr_SRCS})

@
\subsection{Debug imr}
When you add a new source file, change [[CMakeLists.txt]]. You also need to
change [[c]] file in the [[src]] directory.

Create a [[build]] directory at the src directory.
\begin{Verbatim}[frame=lines,framesep=5mm]
mkdir build
\end{Verbatim}

In the [[build]] execute the following line to build imr.
\begin{Verbatim}[frame=lines,framesep=5mm]
pushd ..;./c;popd;cmake ..;make
\end{Verbatim}

\section{Overview of IMR}
\subsection{To Do}
\begin{enumerate}
\item Implement recombinant tree update.
\item Code the structure of recombinant branches. 
\item Code the update of recombinant branches using Kuhner2000 method.
\item Use fastsimcoal or Excoffier2011 method to simulate data and test it.
\item Code the recombinant tree parameter.
\item Code the species tree parameter.
\item Recode the computation of prior of recombinant trees.
\item Code the update of splitting time using Rannala2003 method.
\item Code the update of migration events using Beerli1999 method.
\item Find examples with long sequences to work with.
\item Write a manuscript.
\item Publish the code with the submission of the manuscript.
\item Build an initial recombinant tree using Gusfield2004 method (not
work).
\item Convert galledtree output to XML input file for recombinant tree. (not
work)
\item Specify the XML input/output file format, and code it using tinyXML.
(tried)
\item Convert fastsimcoal output to XML input files using PERL. I can easily
parse a simple XML file. Let's convert fastsimcoal output files into an imr
input file. I will use a perl script for that. Two input files and one output
file. (tried)
\end{enumerate}

\subsection{Features of IMR}
We present the features developed during the development of IMR.
All test data sets and command lines are provided in each of subsections that
follow.
\begin{enumerate}
\item A single population model of IMR with infinite-sites data, and
\item Two-population demographics of IMR with infinite-sites data.
\end{enumerate}


\section{Commmand line options}

\section{Simulations}

\subsection{fastsimcoal}
Use menu *convert-fsc-to-imr* to convert a Fastsimcoal file to an imr input file.

\section{Real Data}

\section{Demographics: species or population tree}

\section{Recombinant tree}
I build a recombinant tree and construct ways of changing the recombinant tree.

\section{Likelihood of data given a recombinant tree}
I need to compute the probability of data given a recombinant tree.

\section{Probability of a recombinant tree given a species tree}

\section{XML}

[[printRecombination]] takes event time, up, left, right branches, lefthand side
of the breaking point, a vector of rightmost sites of non-recombining regions
for the left branch, another vector for the right branch, and the four XML
objects.
\begin{Verbatim}[frame=lines,framesep=5mm]
  printRecombination (2.0, 6, 8, 9, 8, 
                      iVec8, iVec9, 
                      numberSite,
                      rectree, event, edge, site);
\end{Verbatim}

[[printCoalescent]] takes event time, left, right, down, a vector of the union
of the left and right edge.
\begin{Verbatim}[frame=lines,framesep=5mm]
  static void printCoalescent (double t, int left, int right, int down,
                               const std::vector<int>& iVecDown, 
                               int numberSite,
                               TiXmlElement * rectree, 
                               TiXmlElement * event, 
                               TiXmlElement * edge, 
                               TiXmlElement * site);
\end{Verbatim}

\section{Code}
\subsection{Copyright}
<<imr gnu copyright>>=
// This file is a part of IMR.
//
// IMR is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// IMamp is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with IMR.  If not, see <http://www.gnu.org/licenses/>.

@
\subsection{Main}

<<imr.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include "SimpleOpt.h"
#include "SimpleGlob.h"
#include "imrTree.h"
#include "imrHelp.h"
#include "imrXmlFastsimcoal.h"
#include "imrXmlImrInput.h"
#include "imrXmlImrOutput.h"
#include "imrXmlImrRectree.h"
#include "imrXmlImrEvent.h"
#include "imrDefault.h"
#include "imrXml.h"
#include "imrCmdLikelihood.h"
#include "imrChain.h"
#include "imrSetup.h"
#include "imrProposal.h"
using namespace std;
using namespace imr;

static string sInfile;
static string sOutfile;
static int sCommand = 0;
static int sXmlPrint = 1;
static int sBuildWhat = 1;
static int sBuildTreeRemove = 0; 

enum 
{
  OPT_BUILD_WHAT_DEFAULT = 1,
  OPT_BUILD_WHAT_EVENT
};

enum 
{
  OPT_XML_PRINT_DEFAULT = 1,
  OPT_XML_PRINT_FASTSIMCOAL,
  OPT_XML_PRINT_IMRINPUT,
  OPT_XML_PRINT_IMROUTPUT,
  OPT_XML_PRINT_RECOMBINANTTREE,
  OPT_XML_PRINT_EVENT
};

enum { 
    OPT_HELP, 
    OPT_INFILE,
    OPT_OUTFILE,
    OPT_VERSION,
    OPT_MCMC,
    OPT_CHAIN,
    OPT_SUMMARIZE,
    OPT_LIKELIHOOD,
    OPT_PRIOR,
    OPT_XML,
    OPT_BUILD,
    OPT_PRINT,
    OPT_WHAT,
    OPT_REMOVE,
    OPT_FOO, 
    OPT_BAR, 
    OPT_HOGE 
};
CSimpleOpt::SOption g_rgOptions[] = {
    // ID       TEXT          TYPE
    { OPT_FOO,  "-a",     SO_NONE    }, // "-a"
    { OPT_BAR,  "-b",     SO_NONE    }, // "-b"
    { OPT_HOGE, "-f",     SO_REQ_SEP }, // "-f ARG"
    { OPT_PRINT, "-p",     SO_REQ_SEP },
    { OPT_PRINT, "--print", SO_REQ_SEP },
    { OPT_WHAT, "-w",     SO_REQ_SEP },
    { OPT_WHAT, "--what", SO_REQ_SEP },
    { OPT_HELP, "-?",     SO_NONE    },
    { OPT_HELP, "--help", SO_NONE    },
    { OPT_INFILE, "-i",     SO_REQ_SEP },
    { OPT_INFILE, "--infile",   SO_REQ_SEP },
    { OPT_OUTFILE, "-o",     SO_REQ_SEP },
    { OPT_OUTFILE, "--outfile",   SO_REQ_SEP },
    { OPT_VERSION, "--version", SO_NONE },
    // Commands
    { OPT_MCMC, "mcmc", SO_NONE },
    { OPT_CHAIN, "chain", SO_NONE },
    { OPT_SUMMARIZE, "summarize", SO_NONE },
    { OPT_LIKELIHOOD, "likelihood", SO_NONE },
    { OPT_PRIOR, "prior", SO_NONE },
    { OPT_XML, "xml", SO_NONE },
    { OPT_BUILD, "build", SO_NONE },
    { OPT_REMOVE, "--remove", SO_REQ_SEP },
    SO_END_OF_OPTIONS                       // END
};

#include "log.h"

// LOG_DECLARE;

int 
main (int argc, char* argv[])
{
  // LOG_INIT("main.log");
  // LOG_MSG("Application initialization");
  if (argc == 1)
    {
      Help::full ();
      return 0;
    }

  // Parses a command line.
  CSimpleOpt args(argc, argv, g_rgOptions);
  while (args.Next()) 
    {
      if (args.LastError() == SO_SUCCESS) 
        {
          if (args.OptionId() == OPT_HELP) 
            {
              Help::full ();
              return 0;
            }
          else if (args.OptionId() == OPT_VERSION) 
            {
              Help::version ();
            }
          else if (args.OptionId() == OPT_OUTFILE) 
            {
              sOutfile = args.OptionArg();
            }
          else if (args.OptionId() == OPT_INFILE) 
            {
              sInfile = args.OptionArg();
            }
          else if (args.OptionId() == OPT_MCMC) 
            {
              cout << "Start MCMC ..." << endl;
            }
          else if (args.OptionId() == OPT_CHAIN) 
            {
              sCommand = OPT_CHAIN;
            }
          else if (args.OptionId() == OPT_SUMMARIZE) 
            {
              cout << "Summarizing a posterior sample ..." << endl;
            }
          else if (args.OptionId() == OPT_LIKELIHOOD) 
            {
              sCommand = OPT_LIKELIHOOD;
            }
          else if (args.OptionId() == OPT_BUILD) 
            {
              sCommand = OPT_BUILD;
            }
          else if (args.OptionId() == OPT_PRIOR) 
            {
              cout << "Computing the prior of a recombinant tree..." << endl;
            }
          else if (args.OptionId() == OPT_XML) 
            {
              sCommand = OPT_XML;
            }
          else if (args.OptionId() == OPT_PRINT) 
            {
              sXmlPrint = atoi(args.OptionArg());
            }
          else if (args.OptionId() == OPT_WHAT) 
            {
              sBuildWhat = atoi(args.OptionArg());
            }
          else if (args.OptionId() == OPT_REMOVE) 
            {
              sBuildTreeRemove = atoi(args.OptionArg());
            }
        }
      else 
        {
          cerr << "Invalid argument: " << args.OptionText() << endl;
        }
    }
  
  Setup (sInfile.c_str());
  Proposal (sInfile.c_str());

  // Execute one command with options.
  switch (sCommand)
    {
    case OPT_XML:
      if (sXmlPrint == OPT_XML_PRINT_DEFAULT) 
        {
          Default::save (sOutfile.c_str());
        }
      else if (sXmlPrint == OPT_XML_PRINT_FASTSIMCOAL) 
        {
          XmlFastsimcoal::save (sOutfile.c_str());
        }
      else if (sXmlPrint == OPT_XML_PRINT_IMRINPUT) 
        {
          XmlImrInput::save (sOutfile.c_str());
        }
      else if (sXmlPrint == OPT_XML_PRINT_IMROUTPUT) 
        {
          XmlImrOutput::save (sOutfile.c_str());
        }
      else if (sXmlPrint == OPT_XML_PRINT_RECOMBINANTTREE) 
        {
          XmlImrRectree::save (sOutfile.c_str());
        }
      else if (sXmlPrint == OPT_XML_PRINT_EVENT) 
        {
          XmlImrEvent::save (sOutfile.c_str());
        }
      else
        {
          Xml::readFastsimcoal (sInfile);
        }
      break;
    case OPT_CHAIN:
      {
        Chain c;
        c.load (sInfile);
        c.run ();
        break;
      }
    case OPT_LIKELIHOOD:
      CmdLikelihood::compute (sInfile.c_str());
      CmdLikelihood::report ();
      break;
    case OPT_BUILD:
      if (sBuildWhat == OPT_BUILD_WHAT_DEFAULT) 
        {
          XmlImrRectree::load (sInfile.c_str(), sOutfile.c_str(), sBuildTreeRemove);
        }
      else if (sBuildWhat == OPT_BUILD_WHAT_EVENT) 
        {
          XmlImrEvent::load (sInfile.c_str());
        }
      break;
    default:
      cerr << "Unrecognized command" << endl;
      break;
    }
  return 0;
}

<<imr.h>>=
<<imr gnu copyright>>
#ifndef _IMR_H_
#define _IMR_H_

#endif // _IMR_H_
@
\subsection{Common header}
<<imrCommon.h>>=
<<imr gnu copyright>>
#ifndef _IMRCOMMON_H_
#define _IMRCOMMON_H_
#endif // _IMRCOMMON_H_
@
\subsection{Defined data types}
A few data types are redefined.
<<imrType.h>>=
<<imr gnu copyright>>
#ifndef _IMRTYPE_H_
#define _IMRTYPE_H_
typedef unsigned long ULONG;
typedef unsigned int UINT;
typedef double UDBL;
typedef double UFLT;
#endif // _IMRTYPE_H_
@
\subsection{Online help}

<<imrHelp.h>>=
<<imr gnu copyright>>
#ifndef _IMRHELP_H_
#define _IMRHELP_H_
namespace imr {
class Help {
public:
  static void full ();
  static void version ();
};
}
#endif // _IMRHELP_H_
<<imrHelp.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include "imrHelp.h"
using namespace std;
namespace imr {
void 
Help::full ()
{
  cout << ""
"IMR(1)                          IMR Commands Manual                       IMR(1)\n"
"\n"
"NAME\n"
"   imr -- Isolation, migration, and recombination\n"
"\n"
"SYNOPSIS\n"
"   imr [OPTION]\n"
"\n"
"DESCRIPTION\n"
"   The program implements a statistical method of estimating population sizes,\n"
"   migration rates, and recombination rates using infinite-sites data.\n"
"   The method is described in papers (Choi 2011).\n"
"\n"
"   General options:\n"
"      -h --help -?\n"
"         Shows this help message.\n"
"      --version\n"
"         Shows the version.\n"
"      -i --infile [INFILE]\n"
"         Reads in an input file.\n"
"      --type\n"
"         Input and output files are in XML format.\n" 
"\n"
"   Commands:\n"
"      mcmc\n"
"         Samples recombinant trees.\n"
"      summarize\n"
"         Summarizes a posterior sample of recombinant trees.\n"
"      likelihood\n"
"         Computes the likelihod of a recombinant tree given data.\n"
"      prior\n"
"         Computes the prior of a recombinant tree given model parameters.\n"
"      xml\n"
"         Reads and writes XML files.\n"
"      build\n"
"         Reads an XML file to build a recombinant tree.\n"
"      chain\n"
"         Uses chains.\n"
"\n"
"   Command build options:\n"
"      -w --what [NUMBER]\n"
"         1 Build a recombiant tree by reading the XML file that is\n"
"           created by xml --print 5 -o imrrectree.xml\n"
"         2 Build a list of events by reading the XML file that is\n"
"           created by xml --print 6 -o imrevent.xml\n"
"      --remove [NUMBER]\n"
"         Remove a recombinant edge.\n"
"\n"
"   Command xml options:\n"
"      -p --print [NUMBER]\n"
"         1 Default setting\n"
"         2 fastsimcoal file\n"
"         3 imr input file\n"
"         4 imr output file\n"
"         5 imr recombinant tree file\n"
"         6 imr event file\n"
"         7 imr chain state file\n"
"\n"
"   Files:\n"
"      INFILE\n"
"         Different commands can be combined with different formats of input\n"
"         files. An input file with command xml is an XML file.\n" 
"      OUTFILE\n"
"\n"
"   Usages:\n"
"      imr xml --infile INFILE\n"
"         Reads in an XML file, and prints it out to standard output.\n"
"      imr xml --print 1 -o default.xml\n" 
"         Prints the imr default setting.\n"
"      imr likelihood -i imroutput.xml\n"
"         Computes the likelihood of data given a recombinant tree.\n"
"      imr xml --print 5 -o imrrectree.xml\n"
"         Creates a recombinant tree in XML format\n"
"      imr build -w 1 --infile imrrectree.xml\n"
"         Build a recombinant tree using an XML file.\n"
"      imr build -w 1 --remove 1 --infile imrrectree.xml\n"
"         Build a recombinant tree using an XML file, and remove the edge.\n"
"      imr build -w 1 --remove 1 --infile imrrectree.xml -o partialtree.xml\n"
"         Build a recombinant tree using an XML file, and remove the edge.\n"
"      imr xml --print 6 -o imrevent.xml\n"
"         Creates a list of events in XML format\n"
"      imr build -w 2 --infile imrevent.xml\n"
"         Build a list of events using an XML file.\n"
"      imr xml --print 7\n"
"         Build a list of events using an XML file.\n"
"      imr xml --print 3 -o imrinput.xml\n" 
"         Prints the imr input file.\n"
"      imr chain --infile imrinput.xml\n"
"         Test a chain.\n"
"\n"
"AUTHOR\n"
"   Written by Sang Chul Choi\n"
"\n"
"REPORTING BUGS\n"
"   Report bugs to google group of Isolation with Migration\n"
"   at http://groups.google.com/group/isolation-with-migration\n"
"\n"
"VERSION\n"
"   imr 1.0 - Build IMRBUILDDATETIME\n"
"\n"
"COPYRIGHT\n"
"   Copyright (C) 2011- Sang Chul Choi\n"
"   See the source for copying conditions.\n"
"   There is NO warranty; not even for MERCHANTABILITY\n"
"\n"
"GNU imr 1.0                     December 2011                             IMR(1)\n"
"";
}
void 
Help::version ()
{
  cout << ""
"imr 1.0 - Build IMRBUILDDATETIME\n"
"Written by Sang Chul Choi.\n"
"\n"
"Copyright (c) 2011- Sang Chul Choi\n"
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
"";
}
}
@
\subsection{Setup}
[[imr]] default values are specified in this file.
I need error handling classes.
The base element [[setup]] has essential setup.
\begin{Verbatim}[frame=lines,framesep=5mm]
    <setup>
        <seed value="12423467" />
        <generation year="25" />
        <chain burn="50000" gens="100000" thin="100" />
        <mc3 number="25" a="0.995" b="0.5" />
    </setup>
\end{Verbatim}
<<imrSetup.h>>=
<<imr gnu copyright>>
#ifndef _IMRSETUP_H_
#define _IMRSETUP_H_
#include <iostream>
#include <vector>
#include "imrCommon.h"
#include "imrType.h"
using namespace std;
namespace imr {
class Setup {
private:
  static ULONG mSeed;
  static UDBL mGeneration;
  static UINT mBurn;
  static UINT mGens;
  static UINT mThin;
  static UINT mNumberChain;
  static UDBL mMC3A;
  static UDBL mMC3B;
  Setup ();
public:
  Setup (const char*);
};
}
#endif // _IMRSETUP_H_
<<imrSetup.cpp>>=
<<imr gnu copyright>>
#include <cassert>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrSetup.h"
namespace imr {
ULONG Setup::mSeed = 0;
UDBL Setup::mGeneration = 1;
UINT Setup::mBurn = 1000;
UINT Setup::mGens = 1000;
UINT Setup::mThin = 10;
UINT Setup::mNumberChain = 1;
UDBL Setup::mMC3A = 0.9;
UDBL Setup::mMC3B = 0.9;
Setup::Setup (const char* f)
{
  TiXmlDocument doc(f);
  bool loadOkay = doc.LoadFile();
  if (loadOkay == false)
    {
      return;
    }

  TiXmlHandle hDoc(&doc);
  TiXmlElement* pElem;
  TiXmlHandle hRoot(0);

  {
    pElem = hDoc.FirstChildElement().Element();
    if (!pElem) return;
    hRoot = TiXmlHandle(pElem);
  }

  {
    pElem = hRoot.FirstChild("setup").FirstChild("seed").Element();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("value", &mSeed);
      }
    pElem = hRoot.FirstChild("setup").FirstChild("generation").Element();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("year", &mGeneration);
      }
    pElem = hRoot.FirstChild("setup").FirstChild("chain").Element();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("burn", &mBurn);
        pElem->QueryValueAttribute("gens", &mGens);
        pElem->QueryValueAttribute("thin", &mThin);
      }
    pElem = hRoot.FirstChild("setup").FirstChild("mc3").Element();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("number", &mNumberChain);
        pElem->QueryValueAttribute("a", &mMC3A);
        pElem->QueryValueAttribute("b", &mMC3B);
      }
  }
/*
  std::cout << "seed: " << mSeed << std::endl
            << "generation: " << mGeneration << std::endl
            << "burn: " << mBurn << std::endl
            << "gens: " << mGens << std::endl
            << "thin: " << mThin << std::endl
            << "MC3 - number of chain: " << mNumberChain << std::endl
            << "MC3 - a: " << mMC3A << std::endl
            << "MC3 - b: " << mMC3B << std::endl;
*/
}
}
@
\subsection{Proposal distributions}
Mutation scalars across loci are updated using Hey2007. Recombinant edges are
updated using Kuhner2000. Population splitting events are updated using
Rannala2003. The values of update are used to compute relative proportions of
update tries. Mutation scalers update of all of the loci, recombinant edge
update for all of the loci, and splitting time update are equally tried. Note
that a set of mutation scalers update is considered to be one iteration. 
\begin{Verbatim}[frame=lines,framesep=5mm]
    <proposal>
        <hey2007 update="1" />
        <kuhner2000 update="1" />
        <rannala2003 update="1" />
    </proposal>
\end{Verbatim}
<<imrProposal.h>>=
<<imr gnu copyright>>
#ifndef _IMRPROPOSAL_H_
#define _IMRPROPOSAL_H_
#include <iostream>
#include <vector>
#include "imrCommon.h"
#include "imrType.h"
using namespace std;
namespace imr {
class Proposal {
private:
  static UINT mHey2007;
  static UINT mKuhner2000;
  static UINT mRannala2003;
  Proposal ();
public:
  Proposal (const char*);
};
}
#endif // _IMRPROPOSAL_H_
<<imrProposal.cpp>>=
<<imr gnu copyright>>
#include <cassert>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrProposal.h"
namespace imr {
UINT Proposal::mHey2007 = 1;
UINT Proposal::mKuhner2000 = 1;
UINT Proposal::mRannala2003 = 1;
Proposal::Proposal (const char* f)
{
  TiXmlDocument doc(f);
  bool loadOkay = doc.LoadFile();
  if (loadOkay == false)
    {
      return;
    }

  TiXmlElement* pElem;
  TiXmlHandle hDoc(&doc);
  TiXmlHandle hRoot(NULL);

  {
    pElem = hDoc.FirstChildElement().ToElement();
    if (!pElem) return;
    hRoot = TiXmlHandle(pElem);
  }

  {
    pElem = hRoot.FirstChild("proposal").FirstChild("hey2007").ToElement();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("update", &mHey2007);
      }
    pElem = hRoot.FirstChild("proposal").FirstChild("kuhner2000").ToElement();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("update", &mKuhner2000);
      }
    pElem = hRoot.FirstChild("proposal").FirstChild("rannala2003").ToElement();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("update", &mRannala2003);
      }
  }
  std::cout << "hey2007: " << mHey2007 << std::endl
            << "kuhner2000: " << mKuhner2000 << std::endl
            << "rannala2003: " << mRannala2003 << std::endl;
}
}
@
\subsection{Prior distributions}
Uniform priors on recombination rate $\rho$, population size $\theta$, and
migration rate are imposed. Maximum values are given.
\begin{Verbatim}[frame=lines,framesep=5mm]
    <prior>
        <rho max="0.5" />
        <theta max="1" />
        <migration max="0.1" />
        <populations>
            <population name="East" id="1" />
            <population name="West" id="2" />
            <population name="Central" id="3" />
        </populations>
        <individuals>
            <individual name="Alice" id="1" population="1" />
            <individual name="Bob" id="2" population="1" />
            <individual name="Carol" id="3" population="1" />
            <individual name="David" id="4" population="1" />
            <individual name="Elizabeth" id="5" population="1" />
        </individuals>
        <structure model="Tree" tree="((1,2)4,3)5">
            <split>((1:1,2:1)4:2,3:2)5</split>
            <theta>((1:5,2:5)4:5,3:5)5:2</theta>
            <rho>((1:1,2:1)4:1,3:1)5:1</rho>
            <migration>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</migration>
        </structure>
    </prior>
\end{Verbatim}
<<imrPrior.h>>=
<<imr gnu copyright>>
#ifndef _IMRPRIOR_H_
#define _IMRPRIOR_H_
#include <iostream>
#include <vector>
#include "imrCommon.h"
#include "imrType.h"
using namespace std;
namespace imr {
class Prior {
private:
  static UDBL mRho;
  static UDBL mTheta;
  static UDBL mMigration;

  Prior ();
public:
  Prior (const char*);
};
// STOPPED
}
#endif // _IMRPRIOR_H_
<<imrPrior.cpp>>=
<<imr gnu copyright>>
#include <cassert>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrPrior.h"
namespace imr {
UINT Proposal::mHey2007 = 1;
UINT Proposal::mKuhner2000 = 1;
UINT Proposal::mRannala2003 = 1;
Proposal::Proposal (const char* f)
{
  TiXmlDocument doc(f);
  bool loadOkay = doc.LoadFile();
  if (loadOkay == false)
    {
      return;
    }

  TiXmlElement* pElem;
  TiXmlHandle hDoc(&doc);
  TiXmlHandle hRoot(NULL);

  {
    pElem = hDoc.FirstChildElement().ToElement();
    if (!pElem) return;
    hRoot = TiXmlHandle(pElem);
  }

  {
    pElem = hRoot.FirstChild("proposal").FirstChild("hey2007").ToElement();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("update", &mHey2007);
      }
    pElem = hRoot.FirstChild("proposal").FirstChild("kuhner2000").ToElement();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("update", &mKuhner2000);
      }
    pElem = hRoot.FirstChild("proposal").FirstChild("rannala2003").ToElement();
    if (pElem != NULL)
      {
        pElem->QueryValueAttribute("update", &mRannala2003);
      }
  }
  std::cout << "hey2007: " << mHey2007 << std::endl
            << "kuhner2000: " << mKuhner2000 << std::endl
            << "rannala2003: " << mRannala2003 << std::endl;
}
}

@
\subsection{Parallelize chains}
I need to consider parallelization of codes. Obviously, each chain can run on a
single CPU. Chains can cooperate with each other using some message passing. MPI
is a choice. Can GPU be helpful in parallelization? If I have a table that needs
to be computed, then this can be useful.
@
\subsection{Multiple chains}
<<imrMultichain.h>>=
<<imr gnu copyright>>
#ifndef _IMRMULTICHAIN_H_
#define _IMRMULTICHAIN_H_
#include <iostream>
#include <vector>
#include "imrCommon.h"
#include "imrType.h"
#include "imrChain.h"
using namespace std;
namespace imr {
class Multichain {
private:
  vector<Chain*> mChain;
public:
  Multichain ();
};
}
#endif // _IMRMULTICHAIN_H_
<<imrMultichain.cpp>>=
<<imr gnu copyright>>
#include <cassert>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "imrMultichain.h"
namespace imr {
Multichain::Multichain()
{
}
}
@
\subsection{Chain}
Can I have a list of variables? I would have an abstract class of random
variable. A gene tree is a random variable. A chain state contains a list of
random variables. Proportions of update tries among random variables should be
tuned. Each iteration of a chain would consist of multiple update tries of
different random variables. Let's make an abstract class of random variable.
Random variables could be a type of data, or a type of parameters.
<<imrChain.h>>=
<<imr gnu copyright>>
#ifndef _IMRCHAIN_H_
#define _IMRCHAIN_H_
#include <iostream>
#include <vector>
#include "imrCommon.h"
#include "imrType.h"
#include "imrRvTree.h"
using namespace std;
namespace imr {
class Chain {
private:
  UINT mId;
  UDBL mBeta;
  UINT mBurn;
  UINT mGens;
  UINT mThin;
  vector<RandomVariable*> mRv;
  string mOut;
public:
  Chain ();
  ~Chain ();
  void run ();
  void load (const string& _infile);
  void save ();
  void write ();
};
}
#endif // _IMRCHAIN_H_
<<imrChain.cpp>>=
<<imr gnu copyright>>
#include <string>
#include <cassert>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrTree.h"
#include "imrRandomVariable.h"
#include "imrRvTree.h"
#include "imrChain.h"
namespace imr {
Chain::Chain()
  : mId(0), mBeta(0)
{
  std::string treeName ("tree");
  RandomVariable* t = new RvTree(treeName);

  mRv.push_back (t);
}
Chain::~Chain()
{
  vector<RandomVariable*>::iterator it;
  for (it = mRv.begin(); it != mRv.end(); it++)
    {
      delete (*it);
    }
}
void
Chain::run ()
{
  cout << "mId: " << mId << endl
       << "mBeta: " << mBeta << endl
       << "mBurn: " << mBurn << endl
       << "mGens: " << mGens << endl
       << "mThin: " << mThin << endl
       << "mOut: " << mOut << endl;
  vector<RandomVariable*>::iterator it;
  for (it = mRv.begin(); it != mRv.end(); it++)
    {
      (*it)->print ();
    }
}
void
Chain::load (const string& _infile)
{
  TiXmlDocument doc(_infile.c_str());
  bool loadOkay = doc.LoadFile();
  if (loadOkay == false)
    {
      return;
    }
  TiXmlHandle hDoc(&doc);
  TiXmlElement* pElem;
  TiXmlHandle hRoot(0);

  {
    pElem = hDoc.FirstChildElement().Element();
    if (!pElem) return;
    hRoot = TiXmlHandle(pElem);
  }

  {
    pElem = hRoot.FirstChild("Chain").Element();
    pElem->QueryValueAttribute(string("Length"), &mGens);
    pElem->QueryValueAttribute("Burnin", &mBurn);
    pElem->QueryValueAttribute("Thin", &mThin);
  }
}
}
@
\subsection{Prior of a recombinant tree}
<<imrPriorg.h>>=
<<imr gnu copyright>>
#ifndef _IMRPRIORG_H_
#define _IMRPRIORG_H_
#include <iostream>
#include <vector>
#include "imrCommon.h"
#include "imrType.h"
#include "imrEdge.h"
#include "imrEvent.h"
using namespace std;
namespace imr {
class Priorg {
public:
  Priorg ();
};
}
#endif // _IMRCHAIN_H_
<<imrPriorg.cpp>>=
<<imr gnu copyright>>
#include <cassert>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "imrTree.h"
#include "imrPriorg.h"
namespace imr {
Priorg::Priorg ()
{
}
}
@
\subsection{Random variable}
A data set is a random variable with name. Data do not change their state.
Parameters are random variables that would change in MCMC. Random variables can
be stored. Random variables have their names [[mName]]. Its current state can be
stored in XML format. 
<<imrRandomVariable.h>>=
<<imr gnu copyright>>
#ifndef _IMRRANDOMVARIABLE_H_
#define _IMRRANDOMVARIABLE_H_
#include <string>
#include "imrType.h"
namespace imr {
class RandomVariable {
protected:
  std::string mName;
  UFLT mProportionUpdate;
public:
  RandomVariable (std::string& _name) : mName(_name) {}
  virtual void update () = 0;
  virtual void save () = 0;
  virtual void load () = 0;
  virtual void print () = 0;
};
}
#endif // _IMRRANDOMVARIABLE_H_
<<imrRvTree.h>>=
<<imr gnu copyright>>
#ifndef _IMRRVTREE_H_
#define _IMRRVTREE_H_
#include <iostream>
#include <string>
#include "imrRandomVariable.h"
using namespace std;
namespace imr {
class RvTree: public RandomVariable {
public:
  RvTree (std::string& _name) : RandomVariable(_name) {}
  virtual void update ();
  virtual void print ();
  virtual void save ()
  {
  }
  virtual void load ()
  {
  }
};
}
#endif // _IMRRVTREE_H_
<<imrRvTree.cpp>>=
<<imr gnu copyright>>
#include <cassert>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "imrRvTree.h"
namespace imr {
void 
RvTree::update ()
{
  cout << "RvTree is updated" << endl;
}
void 
RvTree::print ()
{
  cout << "RandomVariable: " << mName << endl;
}
}
@
\subsection{Template file and class}
<<imrTemplate.h>>=
<<imr gnu copyright>>
#ifndef _IMR_H_
#define _IMR_H_
#include <iostream>
#include <vector>
#include "imrCommon.h"
#include "imrType.h"
using namespace std;
namespace imr {
class Template {
public:
  Template ();
};
}
#endif // _IMR_H_
<<imrTemplate.cpp>>=
<<imr gnu copyright>>
#include <cassert>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "imrTemplate.h"
namespace imr {
Template::Template ()
{
}
}
@
\subsection{Recombinant tree}
A recombinant tree. 

Tree() creates a tree with nothing.

Tree(UINT numLeaf) creates a tree with [[numLeaf]]-many terminal nodes.

Tree(const char* filename) creates a tree using the file. A file is in XML
format.

~Tree() should destroy all edges.

    Tree(UINT numLeaf, UINT sites);
This creates [[numLeaf]] many taxa with [[sites]], which is the number of sites
of a sequence.

Tree::print ()
prints all edges.

Let's remove a lineage from a full recombinant tree. I find an edge that
results from a coalescent event. Eligible links are removed along the chosen edge
first. Start with a coalescent point. Remove all of the eligible links. Follow
the chosen edge. If the next node is a coalescent, remove eligible links that
are contributed by the chosen edge. If the next node is a recombination, remove 
eligible links that are contributed by the chosen edge. Follow along all of the
edges from the chosen edge to remove eligible links. In this step we save edges.

Remove edges that do not have any eligible links. For coalescent events detach
the edge with no eligible links. I remove the edge and its down edge, and extend
the sister edge. For recombination events one of the two edges is removed: I
remove the two down edges, and the up edge is extended. When recombination
events are removed, non-recombining boundaries or [[mSite]] member of [[Tree]]
class must be changed. All of the edge [[mLink]] must be changed accordingly.

I save the edges and the corresponding events that could have been
simulated. Use the series of events to compute $q(G^*->G)$. The events are used
to add the removed edges.

    vector<UINT> mEdgeCoal;
The ID of edges, at the top of which is coalescent.

    void findCoalEdge ();
Find all of the edges that are created with coalescent events. 

    void pruneBranch (UINT l = 0);
Remove the edge [[l]] that must be a coalescent edge.
Check if the edge is one that is created by a coalescent.
Find the eligible links at the top of the chosen edge.
Nullify ineligible links. [[pruneBranchLink]] nullifies ineligible links. 

    void graftBranch ();
From a list of events add recombinant edges. 

    void restoreBranch ();

A detailed procedure of recombinant branch move:
1. Detach a recombinant edge, which creates partial tree $G_p$, and a list of
events $e$.
2. Simulate or create another list of events $e^*$.
3. Attach a new recombinant edge by adding the new events.
4. Detach the new recombinant edge.
5. Attach the old recombinant edge by adding the old events.
Do we need to save the recombinant tree? Let's just save only events not edges.

    void pruneBranchLink (UINT l);
Remove eligible links from a coalescent edge.

Tree::pruneBranchFindEvent (UINT l)
After removing eligible links from a coalescent edge find events that are not
necessary. I do not use this function.

How to remove edges using events lists? 1. Detach only lineages without eligible
links. Do not connect sister and down edges. 2. After detaching all of the
lineages without eligible links, connect sister and down edges from the oldest
events towards tips of the tree. 3. Now, I have a partial tree and the events
that make it a full tree. Try this method out.

I type what I wrote down.
1. Find a pair of lineage whose shared left-parts of the eual sites are longest.
2. I have to have a recombination event at a point between the ending site of
the shared left part and the starting site of the unshared right part.

     shared left
     --------- 
seq1 0 0 0 0 0 0 0
seq2 0 0 0 0 0 1 1
             | | 
           end start

    void pruneBranchUneligibleLink (UINT l);
I remove edges with empty link.

[[mEdgeSpare]] contains [[Edge*]] that could be used later. If I need more
Edges, then I add it to [[mEdge]]. Memory should be deallocated in [[mEdge]] not
[[mEdgeSpare]] because [[mEdgeSpare]] contains so called soft pointers to
memory.

Rearrange links. Some links must merged.
Print the partial tree. -> do this first.
Put the list of edge back to the tree.
Print the full tree. 

To print a recombinant tree. A full or partial tree can be printed out using two
ways. One is to use a list of gene trees. This would be hard to interpret.
Another is to use a list of events ordered in time. 

Tree::printXml (const char* filename)
I print the tree to a file. Find the list of events. Then, print all of the
events. I should use edges to find events. But, multiple edges can share an
event: a recombination event. [[mEdge]] contains edges. A valid edge must have
two connections. I remove all the connections. I could have a separate member
for [[Edge]] to indicate that an edge is not in the tree. This would be
redundant. Or, I could remove [[Edge]] pointers from [[mEdge]] and move them to
[[mEdgeSpare]]. One of edges is used to find the time at the recombination event
at the top of the edge. Let's use left edge of a recombination. Recombination
breakpoint is in the top edge. Otherwise, I have to have duplicates of
breakpoints for recombination events. Let's use [[mEdge]] to find events:
[[mEvent]]. I use [[mEvent]] to print the tree in XML format. [[mEvent]] and
[[mEdge]] should be consistent. This may be annoying. Because one can be created
from the other, I do not need both of them. [[mEdge]] is essential to the
structure of a tree. [[mEvent]] can be secondary. I am still working on
detaching and reattaching a recombinant edge.
<<imrTree.h>>=
<<imr gnu copyright>>
#ifndef _IMRTREE_H_
#define _IMRTREE_H_
#include <iostream>
#include <vector>
#include "imrCommon.h"
#include "imrType.h"
#include "imrEdge.h"
#include "imrEvent.h"
using namespace std;
namespace imr {
class Tree {
  private:
    UINT mSampleSize;
    vector<Edge*> mEdge;
    vector<Edge*> mEdgeSpare;
    Edge* mRoot;
    vector<UINT> mSite;
  private:
    EventList* mEvent;
    EventList* mOldEvent;
    EventList* mNewEvent;
  public:
    Tree();
    Tree(UINT numLeaf, UINT sites);
    Tree(const char* filename);
    ~Tree();
    void addRecombination (UDBL t, UINT up, UINT b);
    void addCoalescent (UDBL t, UINT left, UINT right);
    UINT findBreak (const UINT b);
    void addSite (const UINT b, const UINT bi);
    void print ();
  private:
    vector<UINT> mEdgeCoal;
  public:
    void findCoalEdge ();
    void pruneBranch (UINT l);
    void pruneBranchLink (UINT l);
    void pruneBranchUneligibleLink (UINT l);
    void graftBranch ();
    void restoreBranch ();
    void printEdgeSpare ();
    void connectSisterDown (Edge* sister, Edge* down);
  public:
    void printXml (const char* filename);
    void createEvent ();
};
}
#endif // _IMRTREE_H_
<<imrTree.cpp>>=
<<imr gnu copyright>>
#include <cassert>
#include <iostream>
#include <sstream>
#include <vector>
#include <iterator>
#include <algorithm>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrEdge.h"
#include "imrTree.h"
namespace imr {
Tree::Tree()
{
}

Tree::Tree(UINT numLeaf, UINT site)
  : mRoot(NULL),
    mSampleSize(numLeaf)
{
  mSite.push_back(site);
  for (UINT i = 0; i < numLeaf; i++)
    {
      Edge* e = new Edge(i, 1);
      e->setAllLinks (1);
      mEdge.push_back (e);
    }
  mOldEvent = new EventList();
  mNewEvent = new EventList();
  mEvent = new EventList();
}

Tree::Tree(const char* filename)
{
  std::cout << filename << std::endl;
}

Tree::~Tree()
{
  for (vector<Edge*>::iterator it = mEdge.begin(); 
       it != mEdge.end(); 
       it++) 
    {
      delete *it;
    }
  delete mOldEvent;
  delete mNewEvent;
  delete mEvent;
}

void
Tree::addRecombination (UDBL t, UINT up, UINT b)
{
  // Find the index. 
  // mSite:      30       200   250
  // index:       0         1     2
  // b: 110
  // bi: 1
  // mLink:    1      1       0
  // copyLink: 1      1 1     0
  // left:     1      1 0     0
  // right:    0      0 1     0
  UINT bi = findBreak (b);
  cout << "Break index (" << b << "):" << bi << endl;

  // Find available left and right edge ID.
  // We need to use some pool of edge ID.
  // So that we can easily find edge IDs that are
  // available. If the pool of edge IDs are full,
  // we could increase the size of the pool.
  UINT downLeftId = mEdge.size ();
  UINT downRightId = downLeftId + 1;
  UINT site = mSite.size() + 1;
  Edge* leftEdge = new Edge(downLeftId, site);
  Edge* rightEdge = new Edge(downRightId, site);
  Edge* upEdge = mEdge[up];

  // Copy left and right parts of links of the up.
  leftEdge->copyLeftLink (upEdge, bi);
  rightEdge->copyRightLink (upEdge, bi); 
  upEdge->setDownLeft (leftEdge);
  upEdge->setDownRight (rightEdge);
  leftEdge->setUp (upEdge);
  rightEdge->setUp (upEdge);

  // Set the time of left and right.
  leftEdge->setT (t);
  rightEdge->setT (t);

  // Add one more link to all of the edges.
  for (vector<Edge*>::iterator it = mEdge.begin(); 
       it != mEdge.end(); 
       it++) 
    {
      (*it)->addLink (bi);
    }

  // Add the two new edges to the tree.
  addSite (b, bi);
  mEdge.push_back (leftEdge);
  mEdge.push_back (rightEdge);
}

void
Tree::addCoalescent (UDBL t, UINT left, UINT right)
{
  UINT downId = mEdge.size ();
  UINT site = mSite.size();
  Edge* downEdge = new Edge(downId, site);
  Edge* leftEdge = mEdge[left];
  Edge* rightEdge = mEdge[right];

  // Copy left and right parts of links of the up.
  downEdge->unionLeftRight (leftEdge, rightEdge);
  leftEdge->setDown (downEdge);
  rightEdge->setDown (downEdge);
  downEdge->setLeft (leftEdge);
  downEdge->setRight (rightEdge);

  // Set the time of left and right.
  downEdge->setT (t);

  // Add the two new edges to the tree.
  mEdge.push_back (downEdge);
}

UINT 
Tree::findBreak (const UINT b)
{
  UINT ri = mSite.size();
  for (UINT i = 0;
       i < mSite.size();
       i++)
    {
      if (b < mSite[i])
        {
          ri = i;
          break;
        }
    }
  assert (ri != mSite.size());
  return ri; 
}

void
Tree::addSite (const UINT b, const UINT bi)
{
  mSite.push_back(0);
  UINT s = mSite.size();
  for (UINT i = s - 1; i > bi; i--)
    {
      mSite[i] = mSite[i-1];
    }
  mSite[bi] = b;
}
void 
Tree::print ()
{
  cout << "Site:";
  for (vector<UINT>::iterator it = mSite.begin(); 
       it != mSite.end(); 
       it++) 
    {
      cout << " " << (*it);
    }
  cout << endl;

  for (vector<Edge*>::iterator it = mEdge.begin(); 
       it != mEdge.end(); 
       it++) 
    {
      (*it)->print();
    }
}

void 
Tree::findCoalEdge ()
{
}

void 
Tree::pruneBranch (UINT l)
{
  vector<UINT> link;
  Edge* topEdge = mEdge[l];  
  if (l >= mSampleSize)
    {
      if (topEdge->mLeft == NULL || topEdge->mRight == NULL)
        {
          assert (0); // recombination event
        }
      else if (topEdge->mDownLeft == NULL)
        {
          assert (0); // root branch
        }
    }
  link = topEdge->mLink;

  pruneBranchLink (l);
  
  // Create a list of events.
  pruneBranchUneligibleLink (l);
  // Print spare edges.
  printEdgeSpare ();
  // Now, edges are removed.
  // Rearrange links. Some links must merged.
  // Print the partial tree. -> do this first.
  // Put the list of edge back to the tree.
  // Print the full tree. 
  //  
}

void 
Tree::printEdgeSpare ()
{
  cout << "mEdgeSpare: " << endl;
  vector<Edge*>::reverse_iterator rit;
  for (rit = mEdgeSpare.rbegin() ; rit < mEdgeSpare.rend(); ++rit )
    {
      cout << (*rit)->mId + 1 << " ";
    }
  cout << endl;
}

void
Tree::connectSisterDown (Edge* sister, Edge* down)
{
  Edge* downdownLeft = down->mDownLeft;
  if (downdownLeft != NULL)
    {
      if (downdownLeft->mLeft == down)
        {
          downdownLeft->mLeft = sister;
        }
      else if (downdownLeft->mRight == down)
        {
          downdownLeft->mRight = sister;
        }
      else
        {
          assert (0);
        }
      sister->mDownLeft = downdownLeft;
    }
  Edge* downdownRight = down->mDownRight;
  if (downdownRight != NULL)
    {
      if (downdownRight->mLeft == down)
        {
          downdownRight->mLeft = sister;
        }
      else if (downdownRight->mRight == down)
        {
          downdownRight->mRight = sister;
        }
      else
        {
          assert (0);
        }
      sister->mDownLeft = downdownRight;
    }
}

void 
Tree::pruneBranchUneligibleLink (UINT l)
{
  // Push edges into ... other place for later use.
  UINT s = mOldEvent->getSize ();
  for (UINT i = s; i > 0; i--)
    {
      Event* e = mOldEvent->getEvent (i-1);
      if (e->isCoalescent ())
        {
          Edge* down = e->mDownLeft;
          Edge* left = e->mLeft;
          Edge* right = e->mRight;
          mEdgeSpare.push_back (down);
          if (left->isEmptyLink ())
            {
              down->mLeft = NULL;
              left->mDownLeft = NULL;
            }
          else if (right->isEmptyLink ())
            {
              down->mRight = NULL;
              right->mDownLeft = NULL;
            }
          else
            {
              assert (0);
            }
        }
      else if (e->isRecombination ())
        {
          Edge* downLeft = e->mDownLeft;
          Edge* downRight = e->mDownRight;
          Edge* up = e->mLeft;
          mEdgeSpare.push_back (downRight);
          mEdgeSpare.push_back (downLeft);
          if (up->isEmptyLink ())
            {
              up->mDownLeft = NULL;
              up->mDownRight = NULL;
              downLeft->mLeft = NULL;
              downRight->mLeft = NULL;
            }
          else if (downLeft->isEmptyLink ())
            {
              up->mDownLeft = NULL;
              downLeft->mLeft = NULL;
            }
          else if (downRight->isEmptyLink ())
            {
              up->mDownLeft = NULL;
              downRight->mLeft = NULL;
            }
          else
            {
              assert (0);
            }
        }
    }

  // Connect sister and down.
  for (UINT i = s; i > 0; i--)
    {
      Event* e = mOldEvent->getEvent (i-1);
      if (e->isCoalescent ())
        {
          Edge* down = e->mDownLeft;
          Edge* left = e->mLeft;
          Edge* right = e->mRight;
          mEdgeSpare.push_back (down);
          if (left->isEmptyLink ())
            {
              connectSisterDown (right, down);
            }
          else if (right->isEmptyLink ())
            {
              connectSisterDown (left, down);
            }
          else
            {
              assert (0);
            }
        }
      else if (e->isRecombination ())
        {
          Edge* downLeft = e->mDownLeft;
          Edge* downRight = e->mDownRight;
          Edge* up = e->mLeft;
          mEdgeSpare.push_back (downRight);
          mEdgeSpare.push_back (downLeft);
          if (up->isEmptyLink ())
            {
              up->mDownLeft = NULL;
              up->mDownRight = NULL;
              downLeft->mLeft = NULL;
              downRight->mLeft = NULL;
            }
          else if (downLeft->isEmptyLink ())
            {
              connectSisterDown (up, downRight);
              // up->mDownLeft = NULL;
              // downLeft->mLeft = NULL;
            }
          else if (downRight->isEmptyLink ())
            {
              connectSisterDown (up, downLeft);
              // up->mDownLeft = NULL;
              // downRight->mLeft = NULL;
            }
          else
            {
              assert (0);
            }
        }
    }
}

void 
Tree::pruneBranchLink (UINT l)
{
  Edge* topEdge = mEdge[l];  

  bool moreEdge;
  vector<Edge*> b;
  mOldEvent->reset ();
  topEdge->setAllLinks (0);
  b.push_back(topEdge->mDownRight);
  b.push_back(topEdge->mDownLeft);
  while (!b.empty())
    {
      Edge* p = b.back();
      b.pop_back();
      if (p == NULL)
        {
          continue;
        }
      if (p->isCoalescent ())
        {
          moreEdge = p->unionLink ();
cout << "Processed C " << p->getId() + 1 << endl;
          if (moreEdge == true)
            {
cout << "  more two edges of " << p->getId() + 1 << endl;

              b.push_back (p->mDownRight);
              b.push_back (p->mDownLeft);
            }
          Edge* left = p->mLeft;
          Edge* right = p->mRight;
          assert (!(left->isEmptyLink () && right->isEmptyLink ()));
          if (left->isEmptyLink () || right->isEmptyLink())
            {
              mOldEvent->addCoalescent (p->mT, 
                                        p->mLeft, p->mRight, p);
            }
p->print();
        }
      else if (p->isRecombination ())
        {
          moreEdge = p->intersectLinkWithUp ();
cout << "Processed R " << p->getId() + 1 << endl;
          if (moreEdge == true)
            {
cout << "  more two edges of " << p->getId() + 1 << endl;
      
              b.push_back (p->mDownRight);
              b.push_back (p->mDownLeft);
            }
          if (p->isEmptyLink ())
            {
              Edge* up = p->mLeft;
              Edge* downSister = up->downSister (p);
              // To skip duplicate recombination events.
              if (!(downSister->isEmptyLink () && up->mDownRight == p))
                {
                  mOldEvent->addRecombination (p->mT, 
                                               up, up->mDownLeft, up->mDownRight,
                                               up->mB);
                }
            }
p->print();
        }
    }
  mOldEvent->sort ();
  mOldEvent->print ();
}
void 
Tree::graftBranch ()
{
}
void 
Tree::restoreBranch ()
{
}
void 
Tree::printXml (const char* _filename)
{
  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration ("1.0", "", "");
  doc.LinkEndChild (decl);
  TiXmlElement* root = new TiXmlElement ("Rectree");
  doc.LinkEndChild (root);
  TiXmlElement* events = new TiXmlElement ("Events");
  root->LinkEndChild (events);
  TiXmlElement* edges = new TiXmlElement ("Edges");
  root->LinkEndChild (edges);

  stringstream ss;
  for (vector<UINT>::iterator it = mSite.begin(); it != mSite.end(); it++)
    {
      ss << *it << ",";
    }
  root->SetAttribute("site", ss.str());

  createEvent ();
  mEvent->printXml (events);   
   
  vector<Edge*>::iterator it;
  for (it = mEdge.begin() ; it < mEdge.end(); it++ )
    {
      (*it)->printXml (edges);
    }

  doc.SaveFile (_filename);
}
void 
Tree::createEvent ()
{
  mEvent->reset();
  vector<Edge*>::iterator it;
  for (it = mEdge.begin() ; it < mEdge.end(); it++ )
    {
      mEvent->addEdge (*it);
    }
  mEvent->sort();
}
}

@
\subsection{Recombinant edge}
A recombinant edge.

Each edge has two sequences: one for the boundaries of non-recombining regions,
and another for indicators of regions with relevant data. There will be more
efficient implementations. I just use [[vector]] for all later I will change the
code to adopt more efficient containers.
[[mSite]] is a list of positions of sites whose just right handside break points
are recombination points. If [[mSite]] is 30,200,250, then the length of the
sequence is 250 with two recombination break points: one between 30 and 31, and
another 200 and 201. [[mLink]] is the same size of [[mSite]]. It just shows
whether non-recombining regions contain relevant data. For example, [[mLink]] of
1,1,1 means that all of the sites are connected to data. [[mLink]] of 1,0,0
denotes that the non-recombining region between 1 and 30 inclusively contains
relevant data, the other regions between 31 and 200, and between 201 and 250 do
not contain data.

Edge::setAllLinks (const UINT b)
Set all of the links to b: 0 or 1.

Edge::unionLink ()
Compare links of the two up edges to remove non-eligible links. Return true if
there are some changes to the links.

Edge::intersectLinkWithUp ()
Remove eligible links by comparing the up. This is called when I deal with a
recombination event. Return true if there are changes to the links.

SMC approximation: active lineages that start with a single lineage do not
coalesce together. Because I do not allow coalescent events of two lineages
whose links are not shared, this is a natural result. This approximation could
be also called SMC approximation. 

Events in active lineages: while I attach active lineages to inactive ones,
inactive lineages change. Say, active lineage 1 and 2 coalesce independently
with a single inactive lineage. When I attach one active lineage to the inactive
lineage, the down edge is not the edge of the inactive lineage. Another active
lineage should be attached to the down edge not the edge of the inactive
lineage. So, events must be relative to the lineage in the partial recombinant
tree. When the first lineage is attached to the inactive lineage, the inactive
lineage's edge should be changed to the down edge of the inactive lineage. 
When I detach two active lineages, ... I can just say that each of them is
detached from the sister branch. If two active lineages are attached one after
another, then the branches would be the same.

After removing non-eligible links, some recombination boundaries may not be
valid any more ...
\textbf{IMPORTANT: There are two kinds of active lineages. One has only active
links, and another has both active and inactive links. Let's call the former
full active lineage, and the latter partial active lineage.
The former one results
from the original active lineage via recombination between the active links. The
latter one is from coalescent between active lineage and inactive lineage, or
from coalescent full active lineage and partial active lineage. This happens
because when full or partial active lineages coalesce with inactive lineages
active links can join blank links. 
Partial active lineages cannot coalesce because they have inactive links. But,
a partial active lineage can produce full active lineages through recombination
when one of two lineages from the partial active lineage only contain active
links. Draw figures for these.}

.Removing edges
. Event class is needed.
. EventList class is needed: edge should have information about location of
recombination. I simply follow [[Tree::pruneBranchLink]] procedure to add all
necessary events. Then, sort them in increasing time order. To have a full list
of events, one that would be created in simulation of an active lineage, I need
to consider all of the events between start of the active lineage and end of the
termination of active links.
. Events should consider all the way down until no active links are observerd.
Even after coalescent events of the lineages from the active lineage complete,
active links can survive down the last active lineage coalescent event. On those
active links recombination events are possible. Therefore, new full or partial
active lineages can arise after the seemingly final coalescent event. These
might be called ``hidden passage'' by Kuhner et al. (2000).
. Tree should be renumbered so that we can compare two trees. Coalescents should
have order, like smaller ID is left and the other larger ID is right.

    bool isEmptyLink ();
Check if mLink has all values being 0.

[[mB]]: positive value when there is a recombination event down at the edge.
<<imrEdge.h>>=
<<imr gnu copyright>>
#ifndef _IMREDGE_H_
#define _IMREDGE_H_
#include <vector>
#include "imrType.h"
#include "tinystr.h"
#include "tinyxml.h"
using namespace std;
namespace imr {
class Edge {
  private:
  public:
    UINT mB;
    UDBL mT;
    UINT mId;
    vector<UINT> mLink;
    Edge* mLeft; // mUp
    Edge* mRight;
    Edge* mDownLeft; // mDown
    Edge* mDownRight;
  public:
    Edge(const int id = -1, const UINT link = 0);
    ~Edge();
    void setAllLinks (const UINT b);
    void addLink (const UINT bi);
    void copyLeftLink (const Edge* up, const UINT bi);
    void copyRightLink (const Edge* up, const UINT bi);
    void unionLeftRight (const Edge* l, const Edge* r);
    bool isEmptyLink ();
  public:
    UINT getId () const { return mId; }
    UDBL getT () const { return mT; }

    void setT (const UDBL t) { mT = t; }
    void setUp (Edge* e) { mLeft = e; }
    void setLeft (Edge* e) { setUp (e); }
    void setRight (Edge* e) { mRight = e; }
    void setDown (Edge* e) { mDownLeft = e; }
    void setDownLeft (Edge* e) { setDown (e); }
    void setDownRight (Edge* e) { mDownRight = e; }
    void print();
    void printXml (TiXmlElement* _edges);
  public:
    bool isLeaf () 
    {
      if (mLeft == NULL && mRight == NULL)
        return true;
      else
        return false;  
    }
    bool isCoalescent ()
    {
      if (mLeft != NULL && mRight != NULL)
        return true;
      else
        return false;  
    }
    bool isRecombination () 
    {
      if (mLeft != NULL && mRight == NULL)
        return true;
      else
        return false;  
    }
    bool unionLink ();
    bool intersectLinkWithUp ();
    Edge* sister (Edge* _e)
    {
      if (_e == mLeft)
        return mRight;
      else if (_e == mRight)
        return mLeft;
      else
        return NULL;
    }
    Edge* downSister (Edge* _e)
    {
      if (_e == mDownLeft)
        return mDownRight;
      else if (_e == mDownRight)
        return mDownLeft;
      else
        return NULL;
    }
};
}
#endif // _IMREDGE_H_
<<imrEdge.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <cassert>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrType.h"
#include "imrEdge.h"
using namespace std;
namespace imr {
Edge::Edge(const int id, const UINT link)
  : mLeft(NULL), mRight(NULL), 
    mDownLeft(NULL), mDownRight (NULL),
    mT(-1), mId (id)
{
  if (link > 0)
    {
      mLink.assign (link, 0);
    }
}
Edge::~Edge()
{
}

void 
Edge::printXml (TiXmlElement* _edges)
{
  TiXmlElement* edge = new TiXmlElement ("Edge");
  _edges->LinkEndChild (edge);
  edge->SetDoubleAttribute("id", mId);
  edge->SetDoubleAttribute("time", mT);
  if (isLeaf())
    {
      edge->SetAttribute("type", "leaf");
    }
  else if (isCoalescent())
    {
      edge->SetAttribute("type", "coalescent");
    }
  else if (isRecombination())
    {
      edge->SetAttribute("type", "recombination");
    }

  if (mLeft != NULL)
    {
     edge->SetAttribute("left", mLeft->mId);
    }
  else
    {
     edge->SetAttribute("left", "NULL");
    }
  if (mRight != NULL)
    {
     edge->SetAttribute("right", mRight->mId);
    }
  else
    {
     edge->SetAttribute("right", "NULL");
    }
  if (mDownLeft != NULL)
    {
     edge->SetAttribute("downLeft", mDownLeft->mId);
    }
  else
    {
     edge->SetAttribute("downLeft", "NULL");
    }
  if (mDownRight != NULL)
    {
     edge->SetAttribute("downRight", mDownRight->mId);
    }
  else
    {
     edge->SetAttribute("downRight", "NULL");
    }

  stringstream ss;
  for (vector<UINT>::iterator it = mLink.begin(); it != mLink.end(); it++)
    {
      ss << *it << ",";
    }
  edge->SetAttribute("link", ss.str());
}

bool
Edge::unionLink ()
{
  assert (mLeft != NULL && mRight != NULL);
  bool v = false;
  UINT s = mLink.size();
  for (UINT i = 0; i < s; i++)
    {
      if (mLeft->mLink[i] == 1 || mRight->mLink[i] == 1)
        {
          assert (mLink[i] == 1);
          mLink[i] = 1;
        }
      else
        {
          if (mLink[i] == 1)
            {
              v = true;
            }
          mLink[i] = 0;
        }
    }
  return v;
}

bool
Edge::intersectLinkWithUp ()
{
  assert (mLeft != NULL && mRight == NULL);
  bool v = false;
  UINT s = mLink.size();
  for (UINT i = 0; i < s; i++)
    {
      if (mLeft->mLink[i] == 1 && mLink[i] == 1)
        {
          mLink[i] = 1;
        }
      else
        {
          if (mLink[i] == 1)
            {
              v = true;
            }
          mLink[i] = 0;
        }
    }
  return v;
}

bool 
Edge::isEmptyLink ()
{
  bool v = true;
  for (vector<UINT>::iterator it = mLink.begin();
       it != mLink.end();
       it++)
    {
      if (*it == true)
        {
          v = false;
          break;
        }
    }
  return v;
}

void 
Edge::setAllLinks (const UINT b)
{
  for (vector<UINT>::iterator it = mLink.begin();
       it != mLink.end();
       it++)
    {
      *it = b;
    }
}

void 
Edge::copyLeftLink (const Edge* up, UINT bi)
{
  if (up->mLink.size() + 1 != mLink.size())
    {
      cerr << "Up Link size: " << up->mLink.size() << endl;
      cerr << "Link size: " << mLink.size() << endl;
      assert (0);
    }
  assert (up->mLink.size() + 1 == mLink.size());
  assert (bi < up->mLink.size());
  for (UINT i = 0; i <= bi; i++)
    {
      mLink[i] = up->mLink[i];
    }
}
void 
Edge::copyRightLink (const Edge* up, UINT bi)
{
  assert (up->mLink.size() + 1 == mLink.size());
  assert (bi < up->mLink.size());
  UINT upSize = up->mLink.size();
  for (UINT i = bi; i < upSize; i++)
    {
      mLink[i+1] = up->mLink[i];
    }
}
void 
Edge::addLink (const UINT bi)
{
  mLink.push_back(0);
  UINT s = mLink.size();
  for (UINT i = s - 1; i > bi; i--)
    {
      mLink[i] = mLink[i-1];
    }
}

void 
Edge::unionLeftRight (const Edge* l, const Edge* r)
{
  UINT s = mLink.size();
  for (UINT i = 0; i < s; i++)
    {
      if (l->mLink[i] == 1 || r->mLink[i] == 1)
        {
          mLink[i] = 1;
        }
    }
}
void 
Edge::print ()
{
  UINT id = mId + 1;
  if (mLeft == NULL && mRight == NULL)
    {
      cout << "Leaf (" << id << ")";
    }
  else if (mDownLeft == NULL && mDownRight == NULL)
    {
      cout << "Root (" << id << ")";
    }
  else if (mRight == NULL)
    {
      cout << "Recombination (" << id << ")";
    }
  else if (mDownRight == NULL)
    {
      cout << "Coalescent (" << id << ")";
    }
  else if (mLeft != NULL && mRight != NULL
           && mDownLeft != NULL && mDownRight != NULL)
    {
      UDBL downT = mDownLeft->getT();
      cout << "Coalescent at " << mT << ", and "
           << "Recombination at " << downT << " (" << id << ")";
    }
  cout << " ";
  for (vector<UINT>::iterator it = mLink.begin();
       it != mLink.end();
       it++)
    {
      cout << *it;
    }
  cout << endl;
}

}
@
\subsection{Sequence}
A sequence data for each node.
<<imrSequence.h>>=
<<imr gnu copyright>>
#ifndef _IMRSEQUENCE_H_
#define _IMRSEQUENCE_H_
namespace imr {

}
#endif // _IMRSEQUENCE_H_
<<imrSequence.cpp>>=
<<imr gnu copyright>>
namespace imr {

}
@
\subsection{XML files}
[[imr]] reads in and writes to XML files. Main parts of the XML file are
input, MCMC output, and ML output. The main XML element is imr. The main
parts of elements are setup, parameter, prior, data, mcmc, and ml. 

<<imrXml.h>>=
<<imr gnu copyright>>
#ifndef _IMRXML_H_
#define _IMRXML_H_
#include <string>
#include "tinystr.h"
#include "tinyxml.h"
namespace imr {
class Xml {
private:
  static const unsigned int NUM_INDENTS_PER_SPACE=2;
  
public:
  static int readFastsimcoal (const std::string&);
  static void build_simple_doc ();
  static void write_app_settings_doc ();
  static void dump_to_stdout(const char* pFilename);
  static void dump_to_stdout( TiXmlNode* pParent, unsigned int indent = 0 );
  static int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent);
  static const char * getIndentAlt( unsigned int numIndents );
  static const char * getIndent( unsigned int numIndents );
};
}
#endif // _IMRXML_H_
<<imrXml.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include <string>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrXml.h"
using namespace std;
namespace imr {
int 
Xml::readFastsimcoal (const string& f)
{
  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
  TiXmlElement * element = new TiXmlElement( "Hello" );
  TiXmlText * text = new TiXmlText( "World" );
  element->LinkEndChild( text );
  doc.LinkEndChild( decl );
  doc.LinkEndChild( element );
  doc.SaveFile (f.c_str());
  return 0;
}
void 
Xml::build_simple_doc ()
{
  // Make xml: <?xml ..><Hello>World</Hello>
  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration( "1.0", "", "" );
  TiXmlElement * element = new TiXmlElement( "Hello" );
  TiXmlText * text = new TiXmlText( "World" );
  element->LinkEndChild( text );
  doc.LinkEndChild( decl );
  doc.LinkEndChild( element );
  doc.SaveFile( "madeByHand.xml" );
}
void 
Xml::write_app_settings_doc( )  
{  
  TiXmlDocument doc;  
  TiXmlElement* msg;
  TiXmlDeclaration* decl = new TiXmlDeclaration( "1.0", "", "" );  
  doc.LinkEndChild( decl );  
 
  TiXmlElement * root = new TiXmlElement( "MyApp" );  
  doc.LinkEndChild( root );  

  TiXmlComment * comment = new TiXmlComment();
  comment->SetValue(" Settings for MyApp " );  
  root->LinkEndChild( comment );  
 
  TiXmlElement * msgs = new TiXmlElement( "Messages" );  
  root->LinkEndChild( msgs );  
 
  msg = new TiXmlElement( "Welcome" );  
  msg->LinkEndChild( new TiXmlText( "Welcome to MyApp" ));  
  msgs->LinkEndChild( msg );  
 
  msg = new TiXmlElement( "Farewell" );  
  msg->LinkEndChild( new TiXmlText( "Thank you for using MyApp" ));  
  msgs->LinkEndChild( msg );  
 
  TiXmlElement * windows = new TiXmlElement( "Windows" );  
  root->LinkEndChild( windows );  

  TiXmlElement * window;
  window = new TiXmlElement( "Window" );  
  windows->LinkEndChild( window );  
  window->SetAttribute("name", "MainFrame");
  window->SetAttribute("x", 5);
  window->SetAttribute("y", 15);
  window->SetAttribute("w", 400);
  window->SetAttribute("h", 250);

  TiXmlElement * cxn = new TiXmlElement( "Connection" );  
  root->LinkEndChild( cxn );  
  cxn->SetAttribute("ip", "192.168.0.1");
  cxn->SetDoubleAttribute("timeout", 123.456); // floating point attrib
  
  dump_to_stdout( &doc );
  doc.SaveFile( "appsettings.xml" );  
} 
// ----------------------------------------------------------------------
// STDOUT dump and indenting utility functions
// ----------------------------------------------------------------------

const char * 
Xml::getIndent( unsigned int numIndents )
{
  static const char * pINDENT="                                      + ";
  static const unsigned int LENGTH=strlen( pINDENT );
  unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
  if ( n > LENGTH ) n = LENGTH;

  return &pINDENT[ LENGTH-n ];
}

// same as getIndent but no "+" at the end
const char * 
Xml::getIndentAlt( unsigned int numIndents )
{
  static const char * pINDENT="                                        ";
  static const unsigned int LENGTH=strlen( pINDENT );
  unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
  if ( n > LENGTH ) n = LENGTH;

  return &pINDENT[ LENGTH-n ];
}

int 
Xml::dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
{
  if ( !pElement ) return 0;

  TiXmlAttribute* pAttrib=pElement->FirstAttribute();
  int i=0;
  int ival;
  double dval;
  const char* pIndent=getIndent(indent);
  cout << endl;
  while (pAttrib)
  {
    cout << pIndent << pAttrib->Name() << ": value=[" << pAttrib->Value() 
         << "]";

    if (pAttrib->QueryIntValue(&ival)==TIXML_SUCCESS)  
    {
      cout << " int=" << ival;
    }
    if (pAttrib->QueryDoubleValue(&dval)==TIXML_SUCCESS) 
    {
      cout << " d=" << dval;
    } 
    cout << endl;
    i++;
    pAttrib=pAttrib->Next();
  }
  return i; 
}

void 
Xml::dump_to_stdout( TiXmlNode* pParent, unsigned int indent )
{
  if ( !pParent ) return;

  TiXmlNode* pChild;
  TiXmlText* pText;
  int t = pParent->Type();
  cout << getIndent(indent);
  int num;

  switch ( t )
  {
  case TiXmlNode::TINYXML_DOCUMENT:
    cout << "Document";
    break;

  case TiXmlNode::TINYXML_ELEMENT:
    cout << "Element [" << pParent->Value() << "]";
    num=dump_attribs_to_stdout(pParent->ToElement(), indent+1);
    switch(num)
    {
      case 0:  cout << " (No attributes)"; break;
      case 1:  cout << getIndentAlt(indent) << "1 attribute"; break;
      default: cout << getIndentAlt(indent) << num << " attributes"; break;
    }
    break;

  case TiXmlNode::TINYXML_COMMENT:
    cout << "Comment: [" << pParent->Value() << "]";
    break;

  case TiXmlNode::TINYXML_UNKNOWN:
    cout << "Unknown";
    break;

  case TiXmlNode::TINYXML_TEXT:
    pText = pParent->ToText();
    cout << "Text: [" << pText->Value() << "]";
    break;

  case TiXmlNode::TINYXML_DECLARATION:
    cout << "Declaration";
    break;
  default:
    break;
  }
  cout << endl;
  for ( pChild = pParent->FirstChild(); pChild != 0; pChild = pChild->NextSibling()) 
  {
    dump_to_stdout( pChild, indent+1 );
  }
}

// load the named file and dump its structure to STDOUT
void 
Xml::dump_to_stdout(const char* pFilename)
{
  TiXmlDocument doc(pFilename);
  bool loadOkay = doc.LoadFile();
  if (loadOkay)
  {
    cout << "\n" << pFilename << ":\n" <<  pFilename;
    dump_to_stdout( &doc ); // defined later in the tutorial
  }
  else
  {
    cout << "Failed to load file \"" << pFilename << "\"" << endl;
  }
}
}
@
\subsection{Default setting file}
<<imrDefault.h>>=
<<imr gnu copyright>>
#ifndef _IMRDEFAULT_H_
#define _IMRDEFAULT_H_
namespace imr {
class Default {
public:
  static unsigned int mMajorVersion;
  static unsigned int mMinorVersion;
  static void save (const char*);
  static void load (const char*);
};
}
#endif // _IMRDEFAULT_H_
<<imrDefault.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrDefault.h"
using namespace std;
namespace imr {
unsigned int Default::mMajorVersion = 1;
unsigned int Default::mMinorVersion = 0;
void
Default::save (const char* f)
{
  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration ("1.0", "", "");
  doc.LinkEndChild (decl);
  TiXmlElement * root = new TiXmlElement ("Default");
  doc.LinkEndChild (root);
  TiXmlElement * version = new TiXmlElement ("Version");
  root->LinkEndChild (version);
  version->SetAttribute("major", mMajorVersion); 
  version->SetAttribute("minor", mMinorVersion); 
  doc.SaveFile (f);
}
void
Default::load (const char* f)
{
}
}
@
\subsection{fastsimcoal file}
A Fastsimcoal output file is created in XML format. Use the following command to
create one.
\begin{Verbatim}[frame=lines,framesep=5mm]
imr xml --print 2 -o fastsimcoal.xml
\end{Verbatim}
<<imrXmlFastsimcoal.h>>=
<<imr gnu copyright>>
#ifndef _IMRXMLFASTSIMCOAL_H_
#define _IMRXMLFASTSIMCOAL_H_
namespace imr {
class XmlFastsimcoal {
public:
  static void save (const char*);
  static void load (const char*);
};
}
#endif // _IMRXMLFASTSIMCOAL_H_
<<imrXmlFastsimcoal.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrXmlFastsimcoal.h"
using namespace std;
namespace imr {
void
XmlFastsimcoal::save (const char* f)
{
  TiXmlElement * sequence;
  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration ("1.0", "", "");
  doc.LinkEndChild (decl);
  TiXmlElement * root = new TiXmlElement ("Fastsimcoal");
  doc.LinkEndChild (root);
  // Profile
  TiXmlElement * profile = new TiXmlElement ("Profile");
  root->LinkEndChild (profile);
  profile->SetAttribute("Title", "A series of simulated samples");
  profile->SetAttribute("NbSamples", 1);
  profile->SetAttribute("GenotypicData", 0);
  profile->SetAttribute("GameticPhase", 0);
  profile->SetAttribute("RecessiveData", 0);
  profile->SetAttribute("DataType", "DNA");
  profile->SetAttribute("LocusSeparator", "NONE");
  profile->SetAttribute("MissingData", "?");
  // Data
  TiXmlElement * data = new TiXmlElement ("Data");
  root->LinkEndChild (data);
  TiXmlElement * sample = new TiXmlElement ("Sample");
  data->LinkEndChild (sample);
  sample->SetAttribute("SampleName", "Sample 1");
  sample->SetAttribute("SampleSize", 5);
  TiXmlElement * sampledata = new TiXmlElement ("SampleData");
  data->LinkEndChild (sampledata);
  // Sequence 1
  sequence = new TiXmlElement ("Sequence");
  sampledata->LinkEndChild (sequence);
  sequence->SetAttribute("Name", "1_1");
  sequence->SetAttribute("Population", 1);
  sequence->LinkEndChild (new TiXmlText ("ACTGCC")); 
  // Sequence 2
  sequence = new TiXmlElement ("Sequence");
  sampledata->LinkEndChild (sequence);
  sequence->SetAttribute("Name", "1_2");
  sequence->SetAttribute("Population", 1);
  sequence->LinkEndChild (new TiXmlText ("TAATCC")); 
  // Sequence 3
  sequence = new TiXmlElement ("Sequence");
  sampledata->LinkEndChild (sequence);
  sequence->SetAttribute("Name", "1_3");
  sequence->SetAttribute("Population", 1);
  sequence->LinkEndChild (new TiXmlText ("TAATCT")); 
  // Sequence 4 
  sequence = new TiXmlElement ("Sequence");
  sampledata->LinkEndChild (sequence);
  sequence->SetAttribute("Name", "1_4");
  sequence->SetAttribute("Population", 1);
  sequence->LinkEndChild (new TiXmlText ("ACTGCT")); 
  // Sequence 5
  sequence = new TiXmlElement ("Sequence");
  sampledata->LinkEndChild (sequence);
  sequence->SetAttribute("Name", "1_5");
  sequence->SetAttribute("Population", 1);
  sequence->LinkEndChild (new TiXmlText ("ACTGGC")); 
  // Structure
  TiXmlElement * structure = new TiXmlElement ("Structure");
  root->LinkEndChild (structure);
  structure->SetAttribute("StructureName", "Simulated data");
  structure->SetAttribute("NbGroups", 1);
  
  doc.SaveFile (f);
}
void
XmlFastsimcoal::load (const char* f)
{
}
}
@
\subsection{Input file}
Let's list things that are necessary in an imr input file. 
Total generation, Burnin length, Thin length.
Number of chains, MC3 scheme, MC3 parameters.
Populations: population names and population ID.
Individuals: individual names and individual ID.
Population tree.
Prior on splitting time.
Prior on migration rate.
Prior on population sizes.
Running mode: mcmc or likelihood.
Random number seed.
Generation time in years.
Trace plots.
\begin{Verbatim}[frame=lines,framesep=5mm]
imr xml --print 3 -o imrinput.xml
\end{Verbatim}
<<imrXmlImrInput.h>>=
<<imr gnu copyright>>
#ifndef _IMRXMLIMRINPUT_H_
#define _IMRXMLIMRINPUT_H_
namespace imr {
class XmlImrInput {
public:
  static void save (const char*);
  static void load (const char*);
};
}
#endif // _IMRXMLIMRINPUT_H_
<<imrXmlImrInput.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrXmlImrInput.h"
using namespace std;
namespace imr {
void
XmlImrInput::save (const char* f)
{
  TiXmlElement * population;
  TiXmlElement * individual;
  TiXmlElement * locus;
  TiXmlElement * position;
  TiXmlElement * sequence;
  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration ("1.0", "", "");
  doc.LinkEndChild (decl);
  TiXmlElement * root = new TiXmlElement ("ImrInput");
  doc.LinkEndChild (root);
  // Random number generator seed
  TiXmlElement * seed = new TiXmlElement ("Seed");
  root->LinkEndChild (seed);
  seed->SetAttribute("Value", 12423467);
  // Generation time in years
  TiXmlElement * generationTime = new TiXmlElement ("GenerationTime");
  root->LinkEndChild (generationTime);
  generationTime->SetAttribute("year", 25);
  // Chain
  TiXmlElement * chain = new TiXmlElement ("Chain");
  root->LinkEndChild (chain);
  chain->SetAttribute("Length", 100000);
  chain->SetAttribute("Burnin", 50000);
  chain->SetAttribute("Thin", 100);
  // MC3
  TiXmlElement * mc3 = new TiXmlElement ("MC3");
  root->LinkEndChild (mc3);
  mc3->SetAttribute("Number", 25);
  mc3->SetDoubleAttribute("A", 0.995);
  mc3->SetDoubleAttribute("B", 0.5);
  TiXmlElement * populations = new TiXmlElement ("Populations");
  root->LinkEndChild (populations);
  populations->SetAttribute("Number", 3);
  // Population 1
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "East");
  population->SetAttribute("ID", 1);
  // Population 2
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "West");
  population->SetAttribute("ID", 2);
  // Population 3
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "Central");
  population->SetAttribute("ID", 3);
  // Individuals
  TiXmlElement * individuals = new TiXmlElement ("Individuals");
  root->LinkEndChild (individuals);
  individuals->SetAttribute("Number", 2);
  // Individual 1
  individual = new TiXmlElement ("Individual");
  individuals->LinkEndChild (individual);
  individual->SetAttribute("Name", "Alice");
  individual->SetAttribute("ID", 1);
  individual->SetAttribute("Population", 1);
  // Individual 2
  individual = new TiXmlElement ("Individual");
  individuals->LinkEndChild (individual);
  individual->SetAttribute("Name", "Bob");
  individual->SetAttribute("ID", 2);
  individual->SetAttribute("Population", 2);
  // Demographic Model
  TiXmlElement * demographicModel = new TiXmlElement ("DemographicModel");
  root->LinkEndChild (demographicModel);
  demographicModel->SetAttribute("Model", "Tree");
  demographicModel->SetAttribute("Tree", "((1,2)4,3)5");
  // Prior on split time
  TiXmlElement * priorSplitTime = new TiXmlElement ("PriorSplitTime");
  demographicModel->LinkEndChild (priorSplitTime);
  priorSplitTime->LinkEndChild (new TiXmlText ("((1:1,2:1)4:2,3:2)5")); 
  // Prior on population sizes
  TiXmlElement * priorPopulationSize = new TiXmlElement ("PriorPopulationSize");
  demographicModel->LinkEndChild (priorPopulationSize);
  priorPopulationSize->LinkEndChild (new TiXmlText ("((1:5,2:5)4:5,3:5)5:2")); 
  // Prior on migration rates
  TiXmlElement * priorMigration = new TiXmlElement ("PriorMigration");
  demographicModel->LinkEndChild (priorMigration);
  priorMigration->LinkEndChild (new TiXmlText ("0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0")); 
   // Data
  TiXmlElement * data = new TiXmlElement ("Data");
  root->LinkEndChild (data);
  data->SetAttribute("NumberLoci", 1);
  // Locus
  locus = new TiXmlElement ("Locus");
  locus->SetAttribute("Name", "locus1");
  locus->SetAttribute("NumberSequence", 2);
  locus->SetAttribute("NumberSite", 6);
  data->LinkEndChild (locus);
  // Positions
  position = new TiXmlElement ("Position");
  locus->LinkEndChild (position);
  position->SetAttribute("Length", 10000);
  position->LinkEndChild (new TiXmlText ("4926 4935 5171 6649 6911 9819")); 
  // Sequence 1
  sequence = new TiXmlElement ("Sequence");
  locus->LinkEndChild (sequence);
  sequence->SetAttribute("IndividualID", 1);
  sequence->LinkEndChild (new TiXmlText ("ACTGCC")); 
  // Sequence 2
  sequence = new TiXmlElement ("Sequence");
  locus->LinkEndChild (sequence);
  sequence->SetAttribute("IndividualID", 2);
  sequence->LinkEndChild (new TiXmlText ("TAATCC")); 
  doc.SaveFile (f);
}
void
XmlImrInput::load (const char* f)
{
}
}
@
\subsection{imr output file}
Let's list things that are necessary in an imr output file. 
\begin{Verbatim}[frame=lines,framesep=5mm]
imr xml --print 4 -o imroutput.xml
\end{Verbatim}
<<imrXmlImrOutput.h>>=
<<imr gnu copyright>>
#ifndef _IMRXMLIMROUTPUT_H_
#define _IMRXMLIMROUTPUT_H_
namespace imr {
class XmlImrOutput {
public:
  static void save (const char*);
  static void load (const char*);
};
}
#endif // _IMRXMLIMROUTPUT_H_
<<imrXmlImrOutput.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrXmlImrOutput.h"
using namespace std;
namespace imr {
void
XmlImrOutput::save (const char* f)
{
  TiXmlElement * population;
  TiXmlElement * individual;
  TiXmlElement * locus;
  TiXmlElement * position;
  TiXmlElement * sequence;
  TiXmlElement * recombinantTree;
  TiXmlElement * localTree;
  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration ("1.0", "", "");
  doc.LinkEndChild (decl);
  TiXmlElement * root = new TiXmlElement ("ImrOutput");
  doc.LinkEndChild (root);
  
  // Random number generator seed
  TiXmlElement * seed = new TiXmlElement ("Seed");
  root->LinkEndChild (seed);
  seed->SetAttribute("Value", 12423467);
  // Generation time in years
  TiXmlElement * generationTime = new TiXmlElement ("GenerationTime");
  root->LinkEndChild (generationTime);
  generationTime->SetAttribute("year", 25);
  // Chain
  TiXmlElement * chain = new TiXmlElement ("Chain");
  root->LinkEndChild (chain);
  chain->SetAttribute("Length", 100000);
  chain->SetAttribute("Burnin", 50000);
  chain->SetAttribute("Thin", 100);
  // MC3
  TiXmlElement * mc3 = new TiXmlElement ("MC3");
  root->LinkEndChild (mc3);
  mc3->SetAttribute("Number", 25);
  mc3->SetDoubleAttribute("A", 0.995);
  mc3->SetDoubleAttribute("B", 0.5);
  TiXmlElement * populations = new TiXmlElement ("Populations");
  root->LinkEndChild (populations);
  populations->SetAttribute("Number", 3);
  // Population 1
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "East");
  population->SetAttribute("ID", 1);
  // Population 2
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "West");
  population->SetAttribute("ID", 2);
  // Population 3
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "Central");
  population->SetAttribute("ID", 3);
  // Individuals
  TiXmlElement * individuals = new TiXmlElement ("Individuals");
  root->LinkEndChild (individuals);
  individuals->SetAttribute("Number", 2);
  // Individual 1
  individual = new TiXmlElement ("Individual");
  individuals->LinkEndChild (individual);
  individual->SetAttribute("Name", "Alice");
  individual->SetAttribute("ID", 1);
  individual->SetAttribute("Population", 1);
  // Individual 2
  individual = new TiXmlElement ("Individual");
  individuals->LinkEndChild (individual);
  individual->SetAttribute("Name", "Bob");
  individual->SetAttribute("ID", 2);
  individual->SetAttribute("Population", 2);
  // Demographic Model
  TiXmlElement * demographicModel = new TiXmlElement ("DemographicModel");
  root->LinkEndChild (demographicModel);
  demographicModel->SetAttribute("Model", "Tree");
  demographicModel->SetAttribute("Tree", "((1,2)4,3)5");
  // Prior on split time
  TiXmlElement * priorSplitTime = new TiXmlElement ("PriorSplitTime");
  demographicModel->LinkEndChild (priorSplitTime);
  priorSplitTime->LinkEndChild (new TiXmlText ("((1:1,2:1)4:2,3:2)5")); 
  // Prior on population sizes
  TiXmlElement * priorPopulationSize = new TiXmlElement ("PriorPopulationSize");
  demographicModel->LinkEndChild (priorPopulationSize);
  priorPopulationSize->LinkEndChild (new TiXmlText ("((1:5,2:5)4:5,3:5)5:2")); 
  // Prior on migration rates
  TiXmlElement * priorMigration = new TiXmlElement ("PriorMigration");
  demographicModel->LinkEndChild (priorMigration);
  priorMigration->LinkEndChild (new TiXmlText ("0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0")); 
   // Data
  TiXmlElement * data = new TiXmlElement ("Data");
  root->LinkEndChild (data);
  data->SetAttribute("NumberLoci", 1);
  // Locus
  locus = new TiXmlElement ("Locus");
  locus->SetAttribute("Name", "locus1");
  locus->SetAttribute("NumberSequence", 2);
  locus->SetAttribute("NumberSite", 6);
  data->LinkEndChild (locus);
  // Positions
  position = new TiXmlElement ("Position");
  locus->LinkEndChild (position);
  position->SetAttribute("Length", 10000);
  position->LinkEndChild (new TiXmlText ("4926 4935 5171 6649 6911 9819")); 
  // Sequence 1
  sequence = new TiXmlElement ("Sequence");
  locus->LinkEndChild (sequence);
  sequence->SetAttribute("IndividualID", 1);
  sequence->LinkEndChild (new TiXmlText ("ACTGCC")); 
  // Sequence 2
  sequence = new TiXmlElement ("Sequence");
  locus->LinkEndChild (sequence);
  sequence->SetAttribute("IndividualID", 2);
  sequence->LinkEndChild (new TiXmlText ("TAATCC")); 

  // RecombinantTrees
  TiXmlElement * recombinantTrees = new TiXmlElement ("RecombinantTrees");
  root->LinkEndChild (recombinantTrees);
  recombinantTrees->SetAttribute("Number", 1);
  // RecombinantTree
  recombinantTree = new TiXmlElement ("RecombinantTree");
  recombinantTrees->LinkEndChild (recombinantTree);
  recombinantTree->SetAttribute("Length", 10000);
  // Local tree 1
  localTree = new TiXmlElement ("LocalTree");
  recombinantTree->LinkEndChild (localTree);
  localTree->SetAttribute("Position", 1);
  localTree->LinkEndChild (new TiXmlText ("(((1.1:2626, (3.1:61, 2.1:61):2565):16635, 5.1:19261):29956, 4.1:49217);")); 
  // Local tree 2
  localTree = new TiXmlElement ("LocalTree");
  recombinantTree->LinkEndChild (localTree);
  localTree->SetAttribute("Position", 37);
  localTree->LinkEndChild (new TiXmlText ("(((1.1:2626, (3.1:61, 2.1:61):2565):16635, 5.1:19261):19792, 4.1:39053);")); 
  // Local tree 3
  localTree = new TiXmlElement ("LocalTree");
  recombinantTree->LinkEndChild (localTree);
  localTree->SetAttribute("Position", 215);
  localTree->LinkEndChild (new TiXmlText ("(((1.1:2626, (3.1:61, 2.1:61):2565):16635, 5.1:19261):19792, 4.1:39053);")); 
  doc.SaveFile (f);
}
void
XmlImrOutput::load (const char* f)
{
}
}
@
\subsection{imr XML recombinant tree file}
Let's print a recombinant tree in XML file.
\begin{Verbatim}[frame=lines,framesep=5mm]
imr xml --print 5 -o imrrectree.xml
\end{Verbatim}
<<imrXmlImrRectree.h>>=
<<imr gnu copyright>>
#ifndef _IMRXMLIMRRECTREE_H_
#define _IMRXMLIMRRECTREE_H_
#include <vector>
#include <cstdio>
#include "tinystr.h"
#include "tinyxml.h"
namespace imr {
class XmlImrRectree {
private:
  static void printEdge (const std::vector<int>& v, TiXmlElement * edge, TiXmlElement * site);
  static void printRecombination (double t, int up, int left, int right, int breakPoint,
                                  const std::vector<int>& iVecLeft, 
                                  const std::vector<int>& iVecRight, 
                                  int numberSite,
                                  TiXmlElement * rectree, 
                                  TiXmlElement * event, TiXmlElement * edge,
                                  TiXmlElement * site);
  static void printCoalescent (double t, int left, int right, int down,
                               const std::vector<int>& iVecDown, 
                               int numberSite,
                               TiXmlElement * rectree, 
                               TiXmlElement * event, 
                               TiXmlElement * edge, 
                               TiXmlElement * site);
public:
  static void save (const char*);
  static void load (const char*, const char*, int removeEdge = 0);
  static const char * getIndent( unsigned int numIndents );
  static const char * getIndentAlt( unsigned int numIndents );
  static int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent);
  static void dump_to_stdout( TiXmlNode* pParent, unsigned int indent = 0);
  static void dump_to_stdout(const char* pFilename);
};
}
#endif // _IMRXMLIMRRECTREE_H_
<<imrXmlImrRectree.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include <vector>
#include "imrTree.h"
#include "tinystr.h"
#include "tinyxml.h"
#include "imrXmlImrRectree.h"
using namespace std;
namespace imr {
void
XmlImrRectree::save (const char* f)
{
  const int numberSite = 12;
  int arr1[numberSite]  = {1,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec1(arr1, arr1 + numberSite);
  int arr6[numberSite]  = {1,1,1,1,1,1,1,1,1,0,0,0}; std::vector<int> iVec6(arr6, arr6 + numberSite);
  int arr7[numberSite]  = {0,0,0,0,0,0,0,0,0,1,1,1}; std::vector<int> iVec7(arr7, arr7 + numberSite);
  int arr8[numberSite]  = {1,1,1,1,1,1,1,1,0,0,0,0}; std::vector<int> iVec8(arr8, arr8 + numberSite);
  int arr9[numberSite]  = {0,0,0,0,0,0,0,0,1,0,0,0}; std::vector<int> iVec9(arr9, arr9 + numberSite);
  int arr10[numberSite] = {1,1,1,1,1,0,0,0,0,0,0,0}; std::vector<int> iVec10(arr10, arr10 + numberSite);
  int arr11[numberSite] = {0,0,0,0,0,1,1,1,1,1,1,1}; std::vector<int> iVec11(arr11, arr11 + numberSite);
  int arr12[numberSite] = {1,0,0,0,0,0,0,0,0,0,0,0}; std::vector<int> iVec12(arr12, arr12 + numberSite);
  int arr13[numberSite] = {0,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec13(arr13, arr13 + numberSite);
  int arr14[numberSite] = {1,1,1,1,1,1,1,1,1,1,0,0}; std::vector<int> iVec14(arr14, arr14 + numberSite);
  int arr15[numberSite] = {0,0,0,0,0,0,0,0,0,0,1,1}; std::vector<int> iVec15(arr15, arr15 + numberSite);
  int arr16[numberSite] = {0,0,0,0,0,0,0,0,0,0,1,0}; std::vector<int> iVec16(arr16, arr16 + numberSite);
  int arr17[numberSite] = {0,0,0,0,0,0,0,0,0,0,0,1}; std::vector<int> iVec17(arr17, arr17 + numberSite);
  int arr18[numberSite] = {0,0,0,0,0,1,1,1,1,1,1,1}; std::vector<int> iVec18(arr18, arr18 + numberSite);
  int arr19[numberSite] = {1,1,1,1,1,1,1,1,1,1,0,0}; std::vector<int> iVec19(arr19, arr19 + numberSite);
  int arr20[numberSite] = {0,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec20(arr20, arr20 + numberSite);
  int arr21[numberSite] = {1,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec21(arr21, arr21 + numberSite);
  int arr22[numberSite] = {1,1,1,0,0,0,0,0,0,0,0,0}; std::vector<int> iVec22(arr22, arr22 + numberSite);
  int arr23[numberSite] = {0,0,0,1,1,1,1,1,1,1,0,0}; std::vector<int> iVec23(arr23, arr23 + numberSite);
  int arr24[numberSite] = {1,1,0,0,0,0,0,0,0,0,0,0}; std::vector<int> iVec24(arr24, arr24 + numberSite);
  int arr25[numberSite] = {0,0,1,1,1,1,1,1,0,0,0,0}; std::vector<int> iVec25(arr25, arr25 + numberSite);
  int arr26[numberSite] = {0,1,1,1,0,0,0,0,0,0,0,0}; std::vector<int> iVec26(arr26, arr26 + numberSite);
  int arr27[numberSite] = {0,0,0,0,1,1,1,1,1,1,1,1}; std::vector<int> iVec27(arr27, arr27 + numberSite);
  int arr28[numberSite] = {1,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec28(arr28, arr28 + numberSite);
  int arr29[numberSite] = {1,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec29(arr29, arr29 + numberSite);
  int arr30[numberSite] = {1,1,1,1,1,1,0,0,0,0,0,0}; std::vector<int> iVec30(arr30, arr30 + numberSite);
  int arr31[numberSite] = {0,0,0,0,0,0,1,1,1,1,1,1}; std::vector<int> iVec31(arr31, arr31 + numberSite);
  int arr32[numberSite] = {1,1,0,0,0,0,0,0,0,0,0,0}; std::vector<int> iVec32(arr32, arr32 + numberSite);
  int arr33[numberSite] = {0,0,0,0,1,1,1,0,0,0,0,0}; std::vector<int> iVec33(arr33, arr33 + numberSite);
  int arr34[numberSite] = {0,0,0,0,0,0,0,1,1,1,1,1}; std::vector<int> iVec34(arr34, arr34 + numberSite);
  int arr35[numberSite] = {0,0,0,0,0,1,1,1,1,1,1,1}; std::vector<int> iVec35(arr35, arr35 + numberSite);
  int arr36[numberSite] = {0,0,0,0,1,1,1,1,1,1,1,1}; std::vector<int> iVec36(arr36, arr36 + numberSite);
  int arr37[numberSite] = {1,1,1,0,0,0,0,0,0,0,0,0}; std::vector<int> iVec37(arr37, arr37 + numberSite);
  int arr38[numberSite] = {0,0,0,0,1,1,1,1,1,1,1,1}; std::vector<int> iVec38(arr38, arr38 + numberSite);
  int arr39[numberSite] = {0,0,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec39(arr39, arr39 + numberSite);
  int arr40[numberSite] = {1,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec40(arr40, arr40 + numberSite);
  int arr41[numberSite] = {1,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec41(arr41, arr41 + numberSite);
  int arr42[numberSite] = {1,1,1,1,1,1,1,1,1,1,1,1}; std::vector<int> iVec42(arr42, arr42 + numberSite);
  TiXmlElement * rectree;
  TiXmlElement * event;
  TiXmlElement * edge;
  TiXmlElement * site;

  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration ("1.0", "", "");
  doc.LinkEndChild (decl);
  TiXmlElement * root = new TiXmlElement ("ImrRectree");
  doc.LinkEndChild (root);

  // Rectree
  rectree = new TiXmlElement ("Rectree");
  root->LinkEndChild (rectree);
  rectree->SetAttribute("interval", 26);
  // Event 0
  event = new TiXmlElement ("Event");
  rectree->LinkEndChild (event);
  event->SetDoubleAttribute("time", 0.0);
  event ->SetAttribute("type", "sample");
	// Edge 1
  edge = new TiXmlElement ("Edge");
  event->LinkEndChild (edge);
  edge->SetAttribute("id", 1);
  edge->SetAttribute("sites", numberSite);
  printEdge (iVec1, edge, site);
	// Edge 2
  edge = new TiXmlElement ("Edge");
  event->LinkEndChild (edge);
  edge->SetAttribute("id", 2);
  edge->SetAttribute("sites", 12);
  printEdge (iVec1, edge, site);
	// Edge 3
  edge = new TiXmlElement ("Edge");
  event->LinkEndChild (edge);
  edge->SetAttribute("id", 3);
  edge->SetAttribute("sites", 12);
  printEdge (iVec1, edge, site);
	// Edge 4
  edge = new TiXmlElement ("Edge");
  event->LinkEndChild (edge);
  edge->SetAttribute("id", 4);
  edge->SetAttribute("sites", 12);
  printEdge (iVec1, edge, site);
	// Edge 5
  edge = new TiXmlElement ("Edge");
  event->LinkEndChild (edge);
  edge->SetAttribute("id", 5);
  edge->SetAttribute("sites", 12);
  printEdge (iVec1, edge, site);

  // Event 1
  printRecombination (1.0, 5, 6, 7, 9, 
                      iVec6, iVec7, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 2
  printRecombination (2.0, 6, 8, 9, 8, 
                      iVec8, iVec9, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 3
  printRecombination (3.0, 2, 10, 11, 5, 
                      iVec10, iVec11, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 4
  printRecombination (4.0, 4, 12, 13, 1, 
                      iVec12, iVec13, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 5
  printRecombination (5.0, 3, 14, 15, 10, 
                      iVec14, iVec15, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 6
  printRecombination (6.0, 15, 16, 17, 11, 
                      iVec16, iVec17, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 7
  printCoalescent (7.0, 7, 11, 18,
                   iVec18,
                   numberSite,
                   rectree, event, edge, site);
  // Event 8
  printCoalescent (8.0, 10, 14, 19,
                   iVec19,
                   numberSite,
                   rectree, event, edge, site);
  // Event 9
  printCoalescent (9.0, 13, 16, 20,
                   iVec20,
                   numberSite,
                   rectree, event, edge, site);
  // Event 10
  printCoalescent (10.0, 1, 9, 21,
                   iVec21,
                   numberSite,
                   rectree, event, edge, site);
  // Event 11
  printRecombination (11.0, 19, 22, 23, 3, 
                      iVec22, iVec23, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 12
  printRecombination (12.0, 8, 24, 25, 2, 
                      iVec24, iVec25, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 13
  printRecombination (13.0, 20, 26, 27, 4, 
                      iVec26, iVec27, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 14
  printCoalescent (14.0, 21, 23, 28,
                   iVec28,
                   numberSite,
                   rectree, event, edge, site);
  // Event 15
  printCoalescent (15.0, 26, 28, 29,
                   iVec29,
                   numberSite,
                   rectree, event, edge, site);
  // Event 16
  printRecombination (16.0, 29, 30, 31, 6, 
                      iVec30, iVec31, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 17
  printCoalescent (17.0, 12, 24, 32,
                   iVec32,
                   numberSite,
                   rectree, event, edge, site);
  // Event 18
  printRecombination (18.0, 27, 33, 34, 7, 
                      iVec33, iVec34, 
                      numberSite,
                      rectree, event, edge, site);
  // Event 19
  printCoalescent (19.0, 18, 31, 35,
                   iVec35,
                   numberSite,
                   rectree, event, edge, site);
  // Event 20
  printCoalescent (20.0, 33, 35, 36,
                   iVec36,
                   numberSite,
                   rectree, event, edge, site);
  // Event 21
  printCoalescent (21.0, 22, 32, 37,
                   iVec37,
                   numberSite,
                   rectree, event, edge, site);
  // Event 22
  printCoalescent (22.0, 17, 36, 38,
                   iVec38,
                   numberSite,
                   rectree, event, edge, site);
  // Event 23
  printCoalescent (23.0, 25, 38, 39,
                   iVec39,
                   numberSite,
                   rectree, event, edge, site);
  // Event 24
  printCoalescent (24.0, 30, 39, 40,
                   iVec40,
                   numberSite,
                   rectree, event, edge, site);
  // Event 25
  printCoalescent (25.0, 37, 40, 41,
                   iVec41,
                   numberSite,
                   rectree, event, edge, site);
  // Event 26
  printCoalescent (26.0, 34, 41, 42,
                   iVec42,
                   numberSite,
                   rectree, event, edge, site);

  doc.SaveFile (f);
}

void
XmlImrRectree::load (const char* f, const char* of, int removeEdge)
{
  TiXmlDocument doc(f);
  bool loadOkay = doc.LoadFile();
  if (loadOkay == false)
    {
      return;
    }

  TiXmlHandle hDoc(&doc);
  TiXmlElement* pElem;
  TiXmlElement* pEdgeElem;
  TiXmlElement* pSite;
  TiXmlNode* pEdge;
  TiXmlHandle hRoot(0);

  // root
  {
    pElem=hDoc.FirstChildElement().Element();
    // should always have a valid root but handle gracefully if it does
    if (!pElem) return;

    // save this for later
    hRoot=TiXmlHandle(pElem);
  }

  // Number of interval
  {
    pElem=hRoot.FirstChild( "Rectree" ).Element();
    for( pElem; pElem; pElem=pElem->NextSiblingElement())
      {
        int interval;
        pElem->QueryIntAttribute("interval", &interval);
        std::cout << "Rectree interval: " << interval << std::endl;
      }
  }

  int numberSample = 0;
  {
    pElem=hRoot.FirstChild( "Rectree" ).FirstChild().Element();
    for( pElem; pElem; pElem=pElem->NextSiblingElement())
      {
        double t;
        pElem->QueryDoubleAttribute("time", &t);
        string type;
        type = pElem->Attribute("type");
        if (type == "sample")
          {
            pEdgeElem = pElem->FirstChild()->ToElement();
            for( pEdgeElem; pEdgeElem != 0; pEdgeElem=pEdgeElem->NextSiblingElement())
              {
                numberSample++; 
              }
            break;
          }
      }
  }
  cout << "Number of sample is " << numberSample << endl;

  Tree* recTree = new Tree(numberSample, 12);

  // Number of events
  {
    pElem=hRoot.FirstChild( "Rectree" ).FirstChild().Element();
    for( pElem; pElem; pElem=pElem->NextSiblingElement())
      {
        double t;
        pElem->QueryDoubleAttribute("time", &t);
        string type;
        type = pElem->Attribute("type");
        if (type == "recombination")
          {
            int up, recombinationPosition;
            pElem->QueryIntAttribute("up", &up);
            pElem->QueryIntAttribute("break", &recombinationPosition);
            std::cout << "\nEvent\t" << t << "\t" << type
                      << "\tup:\t" << up << "\tbreak\t" << recombinationPosition
                      << std::endl;
            recTree->addRecombination (t, up-1, recombinationPosition);
          }
        else if (type == "coalescent")
          {
            int left, right;
            pElem->QueryIntAttribute("left", &left);
            pElem->QueryIntAttribute("right", &right);
            std::cout << "Event\t" << t << "\t" << type
                      << "\tleft:\t" << left << "\tright\t" << right
                      << std::endl;
            recTree->addCoalescent (t, left-1, right-1);
          }
        else 
          {
            std::cout << "Event\t" << t << "\t" << type
                      << std::endl;
          }

        pEdgeElem = pElem->FirstChild()->ToElement();

        for( pEdgeElem; pEdgeElem != 0; pEdgeElem=pEdgeElem->NextSiblingElement())
          {
            int id;
            pEdgeElem->QueryIntAttribute("id", &id);
            std::cout << "  ID\t" << id << "\t";

            pSite = pEdgeElem->FirstChild()->ToElement();
            for( pSite; pSite != 0; pSite=pSite->NextSiblingElement())
              {
                int eligible;
                pSite->QueryIntAttribute("eligible", &eligible);
                std::cout << eligible;
              }
            std::cout << std::endl;
          }
        cout << "=========================" << endl;
        recTree->print();
      }
  }

  // Print the recTree.
  recTree->print();

/*
  if (removeEdge > 0)
    {
      recTree->pruneBranch (removeEdge - 1);
    }
  cout << "After removing eligible links starting at edge "
       << removeEdge << endl;
  recTree->print();
*/
  recTree->printXml(of);

  delete recTree;
  recTree = NULL;
}

// ----------------------------------------------------------------------
// STDOUT dump and indenting utility functions
// ----------------------------------------------------------------------
const unsigned int NUM_INDENTS_PER_SPACE=2;

const char * XmlImrRectree::getIndent( unsigned int numIndents )
{
  static const char * pINDENT="                                      + ";
  static const unsigned int LENGTH=strlen( pINDENT );
  unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
  if ( n > LENGTH ) n = LENGTH;

  return &pINDENT[ LENGTH-n ];
}

// same as getIndent but no "+" at the end
const char * XmlImrRectree::getIndentAlt( unsigned int numIndents )
{
  static const char * pINDENT="                                        ";
  static const unsigned int LENGTH=strlen( pINDENT );
  unsigned int n=numIndents*NUM_INDENTS_PER_SPACE;
  if ( n > LENGTH ) n = LENGTH;

  return &pINDENT[ LENGTH-n ];
}

int XmlImrRectree::dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent)
{
  if ( !pElement ) return 0;

  TiXmlAttribute* pAttrib=pElement->FirstAttribute();
  int i=0;
  int ival;
  double dval;
  const char* pIndent=getIndent(indent);
  printf("\n");
  while (pAttrib)
  {
    printf( "%s%s: value=[%s]", pIndent, pAttrib->Name(), pAttrib->Value());

    if (pAttrib->QueryIntValue(&ival)==TIXML_SUCCESS)    printf( " int=%d", ival);
    if (pAttrib->QueryDoubleValue(&dval)==TIXML_SUCCESS) printf( " d=%1.1f", dval);
    printf( "\n" );
    i++;
    pAttrib=pAttrib->Next();
  }
  return i; 
}

void XmlImrRectree::dump_to_stdout( TiXmlNode* pParent, unsigned int indent )
{
  if ( !pParent ) return;

  TiXmlNode* pChild;
  TiXmlText* pText;
  int t = pParent->Type();
  printf( "%s", getIndent(indent));
  int num;

  switch ( t )
  {
  case TiXmlNode::TINYXML_DOCUMENT:
    printf( "Document" );
    break;

  case TiXmlNode::TINYXML_ELEMENT:
    printf( "Element [%s]", pParent->Value() );
    num=dump_attribs_to_stdout(pParent->ToElement(), indent+1);
    switch(num)
    {
      case 0:  printf( " (No attributes)"); break;
      case 1:  printf( "%s1 attribute", getIndentAlt(indent)); break;
      default: printf( "%s%d attributes", getIndentAlt(indent), num); break;
    }
    break;

  case TiXmlNode::TINYXML_COMMENT:
    printf( "Comment: [%s]", pParent->Value());
    break;

  case TiXmlNode::TINYXML_UNKNOWN:
    printf( "Unknown" );
    break;

  case TiXmlNode::TINYXML_TEXT:
    pText = pParent->ToText();
    printf( "Text: [%s]", pText->Value() );
    break;

  case TiXmlNode::TINYXML_DECLARATION:
    printf( "Declaration" );
    break;
  default:
    break;
  }
  printf( "\n" );
  for ( pChild = pParent->FirstChild(); pChild != 0; pChild = pChild->NextSibling()) 
  {
    dump_to_stdout( pChild, indent+1 );
  }
}

// load the named file and dump its structure to STDOUT
void XmlImrRectree::dump_to_stdout(const char* pFilename)
{
  TiXmlDocument doc(pFilename);
  bool loadOkay = doc.LoadFile();
  if (loadOkay)
  {
    printf("\n%s:\n", pFilename);
    dump_to_stdout( &doc ); // defined later in the tutorial
  }
  else
  {
    printf("Failed to load file \"%s\"\n", pFilename);
  }
}

void 
XmlImrRectree::printEdge (const std::vector<int>& v, TiXmlElement * edge, TiXmlElement * site)
{
  for (unsigned int i = 0; i < v.size(); i++)
    {
      site = new TiXmlElement ("Site");
      edge->LinkEndChild (site); 
      site->SetAttribute("position", i+1);
      site->SetAttribute("eligible", v[i]);
    }
}

void 
XmlImrRectree::printRecombination (double t, int up, int left, int right, int breakPoint,
                                   const std::vector<int>& iVecLeft, 
                                   const std::vector<int>& iVecRight, 
                                   int numberSite,
                                   TiXmlElement * rectree, 
                                   TiXmlElement * event, 
                                   TiXmlElement * edge, 
                                   TiXmlElement * site)
{
  // Event 2
  event = new TiXmlElement ("Event");
  rectree->LinkEndChild (event);
  event->SetDoubleAttribute("time", t);
  event ->SetAttribute("type", "recombination");
  event ->SetAttribute("up", up);
  event ->SetAttribute("break", breakPoint);
  // Edge 8
  edge = new TiXmlElement ("Edge");
  event->LinkEndChild (edge);
  edge->SetAttribute("id", left);
  edge->SetAttribute("sites", numberSite);
  printEdge (iVecLeft, edge, site);
	// Edge 9
  edge = new TiXmlElement ("Edge");
  event->LinkEndChild (edge);
  edge->SetAttribute("id", right);
  edge->SetAttribute("sites", numberSite);
  printEdge (iVecRight, edge, site);
}

void 
XmlImrRectree::printCoalescent (double t, int left, int right, int down,
                                const std::vector<int>& iVecDown, 
                                int numberSite,
                                TiXmlElement * rectree, 
                                TiXmlElement * event, 
                                TiXmlElement * edge, 
                                TiXmlElement * site)
{
  // Coalescent Event
  event = new TiXmlElement ("Event");
  rectree->LinkEndChild (event);
  event->SetDoubleAttribute("time", t);
  event ->SetAttribute("type", "coalescent");
  event ->SetAttribute("left", left);
  event ->SetAttribute("right", right);
  // Edge down
  edge = new TiXmlElement ("Edge");
  event->LinkEndChild (edge);
  edge->SetAttribute("id", down);
  edge->SetAttribute("sites", numberSite);
  printEdge (iVecDown, edge, site);
}

}
@
\subsection{imr XML event file}
Let's print a list of events in XML file.
\begin{Verbatim}[frame=lines,framesep=5mm]
imr xml --print 6 -o imrevent.xml
\end{Verbatim}
<<imrXmlImrEvent.h>>=
<<imr gnu copyright>>
#ifndef _IMRXMLIMREVENT_H_
#define _IMRXMLIMREVENT_H_
#include <vector>
#include <cstdio>
#include "tinystr.h"
#include "tinyxml.h"
namespace imr {
class XmlImrEvent {
private:
  static void printSample (TiXmlElement * _event,
                           const UINT _id, 
                           const std::vector<int>& _site,
                           const std::vector<int>& _link,
                           const char* _seq);
  static void printRecombination (TiXmlElement * _root,
                                  UDBL _t, UINT _up, 
                                  UINT _left, UINT _right, UINT _breakpoint);
  static void printCoalescent (TiXmlElement * _root, 
                               UDBL _t, UINT _left, UINT _right, UINT _down);
public:
  static void save (const char*);
  static void load (const char*, int removeEdge = 0);

  static const char * getIndent( unsigned int numIndents );
  static const char * getIndentAlt( unsigned int numIndents );
  static int dump_attribs_to_stdout(TiXmlElement* pElement, unsigned int indent);
  static void dump_to_stdout( TiXmlNode* pParent, unsigned int indent = 0);
  static void dump_to_stdout(const char* pFilename);
};
}
#endif // _IMRXMLIMREVENT_H_
<<imrXmlImrEvent.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include <vector>
#include "imrEvent.h"
#include "tinystr.h"
#include "tinyxml.h"
#include "imrXmlImrEvent.h"
using namespace std;
namespace imr {
void
XmlImrEvent::save (const char* f)
{
  const int numberSite = 10000;
  int arr1[1]  = {numberSite}; std::vector<int> iVec1(arr1, arr1 + 1);
  int arr2[1]  = {1}; std::vector<int> iVec2(arr2, arr2 + 1);

  TiXmlElement * event;
  TiXmlElement * edge;
  TiXmlElement * site;

  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration ("1.0", "", "");
  doc.LinkEndChild (decl);
  TiXmlElement * root = new TiXmlElement ("ImrEvent");
  doc.LinkEndChild (root);

  // Event 0
  event = new TiXmlElement ("Event");
  root->LinkEndChild (event);
  event->SetDoubleAttribute("time", 0.0);
  event->SetAttribute("type", "sample");
  event->SetAttribute("position", "4926,4935,5171,6649,6911,9819");

	// Samples
  printSample (event, 1, iVec1, iVec2, "ACTGCC");
  printSample (event, 2, iVec1, iVec2, "TAATCC");
  printSample (event, 3, iVec1, iVec2, "TAATCT");
  printSample (event, 4, iVec1, iVec2, "ACTGCT");
  printSample (event, 5, iVec1, iVec2, "ACTGGC");

  printRecombination (root, 1.0, 5, 6, 7, 9);
  printRecombination (root, 2.0, 6, 8, 9, 8);
  printRecombination (root, 3.0, 2, 10, 11, 5);
  printRecombination (root, 4.0, 4, 12, 13, 1);
  printRecombination (root, 5.0, 3, 14, 15, 10);
  printRecombination (root, 6.0, 15, 16, 17, 11);
  printCoalescent (root, 7.0, 7, 11, 18);
  printCoalescent (root, 8.0, 10, 14, 19);
  printCoalescent (root, 9.0, 13, 16, 20);
  printCoalescent (root, 10.0, 1, 9, 21);
  printRecombination (root, 11.0, 19, 22, 23, 3);
  printRecombination (root, 12.0, 8, 24, 25, 2 );
  printRecombination (root, 13.0, 20, 26, 27, 4);
  printCoalescent (root, 14.0, 21, 23, 28);
  printCoalescent (root, 15.0, 26, 28, 29);
  printRecombination (root, 16.0, 29, 30, 31, 6);
  printCoalescent (root, 17.0, 12, 24, 32);
  printRecombination (root, 18.0, 27, 33, 34, 7);
  printCoalescent (root, 19.0, 18, 31, 35);
  printCoalescent (root, 20.0, 33, 35, 36);
  printCoalescent (root, 21.0, 22, 32, 37);
  printCoalescent (root, 22.0, 17, 36, 38);
  printCoalescent (root, 23.0, 25, 38, 39);
  printCoalescent (root, 24.0, 30, 39, 40);
  printCoalescent (root, 25.0, 37, 40, 41);
  printCoalescent (root, 26.0, 34, 41, 42);

  doc.SaveFile (f);
}


void 
XmlImrEvent::printSample (TiXmlElement * _event,
                          const UINT _id, 
                          const std::vector<int>& _site,
                          const std::vector<int>& _link,
                          const char* _seq)
{
  TiXmlElement * edge = new TiXmlElement ("Edge");
  _event->LinkEndChild (edge);
  edge->SetAttribute("id", _id);
  edge->SetAttribute("seq", _seq);
}

void 
XmlImrEvent::printRecombination (TiXmlElement * _root,
                                 UDBL _t, UINT _up, 
                                 UINT _left, UINT _right, UINT _breakpoint)
{
  TiXmlElement * event = new TiXmlElement ("Event");
  _root->LinkEndChild (event);
  event->SetDoubleAttribute("time", _t);
  event->SetAttribute("type", "recombination");
  event->SetAttribute("up", _up);
  event->SetAttribute("left", _left);
  event->SetAttribute("right", _right);
  event->SetAttribute("breakpoint", _breakpoint);
}

void
XmlImrEvent::printCoalescent (TiXmlElement * _root, 
                              UDBL _t, UINT _left, UINT _right, UINT _down)
{
  TiXmlElement * event = new TiXmlElement ("Event");
  _root->LinkEndChild (event);
  event->SetDoubleAttribute("time", _t);
  event->SetAttribute("type", "coalescent");
  event->SetAttribute("left", _left);
  event->SetAttribute("right", _right);
  event->SetAttribute("down", _down);
}

void
XmlImrEvent::load (const char* f, int removeEdge)
{
  TiXmlDocument doc(f);
  bool loadOkay = doc.LoadFile();
  if (loadOkay == false)
    {
      return;
    }

  TiXmlHandle hDoc(&doc);
  TiXmlElement* pElem;
  TiXmlElement* pEdgeElem;
  TiXmlElement* pSite;
  TiXmlNode* pEdge;
  TiXmlHandle hRoot(0);

  // root
  {
    pElem=hDoc.FirstChildElement().Element();
    // should always have a valid root but handle gracefully if it does
    if (!pElem) return;

    // save this for later
    hRoot=TiXmlHandle(pElem);
  }

  EventList* el = new EventList();

  // Number of events
  {
    pElem=hRoot.FirstChild("Event").Element();
    for( pElem; pElem; pElem=pElem->NextSiblingElement())
      {
        double t;
        pElem->QueryDoubleAttribute("time", &t);
        string type;
        type = pElem->Attribute("type");
        if (type == "recombination")
          {
            int up, left, right, recombinationPosition;
            pElem->QueryIntAttribute("up", &up);
            pElem->QueryIntAttribute("left", &left);
            pElem->QueryIntAttribute("right", &right);
            pElem->QueryIntAttribute("breakpoint", &recombinationPosition);
            std::cout << "Event\t" << t << "\t" << type
                      << "\tup:\t" << up
                      << "\tleft:\t" << left
                      << "\tright:\t" << right << "\tbreak\t" << recombinationPosition
                      << std::endl;
            el->addRecombination (t, NULL, NULL, NULL, recombinationPosition);
          }
        else if (type == "coalescent")
          {
            int left, right;
            pElem->QueryIntAttribute("left", &left);
            pElem->QueryIntAttribute("right", &right);
            std::cout << "Event\t" << t << "\t" << type
                      << "\tleft:\t" << left << "\tright\t" << right
                      << std::endl;
            el->addCoalescent (t, NULL, NULL, NULL);
          }
        else 
          {
            std::cout << "Event\t" << t << "\t" << type
                      << std::endl;
          }

        //recTree->print();
      }
  }

  el->sort ();
  el->print ();

  delete el;
  el = NULL;
}

}
@
\subsection{Compute likelihood}
\begin{Verbatim}[frame=lines,framesep=5mm]
imr likelihood -i imroutput.xml
\end{Verbatim}
<<imrCmdLikelihood.h>>=
<<imr gnu copyright>>
#ifndef _IMRCMDLIKELIHOOD_H_
#define _IMRCMDLIKELIHOOD_H_
namespace imr {
class CmdLikelihood {
public:
  static double likelihood;
  static void compute (const char*);
  static void report ();
};
}
#endif // _IMRCMDLIKELIHOOD_H_
<<imrCmdLikelihood.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrCmdLikelihood.h"
using namespace std;
namespace imr {
double CmdLikelihood::likelihood = 0L;
void
CmdLikelihood::compute (const char* f)
{
  // Read the XML file.
  // Parse it to create a recombinant tree.
  // Compute the likelihood of the data given the tree.
  // Print out the recombinant tree.
  TiXmlElement * population;
  TiXmlElement * individual;
  TiXmlElement * locus;
  TiXmlElement * position;
  TiXmlElement * sequence;
  TiXmlElement * recombinantTree;
  TiXmlElement * localTree;
  TiXmlDocument doc;
  TiXmlDeclaration * decl = new TiXmlDeclaration ("1.0", "", "");
  doc.LinkEndChild (decl);
  TiXmlElement * root = new TiXmlElement ("ImrOutput");
  doc.LinkEndChild (root);
  
  // Random number generator seed
  TiXmlElement * seed = new TiXmlElement ("Seed");
  root->LinkEndChild (seed);
  seed->SetAttribute("Value", 12423467);
  // Generation time in years
  TiXmlElement * generationTime = new TiXmlElement ("GenerationTime");
  root->LinkEndChild (generationTime);
  generationTime->SetAttribute("year", 25);
  // Chain
  TiXmlElement * chain = new TiXmlElement ("Chain");
  root->LinkEndChild (chain);
  chain->SetAttribute("Length", 100000);
  chain->SetAttribute("Burnin", 50000);
  chain->SetAttribute("Thin", 100);
  // MC3
  TiXmlElement * mc3 = new TiXmlElement ("MC3");
  root->LinkEndChild (mc3);
  mc3->SetAttribute("Number", 25);
  mc3->SetDoubleAttribute("A", 0.995);
  mc3->SetDoubleAttribute("B", 0.5);
  TiXmlElement * populations = new TiXmlElement ("Populations");
  root->LinkEndChild (populations);
  populations->SetAttribute("Number", 3);
  // Population 1
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "East");
  population->SetAttribute("ID", 1);
  // Population 2
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "West");
  population->SetAttribute("ID", 2);
  // Population 3
  population = new TiXmlElement ("Population");
  populations->LinkEndChild (population);
  population->SetAttribute("Name", "Central");
  population->SetAttribute("ID", 3);
  // Individuals
  TiXmlElement * individuals = new TiXmlElement ("Individuals");
  root->LinkEndChild (individuals);
  individuals->SetAttribute("Number", 2);
  // Individual 1
  individual = new TiXmlElement ("Individual");
  individuals->LinkEndChild (individual);
  individual->SetAttribute("Name", "Alice");
  individual->SetAttribute("ID", 1);
  individual->SetAttribute("Population", 1);
  // Individual 2
  individual = new TiXmlElement ("Individual");
  individuals->LinkEndChild (individual);
  individual->SetAttribute("Name", "Bob");
  individual->SetAttribute("ID", 2);
  individual->SetAttribute("Population", 2);
  // Demographic Model
  TiXmlElement * demographicModel = new TiXmlElement ("DemographicModel");
  root->LinkEndChild (demographicModel);
  demographicModel->SetAttribute("Model", "Tree");
  demographicModel->SetAttribute("Tree", "((1,2)4,3)5");
  // Prior on split time
  TiXmlElement * priorSplitTime = new TiXmlElement ("PriorSplitTime");
  demographicModel->LinkEndChild (priorSplitTime);
  priorSplitTime->LinkEndChild (new TiXmlText ("((1:1,2:1)4:2,3:2)5")); 
  // Prior on population sizes
  TiXmlElement * priorPopulationSize = new TiXmlElement ("PriorPopulationSize");
  demographicModel->LinkEndChild (priorPopulationSize);
  priorPopulationSize->LinkEndChild (new TiXmlText ("((1:5,2:5)4:5,3:5)5:2")); 
  // Prior on migration rates
  TiXmlElement * priorMigration = new TiXmlElement ("PriorMigration");
  demographicModel->LinkEndChild (priorMigration);
  priorMigration->LinkEndChild (new TiXmlText ("0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0")); 
   // Data
  TiXmlElement * data = new TiXmlElement ("Data");
  root->LinkEndChild (data);
  data->SetAttribute("NumberLoci", 1);
  // Locus
  locus = new TiXmlElement ("Locus");
  locus->SetAttribute("Name", "locus1");
  locus->SetAttribute("NumberSequence", 2);
  locus->SetAttribute("NumberSite", 6);
  data->LinkEndChild (locus);
  // Positions
  position = new TiXmlElement ("Position");
  locus->LinkEndChild (position);
  position->SetAttribute("Length", 10000);
  position->LinkEndChild (new TiXmlText ("4926 4935 5171 6649 6911 9819")); 
  // Sequence 1
  sequence = new TiXmlElement ("Sequence");
  locus->LinkEndChild (sequence);
  sequence->SetAttribute("IndividualID", 1);
  sequence->LinkEndChild (new TiXmlText ("ACTGCC")); 
  // Sequence 2
  sequence = new TiXmlElement ("Sequence");
  locus->LinkEndChild (sequence);
  sequence->SetAttribute("IndividualID", 2);
  sequence->LinkEndChild (new TiXmlText ("TAATCC")); 

  // RecombinantTrees
  TiXmlElement * recombinantTrees = new TiXmlElement ("RecombinantTrees");
  root->LinkEndChild (recombinantTrees);
  recombinantTrees->SetAttribute("Number", 1);
  // RecombinantTree
  recombinantTree = new TiXmlElement ("RecombinantTree");
  recombinantTrees->LinkEndChild (recombinantTree);
  recombinantTree->SetAttribute("Length", 10000);
  // Local tree 1
  localTree = new TiXmlElement ("LocalTree");
  recombinantTree->LinkEndChild (localTree);
  localTree->SetAttribute("Position", 1);
  localTree->LinkEndChild (new TiXmlText ("(((1.1:2626, (3.1:61, 2.1:61):2565):16635, 5.1:19261):29956, 4.1:49217);")); 
  // Local tree 2
  localTree = new TiXmlElement ("LocalTree");
  recombinantTree->LinkEndChild (localTree);
  localTree->SetAttribute("Position", 37);
  localTree->LinkEndChild (new TiXmlText ("(((1.1:2626, (3.1:61, 2.1:61):2565):16635, 5.1:19261):19792, 4.1:39053);")); 
  // Local tree 3
  localTree = new TiXmlElement ("LocalTree");
  recombinantTree->LinkEndChild (localTree);
  localTree->SetAttribute("Position", 215);
  localTree->LinkEndChild (new TiXmlText ("(((1.1:2626, (3.1:61, 2.1:61):2565):16635, 5.1:19261):19792, 4.1:39053);")); 
  doc.SaveFile (f);
}
void
CmdLikelihood::report ()
{
}
}
@
\subsection{Event}
Coalescent, migration, recombination, and population structure changes affect
the structure of a recombinant tree, which consists of events. 

Coalescent events have two up nodes and one down node. A coalescent event
creates an edge. Time is at the top of the edge.

Migration events have one up node and one down node. The up node is the source,
and the down node is the destination. Note that this is backward in time. Time
is at the start of the edge. 

Recombination events have one up node and two down nodes. Edges from
recombination events have one up node, and still one down node. Time is at the
top of the edge. 

Consider two kinds of situations. I could build a tree from samples. Or, I could
add a recombinant edge to a partial tree. When I build a tree using samples,
events are incrementally constructed: coalescent events create new down edges,
recombination events create new pairs of down edges, and migrations change
configuration of lineages in population structure. Population structure changes
population labels of many of edges. Do I have to have separate edges when
population structure changes? Let's do this.
The final coalescent event is done when all of active links are exhausted.
How can I build a de novo gene tree? Recombination events can happen at any
point between active links. Full active lineages can coalesce. There are no
partial active or inactive lineages. Every lineage is an active lineage. I only
allow coalescent between lineages that share links. This is one of SMC
approximation. 
In the setting of full and partial recombinant trees, I have full and partial
active lineages, and inactive lineages. 

In the first setting, I start with a sample of genes at the top of a recombinant
tree. When coalescent events occur, I remove two edges in a population and add a
new edge. The top of the new edge is designated by a coalescent event. When
recombination events occur, I remove one edge and create two new edges in the
same population. When miration events happen, I remove the edge and create a new
one in a different population. When population structure changes, I change
labels of all of the edges that enter new populations. 
During this time I need to consider which coalescent events are impossible with
respect to infinite sites data.

How to sort events in time?

Event::makeCoalescent (UDBL \_t, Edge* \_left, Edge* \_right, Edge* \_down)
A given event becomes a coalescent.

Event::makeRecombination (UDBL \_t, Edge* \_up, Edge* \_down, UINT \_b)
A given event becomes a recombination.

EventList::addEdge (Edge* \_e)
A recombinant tree consists of edges. The edges are stored in [[mEdge]] of
[[Tree]]. Using edges I create a list of events. At the top of an edge is the
time of an event that creates the edge. A coalescent event would create an edge
after the event. A recombination event would create two edges. I just use the
left edge to add the event. A migration event would also create an edge.
A splitting event would create many edges. I would use one edge of them.
Consider those edges as ``migration event'' from descendent population to its
ancestor.
<<imrEvent.h>>=
<<imr gnu copyright>>
#ifndef _IMREVENT_H_
#define _IMREVENT_H_
#include <vector>
#include <cassert>
#include "tinystr.h"
#include "tinyxml.h"
#include "imrEdge.h"
#include "imrType.h"
using namespace std;
namespace imr {
class Event {
  private:
    UINT mB;
  public:
    UDBL mT;
    Edge* mLeft; // mUp
    Edge* mRight;
    Edge* mDownLeft; // mDown
    Edge* mDownRight;
  public:
    Event();
    ~Event();
    Event (UDBL _t, Edge* _left, Edge* _right, Edge* _down);
    Event (UDBL _t, Edge* _up, Edge* _downLeft, Edge* _downRight, UINT _b);
    void makeCoalescent (UDBL _t, Edge* _left, Edge* _right, Edge* _down);
    void makeRecombination (UDBL _t, Edge* _up, Edge* _downLeft, Edge* _downRight, UINT _b);
    void print ();
    bool isCoalescent ()
    {
      if (mLeft != NULL && mRight != NULL 
          && mDownLeft != NULL && mDownRight == NULL)
        return true;
      else
        return false;
    }
    bool isRecombination ()
    {
      if (mLeft != NULL && mRight == NULL 
          && mDownLeft != NULL && mDownRight != NULL)
        return true;
      else
        return false;
    }
    void printXml (TiXmlElement* root);
};
class EventList {
  private:
    vector<Event*> mL;
    UINT mLPosition;
  public:
    EventList();
    ~EventList();
    void addEdge (Edge* _e);
    void addCoalescent (UDBL _t, Edge* _left, Edge* _right, Edge* _down);
    void addRecombination (UDBL _t, Edge* _up, Edge* _downLeft, Edge* _downRight, UINT _b);
    void addMigration (UDBL _t, Edge* _up, Edge* _down);
    void addSplit ();
    void sort ();
    void print ();
    void reset ();
    Event* getEvent (UINT i)
    {
      assert (i < mL.size());
      return mL[i];
    }
    UINT getSize ()
    {
      return mLPosition;
    }
    void printXml (TiXmlElement* root);
};
}
#endif // _IMREVENT_H_
<<imrEvent.cpp>>=
<<imr gnu copyright>>
#include <iostream>
#include <algorithm>
#include <vector>
#include <cassert>
#include "imrCommon.h"
#include "imrType.h"
#include "imrEvent.h"
using namespace std;
namespace imr {
struct EventCompare {
  bool operator() (Event* i, Event* j) { return (i->mT < j->mT); }
} eventCompare;
Event::Event()
  : mLeft(NULL), mRight(NULL), 
    mDownLeft(NULL), mDownRight (NULL),
    mT(-1), mB(0)
{
}
Event::~Event()
{
}
Event::Event (UDBL _t, Edge* _left, Edge* _right, Edge* _down)
  : mT(_t), mLeft(_left), mRight(_right), mDownLeft(_down), mDownRight(NULL), mB(0)
{
}
Event::Event (UDBL _t, Edge* _up, Edge* _downLeft, Edge* _downRight, UINT _b)
  : mT(_t),  mB(_b),
    mLeft(_up), mRight(NULL), 
    mDownLeft(_downLeft), mDownRight(_downRight)
{
}
void 
Event::makeCoalescent (UDBL _t, Edge* _left, Edge* _right, Edge* _down)
{
  mT = _t;
  mLeft = _left;
  mRight = _right;
  mDownLeft = _down;
  mDownRight = NULL;
  mB = 0;
}
void 
Event::makeRecombination (UDBL _t,
                          Edge* _up,
                          Edge* _downLeft,
                          Edge* _downRight,
                          UINT _b)
{
  mT = _t;
  mLeft = _up;
  mRight = NULL;
  mDownLeft = _downLeft;
  mDownRight = _downRight;
  mB = _b;
}
void
Event::print ()
{
  if (mLeft != NULL && mRight == NULL 
      && mDownLeft != NULL && mDownRight != NULL)
    {
      cout << "Recombination at " << mT << ", (" << mB << ") "
           << "left: " << mLeft->mId + 1
           << ", downLeft: " << mDownLeft->mId + 1
           << ", downRight: " << mDownRight->mId + 1
           << endl;
    }
  else if (mLeft != NULL && mRight != NULL 
           && mDownLeft != NULL && mDownRight == NULL)
    {
      cout << "Coalescent at " << mT << ", "
           << "left: " << mLeft->mId + 1
           << ", right: " << mRight->mId + 1
           << ", downLeft: " << mDownLeft->mId + 1
           << endl;
    }
  else
    {
      cout << "Event time at " << mT << " (" << mB << ")" << endl;
    }
}
EventList::EventList()
  : mLPosition(0)
{
}
EventList::~EventList()
{
  for (vector<Event*>::iterator it = mL.begin(); it != mL.end(); it++)
    {
      delete *it;
    }
}

void 
EventList::addCoalescent (UDBL _t, Edge* _left, Edge* _right, Edge* _down)
{
  Event* e;
  if (mLPosition < mL.size())
    {
      e = mL[mLPosition++];
      e->makeCoalescent (_t, _left, _right, _down);
    }
  else
    {
      e = new Event(_t, _left, _right, _down);
      mL.push_back(e);
      mLPosition = mL.size();
    }
}
void 
EventList::addRecombination (UDBL _t,
                             Edge* _up, 
                             Edge* _downLeft, 
                             Edge* _downRight, 
                             UINT _b)
{
  Event* e;
  if (mLPosition < mL.size())
    {
      e = mL[mLPosition++];
      e->makeRecombination (_t, _up, _downLeft, _downRight, _b);
    }
  else
    {
      e = new Event(_t, _up, _downLeft, _downRight, _b);
      mL.push_back(e);
      mLPosition = mL.size();
    }
}
void 
EventList::addMigration (UDBL _t, Edge* _up, Edge* _down)
{
  assert (0);
}

void 
EventList::addSplit ()
{
  assert (0);
}
void 
EventList::sort ()
{
  std::sort (mL.begin(), mL.end(), eventCompare);  
}
void 
EventList::print ()
{
  cout << "EventList" << endl;
  for (vector<Event*>::iterator it = mL.begin(); it != mL.end(); it++)
    {
      (*it)->print();
    }
}
void 
EventList::reset ()
{
  mLPosition = 0;
}
void 
EventList::addEdge (Edge* _e)
{
  if (_e->isLeaf())
    {
      return;
    }

  Event* e;
  if (mLPosition < mL.size())
    {
      e = mL[mLPosition++];
      if (_e->isCoalescent())
        {
          e->makeCoalescent (_e->mT, _e->mLeft, _e->mRight, _e);
        }
      else if (_e->isRecombination())
        {
          Edge* downSister = _e->mLeft->mDownRight;
          if (_e == downSister)
            {
              return;
            }
          UINT b = _e->mB;
          e->makeRecombination (_e->mT, _e->mLeft, _e, downSister, b);
        }
      else
        {
          assert (0);
        }
    }
  else
    {
      if (_e->isCoalescent())
        {
          e = new Event(_e->mT, _e->mLeft, _e->mRight, _e);
        }
      else if (_e->isRecombination())
        {
          Edge* downSister = _e->mLeft->mDownRight;
          if (_e == downSister)
            {
              return;
            }
          UINT b = _e->mB;
          e = new Event(_e->mT, _e->mLeft, _e, downSister, b);
        }
      else
        {
          _e->print();
          assert (0);
        }
      mL.push_back(e);
      mLPosition = mL.size();
    }
}
void 
Event::printXml (TiXmlElement* _events)
{
  TiXmlElement* event = new TiXmlElement ("Event");
  _events->LinkEndChild (event);
  event->SetDoubleAttribute("time", mT);
  if (isCoalescent())
    {
      event ->SetAttribute("type", "coalescent");
      event ->SetAttribute("left", mLeft->mId);
      event ->SetAttribute("right", mRight->mId);
      event ->SetAttribute("down", mDownLeft->mId);
    }
  else if (isRecombination())
    {
      event ->SetAttribute("type", "recombination");
      event ->SetAttribute("up", mLeft->mId);
      event ->SetAttribute("downleft", mDownLeft->mId);
      event ->SetAttribute("downright", mDownRight->mId);
      event ->SetAttribute("breakpoint", mB);
    }
}
void 
EventList::printXml (TiXmlElement* _rectree)
{
  for (vector<Event*>::iterator it = mL.begin(); it != mL.end(); it++)
    {
      (*it)->printXml(_rectree);
    }
}
    
}
@
\section{Manuscript}
@
\pagebreak{}

\addcontentsline{toc}{section}{References}
\bibliographystyle{imr}
\bibliography{imr}

\end{document}

Some sites
http://ooc-lang.org
github 
http://www.parrot.org
http://rakudo.org
