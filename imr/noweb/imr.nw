\documentclass{article}
\usepackage{noweb}
\usepackage{fancyvrb}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage[authoryear]{natbib}
\setlength{\pdfpagewidth}{\paperwidth}
\setlength{\pdfpageheight}{\paperheight}
\pagestyle{noweb}
\begin{document}

\title{Isolation, Migration, and Recombination Model}
\author{Sang Chul Choi\\
Dept.\ of Genetics, Rutgers University,\\
Piscataway, NJ 08854,\\
Dept.\ of Biological Statistics & Computational Biology, Cornell University,\\
Ithaca, NY 14853}

\maketitle

\tableofcontents

\newpage{}
\section{History}
\begin{enumerate}
\item Wed Mar  3 12:24:01 EST 2010: I started to code recombinant trees.
\end{enumerate}

\newpage{}

\section{Installation}
Build a debug version using CMake.
\begin{Verbatim}[frame=lines,framesep=5mm]
$ cd src/imr/src
$ mkdir debug
$ cd debug
$ cmake .. -DCMAKE_BUILD_TYPE:STRING=Debug
\end{Verbatim}

\newpage{}
\section{Overview of IMR}
\subsection{To Do}
\begin{enumerate}
\item Specify the XML input/output file format, and code it using tinyXML.
\item Code the recombinant tree parameter.
\item Code the species tree parameter.
\item Build an initial recombinant tree using Gusfield2004 method.
\item Recode the computation of prior of recombinant trees.
\item Code the update of splitting time using Rannala2003 method.
\item Code the update of recombinant branches using Kuhner2000 method.
\item Code the update of migration events using Beerli1999 method.
\item Use fastsimcoal or Excoffier2011 method to simulate data and test it.
\item Find examples with long sequences to work with.
\item Write a manuscript.
\item Publish the code with the submission of the manuscript.
\end{enumerate}

\subsection{Features of IMR}
We present the features developed during the development of IMR.
All test data sets and command lines are provided in each of subsections that
follow.
\begin{enumerate}
\item A single population model of IMR, and
\item Two-population demographics.
\end{enumerate}

\paragraph{sim2 run ima2 with assignment single}
This is IMa2 command line options for two population.

<<sim trueassignment>>=
function seqn {
  a=""
  for (( c=1; c<=$1; c++ ))
  do
    a=$a$2
  done
  echo $a
}
<<sim set param gmax>>=
gmax=50
<<sim st>>=
ST=/home/goshng/Documents/Projects/IMamp/build/src/uncertainty
<<sim delete and create structurama>>=
rm -rf structurama
mkdir structurama
<<sim2 variables>>=
q1=1.0
q2=1.0
qa=1.0
m1=0.0
m2=0.0
t=0.25
n1=20
n2=20
l=4
gmax=50
lmax=10
<<s2 set param>>=
q1=1.0
q2=1.0
qa=1.0
m1=0.1
m2=0.1
t=0.10
n1=20
n2=20
gmax=50
lmax=10
<<sim2 set input file>>=
fname=s2-q1_$q1-q2_$q2-qa_$qa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_$g 
<<sim2 simulate simdiv>>=
$SIMDIV -odata/$fname.dat -s$RANDOM -uI -L$l q1$q1 -q2$q2 -qa$qa -m1$m1 -m2$m2 -t$t -n1$n1 -n2$n2 -j4
<<sim put structurama batch command>>=
echo "wine ~/bin/Structurama.exe < $fname.bat" >> structurama.bat
<<sim convert im to nexus>>=
perl im2nexus.pl --in=data/$fname.dat > structurama/$fname.in
<<sim delete and create R>>=
rm -rf R
mkdir R
<<sim bash>>=
#!/bin/bash
<<sim simdiv>>=
SIMDIV=simdiv
<<sim delete and create data>>=
rm -rf data
mkdir data
<<sim delete and create log output>>=
rm -rf log
mkdir log
rm -rf output
mkdir output
<<sim calc>>=
CALC=/home/goshng/bin/calc
<<sript calc>>=
#!/bin/bash
echo "scale=3; $1" | bc ;exit
<<sim2 run simdiv with j>>=
$SIMDIV -odata/$fname.dat -s$r -uI -L$l q1$q1 -q2$q2 -qa$qa -m1$m1 -m2$m2 -t$t -n1$n1 -n2$n2 -j4
<<sim2 run simdiv>>=
$SIMDIV -odata/$fname.da2 -s$r -uI -L$l q1$q1 -q2$q2 -qa$qa -m1$m1 -m2$m2 -t$t -n1$n1 -n2$n2
<<sim structurama batch>>=
echo "execute $fname.in" > structurama/$fname.bat
echo "model numpops=2" >> structurama/$fname.bat
echo mcmc Printfreq=100000 >> structurama/$fname.bat
echo sum burnin=10000 >> structurama/$fname.bat
echo quit >> structurama/$fname.bat
<<sim ima2>>=
IM=/home/goshng/compile/IMamp/build/src/IMa2
<<sim2 run ima2 with assignment>>=
$IM -i$BASEDIR/data/$fname.dat \
    -o$BASEDIR/output/$fname.out \
    -a1 \
    -q10.0 -m1.0 -t4.0 -s$RANDOM \
    -hfg -hn10 -hk5 -ha0.96 -hb0.9 \
    -b30000 -l3000 -d20 -z100000 \
    -x$tasn
<<sim2 run ima2>>=
$IM -i$BASEDIR/data/$fname.da2 \
    -o$BASEDIR/output/$fname.ou2 \
    -q10.0 -m1.0 -t4.0 -s$RANDOM \
    -hfg -hn10 -hk5 -ha0.96 -hb0.9 \
    -b30000 -l3000 -d20 -z100000 
<<sim2 run ima2 with assignment single>>=
# option for -a has changed; it used to be -a137
$IM -i$BASEDIR/data/$fname.dat \
    -o$BASEDIR/output/$fname.out \
    -a1 -q3.0 -m1.0 -t3.0 -s$RANDOM \
    -b300000 -l3000 -d100 -z100000 \
    -x$tasn
<<sim2 set trueassignment>>=
ta=`seqn $n1 1`
tb=`seqn $n2 2`
tasn=$ta$tb

@
\subsubsection{Simulation 1}
Simulation 1. The number of loci affects the accuracy of assignment.
We set all $\theta$'s to 1, $t/4N$ to 0.1, and $4Nm$ to 0.1. We
sampled 20 haploid individuals from each population, totaling 40 genes
for each locus. We increased numbers of loci to assess the impact
of larger data on the accuracy of inference of assignment. The number
of loci varied from 1 to 10, each repeated with 50 replicates. We
generated data sets under infinitely many sites model. The distance
of mean assignment and true assignment measures the accuracy of assignment
inference. The worst estimate results in 20 of assignment distance
from the true assignment. Each run of MCMC was carried out with 300,000
of burnin followed by 300,000 of generations. Posterior samples of
assignments were thinned with 100, which gave 3,000 of samples. A
uniform prior of range between 0 and 10 was used for population mutation
rates $\theta$. A uniform prior of range between 0 and 1 was for population
migration rates $M$. Maximum of uniform prior for split time $T$ was 3.

\paragraph{s2-sim.sh}
It will generate the data set for Simulation 1. It is a bash script. 
Chunk [[s2 set param]] that is called before any parameters are used 
set the parameters.
We have 6 parameters, [[q1]], [[q2]], [[qa]], [[m1]], [[m2]], and [[t]].
From populations 1 and 2, [[n1]] and [[n2]] of genes are sampled, respectively.
We repeat the simulation [[gmax]] times. We vary the number of loci upto
[[lmax]].
It is a bash script, [[sim bash]]. It uses [[simdiv]], [[sim simdiv]]. When the
script is executed, it deletes and creates a subdirectory named [[data]], chunk
[[sim delete and create data]]. The script variable [[RANDOM]] is set to a seed,
and we can use it to generate a very simple random integer. This must be good
enough to generate data that can be generated later. There are two for-loops:
one for number of loci, and the other for number of repetitions. A file name is
created using parameters that were set: [[fname]]. We use [[simdiv]] to put
simulated data in the file, [[fname]]. We simulate infinite sites data.

\paragraph{s2-structurama.sh}
We convert all the data files generated by [[s2-sim.sh]] so that STRUCTURAMA can
read in them. We convert the files using [[im2nexus.pl]] perl script. A batch
file, [[sfile]], is created to execute STRUCTURAMA with all the converted data
sets. We change the directory to [[structurama]] after we run the script
[[s2-structurama.sh]], and execute [[sfile]] to run STRUCTURAMA for all the data
sets. [[sfile]] contains a list of STRUCTURAMA commands. Each command requires
another batch file for STRUCTURAMA. STRUCTURAMA can read a list of its own
commands to infer assignment. [[bfile]] contains STRUCTURAMA commands. We need
two files for a STRUCTURAMA run: data and command batch files. 

\paragraph{s2-structurama-summary.sh}
We can summarize the output files from STRUCTURAMA. 

\paragraph{s2.sh}
It is a master script that calls all jobs in the cluster. A job is submitted
based on the number of loci. We submit as many jobs as maximum number of loci.
We delete and create two subdirectories: [[log]] and [[output]]. We only need
[[lmax]]. [[s2-ima.sh]] does the actual jobs of running [[IMa2]].

\paragraph{s2-ima.sh}
We run [[IMa2]] [[gmax]] times. 

\paragraph{s2-stat.sh}
We generate R script and its data files. We run the R script to draw the
boxplots for the first simualtion figure. This needs more comment.

\paragraph{s2-man.sh}
We now have resulting data to show the file.

\begin{Verbatim}[frame=lines,framesep=5mm]
$ cd run/s2
$ no s2-sim.sh
$ bash s2-sim.sh
$ scp -r data operon:run/s2/
$ no s2.sh
$ no s2-ima.sh
$ scp s2*sh operon:run/s2/
$ ssh operon
$ wcd s2
$ bash s2.sh
$ exit
$ no s2-structurama.sh
$ cd structurama
$ split -l 250 structurama.bat <divide it so that we can run as many jobs>
$ bash xa* (?)
$ no s2-structurama-summary.sh
$ bash s2-structurama-summary.sh
$ <wait for a day>
$ scp -r operon:run/s2/output .
$ no s2-stat.sh
$ bash s2-stat.sh im
$ mkdir st
$ cd st
$ ln -s ../structurama output
$ bash ../s5-stat.sh st
$ cd ../R
$ cat l.txt ../st/R/l.txt > ll.txt
$ <Edit ll.txt to remove a second head>
$ paste l.txt ../st/R/l.txt > t.txt
$ <Edit t.txt to append st>
$ R --no-save < ll.R
\end{Verbatim}

<<s2-sim.sh>>=
<<sim bash>>
<<sim simdiv>>
<<sim delete and create data>>
<<sim delete and create structurama>>
<<sim2 variables>>
<<s2 set param>>
rm -rf structurama.bat
RANDOM=1
for l in `seq $lmax`
do
  for g in `seq $gmax`
  do
  <<sim2 set input file>>
  <<sim2 simulate simdiv>>
  <<sim convert im to nexus>>
  <<sim put structurama batch command>>
  <<sim structurama batch>>
  done
done

mv structurama.bat structurama
echo "Run bash $sfile after changing directory to structurama"

<<s2-structurama-summary.sh>>=
<<sim bash>>
<<sim st>>
<<sim trueassignment>>
<<sim2 variables>>
<<s2 set param>>
<<sim2 set trueassignment>>

for l in `seq $lmax`
do
  for g in `seq $gmax`
  do
  <<sim2 set input file>>
  $ST structurama/$fname 10001 $tasn
  done
done

<<s2.sh>>=
<<sim bash>>
<<sim delete and create log output>>
<<s2 set param>>
RANDOM=1
for l in `seq $lmax`
do
  qsub -o log/$l.out -e log/$l.err -cwd s2-ima.sh $l $RANDOM
done

<<s2-ima.sh>>=
<<sim bash>>
<<sim ima2>>
<<sim trueassignment>>
BASEDIR=/home/goshng/run/s2
<<s2 set param>>
l=$1
RANDOM=$2
<<sim2 set trueassignment>>
for g in `seq $gmax`
do
  <<sim2 set input file>>
  <<sim2 run ima2 with assignment single>>
done

<<s2-stat.sh>>=
<<sim bash>>
<<sim calc>>
<<sim delete and create R>>
<<s2 set param>>
model=$1
gmax1=`$CALC $gmax-1`

rfile=R/l.R
rdata=R/l.txt
printf "pdf (\"R/l.pdf\")\n" > $rfile

printf "x <- read.table (\"$rdata\", head=T)\n" >> $rfile
printf "boxplot (d ~ nloci, data=x, main=\"t/q: $t, m: $m\", ylim=c(0,20), xlab=\"q\")\n" >> $rfile

printf "nloci\ttotald\taveraged\tnormalized\tvarianced\tsquared\tmeansquared\td\tmodel\n" >> $rdata

for l in `seq $lmax`
do

  TMPFILE=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1
  for i in `seq $gmax1`
  do
  printf "$l\t" >> $TMPFILE
  done
  printf "$l\n" >> $TMPFILE

  paste output/s2-q1_$q1-q2_$q2-qa_$qa-m1_$m1-m2_$m1-t_$t-l_$l-n1_$n1-n2_$n2-g_*.sum >> $TMPFILE
  for i in `seq $gmax1`
  do
  printf "$model\t" >> $TMPFILE
  done
  printf "$model\n" >> $TMPFILE



  transpose $TMPFILE >> $rdata

  unlink $TMPFILE
done

printf "dev.off()\n" >> $rfile

R --no-save < $rfile

<<s2-structurama.sh>>=
#!/bin/bash
ST=/home/goshng/Documents/Projects/IMamp/src/st

rm -rf structurama
mkdir structurama

sfile=structurama.bat
rm -f $sfile

<<s2-fixed>>
<<s3-trueassignment>>

m1=0.1
m2=0.1
t=0.10

ta=`seqn $n1 1`
tb=`seqn $n2 2`
tasn=$ta$tb

for l in `seq $lmax`
do
for g in `seq $gmax`
do

fname=s2-q1_$theta1-q2_$theta2-qa_$thetaa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_$g 

perl im2nexus.pl --in=data/$fname.dat > structurama/$fname.in
#$ST structurama/$fname $tasn

bfile=structurama/$fname.bat

echo "wine ~/bin/Structurama.exe < $fname.bat" >> $sfile

echo "execute $fname.in" > $bfile
echo "model numpops=2" >> $bfile
echo mcmc Printfreq=100000 >> $bfile
echo sum >> $bfile
echo quit >> $bfile

done

mv $sfile structurama
echo "Run bash $sfile after changing directory to structurama"

<<ll.R>>=
x <- read.table ("ll.txt", head=T)

pdf("7.pdf")
boxplot (d ~ nloci, ylim=c(0,25), boxwex=0.25, data=x, at=1:10 - 0.2, subset = model == "im",
col="gray", axes=F, xlab="Number of loci", 
ylab="Distance from true assignment", cex=0.5)
boxplot (d ~ nloci, boxwex=0.25, data=x, at=1:10 + 0.2, subset = model == "st",
col="white", add=TRUE, axes=F, cex=0.5)
axis (1, 1:10)
axis (2, c(0,5,10,15,20))
box ()
legend (6, 25, c("IM", "STRUCTURAMA"), fill=c("gray", "white"))
dev.off()

postscript ("7.eps", width=5, height=5, paper="special", horizontal = FALSE)
par (mar=c(4,4,0.2,0.2))
boxplot (d ~ nloci, ylim=c(0,25), boxwex=0.25, data=x, at=1:10 - 0.2, subset = model == "im",
col="gray", axes=F, xlab="Number of loci", 
ylab="Distance from true assignment", cex=0.5)
boxplot (d ~ nloci, boxwex=0.25, data=x, at=1:10 + 0.2, subset = model == "st",
col="white", add=TRUE, axes=F, cex=0.5)
axis (1, 1:10)
axis (2, c(0,5,10,15,20))
box ()
legend (6, 25, c("IM", "STRUCTURAMA"), fill=c("gray", "white"))
dev.off()

x <- read.table ("t.txt", head=T)
t.test(x$d, x$st.d,paired=T)


@
\subsubsection{Simulation 2}
Simulation 2. Split time and migration rates vary. We kept the size
of three populations the same. We varied population mutation rates
with 0.5, 1.0, and 2.0. Population migration rates of both directions
were equal. We varied $4Nm$ from 0.0, 0.1, to 1.0. We changed $t/4N$
from 0.05, 0.10, to 0.20. We sampled 20 gene copies from each of contemporary
populations 1 and 2 with 4 times, which resulted in 4 loci data sets.
We simulated data sets under infinitely many sites models with the
27 settings of parameters with 50 replicates. We computed distances
between true assignment and estimates for each of data sets of size
1,350. We used the distance of mean and true assignments for assessing
the accuracy of assignment inference. 
We ran MCMC chains with the same setup of length and priors as in Simulation 1
except for maximum of uniform prior of split time $T$ being set to 10 not 3.

\paragraph{s5-sim.sh}
We simulate data sets of size 50 for 27 different parameter sets. 

\paragraph{s5-structurama.sh}

\paragraph{s5-structurama-summary.sh}

\paragraph{s5.sh}

\paragraph{s5-stat.sh}

\paragraph{s5-test.R}

\begin{Verbatim}[frame=lines,framesep=5mm]
$ cd run/s5
$ no s5-sim.sh
$ bash s5-sim.sh
$ scp -r data operon:run/s5/
$ no s5.sh
$ no s5-ima.sh
$ scp s5*sh operon:run/s5/
$ ssh operon
$ wcd s5
$ bash s5.sh
$ exit
$ no s5-structure.sh
$ cd structurama
$ split -l 250 structurama.bat <divide it so that we can run as many jobs>
$ bash xa* (?)
$ <wait for a day>
$ scp -r operon:run/s5/output .
$ no s5-stat.sh
$ bash s5-stat.sh
$ bash s5-structurama-summary.sh
$ mkdir st
$ cd st
$ ln -s ../structurama output
$ bash ../s5-stat.sh
$ cd ..
$ paste R/qtm.txt st/R/qtm.txt > table3.txt 
\end{Verbatim}

<<s5 parameters loop begin>>=
for q in 0.5 1.0 2.0
do
for tq in 0.05 0.10 0.20
do
for qm in 0.0 0.1 1.0
do

<<s5 parameters loop end>>=
done
done
done

<<s5-sim.sh>>=
<<sim bash>>
<<sim simdiv>>
<<sim delete and create data>>
<<sim delete and create structurama>>
<<sim2 variables>>
rm -rf structurama.bat
RANDOM=5
<<s5 parameters loop begin>>
for g in `seq $gmax`
do
  t=`calc $tq*$q`
  m=`calc $qm/$q`
  m1=$m
  m2=$m
  q1=$q
  q2=$q
  qa=$q
  <<sim2 set input file>>
  <<sim2 simulate simdiv>>
  <<sim convert im to nexus>>
  <<sim put structurama batch command>>
  <<sim structurama batch>>
done
<<s5 parameters loop end>>

mv $sfile structurama
echo "Run bash $sfile after changing directory to structurama"

<<s5-structurama-summary.sh>>=
<<sim bash>>
<<sim st>>
<<sim calc>>
<<sim progress>>
<<sim trueassignment>>
<<sim2 variables>>
<<sim2 set trueassignment>>

ntotal=`$CALC 3*3*3*$gmax`
nincrease=0
npercent=0

<<s5 parameters loop begin>>
for g in `seq $gmax`
do
  t=`calc $tq*$q`
  m=`calc $qm/$q`
  m1=$m
  m2=$m
  q1=$q
  q2=$q
  qa=$q
  <<sim2 set input file>>
  $ST structurama/$fname 10001 $tasn
  nincrease=`$CALC $nincrease+1`
  npercent=`$CALC $nincrease/$ntotal*100`
  npercent=$(printf %.0f $npercent)
  nbar=`progressn $npercent 100 \#`
  echo -ne "$nbar ($npercent%)\r"
done
<<s5 parameters loop end>>
echo -ne '\n'

<<sim progress>>=
function progressn {
  aspace="-"
  a=""
  for (( c=1; c<=$1; c++ ))
  do
    a=$a$3
  done

  for (( c=$1; c<=$2; c++ ))
  do
    a=$a$aspace
  done

  echo $a
}

<<s5.sh>>=
<<sim bash>>
<<sim delete and create log output>>
RANDOM=5
<<s5 parameters loop begin>>
t=`calc $tq*$q`
m=`calc $qm/$q`
qsub -o log/$m.out -e log/$m.err -cwd s5-ima.sh $RANDOM $theta $t $m
<<s5 parameters loop end>>

@
The -a option used to be 137.
<<s5-ima.sh>>=
<<sim bash>>
<<sim ima2>>
BASEDIR=/home/goshng/run/s5
<<sim2 variables>>
<<sim trueassignment>>
RANDOM=$1
q1=$2
q2=$2
qa=$2
t=$3
m1=$4
m2=$4
<<sim2 set trueassignment>>
for g in `seq $gmax`
do
  <<sim2 set input file>>
$IM -i$BASEDIR/data/$fname.dat \
    -o$BASEDIR/output/$fname \
    -a1 -q10.0 -m1.0 -t10.0 -s$RANDOM \
    -b300000 -l3000 -d100 -z100000 \
    -x$tasn
done

<<s5-stat.sh>>=
<<sim bash>>
<<sim2 variables>>
gmax=`calc $gmax-1`
<<sim delete and create R>>

function plotq {

  rfile=q.R
  printf "pdf (\"q.pdf\")\n" > $rfile
  printf "par(mfrow=c(3,3))\n" >> $rfile
  printf "figurename = c('A','B','C','D','E','F','G','H','I')\n" >> $rfile
  printf "figurenamei <- 1\n" >> $rfile

  for tq in 0.05 0.10 0.20
  do
  for qm in 0.0 0.1 1.0
  do


  rdata=R/q-t_$tq-m_$qm.txt
  printf "x <- read.table (\"$rdata\", head=T)\n" >> $rfile
  printf "boxplot (d ~ a, data=x, main=figurename[figurenamei], ylim=c(0,20), xlab=\"q\")\n" >> $rfile
  printf "figurenamei <- figurenamei + 1\n" >> $rfile
  #printf "boxplot (d ~ a, data=x, main=\"t/q: $tq, qm: $qm\", ylim=c(0,20), xlab=\"q\")\n" >> $rfile

  printf "a\ttotald\taveraged\tnormalized\tvarianced\tsquared\tmeansquared\td\n" > $rdata

  for q in 0.5 1.0 2.0
  do
    t=`calc $tq*$q`
    m=`calc $qm/$q`
    TMPFILE=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1
    for i in `seq $gmax`
    do
    printf "$q\t" >> $TMPFILE
    done
    printf "$q\n" >> $TMPFILE

    paste output/s2-q1_$q-q2_$q-qa_$q-m1_$m-m2_$m-t_$t-l_4-n1_20-n2_20-g_*.sum >> $TMPFILE
    transpose $TMPFILE >> $rdata
    unlink $TMPFILE
  done

  done
  done

  printf "dev.off()\n" >> $rfile

  R --no-save < $rfile
}

plotq

<<s5-test.R>>=
getmedian <- function (fname)
{
  x <- read.table (fname, head=T)

  d <- c()
  for (q in unique (x$q))
  {
    for (tq in unique (x$tq))
      {
        for (qm in unique (x$qm))
          {
            y <- x$d[x$q == q & x$tq == tq & x$qm ==qm]
            d <- c(d, median (y))
          }
      }
  }
  d
}

d <- getmedian ("R/qtm.txt")
d1 <- getmedian ("st/R/qtm.txt")
wilcox.test (d, d1, alternative="less")

@
\subsubsection{Simulation 3}
Simulation 3. Assignment and demographic parameters are jointly estimated.
Population 1 is of size 1, 2 is of size 3, and ancestor is of size
2. We set no migrations. We varied $t/4N_{A}$ from 0.05, 0.10, to
0.20. We sampled 20 gene copies from each of two present-day populations
with 4 times for 4 independent loci. We replicated 100 times. We ran
10 chains of MC$^{3}$ with swap frequency of 5 and $\beta_{i}$ being\[
1-\frac{(1-h_{b})\times i\times h_{a}^{10-1-i}}{10-1}\]
where $h_{a}=0.96$ and $h_{b}=0.9.$ Uniform prior of population
size is of range $(0,10)$, uniform prior of migration rate is of
$(0,1)$, and uniform prior of split time is of $(0,4).$ After a
burnin generations of 30,000, we sampled genealogies and assignments
of 3,000 with a thinning interval of 20. We ran IM with assignment
fixed to the true assignment. We compared two sets of demographic
parameter estimates, one from IMa with assignment variable and another
from IMa with assignment fixed to true.

\paragraph{sim bash}
All bash script starts with this bash directive. I use [[bash]] command to run
bash scripts and the directive is for indicating that the file is a bash script.

\paragraph{sim calc}
[[calc]] is a very small script that allows bash script users to calculate
simple algebraic equation of arbitrary precision numbers. It uses [[bc]]
command. Because [[calc]] is not a standard command, cluster nodes may not know
where and what it is. 

\paragraph{s3-sim.sh}
[[s3-sim.sh]] creates [[IMa]] input files and places them into [[data]]
directory. We have a number of parameters for the simulation: 
[[q1]], [[q2]], [[qa]], [[m1]], [[m2]], [[t]], [[n1]], [[n2]], [[l]],
[[gmax]], and [[lmax]] (refer to chunk [[sim2 variables]]).
Each simulated data file is generated with a random seed. To repeat a whole
simulation we generate those random seeds from [[BASH]] with a given value being
set to [[RANDOM]] environment variable.
It also creates STRUCTURAMA input and batch files.

\paragraph{sim2 run simdiv with j}
\paragraph{sim2 run simdiv}
We need all parameters for two-population [[IMa]] simulation: [[fname]], [[r]],
[[l]], [[q1]], [[q2]], [[qa]], [[m1]], [[m2]], [[t]], [[n1]], and [[n2]]. The
option [[j]] being 4 allows to generate an input file for [[IMa]] with
assignment. Without [[j]] option, it generates an input file for [[IMa]] without
assignment.

\paragraph{sim structurama batch}
We have not yet convert [[IMa]] input files to [[STRUCTURAMA]]'s. To run
[[STRUCTURAMA]] in a batch mode a batch file is required. We could have put all
command lines in a single batch file if [[STRUCTURAMA]] did not crash. It runs
more smoothly when we run it with a batch file with a single job not many
multiple jobs. We create a batch file for each of [[IMa]] input files.
Note that [[fname]] is the variable for the name of an [[IMa]] input file.
We should place structurama infput and batch files on a subdirectory named
[[structurama]]. Wait! Simulation 3 does not involve STRUCTURAMA.

\paragraph{s3.sh}

\paragraph{sim2 run ima2 with assignment}
\paragraph{sim2 run ima2}
\paragraph{sim2 urn ima2 with assignment single}

\paragraph{s3-ima.sh}

\paragraph{s3-stat.sh}
We parse output files for parameter estimates.
Let us parse output files to get the one that I want.

\paragraph{s3-gplot.sh}

\paragraph{Three population sizes are different.}
There are 3 combinations, one of which includes 50 ([[gmax]]) replicates. 
The population
size is fixed at q1 (1.0), q2 (3.0), qa (2.0)
for three populations. We run IMa with and without
assignment variable. No migration is considered.

\begin{tabular}{|c|c|c|c|}
\hline 
level & 1 & 2 & 3\tabularnewline
\hline
\hline 
$t/q$ & 0.05 & 0.10 & 0.20\tabularnewline
\hline
\end{tabular}

<<s3 loop start parameters>>=
<<sim set param gmax>>
for tq in 0.05 0.10 0.20
do
for g in `seq $gmax`
do
<<s3 loop end parameters>>=
done
done
<<s3 set parameters>>=
q=2
qm=0
t=`$CALC $tq*$q`
m=`$CALC $qm/$q`
m1=$m
m2=$m
q1=1
q2=3
qa=$q


<<s3-sim.sh>>=
<<sim bash>>
<<sim simdiv>>
<<sim calc>>
<<sim delete and create data>>
RANDOM=3
<<sim2 variables>>

<<s3 loop start parameters>>
<<s3 set parameters>>
<<sim2 set input file>>
r=$RANDOM
<<sim2 run simdiv with j>>
<<sim2 run simdiv>>
<<s3 loop end parameters>>

<<s3.sh>>=
<<sim bash>>
<<sim delete and create log output>>
RANDOM=5
<<s3 loop start parameters>>
qsub -o log/$tq.out -e log/$tq.err -cwd s3-ima.sh $RANDOM $tq $g
<<s3 loop end parameters>>


<<s3-ima.sh>>=
<<sim bash>>
<<sim ima2>>
<<sim calc>>
BASEDIR=/home/goshng/run/s3

<<sim2 variables>>
RANDOM=$1
tq=$2
g=$3
<<sim trueassignment>>
<<sim2 set trueassignment>>

<<s3 set parameters>>
<<sim2 set input file>>
<<sim2 run ima2 with assignment>>
<<sim2 run ima2>>

<<s3-stat.sh>>=
<<sim bash>>
<<sim calc>>
<<sim2 variables>>
<<sim set param gmax>>
<<sim delete and create R>>
gmax=`$CALC $gmax-1`

function plott {

  rfile=t.R
  printf "pdf (\"t.pdf\")\n" > $rfile
  printf "par(mfrow=c(3,2))\n" >> $rfile

  for tq in 0.05 0.10 0.20
  do

  rdata=R/t_$tq.txt
  printf "x <- read.table (\"$rdata\", head=T)\n" >> $rfile
  printf "hist (x\$t, main=\"t/q: $tq, qm: $qm\", xlab=\"q\")\n" >> $rfile

  <<s3 set parameters>>

  TMPFILE0=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1
  TMPFILE1=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1
  TMPFILE2=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1

  OUTFILE=output/s2-q1_$q1-q2_$q2-qa_$qa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_

  for i in `seq $gmax`
  do
  printf "WA\t" >> $TMPFILE0
  done
  printf "WA\t" >> $TMPFILE0

  for i in `seq $gmax`
  do
  printf "OA\t" >> $TMPFILE0
  done
  printf "OA\n" >> $TMPFILE0

# split time and q0, q1, qa, m1, m2, ESS 
grep HiSmth $OUTFILE*.out|awk 'NR % 2 {print $3}'|transpose > $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $2}'|transpose >> $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $3}'|transpose >> $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $4}'|transpose >> $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $5}'|transpose >> $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $6}'|transpose >> $TMPFILE1
#grep ESS $OUTFILE*.out|awk 'NR % 2 {print $3}'|transpose >> $TMPFILE1
awk 'NR%7==0' $OUTFILE*.out.sum|transpose >> $TMPFILE1
# the same without assignment
grep HiSmth $OUTFILE*.ou2|awk 'NR % 2 {print $3}'|transpose > $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $2}'|transpose >> $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $3}'|transpose >> $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $4}'|transpose >> $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $5}'|transpose >> $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $6}'|transpose >> $TMPFILE2
#grep ESS $OUTFILE*.ou2|awk '{print $3}'|transpose >> $TMPFILE2

  for i in `seq $gmax`
  do
  printf "0\t" >> $TMPFILE2
  done
  printf "0\n" >> $TMPFILE2


paste $TMPFILE1 $TMPFILE2 >> $TMPFILE0

printf "run\tt\tq0\tq1\tqa\tm1\tm2\td\n" > $rdata
transpose $TMPFILE0 >> $rdata
rm $TMPFILE0 $TMPFILE1 $TMPFILE2

  done

  printf "dev.off()\n" >> $rfile

  #R --no-save < $rfile
}

plott

<<s3-gplot.sh>>=
<<sim bash>>

rfile=gplot.R

printf "library(ggplot2)\n" > $rfile

printf "x1 <- read.table(\"R/t_0.05.txt\", head=T)\n" >> $rfile
printf "x2 <- read.table(\"R/t_0.10.txt\", head=T)\n" >> $rfile
printf "x3 <- read.table(\"R/t_0.20.txt\", head=T)\n" >> $rfile

printf "tv.t <- c(0.1,0.2,0.4)\n">>$rfile
printf "tv.q0 <- rep(1,3)\n">>$rfile
printf "tv.q1 <- rep(3,3)\n">>$rfile
printf "tv.qa <- rep(2,3)\n">>$rfile
printf "tv.m1 <- rep(0,3)\n">>$rfile
printf "tv.m2 <- rep(0,3)\n">>$rfile
printf "tv.d <- rep(0,3)\n">>$rfile

for i in t q0 q1 qa m1 m2 d
do
  printf "pdf (\"R/$i.pdf\")\n" >> $rfile
  printf "p1 = qplot(run, $i, data=x1, geom=c(\"boxplot\",\"jitter\"), main=\"t/2=0.05\") + geom_hline(yintercept=tv.$i[[1]], colour=\"red\")\n">>$rfile

  printf "p2 = qplot(run, $i, data=x2, geom=c(\"boxplot\",\"jitter\"), main=\"t/2=0.10\") + geom_hline(yintercept=tv.$i[[2]], colour=\"red\")\n">>$rfile
  printf "p3 = qplot(run, $i, data=x3, geom=c(\"boxplot\",\"jitter\"), main=\"t/2=0.20\") + geom_hline(yintercept=tv.$i[[3]], colour=\"red\")\n">>$rfile
  printf "vplayout <- function(x,y) viewport(layout.pos.row=x, layout.pos.col=y)\n">>$rfile
  printf "grid.newpage()\n">>$rfile
  printf "pushViewport(viewport(layout=grid.layout(2,2)))\n">>$rfile
  printf "print(p1,vp=vplayout(1,1))\n">>$rfile
  printf "print(p2,vp=vplayout(1,2))\n">>$rfile
  printf "print(p3,vp=vplayout(2,1))\n">>$rfile
  printf "dev.off()\n" >> $rfile
done

/usr/local/bin/R --no-save < $rfile

@
Follow the list of command lines to complete or repeat the analysis of [[s3]]. 
\begin{Verbatim}[frame=lines,framesep=5mm]
# start at the base directory of IMamp
$ mkdir run/s3
$ cd run/s3
$ no s3-sim.sh
$ bash s3-sim.sh
$ scp -r data operon:run/s3/
$ no s3.sh
$ no s3-ima.sh
$ scp s3*sh operon:run/s3/
$ ssh operon
$ wcd s3
$ bash s3.sh
$ exit
$ no s3-structure.sh
$ cd structurama
$ split -l 250 structurama.bat <divide it so that we can run as many jobs>
$ bash xa* (?)
$ <wait for a day>
$ scp -r operon:run/s3/output .
$ no s3-stat.sh
$ bash s3-stat.sh
$ mkdri st
$ cd st
$ ln -s ../structurama output
$ bash ../s3-stat.sh
\end{Verbatim}

\subsubsection{Simulation 6}
We redo ``Simulation 3'' using two splitting times and nonzero migration rates.

<<s6 loop start parameters>>=
<<sim set param gmax>>
for tq in 1 2 3 
do
for g in `seq $gmax`
do
<<s6 loop end parameters>>=
done
done
<<s6 set parameters>>=
q=2
if [ "$tq" -eq 1 ]
then
t=`$CALC 0.01*$q`
m=`$CALC 0/$q`
fi
if [ "$tq" -eq 2 ]
then
t=`$CALC 0.1*$q`
m=`$CALC 0/$q`
fi
if [ "$tq" -eq 3 ]
then
t=`$CALC 0.1*$q`
m=`$CALC 1.0/$q`
fi

m1=$m
m2=$m
q1=1
q2=3
qa=$q


<<s6-sim.sh>>=
<<sim bash>>
<<sim simdiv>>
<<sim calc>>
<<sim delete and create data>>
RANDOM=3
<<sim2 variables>>
l=10


<<s6 loop start parameters>>
<<s6 set parameters>>
<<sim2 set input file>>
r=$RANDOM
<<sim2 run simdiv with j>>
<<sim2 run simdiv>>
<<s6 loop end parameters>>

<<s6.sh>>=
<<sim bash>>
<<sim delete and create log output>>
RANDOM=5
<<s6 loop start parameters>>
qsub -o log/$tq.out -e log/$tq.err -cwd s6-ima.sh $RANDOM $tq $g
<<s6 loop end parameters>>


<<s6-ima.sh>>=
<<sim bash>>
<<sim ima2>>
<<sim calc>>
BASEDIR=/home/goshng/run/s6

<<sim2 variables>>
l=10
RANDOM=$1
tq=$2
g=$3
<<sim trueassignment>>
<<sim2 set trueassignment>>

<<s6 set parameters>>
<<sim2 set input file>>
<<sim2 run ima2 with assignment>>
<<sim2 run ima2>>

<<s6-stat.sh>>=
<<sim bash>>
<<sim calc>>
<<sim2 variables>>
<<sim set param gmax>>
<<sim delete and create R>>
gmax=`$CALC $gmax-1`

function plott {

  rfile=t.R
  printf "pdf (\"t.pdf\")\n" > $rfile
  printf "par(mfrow=c(3,2))\n" >> $rfile

  for tq in 0.05 0.10 0.20
  do

  rdata=R/t_$tq.txt
  printf "x <- read.table (\"$rdata\", head=T)\n" >> $rfile
  printf "hist (x\$t, main=\"t/q: $tq, qm: $qm\", xlab=\"q\")\n" >> $rfile

  <<s6 set parameters>>

  TMPFILE0=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1
  TMPFILE1=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1
  TMPFILE2=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1

  OUTFILE=output/s2-q1_$q1-q2_$q2-qa_$qa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_

  for i in `seq $gmax`
  do
  printf "WA\t" >> $TMPFILE0
  done
  printf "WA\t" >> $TMPFILE0

  for i in `seq $gmax`
  do
  printf "OA\t" >> $TMPFILE0
  done
  printf "OA\n" >> $TMPFILE0

# split time and q0, q1, qa, m1, m2, ESS 
grep HiSmth $OUTFILE*.out|awk 'NR % 2 {print $3}'|transpose > $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $2}'|transpose >> $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $3}'|transpose >> $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $4}'|transpose >> $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $5}'|transpose >> $TMPFILE1
grep ^Mean $OUTFILE*.out|awk '{print $6}'|transpose >> $TMPFILE1
#grep ESS $OUTFILE*.out|awk 'NR % 2 {print $3}'|transpose >> $TMPFILE1
awk 'NR%7==0' $OUTFILE*.out.sum|transpose >> $TMPFILE1
# the same without assignment
grep HiSmth $OUTFILE*.ou2|awk 'NR % 2 {print $3}'|transpose > $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $2}'|transpose >> $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $3}'|transpose >> $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $4}'|transpose >> $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $5}'|transpose >> $TMPFILE2
grep ^Mean $OUTFILE*.ou2|awk '{print $6}'|transpose >> $TMPFILE2
#grep ESS $OUTFILE*.ou2|awk '{print $3}'|transpose >> $TMPFILE2

  for i in `seq $gmax`
  do
  printf "0\t" >> $TMPFILE2
  done
  printf "0\n" >> $TMPFILE2


paste $TMPFILE1 $TMPFILE2 >> $TMPFILE0

printf "run\tt\tq0\tq1\tqa\tm1\tm2\td\n" > $rdata
transpose $TMPFILE0 >> $rdata
rm $TMPFILE0 $TMPFILE1 $TMPFILE2

  done

  printf "dev.off()\n" >> $rfile

  #R --no-save < $rfile
}

plott

<<s3-gplot.sh>>=
<<sim bash>>

rfile=gplot.R

printf "library(ggplot2)\n" > $rfile

printf "x1 <- read.table(\"R/t_0.05.txt\", head=T)\n" >> $rfile
printf "x2 <- read.table(\"R/t_0.10.txt\", head=T)\n" >> $rfile
printf "x3 <- read.table(\"R/t_0.20.txt\", head=T)\n" >> $rfile

printf "tv.t <- c(0.1,0.2,0.4)\n">>$rfile
printf "tv.q0 <- rep(1,3)\n">>$rfile
printf "tv.q1 <- rep(3,3)\n">>$rfile
printf "tv.qa <- rep(2,3)\n">>$rfile
printf "tv.m1 <- rep(0,3)\n">>$rfile
printf "tv.m2 <- rep(0,3)\n">>$rfile
printf "tv.d <- rep(0,3)\n">>$rfile

for i in t q0 q1 qa m1 m2 d
do
  printf "pdf (\"R/$i.pdf\")\n" >> $rfile
  printf "p1 = qplot(run, $i, data=x1, geom=c(\"boxplot\",\"jitter\"), main=\"t/2=0.05\") + geom_hline(yintercept=tv.$i[[1]], colour=\"red\")\n">>$rfile

  printf "p2 = qplot(run, $i, data=x2, geom=c(\"boxplot\",\"jitter\"), main=\"t/2=0.10\") + geom_hline(yintercept=tv.$i[[2]], colour=\"red\")\n">>$rfile
  printf "p3 = qplot(run, $i, data=x3, geom=c(\"boxplot\",\"jitter\"), main=\"t/2=0.20\") + geom_hline(yintercept=tv.$i[[3]], colour=\"red\")\n">>$rfile
  printf "vplayout <- function(x,y) viewport(layout.pos.row=x, layout.pos.col=y)\n">>$rfile
  printf "grid.newpage()\n">>$rfile
  printf "pushViewport(viewport(layout=grid.layout(2,2)))\n">>$rfile
  printf "print(p1,vp=vplayout(1,1))\n">>$rfile
  printf "print(p2,vp=vplayout(1,2))\n">>$rfile
  printf "print(p3,vp=vplayout(2,1))\n">>$rfile
  printf "dev.off()\n" >> $rfile
done

/usr/local/bin/R --no-save < $rfile

@
Follow the list of command lines to complete or repeat the analysis of [[s3]]. 
\begin{Verbatim}[frame=lines,framesep=5mm]
# start at the base directory of IMamp
$ mkdir run/s3
$ cd run/s3
$ no s3-sim.sh
$ bash s3-sim.sh
$ scp -r data operon:run/s3/
$ no s3.sh
$ no s3-ima.sh
$ scp s3*sh operon:run/s3/
$ ssh operon
$ wcd s3
$ bash s3.sh
$ exit
$ no s3-structure.sh
$ cd structurama
$ split -l 250 structurama.bat <divide it so that we can run as many jobs>
$ bash xa* (?)
$ <wait for a day>
$ scp -r operon:run/s3/output .
$ no s3-stat.sh
$ bash s3-stat.sh
$ mkdri st
$ cd st
$ ln -s ../structurama output
$ bash ../s3-stat.sh
\end{Verbatim}


\subsubsection{Simulation 7}
We redo ``Simulation 6'' using two splitting times and nonzero migration rates.

0.05 (0,0)
0.1 (0,0)
0.1 (0.5, 0.5)
0.2 (1.0, 1.0)
<<s7 loop start parameters>>=
<<sim set param gmax>>
for tq in 1 2 3 4
do
for g in `seq $gmax`
do
<<s7 loop end parameters>>=
done
done
<<s7 set parameters>>=
q=2
if [ "$tq" -eq 1 ]
then
t=`$CALC 0.025*$q`
m=`$CALC 0/$q`
fi
if [ "$tq" -eq 2 ]
then
t=`$CALC 0.05*$q`
m=`$CALC 0/$q`
fi
if [ "$tq" -eq 3 ]
then
t=`$CALC 0.05*$q`
m=`$CALC 1.0/$q`
fi
if [ "$tq" -eq 4 ]
then
t=`$CALC 0.1*$q`
m=`$CALC 2.0/$q`
fi

m1=$m
m2=$m
q1=1
q2=3
qa=$q


<<s7-sim.sh>>=
<<sim bash>>
<<sim simdiv>>
<<sim calc>>
<<sim delete and create data>>
RANDOM=3
<<sim2 variables>>
l=10


<<s7 loop start parameters>>
<<s7 set parameters>>
<<sim2 set input file>>
r=$RANDOM
<<sim2 run simdiv with j>>
<<sim2 run simdiv>>
<<s6 loop end parameters>>

<<s7.sh>>=
<<sim bash>>
<<sim delete and create log output>>
RANDOM=5
<<s7 loop start parameters>>
qsub -o log/$tq.out -e log/$tq.err -cwd s7-ima.sh $RANDOM $tq $g
<<s7 loop end parameters>>


<<s7-ima.sh>>=
<<sim bash>>
<<sim ima2>>
<<sim calc>>
BASEDIR=/home/goshng/run/s7

<<sim2 variables>>
l=10
RANDOM=$1
tq=$2
g=$3
<<sim trueassignment>>
<<sim2 set trueassignment>>

<<s7 set parameters>>
<<sim2 set input file>>
<<sim2 run ima2 with assignment>>
<<sim2 run ima2>>

<<s7-stat.sh>>=
<<sim bash>>
<<sim calc>>
<<sim2 variables>>
l=10
gmax=50
RANDOM=$1
tq=$2
<<sim delete and create R>>
gmax=`$CALC $gmax-1`

function sumt {

  for tq in 1 2 3 4
  do

  rdata=R/d$tq.txt
  printf "totald\taveraged\tnormalized\tvarianced\tsquared\tmeansquared\td\n" > $rdata

  <<s7 set parameters>>

  OUTFILE=output/s2-q1_$q1-q2_$q2-qa_$qa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_
  perl s3-stat.pl .fixed$tq $OUTFILE*.ou2
  perl s3-stat.pl .variable$tq $OUTFILE*.out

  TMPFILE=`mktemp /tmp/stat.XXXXXXXXXXXXX` || exit 1
  paste $OUTFILE*.out.sum|transpose >> $rdata
  printf "x <- read.table (\"$rdata\", head=T)\n" > $TMPFILE
  printf "mean (x\$d)\n" >> $TMPFILE
  printf "quantile (x\$d, probs=c(0.025,0.975))\n" >> $TMPFILE
  R --no-save < $TMPFILE
  unlink $TMPFILE
  done
}

sumt
R --no-save < s7.R

<<s7.R>>=
CI<- function (fn, truevalue)
{
  x <- read.table(fn)
  lb <- 0.025 * sum (x$V2)
  ub <- 0.975 * sum (x$V2)
  lbx <- 0
  ubx <- 0
  s <- 0
  for (i in 1:length(x$V2))
    {
      prevs <- s
      s <- s + x$V2[i]
      if (s > lb && lbx == 0)
        {
          lbx <- i - 1
        }
      if (s > ub && ubx == 0)
        {
          ubx <- i
        }
    }
  i <- which(x$V2==max(x$V2))
  print(paste (fn, truevalue, i, x$V1[i], "lbx", lbx, "lb", x$V1[lbx], "ubx", ubx, "ub", x$V1[ubx])) 
}

print ("t-----------------------------------------------------------")
CI ("t.sum.fixed1", 0.05)
CI ("t.sum.variable1", 0.05)
CI ("t.sum.fixed2", 0.1)
CI ("t.sum.variable2", 0.1)
CI ("t.sum.fixed3", 0.1)
CI ("t.sum.variable3", 0.1)
CI ("t.sum.fixed4", 0.2)
CI ("t.sum.variable4", 0.2)
print ("q0-----------------------------------------------------------")
CI ("q0.sum.fixed1", 1)
CI ("q0.sum.variable1", 1)
CI ("q0.sum.fixed2", 1)
CI ("q0.sum.variable2", 1)
CI ("q0.sum.fixed3", 1)
CI ("q0.sum.variable3", 1)
CI ("q0.sum.fixed4", 1)
CI ("q0.sum.variable4", 1)
print ("q1-----------------------------------------------------------")
CI ("q1.sum.fixed1", 3)
CI ("q1.sum.variable1", 3)
CI ("q1.sum.fixed2", 3)
CI ("q1.sum.variable2", 3)
CI ("q1.sum.fixed3", 3)
CI ("q1.sum.variable3", 3)
CI ("q1.sum.fixed4", 3)
CI ("q1.sum.variable4", 3)
print ("q2-----------------------------------------------------------")
CI ("q2.sum.fixed1", 2)
CI ("q2.sum.variable1", 2)
CI ("q2.sum.fixed2", 2)
CI ("q2.sum.variable2", 2)
CI ("q2.sum.fixed3", 2)
CI ("q2.sum.variable3", 2)
CI ("q2.sum.fixed4", 2)
CI ("q2.sum.variable4", 2)
print ("m01-----------------------------------------------------------")
CI ("m01.sum.fixed1", 0)
CI ("m01.sum.variable1", 0)
CI ("m01.sum.fixed2", 0)
CI ("m01.sum.variable2", 0)
CI ("m01.sum.fixed3", 0.5)
CI ("m01.sum.variable3", 0.5)
CI ("m01.sum.fixed4", 1)
CI ("m01.sum.variable4", 1)
print ("m10-----------------------------------------------------------")
CI ("m10.sum.fixed1", 0)
CI ("m10.sum.variable1", 0)
CI ("m10.sum.fixed2", 0)
CI ("m10.sum.variable2", 0)
CI ("m10.sum.fixed3", 0.5)
CI ("m10.sum.variable3", 0.5)
CI ("m10.sum.fixed4", 1)
CI ("m10.sum.variable4", 1)





@
Follow the list of command lines to complete or repeat the analysis of [[s3]]. 
\begin{Verbatim}[frame=lines,framesep=5mm]
# start at the base directory of IMamp
$ mkdir run/s7
$ cd run/s7
$ no s7-sim.sh
$ bash s7-sim.sh
$ no s7.sh
$ no s7-ima.sh
$ cd ..
$ scp -r s7 operon:run/
$ ssh operon
$ wcd s7
$ bash s7.sh
$ exit
- wait for a day -
$ scp -r operon:run/s7/output .
??????????????????????????????????????
$ no s7.R
$ no s7-stat.sh
$ bash s7-stat.sh
\end{Verbatim}


@
\subsubsection{Simulation 4}
We implicitly infer population tree by updating only assignment with
12 different demographic parameter setups. A population tree with
three leaves was assumed. All of the five populations were of size
1 of $\theta.$ The second split time is fixed to 0.5 and the first
split time varies between 0 and 0.5: 0.1, 0.2, 0.3, and 0.4. All of
the eight migration rates vary: 0, 0.1, and 1.0. We simulated seven
genes for each of three populations. We generated 30 replicates for
each of 12 parameter setups with four loci. We fixed assignment to
the true to implicitly update population tree using three-point-turn
updating method. Depending on which population is outgrouped, one
of three assignment labelings is possible. Our setup of MCMC is as
follows: 30,000 of burnin, 1,000,000 of generations, 100 of thins,
10,000 of sample size, 10 chains with $h_{a}=0.96$ and $h_{b}=0.9,$
3 of maximum prior of $\theta,$ 2 of maximum prior of $T,$ and 2
of maximum prior of $M.$

<<s4-sim.sh>>=
<<sim bash>>
<<sim simdiv>>
<<sim calc>>
<<sim delete and create data>>
RANDOM=4
<<sim3 variables>>
<<sim3 function input>>

<<s4 loop start parameters>>
<<s4 set parameters>>
<<sim3 set input file>>
<<sim3 input file name>>
r=$RANDOM
<<sim3 run simdiv>>
<<s4 loop end parameters>>

<<s4.sh>>=
<<sim bash>>
<<sim delete and create log output>>
RANDOM=4
<<s4 loop start parameters>>
qsub -q sun27 -o log/$tq-$qm.out -e log/$tq-$qm.err -cwd s4-ima.sh $RANDOM $tq $qm $g
<<s4 loop end parameters>>

<<s4-ima.sh>>=
<<sim bash>>
<<sim ima2>>
<<sim calc>>
BASEDIR=/home/goshng/run/s4

<<sim3 variables>>
RANDOM=$1
tq=$2
qm=$3
g=$4

<<sim3 input file name>>
<<s4 run ima2 with assignment>>

<<s4-stat.sh>>=


<<s4 run ima2 with assignment>>=
$IM -i$BASEDIR/data/$fname.dat \
    -o$BASEDIR/output/$fname.out \
    -a1 \
    -q3 -m2 -t2 -s$RANDOM \
    -hfg -hn10 -hk10 -ha0.96 -hb0.9 \
    -b30000 -l10000 -d100 -z100000 \
    --three-point-turn
<<sim3 variables>>=
theta1="1"
theta2="1"
theta3="1"
theta4="1"
theta5="1"
m12="0.0"
m21="0.0"
m23="0.0"
m32="0.0"
m31="0.0"
m13="0.0"
m34="0.0"
m43="0.0"
t1="0.1"
t2="0.5"
l=4
n1=7
n2=7
n3=7

<<s4 set parameters>>=
m12=$qm
m21=$qm
m23=$qm
m32=$qm
m31=$qm
m13=$qm
m34=$qm
m43=$qm
t1=$tq

<<s4 loop t and m begin>>=
for tq in 0.1 0.2 0.3 0.4
do
for qm in 0.0 0.1 1.0
do
<<s4 loop t and m end>>=
done
done
<<s4 loop start parameters>>=
gmax=30
<<s4 loop t and m begin>>
for g in `seq $gmax`
do
<<s4 loop end parameters>>=
<<s4 loop t and m end>>
done
<<sim3 input file name>>=
fname=s3-m_$qm-t_$tq-g_$g 
<<sim3 set input file>>=
f3popi $theta1 $theta2 $theta3 $theta4 $theta5 $m12 $m21 $m23 $m32 $m31 $m13 $m34 $m43 $t1 $t2 $n1 $n2 $n3 > data/1
<<sim3 run simdiv>>=
$SIMDIV -idata/1 -odata/$fname.dat -s$RANDOM -uI -L4 

<<sim3 function input>>=
function f3popi {
  theta1=$1
  theta2=$2
  theta3=$3
  theta4=$4
  theta5=$5
  m12=$6
  m21=$7
  m23=$8
  m32=$9
  m31=${10}
  m13=${11}
  m34=${12}
  m43=${13}
  t1=${14}
  t2=${15}
  n1=${16}
  n2=${17}
  n3=${18}

  echo 3
  echo "((0,1):3,2):4"
  printf "((0:%s,1:%s):3:%s,2:%s):4\n" $t1 $t1 $t2 $t2
  printf "((0:%s,1:%s):3:%s,2:%s):4:%s\n" $theta1 $theta2 $theta4 $theta3 $theta5
  printf "0 %s %s 0 0\n" $m12 $m13
  printf "%s 0 %s 0 0\n" $m21 $m23
  printf "%s %s 0 %s 0\n" $m31 $m32 $m34
  printf "0 0 %s 0 0\n"  $m43
  printf "0 0 0 0 0\n"
  printf "%d %d %d\n" $n1 $n2 $n3
}

<<s4-phylogeny.sh>>=
<<sim bash>>
<<sim calc>>

printf "tq\tqm\tg\tt\tc0\tc1\tc2\tp0\tp1\tp2\n"
<<s4 loop start parameters>>
<<sim3 input file name>>
BASENAME=output/$fname.out.asn
t=$(cat $BASENAME | wc -l)
t=`$CALC $t-1`
c0=$(awk '/\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t2\t2\t2\t2\t2\t2\t2/' $BASENAME |wc -l)
c1=$(awk '/\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t2\t2\t2\t2\t2\t2\t2\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]/' $BASENAME |wc -l)
c2=$(awk '/\t2\t2\t2\t2\t2\t2\t2\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]/' $BASENAME |wc -l)
p0=`$CALC $c0/$t`
p1=`$CALC $c1/$t`
p2=`$CALC $c2/$t`
printf "$tq\t$qm\t$g\t$t\t%d\t%d\t%d\t%f\t%f\t%f\n" $c0 $c1 $c2 $p0 $p1 $p2
<<s4 loop end parameters>>

@
\subsubsection{Simulation 5}

\begin{Verbatim}[frame=lines,framesep=5mm]
See Simulation 5
((t1:0.01221420996,t2:0.01221420996):0.3776580047,((t4:0.06225541553,t3:0.06225541553):0.1938673505,t5:0.256122766):0.1337494486);
\end{Verbatim}

<<t5-sim.sh>>=
<<sim bash>>
<<sim simdiv>>
<<sim calc>>
<<sim delete and create data>>
RANDOM=5
<<sim5 variables>>
<<sim5 function input>>

<<t5 loop start parameters>>
<<t5 set parameters>>
<<sim5 set input file>>
<<sim5 input file name>>
r=$RANDOM
<<sim5 run simdiv>>
<<t5 loop end parameters>>

<<t5.sh>>=
<<sim bash>>
<<sim delete and create log output>>
RANDOM=4
<<s4 loop start parameters>>
qsub -q sun27 -o log/$tq-$qm.out -e log/$tq-$qm.err -cwd s4-ima.sh $RANDOM $tq $qm $g
<<s4 loop end parameters>>

<<t5-ima.sh>>=
<<sim bash>>
<<sim ima2>>
<<sim calc>>
BASEDIR=/home/goshng/run/t5

<<sim5 variables>>
RANDOM=$1
tq=$2
qm=$3
g=$4

<<sim5 input file name>>
<<t5 run ima2 with assignment>>

<<t5-stat.sh>>=


<<t5 run ima2 with assignment>>=
$IM -i$BASEDIR/data/$fname.dat \
    -o$BASEDIR/output/$fname.out \
    -a1 \
    -q3 -m2 -t2 -s$RANDOM \
    -hfg -hn10 -hk10 -ha0.96 -hb0.9 \
    -b30000 -l10000 -d100 -z100000 \
    --three-point-turn
<<sim5 variables>>=
q1="1"
q2="1"
q3="1"
q4="1"
q5="1"
q6="1"
q7="1"
q8="1"
q9="1"
l=4

<<t5 set parameters>>=
q1=`$CALC $RANDOM/32767*10`
q2=`$CALC $RANDOM/32767*10`
q3=`$CALC $RANDOM/32767*10`
q4=`$CALC $RANDOM/32767*10`
q5=`$CALC $RANDOM/32767*10`
q6=`$CALC $RANDOM/32767*10`
q7=`$CALC $RANDOM/32767*10`
q8=`$CALC $RANDOM/32767*10`
q9=`$CALC $RANDOM/32767*10`

<<t5 loop t and m begin>>=
#for tq in 0.1 0.2 0.3 0.4
#do
#for qm in 0.0
#do
<<t5 loop t and m end>>=
#done
#done
<<t5 loop start parameters>>=
gmax=10
<<t5 loop t and m begin>>
for g in `seq $gmax`
do
<<t5 loop end parameters>>=
<<t5 loop t and m end>>
done
<<sim5 input file name>>=
fname=t5-$g 
<<sim5 set input file>>=
#f5popi $q1 $q2 $q4 $q3 $q5 $q6 $q7 $q8 $q9 > data/1
f5popi 1 1 1 1 1 1 1 1 1 > data/1
<<sim5 run simdiv>>=
$SIMDIV -idata/1 -odata/$fname.dat -s$RANDOM -uI -L4 

<<sim5 function input>>=
function f5popi {
  q1=$1
  q2=$2
  q3=$3
  q4=$4
  q5=$5
  q6=$6
  q7=$7
  q8=$8
  q9=$9

  echo 5 
  echo "((0,1):5,((2,3):6,4):7):8"
  echo "((0:0.1,1:0.1):5:1.0,((2:0.2,3:2):6:0.5,4:0.5):7:1.0):8"
  printf "((0:%d,1:%d):5:%s,((2:%s,3:%s):6:%s,4:%s):7:%s):8:%s\n" $q1 $q2 $q4 $q3 $q5 $q6 $q7 $q8 $q9
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "0 0 0 0 0 0 0 0 0\n"
  printf "5 5 5 5 5\n"
}

<<t5-phylogeny.sh>>=
<<sim bash>>
<<sim calc>>

printf "tq\tqm\tg\tt\tc0\tc1\tc2\tp0\tp1\tp2\n"
<<s4 loop start parameters>>
<<sim3 input file name>>
BASENAME=output/$fname.out.asn
t=$(cat $BASENAME | wc -l)
t=`$CALC $t-1`
c0=$(awk '/\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t2\t2\t2\t2\t2\t2\t2/' $BASENAME |wc -l)
c1=$(awk '/\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t2\t2\t2\t2\t2\t2\t2\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]/' $BASENAME |wc -l)
c2=$(awk '/\t2\t2\t2\t2\t2\t2\t2\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]\t[01]/' $BASENAME |wc -l)
p0=`$CALC $c0/$t`
p1=`$CALC $c1/$t`
p2=`$CALC $c2/$t`
printf "$tq\t$qm\t$g\t$t\t%d\t%d\t%d\t%f\t%f\t%f\n" $c0 $c1 $c2 $p0 $p1 $p2
<<s4 loop end parameters>>



@
\subsubsection{Converting sequence data to nexus}
I am wondering if sequence data converted to numbers can be used for
structurama. 

\begin{Verbatim}[frame=lines,framesep=5mm]
notangle -L -Rim2nexus.pl noweb/imamp.nw > im2nexus.pl
notangle -L -RIM2Nexus.pm noweb/imamp.nw > IM2Nexus.pm
perl im2nexus.pl --in=inputfile 
\end{Verbatim}
<<perl header>>=
#!/usr/bin/perl -w
<<im2nexus.pl>>=
<<perl header>>
<<im2nexus packages>>
<<im2nexus command>>

<<im2nexus packages>>=
use strict;
use Getopt::Long;
use IM2Nexus;

<<im2nexus command>>=
my $inputfile;
my $isdiploid = 0;
my $isasn = 1;
my $result = GetOptions ("in=s" => \$inputfile,
                         "diploid:i" => \$isdiploid,
                         "asn:i" => \$isasn);
my $im2nexus = new IM2Nexus ('inputfile' => $inputfile,
                             'isdiploid' => $isdiploid,
                             'isasn' => $isasn);
$im2nexus->read();
$im2nexus->write();
$im2nexus->writemathematica();

@
Parsing [[imamp]] input file is not an easy task. We only need to know 
number of loci and number of gene copies of each locus for population assignment
summarization purpose.
<<IM2Nexus.pm>>=
package IM2Nexus;
require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(read write writemathematica);


<<perl util trim>>

sub new 
{
  my $type = shift;
  my %parm = @_;
  my $this = {};
  $this->{'inputfile'} = $parm{'inputfile'};
  $this->{'isdiploid'} = $parm{'isdiploid'};
  $this->{'isasn'} = $parm{'isasn'};
  bless $this, $type;
}

sub read
{
  my $class = shift @_;
  my $line;
  my %genenames;
  my %genes;
  my $i;
  my $j;
  my @individuals;
  my @genotypes;
  my %avoiddiploid;

  open IMAIN, $class->{'inputfile'};

  # the only comment 
  $line = <IMAIN>;
  chomp $line;
  $class->{'comment'} = $line;

  $line = <IMAIN>;
  while ($line =~ /^#/)
    {
      $line = <IMAIN>;
    }
  # We assume that we are at the start line, or number of populations.

  # number of populations
  $line =~ /^(\d+)/;
  $class->{'npops'} = $1;

  # names of populations
  $line = <IMAIN>;
  my @elements = split /\s+/, $line; 
  $class->{'names'} = \@elements;

  # population tree
  $line = <IMAIN>;
  chomp $line;
  $class->{'tree'} = $line;

  # number of loci
  $line = <IMAIN>;
  $line =~ /^(\d+)/;
  $class->{'nloci'} = $1;

  # iterate the loci
  my $ngenes = 0;
  my $nind = 0;
  for ($i = 0; $i < $class->{'nloci'}; $i++)
    {
      $line = <IMAIN>;

      # Find the number of genes
      my $n;
      if ($class->{'isasn'} == 1)
        {
          $line =~ /\s+A(\d+)/;
          $n = $1;
        }
      else
        {
          my @es = split /\s+/, $line;
          $n = 0;
          for ($j = 0; $j < $class->{'npops'}; $j++)
            {
              $n += $es[$j+1];
            }
        }

      my @items = split /\s+/, $line;

      for ($j = 0; $j < $n; $j++)
        {
          $line = <IMAIN>;
          my @items = split /\s+/, $line; 
          my $genename = substr $line, 0, 10;
          $genename = trim ($genename);
          unless (exists $genenames{$genename})
            {
              $genenames{$genename} = $nind;
              $nind++;
            }
          my $gene = substr $line, 10;
          $gene = trim ($gene);
          unless (exists $genes{$gene})
            {
              $genes{$gene} = $ngenes;
              $ngenes++;
            }
        }
    }
  close IMAIN;

  my @nullgenes = ();
  for ($i = 0; $i < $class->{'nloci'}; $i++)
    {
      push @nullgenes, "?";
    }

  @individuals = ();
  for ($i = 0; $i < $nind; $i++)
    {
      push @individuals, "x";
      push @genotypes, [ @nullgenes ];
    }
  foreach (keys %genenames)
    {
      $individuals[$genenames{$_}] = $_;
    }

  open IMAIN, $class->{'inputfile'};
  $line = <IMAIN>;
  $line = <IMAIN>;
  while ($line =~ /^#/)
    {
      $line = <IMAIN>;
    }
  $line = <IMAIN>;
  $line = <IMAIN>;
  $line = <IMAIN>;

  # iterate the loci
  $ngenes = 0;
  for ($i = 0; $i < $class->{'nloci'}; $i++)
    {
      %avoiddiploid = ();
      $line = <IMAIN>;

      my $n;
      if ($class->{'isasn'} == 1)
        {
          $line =~ /\s+A(\d+)/;
          $n = $1;
        }
      else
        {
          my @es = split /\s+/, $line;
          $n = 0;
          for ($j = 0; $j < $class->{'npops'}; $j++)
            {
              $n += $es[$j+1];
            }
        }

      my @items = split /\s+/, $line; 
      for ($j = 0; $j < $n; $j++)
        {
          $line = <IMAIN>;
          my @items = split /\s+/, $line; 
          my $genename = substr $line, 0, 10;
          $genename = trim ($genename);
          my $gene = substr $line, 10;
          $gene = trim ($gene);
          my $ii =$genenames{$genename}; 
          unless (exists $avoiddiploid{$genename})
            {
              $genotypes[$ii][$i] = $genes{$gene};
            }
          $avoiddiploid{$genename} = $ii;
        }
    }
  close IMAIN;

  $class->{'individuals'} = \@individuals;
  $class->{'genotypes'} = \@genotypes;
  $class->{'nind'} = $nind;
}

@
\begin{Verbatim}[frame=lines,framesep=5mm]
#NEXUS

[ COMMENT ]

begin data;
   dimensions nind=3 nloci=4;
   info
   Larry ( 1 , 1 ) ( 0 , 3 ) ( 8 , 8 ) ( 7 , 2 ) , 
   Moe   ( 1 , 1 ) ( 3 , 3 ) ( 8 , 8 ) ( 7 , 7 ) , 
   Curly ( 1 , 2 ) ( 0 , 0 ) ( 8 , ? ) ( 7 , 8 )
	;
end;
\end{Verbatim}

<<IM2Nexus.pm>>=
sub write
{
  my $class = shift @_;
  my $line;
  my $i;
  my $j;
  my $li;
  my $ii;
  my @individuals = @{$class->{'individuals'}};
  my @genotypes = @{$class->{'genotypes'}};

  print "#NEXUS\n\n";
  print "[".$class->{'comment'}, "]\n\n";
  print "begin data;\n";
  print "   dimensions nind=";
  print $class->{'nind'};
  print " nloci=";
  print $class->{'nloci'};
  print ";\n";
  print "   info\n";
  for ($i = 0; $i < $class->{'nind'}; $i++)
    {
      print "   ".$individuals[$i]." ";
      for ($j = 0; $j < $class->{'nloci'}; $j++)
        {
          #print "(".$genotypes[$i][$j].", ?) ";
          print "(".$genotypes[$i][$j].") ";
        }
      if ($i < $class->{'nind'} - 1)
        {
          print ",";
        }   
      print "\n";
    }
  print "  ;\n";
  print "end;\n";

#  print "\n";
#  print "\nbegin structurama;\n";
#  print "  model numpops=2;\n";
#  print "  mcmc printfreq=100000;\n";
#  print "end;\n";

}

sub writemathematica
{
  my $class = shift @_;
  my $line;
  my $i;
  my $j;
  my $li;
  my $ii;
  my @individuals = @{$class->{'individuals'}};
  my @genotypes = @{$class->{'genotypes'}};

  print "{";
  for ($j = 0; $j < $class->{'nloci'}; $j++)
    {
      print "{";
      for ($i = 0; $i < $class->{'nind'}; $i++)
        {
          print "{".$genotypes[$i][$j]."} ";
          if ($i < $class->{'nind'} - 1)
            {
              print ",";
            }   
        }
      print "}";
      if ($j < $class->{'nloci'} - 1)
        {
          print ",";
        }
    }
  print "}";
}
1;

<<perl util trim>>=
# Declare the subroutines
sub trim($);
sub ltrim($);
sub rtrim($);

# Create a test string
# my $string = "  \t  Hello world!   ";

# Here is how to output the trimmed text "Hello world!"
# print trim($string)."\n";
# print ltrim($string)."\n";
# print rtrim($string)."\n";

# Perl trim function to remove whitespace from the start and end of the string
sub trim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}
# Left trim function to remove leading whitespace
sub ltrim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	return $string;
}
# Right trim function to remove trailing whitespace
sub rtrim($)
{
	my $string = shift;
	$string =~ s/\s+$//;
	return $string;
}
@



@
\subsection{Test of single population of IMa}
I wanted to test the model comparison using thermodynamic integration. A data
set is generated under a single population demographic model. When we run IM
with single-population or two-population models, a single population model would
fit the data better than a two-population model. A single population model is
implemented. A data set is downloaded from http://beast.bio.ed.ac.uk/Saharica\_Trial
to test the implementation of IM with a single population model.

\subsection{Test of island model}
We want to test the feature of inference of [[IMa]] under island model. 
We follow the simulation setup developed by 
Abdo et al. (2004 in Molecular Ecology 13, 837--851) and 
Beerli (2006 in Bioinformatics 2, 341--345). The first and second [[ms]] command
lines are from Abdo and Beerli, respectively.
\begin{Verbatim}[frame=lines,framesep=5mm]
ms 50 L -t 4Nu -I 2 25 25 4Nm -seeds # # #
ms 80 L -t 4Nu -I 4 20 20 20 20 -ma x 0 0 1 1 x 0 0 0 1 x 0 0 0 1 x -seeds # # #
\end{Verbatim}
The first simulation under island model uses three $L$ (1, 10, 100), three
$4N\mu$ ($2.5\times10^{-4}$, $2.5\times10^{-3}$, $2.5\times10^{-2}$), and four
$4Nm$ ($2.5\times10^{-6}$, $2.5\times10^{-2}$, $2.5\times10^{-1}$, $2.5$). We
construct 100 replications per combination. Thus, total 3,600 data files will be
generated by following the simulation setup due to Abdo's. 
The second one uses three $L$ (1, 10, 100), four $4N\mu$ 
($1.0\times10^{-4}$, $1.0\times10^{-3}$, $1.0\times10^{-2}$,
$1.0\times10^{-1}$), and single $4Nm$ ($m/\mu$ being 100 for each $4N\mu$).
Total 1,200 data files will be created such a way of Beerli's. The orginal
simulation setups use finite site mutation model. We simulate infinite-sites
data under island model. 

<<island.sh>>=
#!/bin/bash

for L in 1 10 100
do
  for t in 0.00025 0.0025 0.025
  do
    for M in 0.0000025 0.025 0.25 2.5 
    do 
      for g in {1..100}
      do
        #ms 50 $L -t $t -I 2 25 25 $M -seeds # # # | perl msi2im.pl > data/island/island-$L-$t-$M-$g.dat

        ms 50 $L -t $t -I 2 25 25 $M | perl msi2im.pl > data/island/island-$L-$t-$M-$g.dat
      done
    done
  done
done

@
\subsection{Test of relabel method of updating assignment}

\subsection{Test of BF method of updating assignment}

\subsection{Test of demographic parameter and assignment estimation}
We apply a version of two-population IMa with assignment to a simulate data set.
We simulate almost the same data set as that used for simulation study except
that one of two populations are larger in their size. We used 0.5, 1, and 2 for
population size parameters. We set the size of second population to the three
times as 
those: 1.5, 3, and 6. Our goal is to see if we recover the population sizes.
We mostly copy the code of [[s5]] simulation study.

How can we compare the result with true value?
I need to get values first, then 


<<e1-sim.sh>>=
#!/bin/bash
#SIMDIV=/home/goshng/compile/simdiv/simdiv
SIMDIV=simdiv

rm -rf data
mkdir data
<<sim2 variables>>
RANDOM=5

<<s5 parameters loop begin>>

for g in `seq $gmax`
do

t=`calc $tq*$theta`
m=`calc $qm/$theta`
m1=$m
m2=$m
theta1=$theta
theta2=`calc $theta*3`
thetaa=$theta
fname=s2-q1_$theta1-q2_$theta2-qa_$thetaa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_$g 

$SIMDIV -odata/$fname.dat -s$RANDOM -uI -L$l q1$theta1 -q2$theta2 -qa$thetaa -m1$m1 -m2$m2 -t$t -n1$n1 -n2$n2 -j4

echo "execute $fname.in" > data/$fname.bat
echo "model numpops=2" >> data/$fname.bat
echo mcmc >> data/$fname.bat
echo sum >> data/$fname.bat
echo quit >> data/$fname.bat

done
done
done
done

<<e1-structurama.sh>>=
#!/bin/bash
ST=/home/goshng/Documents/Projects/IMamp/src/st

rm -rf structurama
mkdir structurama

sfile=structurama.bat
rm -f $sfile

<<sim2 variables>>
<<sim trueassignment>>

ta=`seqn $n1 1`
tb=`seqn $n2 2`
tasn=$ta$tb


<<s5 parameters loop begin>>
for g in `seq $gmax`
do

t=`calc $tq*$theta`
m=`calc $qm/$theta`
m1=$m
m2=$m
theta1=$theta
theta2=`calc $theta*3`
thetaa=$theta
fname=s2-q1_$theta1-q2_$theta2-qa_$thetaa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_$g 

perl im2nexus.pl --in=data/$fname.dat > structurama/$fname.in
$ST structurama/$fname $tasn

bfile=structurama/$fname.bat

echo "wine ~/bin/Structurama.exe < $fname.bat" >> $sfile

echo "execute $fname.in" > $bfile
echo "model numpops=2" >> $bfile
echo mcmc Printfreq=100000 >> $bfile
echo sum >> $bfile
echo quit >> $bfile

done
done
done
done

mv $sfile structurama
echo "Run bash $sfile after changing directory to structurama"

<<e1.sh>>=
#!/bin/bash

rm -rf log
mkdir log
rm -rf output
mkdir output

RANDOM=5

<<s5 parameters loop begin>>

t=`calc $tq*$theta`
m=`calc $qm/$theta`
qsub -o log/$m.out -e log/$m.err -cwd e1-ima.sh $RANDOM $theta $t $m

done
done
done

<<e1-ima.sh>>=
#!/bin/bash
IM=/home/goshng/compile/IMamp/build/src/IMa2
BASEDIR=/home/goshng/run/e1

<<sim2 variables>>
<<sim trueassignment>>
RANDOM=$1
theta1=$2
theta2=`/home/goshng/bin/calc $2*3`
thetaa=$2
t=$3
m1=$4
m2=$4

ta=`seqn $n1 1`
tb=`seqn $n2 2`
tasn=$ta$tb

for g in `seq $gmax`
do
fname=s2-q1_$theta1-q2_$theta2-qa_$thetaa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_$g 

$IM -i$BASEDIR/data/$fname.dat \
    -o$BASEDIR/output/$fname \
    -a137 -q10.0 -m1.0 -t10.0 -s$RANDOM \
    -b300000 -l3000 -d100 -z100000 \
    -x$tasn
done

@
\subsection{Test of model comparison using thermodynamic integration}
<<l1-fixed>>=
theta1=1.0
theta2=1.0
thetaa=1.0
m1=0.0
m2=0.0
t=1.0
l=5
n1=10
n2=10

<<l1-sim.sh>>=
#!/bin/bash
#SIMDIV=/home/goshng/compile/simdiv/simdiv
SIMDIV=simdiv

rm -rf data
mkdir data
<<l1-fixed>>
RANDOM=1

for g in {1..10}
do

fname=s2-q1_$theta1-q2_$theta2-qa_$thetaa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_$g 
$SIMDIV -odata/$fname.dat -s$RANDOM -uI -L$l q1$theta1 -q2$theta2 -qa$thetaa -m1$m1 -m2$m2 -t$t -n1$n1 -n2$n2

done

<<l1.sh>>=
#!/bin/bash

rm -rf log
mkdir log
rm -rf output
mkdir output

RANDOM=1
for x in 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
do

qsub -o log/$x.out -e log/$x.err -cwd l1-ima.sh $x $RANDOM

done

<<l1-ima.sh>>=
#!/bin/bash
IM=/home/goshng/compile/IMamp/build/src/IMa2
BASEDIR=/home/goshng/run/l1
#IM=/home/goshng/Documents/Projects/IMamp/build/src/IMa2
#BASEDIR=/home/goshng/Documents/Projects/IMamp/run/l1

<<l1-fixed>>
x=$1
RANDOM=$2

for g in {1..10}
do
fname=s2-q1_$theta1-q2_$theta2-qa_$thetaa-m1_$m1-m2_$m2-t_$t-l_$l-n1_$n1-n2_$n2-g_$g 
$IM -i$BASEDIR/data/$fname.dat \
    -o$BASEDIR/output/$fname.x$x.out \
    -q3.0 -m1.0 -t3.0 -s$RANDOM \
    -b300000 -l3000 -d100 -z100000 \
    -x$x
$IM -i$BASEDIR/data/$fname.dat \
    -o$BASEDIR/output/$fname.x$x.i.out \
    -a5 -q3.0 -m1.0 -s$RANDOM \
    -b300000 -l3000 -d100 -z100000 \
    -x$x

done

@
\section{Real Data}
We may have to run long multiple chains.
\subsection{Geraldes}
\citet{Geraldes:2008} sequenced 4 intronic autosomal loci, 2 loci
on X chromosomes, 1 locus on Y chromosomes, and 1 locus on mtDNA control
region. We used the first 7 loci excluding mtDNA control region due
to lack of individual information for two populations: Mus domesticus
and Mus castaneus. Total number of individuals was 131; 55 from Mus
domesticus, and 58 from Mus castaneus. Not all of the individuals
have 7 genes, e.g., individual R87 has a gene only from locus \emph{Jarid1d}
(Y chromosome).

\begin{Verbatim}[frame=lines,framesep=5mm]
scp output/8genesDC-l7-longx5.out.uct macbook:works/IMamp/run/geraldes/output/
8genesDC-l7-longx5.out.uct
8genesDC-l7-long.out.uct
IM w/ assignment: 8genesDC-l7-longx5.out.uct
IM w/o assignment: 8genesDC-l7-im-1.out
\end{Verbatim}

\subsection{Fischer}
We used a partial data set of 10 loci that were from \citet{Fischer:2006}.
Four species were included in the analysis: West African chimpanzees
(\emph{Pan troglodytes verus}), East African chimpanzees (\emph{Pan
troglodytes schweinfurthii}), Central African chimpanzees (\emph{Pan
troglodytes troglodytes}), and Bonobos (\emph{Pan paniscus}). Central
and East African chimpanzee species form the first ancestor, and their
common ancestor and West African chimpanzees species form the next
ancestor. Bonobos was an outgroup taxon. The most recent split time
event is tiny enough to complicate assignment inference of individuals
from Central and East African populations.

\subsection{Babik}
We used a partial data set from \citet{Nadachowska:2009} with two
subspecies of a salamander, Lissotriton vulgaris kosswigi and Lissotriton
vulgaris vulgaris. As shown at Figure 2 of \citet{Nadachowska:2009},
gene trees of the loci separate two groups well although the gene
tree of locus Nd2 shows mixed clusters. When we used all of 9 loci
for the assignment using STRUCTURAMA, it recovered the true assignment
(data not shown). We used a smaller data set of 2 loci for estimating
the assignment (Figure 5). Five individual was misassigned in the
assignment estimated using STRUCTURAMA whereas an individuals were
misassigned in the assignment using IM.

\section{Population Assignment}
We make a new approach to the inference of assigning individuals with
unknown origin of populations to a known number of groups using multilocus
molecular data. Methods available to date take advantage of Hardy-Weinberg
equilibrium within populations, which is unnecessary in our approach.
A likelihood framework based on coalescent theory is instead employed
to the problem of population assignment. Assuming an underlying history
of populations of sampled individuals, genealogies of sampled alleles
from multiple loci and assignments of those individuals to the present-day
populations are sampled from a posterior distribution using Markov
chain Monte Carlo with Metropolis-Hastings algorithm. A measure of
distance between assignments facilitates not only summarizing posterior
samples of assignment but also estimating demographic parameters of
underlying histories of populations. We compare our method of using
demographic population models with a method that assumes Hardy-Weinberg
equilibrium using simulated data sets. The new method can allow the
study of demographic history along with population assignment.

We aim at identifying source populations of sampled individuals using
genetic data, which has seen more than a decade in their vast applications
\citep{Pritchard:2000,Paetkau:1995a,Rannala:1997,Dawson:2001,Corander:2003,Baudouin:2004,Guillot:2005,Francois:2006,Pella:2006,Wu:2006,Huelsenbeck:2007,Zhang:2008,Omeara:2009,Reeves:2009}.
Most of the methods of population assignment have been formulated
using allele frequencies. Assuming random mating within populations
and free recombination between loci, they take the product of allele
frequencies for the expected frequencies of multilocus genotypes.
They then can compare the theoretical expectation of genotype frequencies
with observed one to identify populations from which data have come.

Allele frequencies, however, can be unsatisfactory in that true allele
frequencies of population origins are often unknown. They are estimated
\citep{Pritchard:2000} or integrated out \citep{Huelsenbeck:2007}
with a prior distribution assumed. Another shortcoming is that allele
frequencies necessarily rely upon a model of simplified genetic variation.
Under a purely allelic model, for example, two gene copies are either
the same or different, and the allelic approach cannot accommodate
more or fewer differences between gene copies that are not identical.
Data sets of homologous DNA sequences would be trimmed, involving
information loss, in order to reduce sequence data to distinct haplotypes
that could be given allele designations. Allele frequencies by no
means tell us much about the mutational or evolutionary history of
sampled populations. With the mutation and demographic models available
for genetic data, it could be desirable to use the patterns of variation
in genetic samples without any conversion for allele designations
in order to infer not only the evolutionary history of the populations,
but also population assignment.

We describe an approach to population assignment that explicitly accounts
a mutation and demographic model of population divergence to study
more recently diverged populations. The outline of the paper is as
follows. We review a few demographic models that lay the foundation
of the demographic model employed. We sketch out the demographic model
before we describe our method of the inference of population assignment,
consisting in detailing the method of update of assignment variable
in Metropolis-Hastings algorithm, and in proposing joint estimation
of assignment and demographics. We showcase the inference of population
assignment using three sets of real data. Simulated data sets are
analyzed to assess statistical properties of our method, which is
followed by future directions and discussion.

\citet{Kuhner:1995} pioneered an MCMC approach to sampling genealogies
by using importance sampling based on relative likelihoods for estimating
population demographic parameters. They have inspired several research
lines of sampling genealogies given underlying population structures
although they considered only a single population that was simpler
than those developed later. Many possible population structures could
be envisioned, and a few of them were modeled explicitly under statistical
frameworks: island structures of multiple populations that are separated
for infinite time and have migrants between them \citep[e.g.,][]{Beerli:1999},
and tree structures of populations with augmented unobserved ancestral
populations \citep[e.g.,][]{Nielsen:2001,Hey:2007}. More complicated
population structures have been considered under approximate Bayesian
computation as an alternative to full-likelihood methods \citep[e.g.,][]{Becquet:2007a}.
These methods are for studying demographics of one or more closely
related populations, from which homologous copies of a gene are drawn
at one of multiple loci. Parameters of interest include those of mutation
models (e.g., mutation rates), and those of demographics (e.g., population
sizes, migration rates, and the times of population separation).

Among approaches of genealogy sampling, we employed the approach taken
by \citet{Hey:2007} for drawing distinctions among populations by
assigning individuals to populations. The statistical model of population
demography is called isolation-with-migration (IM) model with a closed
form of prior distribution of genealogy given a particular population
tree. It allows sampling of genealogies under a demographic based
on coalescent theory. We attempt to assess impact of evolutionary
forces of mutation, migration, and genetic drift upon statistical
behavior of our method of population assignment. 

We brief on the population genetic model before we elaborate on its
application to population assignment. Demographics are illustrated
by an ultrametric binary rooted tree with a labeled history \citep{Edwards:1970}
where nodes of the tree are ordered in time. We consider a fixed labeled
history and variable divergence time; relative time of population
splits are ordered and the split times are inferred. Divergence time
of ancestral populations is denoted by relative positions of internal
and root nodes. We denote the list of divergence time values by a
vector $\mathbf{t}$. A genealogy is a tree $\mathbf{G}$ that connects
all sampled alleles of a locus through unobserved internal nodes.
All loci of size $L$ are assumed to be independent of each other,
and the corresponding genealogies $\mathbf{G}$ on those loci are
considered to be mutually independent as well. When a genealogy for
each locus is overlaid to a population tree, each of nodes of the
genealogy is labeled a node of the population tree (see Figure 1).
Population labels along a branch of a genealogy can change depending
on the labels of both nodes of the branch. \citet{Hey:2007} sample
genealogy $\mathbf{G}$ of size $L$ and split time $\mathbf{t}$
from the posterior distribution of genealogy given data $\mathbf{X}$
of $L$-many loci:\[
\pi(\mathbf{G},\mathbf{t}|\mathbf{X})=\frac{f(\mathbf{X}|\mathbf{G})\pi(\mathbf{G}|\mathbf{t})\pi(\mathbf{t})}{f(\mathbf{X})}.\]
The closed form of prior distribution $\pi(\mathbf{G}|\mathbf{t})$
of genealogy given split time facilitates the sampling of genealogies
from the posterior distribution. The prior is given by\[
\pi(\mathbf{G}|\mathbf{t})=\int f(\mathbf{G}|\mathbf{t},\mathbf{\Theta})\pi(\mathbf{\Theta}|\mathbf{t})d\mathbf{\Theta}\]
where model parameter $\mathbf{\Theta}$ includes population mutation
and migration parameters. Posterior samples of genealogy are then
plugged into the function of posterior density of parameter $\mathbf{\Theta}$
given data $\mathbf{X}$: \begin{equation}
\pi(\mathbf{\Theta}|\mathbf{X})=\int_{\Psi}f(\mathbf{\Theta}|\mathbf{G},\mathbf{t})\pi(\mathbf{G},\mathbf{t}|\mathbf{X})d\mathbf{G}=\mathbb{E}_{\mathbf{G},\mathbf{t}|\mathbf{X}}\left[f(\mathbf{\Theta}|\mathbf{G},\mathbf{t})\right]\label{eq:lmode}\end{equation}
where $\Psi$ is a set of all possible genealogies, and $\mathbb{E}$
is the expectation over samples from $\pi(\mathbf{G},\mathbf{t}|\mathbf{X})$.
Note that data $\mathbf{X}$ consists of genotype data with known
assignment. Split time $\mathbf{t}$ is not involved in estimating
demographic parameters of $\mathbf{\Theta}$. By maximizing the posterior
density function over parameter ranges we can find a maximum likelihood
estimate of population mutation and migration parameters of $\mathbf{\Theta}$. 

In the section of IM without assignment, a data set $\mathbf{X}$
consists of genotypes $\mathbf{Y}$ and assignment \textbf{$\mathbf{A}$}
of individuals to a known number of populations that are related by
a population tree with its fixed topology. We consider at the present
study assignment $\mathbf{A}$ of individuals a random variable, denoting
genotype data without assignment information by $\mathbf{Y}$. We
mostly confine our interest to the inference of population assignment
for the time being before we discuss issues that arise in the joint
inference of demographic and assignment parameter. 

A hierarchical structure of genotype data $\mathbf{Y}$ with unknown
assignment is in order. Individual $i$ is genotyped over $L$ loci
across its genome that results in its genotype information $Y_{i}$
that makes up genotype data $\mathbf{Y}$ for $n$ individuals. Genotype
data $Y_{i}$ for individual $i$ consists of $L$ sets of vectors
$Y_{il}$ for $L$ loci data where variable $Y_{il}$ is a single-valued
vector for haploid individuals, or a two-valued vector for diploid.
Genotype data $Y_{il}$ for individual $i$ of locus $l$ can be either
a vector $(Y_{il1})$ or $(Y_{il1},Y_{il2})$ where $Y_{il1}$ and
$Y_{il2}$ are genotype data themselves such as DNA sequences or microsatellite
alleles. Assignment parameter $\mathbf{A}$ is a vector of size $n$
with element $A_{i}$ taking a nominal value among $K$ possible populations.
The parameter of genealogy $\mathbf{G}$ is a vector of size $L$
with elements of $G_{l}$. Each genealogy $G_{l}$ of locus $l$ is
an ultrametric binary tree with given lengths. The posterior distribution
of assignment, genealogy, and split time given data $\mathbf{Y}$
without assignment \textbf{$\mathbf{A}$} is as follows: 

\begin{equation}
\pi(\mathbf{G},\mathbf{A},\mathbf{t}|\mathbf{Y})=\frac{f(\mathbf{Y}|\mathbf{G},\mathbf{A})\pi(\mathbf{G}|\mathbf{t},\mathbf{A})\pi(\mathbf{t}|\mathbf{A})\pi(\mathbf{A})}{f(\mathbf{Y})}.\label{eq:posterior}\end{equation}
Since assignment $\mathbf{A}$ is the parameter of our interest, genealogy
$\mathbf{G}$ is treated as a nuisance parameter that is purged of
joint posterior samples of assignment and genealogy. We later use
assignment and genealogy to estimate demographic parameters. If the
assignment parameter of our model is fixed, the model is reduced to
the population genetic model of demography pertaining to \citet{Hey:2007}
\citep[see also][]{Hey:2009}.

The number of ways to assign n individuals to K populations is known
as the Stirling numbers of the second kind \citep{Bell:1934}. The
denominator of Equation (2) for the posterior distribution of genealogy,
split time, and assignment is the integration of the numerator over
genealogy, split time, and assignment parameter spaces, which are
intractable to solve analytically. We employ a Monte Carlo approach
known as Markov chain Monte Carlo \citep{Metropolis:1953,Hastings:1970}
where the acceptance probability, $\alpha(\mathbf{G},\mathbf{t},\mathbf{A}\rightarrow\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*})$,
is given by 

\begin{equation}
\frac{f(\mathbf{Y}|\mathbf{G}^{*},\mathbf{A}^{*})}{f(\mathbf{Y}|\mathbf{G},\mathbf{A})}\frac{\pi(\mathbf{G}^{*}|\mathbf{t}^{*},\mathbf{A}^{*})}{\pi(\mathbf{G}|\mathbf{t},\mathbf{A})}\frac{\pi(\mathbf{t}^{*}|\mathbf{A}^{*})}{\pi(\mathbf{t}|\mathbf{A})}\frac{\pi(\mathbf{A}^{*})}{\pi(\mathbf{A})}\frac{q(\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*}\rightarrow\mathbf{G},\mathbf{t},\mathbf{A})}{q(\mathbf{G},\mathbf{t},\mathbf{A}\rightarrow\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*})}.\label{eq:acceptance}\end{equation}
An update of assignment entails changes to events along branches of
genealogies: migration and population split events. We adapt previously
developed schemes of updating migration and population split events
along a branch. The methods of updating events along a branch are
necessary when parts of genealogies are updated \citep{Beerli:1999,Nielsen:2001}.
We take advantage of the scheme of updating genealogies due to \citet{Beerli:1999}
and \citet{Hey:2007}. The former is employed here in the context
of population assignment, and the latter was taken by \citet{Nielsen:2006}
whose goal is to identify species of a gene also known as ?DNA barcoding?
\citep{Floyd:2002}. Since species can be a term that group related
individuals, we interchange species and populations in the context
of population assignment for the rest of the paper. A single gene
is unknown while most of genes are known in their origin of species
typically in the problem of DNA barcoding. As the number of unknown
genes increases, the problem of DNA barcoding transforms gradually
into that of population assignment, in which all of the genes can
be unknown in their origin of populations.





\subsection{Boilerplates}
Chunks [[c decls]], [[c begin decls]], and [[c end decls]] are
a boilerplate for C++ client codes. The implementation of [[IMamp]] in C may be
relatively easily reused by C++ client codes. The three code sections may help
adjust [[IMamp]] C implementation to C++ codes maybe sometime later.
<<c decls>>=
#undef __BEGIN_DECLS
#undef __END_DECLS
#ifdef __cplusplus
# define __BEGIN_DECLS extern "C" {
# define __END_DECLS }
#else
# define __BEGIN_DECLS /* empty */
# define __END_DECLS /* empty */
#endif

<<c begin decls>>=
__BEGIN_DECLS

<<c end decls>>=
__END_DECLS

<<hey nielsen copyright>>=
/* IMa2  2007-2009 Jody Hey, Rasmus Nielsen and Sang Chul Choi */

<<ima gnu copyright>>=
/**
 * This file is a part of IMamp.
 * 
 * IMamp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 * 
 * IMamp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with IMamp.  If not, see <http://www.gnu.org/licenses/>.
 */

@
\subsection{Useful commands for working with this noweb file}
You do not know where you were at. Here can be a start of coding.
\begin{Verbatim}[frame=lines,framesep=5mm]
../../simdiv/simdiv -isim3pop.i -wsim3pop.l -osim3pop-l5-is.dat -L5 -z0 -s25 -j4
pushd ../../src; ./c; popd; pushd ../../build; ../configure CFLAGS="-g3 -ggdb -O0 -DBF"; make clean; make; popd
pushd ../../src; ./c; popd; pushd ../../build; ../configure CFLAGS="-g3 -ggdb -O0"; make clean; make; popd
pushd ../../src; ./c; popd; pushd ../../build; make; popd; gdb ../../build/src/IMa2
\end{Verbatim}

\begin{Verbatim}[frame=lines,framesep=5mm]
cd ~/Documents/Projects/IMamp/run/Lartillot
../../../simdiv/simdiv -o2.dat -s1241 -uI -L5 -m10.00 -m20.00 -q11 -q21 -qa1 -t1 -n110 -n210 -z0 -j4
../../../simdiv/simdiv -iinput/3.i -winput/3.l -o3.dat -L5 -z0 -s25 -j4
pushd ../../src; ./c; popd; pushd ../../build; ../configure CFLAGS="-g3 -ggdb -O0"; make clean; make; popd
pushd ../../src; ./c; popd; pushd ../../build; make; popd; gdb ../../build/src/IMa2
\end{Verbatim}

These are from [[bf]] update.
\begin{Verbatim}[frame=lines,framesep=5mm]
cd ~/Documents/Projects/IMamp/run/s2l3g6/4j
pushd ../../../src; ./c; popd; pushd ../../../build; ../configure CFLAGS="-g3 -ggdb -O0 -DBF"; make clean; make; popd
pushd ../../../src; ./c; popd; pushd ../../../build; make; popd; gdb ../../../build/src/IMa2

# consider only haploid data types
cd ~/Documents/Projects/IMamp/run/s2l3g6/2j
pushd ../../../src; ./c; popd; pushd ../../../build; ../configure CFLAGS="-g3 -ggdb -O0 -DBF"; make clean; make; popd
pushd ../../../src; ./c; popd; pushd ../../../build; make; popd; gdb ../../../build/src/IMa2
pushd ../../../src; ./c; popd; pushd ../../../build; make; popd; valgrind ../../../build/src/IMa2
\end{Verbatim}

\begin{Verbatim}[frame=lines,framesep=5mm]
cd ~/works/IMamp/run/Hey
pushd ../../src; ./c; popd; pushd ../../build; make; popd
pushd ../../src; ./c; popd; pushd ../../build; make; popd; gdb ../../build/src/IMa2
\end{Verbatim}

To generate a data file:
\begin{Verbatim}[frame=lines,framesep=5mm]
cd run/Hey/input
simdiv -os2-q1_1.0-q2_1.0-qa_1.0-m1_0.0-m2_0.0-t_1.0.dat -s121 -uI -L3 q11.0 -q21.0 -qa1.0 -m10.0 -m20.0 -t1.0 -n15 -n25 -z0 -j4
cd ..
IMa2 -iinput/s2-q1_1.0-q2_1.0-qa_1.0-m1_0.0-m2_0.0-t_1.0.dat -ooutput/s2-q1_1.0-q2_1.0-qa_1.0-m1_0.0-m2_0.0-t_1.0.dat -a137 -m5 -q5 -t3 -r5 -s127242 -b1000000 -l1000 -d100 -z10000
\end{Verbatim}

\begin{Verbatim}[frame=lines,framesep=5mm]
simdiv -os2-q1_1.0-q2_1.0-qa_1.0-m1_0.0-m2_0.0-t_1.0.dat -s121 -uI -L3 q11.0 -q21.0 -qa1.0 -m10.0 -m20.0 -t1.0 -n15 -n25 -j4
IMa2 -iinput/s2-q1_1.0-q2_1.0-qa_1.0-m1_0.0-m2_0.0-t_1.0.dat -ooutput/s2-q1_1.0-q2_1.0-qa_1.0-m1_0.0-m2_0.0-t_1.0.dat -a137 -m5 -q5 -t3 -r5 -s127242 -b1000000 -l1000 -d100 -z10000

simdiv -os2-q1_1.0-q2_1.0-qa_1.0-m1_0.0-m2_0.0-t_1.0.dat -s121 -uI -L3 q11.0 -q21.0 -qa1.0 -m10.0 -m20.0 -t1.0 -n15 -n25 -j4
\end{Verbatim}

@
\subsection{Header file - updateassignment.h}
We have two files:
[[updateassignment.c]] and [[updateassignment.h]], respectively. 
This [[noweb]] file contains codes and their documentation alike.
We use the following commands to extract parts of the codes in 
[[updateassignment]] files from this [[noweb]] file. 
\begin{Verbatim}[frame=lines,framesep=5mm]
notangle -Rupdateassignment.h noweb/imamp.nw | cpif updateassignment.h
\end{Verbatim}
Since we want to debug a source file, we add line numbers in [[noweb]] file to
the source file using the following command line:
\begin{Verbatim}[frame=lines,framesep=5mm]
notangle -L -Rupdateassignment.c noweb/imamp.nw > updateassignment.c
\end{Verbatim}
When we send the source file to someone who would not like to use the [[noweb]]
technique, we do not use the switch [[L]].
\begin{Verbatim}[frame=lines,framesep=5mm]
notangle -Rupdateassignment.c noweb/imamp.nw > updateassignment.c
\end{Verbatim}

FIXME: function header can be detailed with different parts.
<<updateassignment.h>>=
<<hey nielsen copyright>>
#ifndef _UPDATEASSIGNMENT_H_
#define _UPDATEASSIGNMENT_H_
<<c decls>>
<<c begin decls>>
<<updateassignment macros>>
<<updateassignment structs>>
<<updateassignment function header>>
<<c end decls>>
#endif /* _UPDATEASSIGNMENT_H_ */

<<updateassignment function header>>=
<<updateassignment header record>>
<<updateassignment header parser>>
<<updateassignment header bar>>
<<updateassignment header io>>
<<updateassignment header gtree>>
<<updateassignment header ptree>>
<<updateassignment header debug>>
<<updateassignment header assignment2value>>
<<updateassignment header assign>>
<<updateassignment header asn>>
<<updateassignment header assertgenealogy>>
<<updateassignment header ti>>

@
\subsection{Structure definitions}
Most structures defined in the assignment module are used to save and restore
genealogy states. 
There may be two particular situations when we save a genealogy in the case of
rejection of a proposal. We want to save some branches of a genealogy or
some aspects of all the branches of a genealogy. We want to save all population
labels of a genealogy include ones in migration events using structure
[[im_savededge]]. Structure [[im_savedlocus]] may be considered a reduced
version of structure [[im_locus]]. It contains four kinds of members: 1) a copy
of structure [[im_locus]], 2) members for saving labels including ones in 
migration events, 3) members for saving some branches when we slide them, and 4)
members for saving some members of structure [[im_locus]]. It seems like that we
have three levels of saving a state of a Markov chain: 1) nodes or branches, 2) 
genealogies, and 3) ``chains.'' Structure [[im_popntree]] is for the third
level.

Where and when do we need structure [[im_node]]? It is used only with for
individual information. Search for [[im_node]].
We want to
save all the nodes of a genealogy and sort them in time. 

\paragraph{struct im\_event\_struct}
For coalescent events, [[type]] is c. [[p]] and [[pi]] are both -1. 
[[pj]] is population label.
For split time events, [[type]] is s. [[p]] and [[pi]] are both starting
periods, and [[pj]] are ending period.
For migration events, [[type]] is m. [[p]] is the period during which the event
happens. [[pi]] and [[pj]] are starting and ending population labels,
respectively.
[[type]] 'p': lineage 1 migration,
[[type]] 'q': lineage 2 migration,
[[type]] 'r': lineage 3 migration,
[[type]] 'a': lineage 1 coalescent, 
[[type]] 'b': lineage 2 coalescent, and
[[type]] 'd': lineage 1 and 2 coalescent.
Coalescent events have member [[ei]] being the edge ID.

<<updateassignment structs>>=
struct im_node_struct
{
  int li;               /* locus id               */
  int ei;               /* node and its branch id */
  double t;             /* time at the node       */
}; 

typedef struct im_node_struct im_node;

struct im_savededge_struct
{
  int savedpop;           /* old population the edge is in at its top */
  im_migstruct *savedmig; /* migration events                         */
  int cmm;                /* current size of mig array                */
};

typedef struct im_savededge_struct im_savededge;

struct im_savedlocus_struct
{
  /* copy members of locus structure */
  int nlinked;
  int model; 
  /* for saving population labels    */
  im_savededge *gtree;
  /* for saving some branches        */
  struct edge *saved;
  int savedi;
  int savedn;
  /* for saving locus members        */
  int savedroot;
  int savedmignum;
  double savedroottime;
  double savedlength;
  double savedtlength;
  struct genealogy_weights savedgweight;
  double savedpdg;
  double savedplg;
  double *savedpdg_a;

  /* rootmove global variable would be removed from update_gtree.c */
  int copyedge[3];
  int holddownA[MAXLINKED];
  int medgedrop;
  int mrootdrop;
  int rootmove;
  double lmedgedrop;
  double lmrootdrop;
  double holdsisdlikeA[MAXLINKED];
};

typedef struct im_savedlocus_struct im_savedlocus;

struct im_popntree_struct
{
  struct genealogy_weights savedallgweight;
  struct probcalc savedallpcalc;
  double savedt[MAXPERIODS];

  im_node **indlist;
  /* gsl_block_uint ***popnlistDELETE; FIXME: change it to int ** */

  /* Do we need popnlist, npopnlist, popnlistB, and Ps? */
  /* We do not seem to use these. popndown and popnmig are used. */
  int ***popnlist;
  int **npopnlist;

  UByteP **popnlistB;
  UByteP *Ps;     /* list of populations during a period  */
  int **popndown;

  int ***popnmig; /* per period, per popn, list of popn's */
};

typedef struct im_popntree_struct im_popntree;

struct im_ginfo_struct
{
  int *cc;        /* coalescent counts for populations    */
  double *fc;     /* coalescent rates  for populations    */
  int **cm;       /* migration counts between populations */
  double **fm;    /* migration rates between populations  */
  double *thetas; /* theta estimates for populations      */
  double **mms;   /* migration rates between populations  */
  double **ms;    /* migration rate away for populations  */
}; 

typedef struct im_ginfo_struct im_ginfo;

struct im_event_struct
{
  double t;  /* time                                    */
  char type; /* 'c' or 'm' or 's' or 'e'                */
  int p;     /* population label or p-th split time     */
  int pi;    /* only for migration events: starting pop */
  int pj;    /* only for migration events: ending pop   */
  int ei;    /* edge ID for coalescent event            */
}; 

typedef struct im_event_struct im_event;

struct im_bfupdate_struct
{
  im_event *e1;  /* events                      */
  int n1;        /* number of total events      */
  int nmax1;     /* capacity of the array       */
  im_event *e2;  /* events plus active          */
  int n2;
  int nmax2;
  im_event *e3;  /* events beyond a partial     */
  int n3;
  int nmax3;
  int *nz1;
  int **lz1;
  int *n;
  int **l;
  int *a;        /* array of gi_largestsample   */
  double *likes1;/* array of gi_largestsample   */
  int likei1;    /* chosen one                  */
  double **likes11; /* maxA - minA + 1          */
  int likei11;   /* chosen one                  */
  int *seqz1;    /* seq at the bottom of z1     */
  char canz31;   /* 1 if z3 and z1 can coalesce */
  char is_finiterootbranch;
  int A1;

  int sis1;
  im_edgemiginfo *m1;
  im_edgemiginfo *m3;
  int pop;
};

typedef struct im_bfupdate_struct im_bfupdate;


@
\subsection{Source file - updateassignment.c}

\paragraph{updateassignment header}
There are two lines that may be helpful in adding a new file in [[imamp]] and
using some global variables. We ``undefine'' [[GLOBVARS]] and include the
main header, [[imamp.h]]. We take advantage of some functions in
[[update_gtree_common.h]], [[utilities.h]], and [[imagsl.h]]. 
We extract parts of [[GSL]] library and place them file [[imagsl.h]].

<<updateassignment.c>>=
<<hey nielsen copyright>>
#include "config-common.h"
<<updateassignment include>>
<<updateassignment extern>>
<<updateassignment file static variables>>
<<updateassignment static>>

<<updateassignment record>>
<<updateassignment parser>>
<<updateassignment relabel>>
<<updateassignment bf>>
<<updateassignment tpt>>
<<updateassignment uncertainty>>
<<updateassignment gusfield>>
<<updateassignment structurama>>
<<updateassignment mrbayes>>
<<updateassignment rgs>>
<<updateassignment labelswitch>>
<<client structurama>>

/* Export function */
<<updateassignment bar>>
<<updateassignment io>>
<<updateassignment debug>>
<<updateassignment assignment2value>>
<<updateassignment assign>>
<<updateassignment asn>>
<<updateassignment ti>>


/* File static function */
<<updateassignment edgemiginfo>>
<<updateassignment ind>>
<<updateassignment nnminus1>>
<<updateassignment sbf>>
<<updateassignment sagi>>
<<updateassignment gtree>>
<<updateassignment chain>>
<<updateassignment ptree>>
<<updateassignment saved>>
<<updateassignment string>>
<<updateassignment population tree update>>

/* Both */
<<updateassignment assertgenealogy>>

<<updateassignment static>>=
<<updateassignment static edgemiginfo>>
<<updateassignment static ind>>
<<updateassignment static nnminus1>>
<<updateassignment static sbf>>
<<updateassignment static sagi>>
<<updateassignment static gtree>>
<<updateassignment static chain>>
<<updateassignment static assignment2value>>
<<updateassignment static ptree>>
<<updateassignment static saved>>
<<updateassignment static assertgenealogy>>
<<updateassignment static string>>



@
There are two lines that may be helpful in adding a new file in [[imamp]] and
using some global variables. We ``undefine'' [[GLOBVARS]] and include the
main header, [[imamp.h]]. We take advantage of some functions in
[[update_gtree_common.h]], [[utilities.h]], and [[imagsl.h]]. 
We extract parts of [[GSL]] library and place them file [[imagsl.h]].
<<updateassignment include>>=
#include <search.h>
#undef GLOBVARS
#include "imamp.h"
/* #include "imagsl.h" */
#include "update_gtree_common.h"
#include "utilities.h"
#ifdef STRUCTURAMAREMOTERUN
<<server include>>
#endif /* STRUCTURAMAREMOTERUN */
#include "updateassignment.h"

@
We want to access some global variables in other files. 
We need [[outfilename]] that is used in
recording assignment posterior sample using functions such as 
[[recordassignmentlocus]].
We want to know the true assignment that is given by users. If this is given, we
compute the average distance of [[trueassignment]] from assignment posterior
samples. We give a normalized averged distance by the number of individuals to
be assigned so that we may compare two assignment results although they are
different in their number of individuals. We can give sample variance of the
distance. If [[trueassignment]] is NULL, we do nothing mentioned above.
<<updateassignment extern>>=
extern char *outfilename;
extern char *trueassignment;

@
\subsection{File static variables - member variables of Class Asn}
All file static variables are prefixed ``s.'' 
These variables are not seen outside [[updateassignment]] module.
The list of file static variables are
\begin{enumerate}
\item [[snind]]: total number of individuals, 
\item [[snind_known]]: total number of individuals with known labels, 
\item [[snind_unknown]]: total number of individuals with unknown labels, 
\item [[sngenes_ind]]: numbers of genes of each individual, 
\item [[ssizePi]]: size of a bit set of populations,
\item [[sassigned]]: assignment proportion of a single locus (for DNA Barcoding),
\item [[sind2gi]]: edge id for each locus for an individual (FIXME: this may be
replace by something else,
\item [[sci]]: chain that has static information (FIXME: do we need this?),
\end{enumerate}

There are member variables in the main header file that need to be taken
away. Two of them are [[newedgemig]] and [[oldedgemig]]. We will make them file
static variables. We also have [[saC]] for a chain and [[saT]] for an array of 
gene trees. Some of these variables may be obsolete.

\begin{description}
\item [snind, snind\_known, snind\_unknown] 
imaIndSet, imaAsnSet, finish\_setup\_C, setup, start, main
\item [sind2gi]
imaIndSet, imaAsnSet, finish\_setup\_C, setup, start, main
\item [sngenes\_ind]
imaIndSet, imaAsnSet, finish\_setup\_C, setup, start, main
\item [ssizePi]
imaPtreeSetIsland, imaAsnSet, finish\_setup\_C, setup, start, main
imaPtreeSet, imaAsnSet, finish\_setup\_C, setup, start, main
\item [sassigned]
imaAsnSet, finish\_setup\_C, setup, start, main
FREE: imaAsnFree
\item [snnminus1]
imaInitNnminus1, imaAsnSet, finish\_setup\_C, setup, start, main
\item [saoem, saoems]
imaInitEdgemiginfo, imaAsnSet, finish\_setup\_C, setup, start, main
\end{description}

<<updateassignment file static variables>>=
/* Class Edgemiginfo */
static struct edgemiginfo saoem;
static struct edgemiginfo saosm;
static struct edgemiginfo sanem;
static struct edgemiginfo sansm;
static struct edgemiginfo saoem2;
static struct edgemiginfo sanem2;
static struct edgemiginfo *saoems;
static struct edgemiginfo *sanems;
static struct edgemiginfo *saosms;
static struct edgemiginfo *sansms;

/* Class Nnminus1 */
static double *snnminus1;

/* Class Sbf */
static im_bfupdate sbfold;
static im_bfupdate sbfnew;

/* Class Ginfo */
static im_ginfo *saGiold;
static im_ginfo *saGioldz1;
static im_ginfo *saGioldz2;
static im_ginfo *saGinew;
static im_ginfo *saGinewz1;
static im_ginfo *saGinewz2;

/* Member sasigned */
static double **sassigned;

/* Class Individuals */
static int snind;
static int snind_known;
static int snind_unknown;
static int *sngenes_ind;
static int ssizePi;
static int **sind2gi;        
static int *sinds;
static int sci;

/* Class Ptree */
static im_popntree saC;            /* _s_tatic _a_ssignment _C_hain */

/* Class Saved */
static im_savedlocus *saT;         /* _s_tatic _a_ssignment _T_ree */



@
\subsubsection{Class Edgemiginfo}
Functions [[imaInitEdgemiginfo]] and [[imaFreeEdgemiginfo]] 
allocate and deallocate the memory of edgemiginfo
variables. Two members [[mtimeavail]] and [[mp]] are needed to be dealt
with since [[mig]] is an mere array not a pointer.
Function [[imaFreeEdgemiginfo]] is called in [[imaAsnFree]].
Function [[imaInitEdgemiginfo]] is called in
[[imaAsnSet]].

[[imaInitEdgemiginfo]] even with no migration case.
<<updateassignment static edgemiginfo>>=
static void imaInitEdgemiginfo ();
static void imaFreeEdgemiginfo ();
<<updateassignment function header>>=
void imaEdgemiginfoPrint (im_edgemiginfo *m);
<<updateassignment edgemiginfo>>=
void
imaInitEdgemiginfo ()
{
  int i;
  assert (!(npops < 0));
  saoem.mtimeavail = NULL;
  saoem.mp = NULL;
  saosm.mtimeavail = NULL;
  saosm.mp = NULL;
  sanem.mtimeavail = NULL;
  sanem.mp = NULL;
  sansm.mtimeavail = NULL;
  sansm.mp = NULL;
  saoem2.mtimeavail = NULL;
  saoem2.mp = NULL;
  sanem2.mtimeavail = NULL;
  sanem2.mp = NULL;
  
  saoem.mtimeavail = malloc (npops * sizeof (double));
  saoem.mp = malloc (npops * sizeof (int));
  saosm.mtimeavail = malloc (npops * sizeof (double));
  saosm.mp = malloc (npops * sizeof (int));
  sanem.mtimeavail = malloc (npops * sizeof (double));
  sanem.mp = malloc (npops * sizeof (int));
  sansm.mtimeavail = malloc (npops * sizeof (double));
  sansm.mp = malloc (npops * sizeof (int));
  saoem2.mtimeavail = malloc (npops * sizeof (double));
  saoem2.mp = malloc (npops * sizeof (int));
  sanem2.mtimeavail = malloc (npops * sizeof (double));
  sanem2.mp = malloc (npops * sizeof (int));

  if (saoem.mtimeavail == NULL 
      || saoem.mp == NULL
      || saosm.mtimeavail == NULL 
      || saosm.mp == NULL
      || sanem.mtimeavail == NULL 
      || sanem.mp == NULL
      || sansm.mtimeavail == NULL 
      || sansm.mp == NULL
      || saoem2.mtimeavail == NULL 
      || saoem2.mp == NULL
      || sanem2.mtimeavail == NULL 
      || sanem2.mp == NULL)
    {
      IM_err (IMERR_MEM, "saoem/saosm/sanem/sansm/saoem2/sanem2");
    }

  saoems = malloc (2 * nloci * sizeof (struct edgemiginfo)); 
  sanems = malloc (2 * nloci * sizeof (struct edgemiginfo)); 
  saosms = malloc (2 * nloci * sizeof (struct edgemiginfo)); 
  sansms = malloc (2 * nloci * sizeof (struct edgemiginfo)); 
  for (i = 0; i < 2 * nloci; i++)
    {
      saoems[i].mp = malloc (npops * sizeof (int));
      saoems[i].mtimeavail = malloc (npops * sizeof (double));
      sanems[i].mp = malloc (npops * sizeof (int));
      sanems[i].mtimeavail = malloc (npops * sizeof (double));
      saosms[i].mp = malloc (npops * sizeof (int));
      saosms[i].mtimeavail = malloc (npops * sizeof (double));
      sansms[i].mp = malloc (npops * sizeof (int));
      sansms[i].mtimeavail = malloc (npops * sizeof (double));
    }
  return;
}

void
imaFreeEdgemiginfo ()
{
  int i;

  free (saoem.mtimeavail);
  saoem.mtimeavail = NULL;
  free (saoem.mp);
  saoem.mp = NULL;
  free (saosm.mtimeavail);
  saosm.mtimeavail = NULL;
  free (saosm.mp);
  saosm.mp = NULL;
  free (sanem.mtimeavail);
  sanem.mtimeavail = NULL;
  free (sanem.mp);
  sanem.mp = NULL;
  free (sansm.mtimeavail);
  sansm.mtimeavail = NULL;
  free (sansm.mp);
  sansm.mp = NULL;

  free (saoem2.mtimeavail);
  saoem2.mtimeavail = NULL;
  free (saoem2.mp);
  saoem2.mp = NULL;
  free (sanem2.mtimeavail);
  sanem2.mtimeavail = NULL;
  free (sanem2.mp);
  sanem2.mp = NULL;

  for (i = 0; i < 2 * nloci; i++)
    {
      free (saoems[i].mp);
      saoems[i].mp = NULL;
      free (saoems[i].mtimeavail);
      saoems[i].mtimeavail = NULL;
      free (sanems[i].mp);
      sanems[i].mp = NULL;
      free (sanems[i].mtimeavail);
      sanems[i].mtimeavail = NULL;
      free (saosms[i].mp);
      saosms[i].mp = NULL;
      free (saosms[i].mtimeavail);
      saosms[i].mtimeavail = NULL;
      free (sansms[i].mp);
      sansms[i].mp = NULL;
      free (sansms[i].mtimeavail);
      sansms[i].mtimeavail = NULL;
    }
  free (saoems);
  saoems = NULL;
  free (sanems);
  sanems = NULL;
  free (saosms);
  saosms = NULL;
  free (sansms);
  sansms = NULL;

  return;
}

void
imaEdgemiginfoPrint (im_edgemiginfo *m)
{
  int mi;

  if (m == NULL)
    {
      return;
    }

  printf ("    miginfo: edge [%2d] from %lf to %lf\n", m->edgeid, m->upt, m->dnt);
  printf ("             popn [%2d] to [%2d]\n", m->pop, m->fpop);
  mi = 0;
  while (m->mig[mi].mt > -0.5)
    {
      printf ("    mp [%2d] at %lf\n", m->mig[mi].mp, m->mig[mi].mt);
      mi++;
    }
  printf ("    mi vs. mpall: %2d == %2d\n", mi, m->mpall);
  return;
}



@
\subsubsection{Class Nnminus1}
[[snnminus1]] is managed.
<<updateassignment static nnminus1>>=
static void imaInitNnminus1 ();
static void imaFreeNnminus1 ();
<<updateassignment nnminus1>>=
void
imaInitNnminus1 ()
{
  int i;
  int li;
  int largestsamp;
  for (i = 0, li = 0; li < nloci; li++)
    {
      if (i < L[li].numgenes)
        {
          i = L[li].numgenes;
        }
    }
  largestsamp = i;
  snnminus1 = malloc ((largestsamp + 1) * sizeof (double));
  snnminus1[0] = 0;
  for (i = 1; i <= largestsamp; i++)
    {
      snnminus1[i] = (double) (i) * ((double) i - 1);
    }
  return;
}

void 
imaFreeNnminus1 ()
{
  free (snnminus1);
  snnminus1 = NULL;
}

@
\subsubsection{Class Sbf}
We create intervals for events in a genealogy.
These are called in [[imaAsnInit]] and [[imaAsnFree]], respectively.
<<updateassignment static sbf>>=
static int imaSbfInit ();
static int imaSbfFree ();
<<updateassignment sbf>>=
int
imaSbfInit ()
{
  int n;
  int li;
  int ai;
  int pi;
  int largestnA;

  n = 0;
  largestnA = -1;
  for (li = 0; li < nloci; li++)
    {
      if (n < L[li].numlines)
        {
          n = L[li].numlines;
        }
#ifdef COMMENT
      if (largestnA < L[li].maxA[0] - L[li].minA[0] + 1)
        {
          largestnA = L[li].maxA[0] - L[li].minA[0] + 1;
        }
#endif /* COMMENT */
    }
  sbfold.nmax1 = 2 * n;
  sbfold.nmax2 = 2 * n;
  sbfold.nmax3 = 2 * n;
  sbfnew.nmax1 = 2 * n;
  sbfnew.nmax2 = 2 * n;
  sbfnew.nmax3 = 2 * n;

  sbfold.e1 = (im_event *) malloc (sbfold.nmax1 * sizeof (im_event));
  sbfold.e2 = (im_event *) malloc (sbfold.nmax2 * sizeof (im_event));
  sbfold.e3 = (im_event *) malloc (sbfold.nmax3 * sizeof (im_event));
  sbfold.nz1 = (int *) malloc (numpopsizeparams * sizeof (int));
  /* sbfold.nz2 = (int *) malloc (numpopsizeparams * sizeof (int)); */
  sbfold.n = (int *) malloc (numpopsizeparams * sizeof (int));
  sbfold.lz1 = (int **) malloc (numpopsizeparams * sizeof (int *));
  /* sbfold.lz2 = (int **) malloc (numpopsizeparams * sizeof (int *)); */
  sbfold.l = (int **) malloc (numpopsizeparams * sizeof (int *));
  sbfold.a = (int *) malloc (gi_largestngenes * sizeof (int));
  sbfold.likes1 = (double *) malloc (gi_largestngenes * sizeof (double));
  sbfold.likes11 = (double **) malloc (gi_largestngenes * sizeof (double *));
  for (ai = 0; ai < gi_largestngenes; ai++)
    {
      sbfold.likes11[ai] = (double *) malloc (largestnA * sizeof (double));
    }

  sbfold.seqz1 = (int *) malloc (gi_largestnumsites * sizeof (int));
  /* sbfold.seqz2 = (int *) malloc (gi_largestnumsites * sizeof (int)); */
  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      assert (gi_largestngenes > 0);
      sbfold.lz1[pi] = (int *) malloc (gi_largestngenes * sizeof (int));
      /* sbfold.lz2[pi] = (int *) malloc (gi_largestngenes * sizeof (int)); */
      sbfold.l[pi] = (int *) malloc (gi_largestngenes * sizeof (int));
    }
  sbfnew.e1 = (im_event *) malloc (sbfnew.nmax1 * sizeof (im_event));
  sbfnew.e2 = (im_event *) malloc (sbfnew.nmax2 * sizeof (im_event));
  sbfnew.e3 = (im_event *) malloc (sbfnew.nmax3 * sizeof (im_event));
  sbfnew.nz1 = (int *) malloc (numpopsizeparams * sizeof (int));
  /* sbfnew.nz2 = (int *) malloc (numpopsizeparams * sizeof (int)); */
  sbfnew.n = (int *) malloc (numpopsizeparams * sizeof (int));
  sbfnew.lz1 = (int **) malloc (numpopsizeparams * sizeof (int *));
  /* sbfnew.lz2 = (int **) malloc (numpopsizeparams * sizeof (int *)); */
  sbfnew.l = (int **) malloc (numpopsizeparams * sizeof (int *));
  sbfnew.a = (int *) malloc (gi_largestngenes * sizeof (int));
  sbfnew.likes1 = (double *) malloc (gi_largestngenes * sizeof (double));
  sbfnew.likes11 = (double **) malloc (gi_largestngenes * sizeof (double *));
  for (ai = 0; ai < gi_largestngenes; ai++)
    {
      sbfnew.likes11[ai] = (double *) malloc (largestnA * sizeof (double));
    }

  sbfnew.seqz1 = (int *) malloc (gi_largestnumsites * sizeof (int));
  /* sbfnew.seqz2 = (int *) malloc (gi_largestnumsites * sizeof (int)); */
  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      assert (gi_largestngenes > 0);
      sbfnew.lz1[pi] = (int *) malloc (gi_largestngenes * sizeof (int));
      /* sbfnew.lz2[pi] = (int *) malloc (gi_largestngenes * sizeof (int)); */
      sbfnew.l[pi] = (int *) malloc (gi_largestngenes * sizeof (int));
    }

  return 0;
}

int
imaSbfFree ()
{
  int pi, ai;

  free (sbfold.e1);
  sbfold.e1 = NULL;
  sbfold.n1 = 0;
  sbfold.nmax1 = 0;
  free (sbfold.e2);
  sbfold.e2 = NULL;
  sbfold.n2 = 0;
  sbfold.nmax2 = 0;
  free (sbfold.e3);
  sbfold.e3 = NULL;
  sbfold.n3 = 0;
  sbfold.nmax3 = 0;
  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      free (sbfold.lz1[pi]);
      sbfold.lz1[pi] = NULL;
      /* free (sbfold.lz2[pi]); */
      /* sbfold.lz2[pi] = NULL; */
      free (sbfold.l[pi]);
      sbfold.l[pi] = NULL;
    }
  free (sbfold.lz1);
  sbfold.lz1 = NULL;
  /* free (sbfold.lz2); */
  /* sbfold.lz2 = NULL; */
  free (sbfold.l);
  sbfold.l = NULL;
  free (sbfold.nz1);
  sbfold.nz1 = NULL;
  /* free (sbfold.nz2); */
  /* sbfold.nz2 = NULL; */
  free (sbfold.n);
  sbfold.n = NULL;
  free (sbfold.a);
  sbfold.a = NULL;
  free (sbfold.likes1);
  sbfold.likes1 = NULL;
  for (ai = 0; ai < gi_largestngenes; ai++)
    {
      free (sbfold.likes11[ai]);
      sbfold.likes11[ai] = NULL;
    }
  free (sbfold.likes11);
  sbfold.likes11 = NULL;

  XFREE (sbfold.seqz1);
  /* XFREE (sbfold.seqz2); */

  free (sbfnew.e1);
  sbfnew.e1 = NULL;
  sbfnew.n1 = 0;
  sbfnew.nmax1 = 0;
  free (sbfnew.e2);
  sbfnew.e2 = NULL;
  sbfnew.n2 = 0;
  sbfnew.nmax2 = 0;
  free (sbfnew.e3);
  sbfnew.e3 = NULL;
  sbfnew.n3 = 0;
  sbfnew.nmax3 = 0;
  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      free (sbfnew.lz1[pi]);
      sbfnew.lz1[pi] = NULL;
      /* free (sbfnew.lz2[pi]); */
      /* sbfnew.lz2[pi] = NULL; */
      free (sbfnew.l[pi]);
      sbfnew.l[pi] = NULL;
    }
  free (sbfnew.lz1);
  sbfnew.lz1 = NULL;
  /* free (sbfnew.lz2); */
  /* sbfnew.lz2 = NULL; */
  free (sbfnew.l);
  sbfnew.l = NULL;
  free (sbfnew.nz1);
  sbfnew.nz1 = NULL;
  /* free (sbfnew.nz2); */
  /* sbfnew.nz2 = NULL; */
  free (sbfnew.n);
  sbfnew.n = NULL;
  free (sbfnew.a);
  sbfnew.a = NULL;
  free (sbfnew.likes1);
  sbfnew.likes1 = NULL;
  for (ai = 0; ai < gi_largestngenes; ai++)
    {
      free (sbfnew.likes11[ai]);
      sbfnew.likes11[ai] = NULL;
    }
  free (sbfnew.likes11);
  sbfnew.likes11 = NULL;

  XFREE (sbfnew.seqz1);
  /* XFREE (sbfnew.seqz2); */

  return 0;
}

@
\subsubsection{Class Ginfo}
Note that we have [[popnmig]] variable under [[saC]].
FIXME: what does [[popnmig]] do?

Function names should start with ``ima'' that is a package scope. A class scope
of a name will follow it. Next is the method of the class. This could make it
easier to adapt the codes to object oriented programming.
Other functions that are not tied to a class start with a ``verb'' and end with
``objects.'' For example, [[imaInitSagi]] initialize [[saGi]] variables.
<<updateassignment static sagi>>=
static void imaGinfoInit (im_ginfo **g);
static void imaGinfoFree (im_ginfo **g);
static void imaGinfoReset (im_ginfo *g);
static void imaInitSagi ();
static void imaFreeSagi ();
<<updateassignment sagi>>=
void 
imaInitSagi ()
{
  imaGinfoInit (&saGiold);
  imaGinfoInit (&saGioldz1);
  imaGinfoInit (&saGioldz2);
  imaGinfoInit (&saGinew);
  imaGinfoInit (&saGinewz1);
  imaGinfoInit (&saGinewz2);
  return;
}

void 
imaFreeSagi ()
{
  imaGinfoFree (&saGiold);
  imaGinfoFree (&saGioldz1);
  imaGinfoFree (&saGioldz2);
  imaGinfoFree (&saGinew);
  imaGinfoFree (&saGinewz1);
  imaGinfoFree (&saGinewz2);
  return;
}

void 
imaGinfoInit (im_ginfo **g)
{
  int li;
  int pi;

  (*g) = malloc (nloci * sizeof (im_ginfo));
  for (li = 0; li < nloci; li++)
    {
      (*g)[li].cc = malloc (numpopsizeparams * sizeof (int));
      (*g)[li].fc = malloc (numpopsizeparams * sizeof (double));
      (*g)[li].cm = malloc (numpopsizeparams * sizeof (int *));
      (*g)[li].fm = malloc (numpopsizeparams * sizeof (double *));
      (*g)[li].mms = malloc (numpopsizeparams * sizeof (double *));
      for (pi = 0; pi < numpopsizeparams; pi++)
        {
          (*g)[li].cm[pi] = malloc (numpopsizeparams * sizeof (int));
          (*g)[li].fm[pi] = malloc (numpopsizeparams * sizeof (double));
          (*g)[li].mms[pi] = malloc (numpopsizeparams * sizeof (double));
        }
      (*g)[li].ms = malloc (lastperiodnumber * sizeof (double *));
      for (pi = 0; pi < lastperiodnumber; pi++)
        {
          (*g)[li].ms[pi] = malloc (numpopsizeparams * sizeof (double));
        }
      (*g)[li].thetas = malloc (numpopsizeparams * sizeof (double));
    }
  return;
}

void
imaGinfoFree (im_ginfo **g)
{
  int li;
  int pi;

  for (li = 0; li < nloci; li++)
    {
      free ((*g)[li].cc);
      (*g)[li].cc = NULL;
      free ((*g)[li].fc);
      (*g)[li].fc = NULL;
      for (pi = 0; pi < numpopsizeparams ; pi++)
        {
          free ((*g)[li].cm[pi]);
          (*g)[li].cm[pi] = NULL;
          free ((*g)[li].fm[pi]);
          (*g)[li].fm[pi] = NULL;
          free ((*g)[li].mms[pi]);
          (*g)[li].mms[pi] = NULL;
        }
      free ((*g)[li].cm);
      (*g)[li].cm = NULL;
      free ((*g)[li].fm);
      (*g)[li].fm = NULL;
      free ((*g)[li].thetas);
      (*g)[li].thetas = NULL;
      free ((*g)[li].mms);
      (*g)[li].mms = NULL;
      for (pi = 0; pi < lastperiodnumber; pi++)
        {
          free ((*g)[li].ms[pi]);
          (*g)[li].ms[pi] = NULL;
        }
      free ((*g)[li].ms);
      (*g)[li].ms = NULL;
    }
  free (*g);
  (*g) = NULL;
  return;
}

void 
imaGinfoReset (im_ginfo *g)
{
  int ki;
  int pi;
  int pj;

  g->cc = memset (g->cc, 0, numpopsizeparams * sizeof (int));
  g->fc = memset (g->fc, 0, numpopsizeparams * sizeof (double));
  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      g->cm[pi] = memset (g->cm[pi], 0, numpopsizeparams * sizeof (int));
      g->fm[pi] = memset (g->fm[pi], 0, numpopsizeparams * sizeof (double));
      g->mms[pi] = memset (g->mms[pi], 0, numpopsizeparams * sizeof (double));
    }
  for (ki = 0; ki < lastperiodnumber; ki++)
    {
      g->ms[ki] = memset (g->ms[ki], 0, numpopsizeparams * sizeof (double));
    }
  g->thetas = memset (g->thetas, 0, numpopsizeparams * sizeof (double));

  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      assert (g->cc[pi] == 0);
      assert (g->fc[pi] == 0.0);
      for (pj = 0; pj < numpopsizeparams; pj++)
        {
          assert (g->cm[pi][pj] == 0);
          assert (g->fm[pi][pj] == 0.0);
          assert (g->mms[pi][pj] == 0.0);
        }
      assert (g->thetas[pi] == 0.0);
    }
  for (ki = 0; ki < lastperiodnumber; ki++)
    {
      for (pj = 0; pj < numpopsizeparams; pj++)
        {
          assert (g->ms[ki][pj] == 0.0);
        }
    }

  return;
}

@
\subsubsection{Member sassigned}
These functions may be for DNA Barcoding problem, where you want to know a
single gene's assignment given all the rest of gene's assignment being known.
We determine the assignment of a gene by averaging its assignment among possible
populations. We could allow more genes to be assigned for DNA barcoding. We
assume a single gene and a single locus data type.  
<<updateassignment header bar>>=
void imaBarTick ();
void imaBarReset ();
<<updateassignment bar>>=
void
imaBarTick ()
{
  int i;
  int ei;
  int li;
  struct genealogy *G;
  struct edge *gtree;

  assert (assignmentoptions[POPULATIONASSIGNMENTASSIGNED] == 1);
  assert (nloci == 1);
  assert (snind == 1);
  for (li = 0; li < nloci; li++)
    {
      G = &(C[0]->G[li]);
      gtree = G->gtree;

      for (i = 0; i < L[li].numgenesunknown; i++)
        {
          ei =  L[li].numgenesknown + i;
          sassigned[i][gtree[ei].pop] += 1.0;
        }
    }
  return;
}

void
imaBarReset ()
{
  int i;
  int j;
  int li;

  assert (assignmentoptions[POPULATIONASSIGNMENTASSIGNED] == 1);
  assert (nloci == 1);
  assert (snind == 1);
  for (li = 0; li < nloci; li++)
    {
      for (i = 0; i < L[li].numgenesunknown; i++)
        {
          for (j = 0; j < npops; j++)
            {
              sassigned[i][j] = 0.0;
            }
        }
    }
  return;
}

@
\subsubsection{Class Individuals}
Functions [[imaIndInit]], and [[imaIndFree]]:
A ``black box'' takes an input of gene name and locus identifier. Functions
[[imaIndInit]] and [[imaIndFree]] must be used before and after using any
functions that processes the black box. 

DELETE THIS PARAGRAPH:
----------------------
Function [[imaIndFreed]] searches the black box for
gene identifiers in a locus. An approach of using structure may be used. We use
an array of intgers to implement it. Structure [[chain]] has member
[[genelist]]. The size of first dimension is the number of loci, and that of
second dimension is the number genes of a locus. The size of the last dimension
is the number of loci. Each element is [[gsl_block_uint]]. 
We may need a way to list genes of an individual. We may want to have individual
index for a gene. We have member [[iind]] of structure [[edge]]. We have member
[[indlist]] of structure [[chain]].

Functions [[imaGtreeReseti]], 
[[imaGtreeCopyi]], and
[[imaIndSet]]:
It may be easier to separate adding gene names and setting up of
[[genelist]] member. 
Member [[gNames]] contains all names of genes. 
We have a list of gene names for a locus. We may access each name by locus
and gene identifiers. 

We do not worry about computing resource for setting up 
[[genelist]]. 
For each gene of a locus we search for the same name. Whenever we
find one we update [[gsl_block_uint]] members: [[size]] and [[data]]. We use the
same locus and gene identifiers.

Sets $D$ and $D_i$ must be ``compatible'' to each other. 
Elements of sets $D$ and $D_i$ must be indices of individuals whose genes are
extracted. Structure [[edge]] has member [[i]]. 
When identifiers of tip nodes and those of individuals are equal, we do not need
member [[i]]. This may not be usual cases. 

Function [[imaGtreeReseti]] initializes all members [[i]] of structure
[[edge]] $-1$ for all loci. 

Starting from first gene of first
locus we set an index of individual for all genes in [[genelist]] of structure
[[chain]]. Whenever we visit a tip with [[i]] of $-1$ we increase current index
of individuals and set the index to all members [[i]] of tips that are
associated with the tip that we are visiting. Since members [[i]] from 
genealogies from all chains are the same, we set the members for first chain and
copy them for the rest of chains.

Function [[imaGtreeCopyi]] copies members [[i]] of first chain to those of 
the rest of chains.

How do we extend ``perturb'' method to ``scatter'' method? When we have no
migration we are interested in only coalescent events. Nodes may be
connected nodes without migrations. They are labelled the same population.


Function [[imaIndN]]:
We find the number of genes of individual [[k]].

We'd better clean up my codes. There are some codes that have been used for
dealing with individuals. [[genelist]] is one of them.

We try to treat two diploid genes as a single gene. Once we have locus members
ready, then we may create gene trees. Since the number of ``genes'' with combined
diploid genes must be less than or equal to that of actual genes in data, we
have to ``rearrange'' sequence information that has been read in. For example,
function [[parse_locus_info]] sets member [[numgenes]] using the line of locus
information. We may need to find the number of individuals to set [[numgenes]]
to it. Technically, we access the members of structure [[locus]] to change their
values by looking at the names of genes that have been read in function
[[readseqSW]]. Note that we do not allow model [[ISSW]].
Where should I change for updating anything with microsatellite data?
\begin{Verbatim}[frame=lines,framesep=5mm]
build_gtree.c: addA
build_gtree.c: makeSW
\end{Verbatim}

\begin{description}
\item [sngenes\_ind] numbers of genes that belong to an individual, and its size
is equal to global variable [[snind]].
Function [[imaIndInit]] sets it to NULL, and function [[imaIndSet]]
allocates the memory of global variable [[sngenes_ind]]. Function [[imaIndFree]]
deallocates it.
\item [indlist] structure [[edge]] has a member named [[i]] that represents
an individual. The index of an individual is used to list genes that all belong to
the individual. Member variable [[indlist]] of structure [[chain]] is a
two-dimension array of structure [[im_node]]. Usage of structure
[[im_node]] as an elment is just a coincidence because we need a structure
that has two integers for locus and gene identifiers. Structure [[im_node]]
has both of them. We may need another structure for naming issue.
Function [[imaIndInit]] 
allocates memory of variable [[indlist]],
function [[imaIndFree]] deallocates it.
Function [[imaIndSet]] set elements of the variable.
\end{description}

<<updateassignment function header>>=
int imaIndUnknown ();
<<updateassignment ind>>=
int 
imaIndUnknown ()
{
  return snind_unknown;
}

<<updateassignment static ind>>=
static void imaIndInit ();
static void imaIndFree ();
static void imaIndSet ();
static void imaIndSetPairs ();
static void imaGtreeReseti ();
static void imaGtreeCopyi ();
static int imaIndN (int k);
<<updateassignment ind>>=
/*
 * Gene names and individuals
 */
void
imaIndInit ()
{
  sci = 0;
  sngenes_ind = NULL;

  return; 
}

void
imaIndFree ()
{
  int ii;

  free (sngenes_ind);
  sngenes_ind = NULL;

  for (ii = 0; ii < snind; ii++)
    {
      free (saC.indlist[ii]);
      saC.indlist[ii] = NULL;
    }
  free (saC.indlist);
  saC.indlist = NULL;

  for (ii = 0; ii < snind; ii++)
    {
      free (sind2gi[ii]);
      sind2gi[ii] = NULL;
    } 
  free (sind2gi);
  sind2gi = NULL;

  XFREE (sinds);

  return; 
}

void
imaGtreeReseti ()
{
  int ci;
  int li;
  int ei;
  int ngnodes;
  struct genealogy *G = NULL; /* locus li */
  struct edge *gtree = NULL;  /* genealogy of locus li */

  /* initialize */
  for (ci = 0; ci < numchains; ci++)
    {
      for (li = 0; li < nloci; li++)
        {
          G = &C[ci]->G[li];
          gtree = G->gtree;
          ngnodes = L[li].numlines;
          for (ei = 0; ei < ngnodes; ei++)
            {
              gtree[ei].i = -1;
            }
        }
    }
  return;
}

void
imaGtreeCopyi ()
{
  int ci;
  int li;
  int ei;
  int ngenes;
  struct genealogy *G = NULL;     /* locus li */
  struct edge *gtree = NULL;  /* genealogy of locus li */
  struct genealogy *G2 = NULL;    /* locus li */
  struct edge *gtree2 = NULL; /* genealogy of locus li */

  /* initialize */
  for (ci = 1; ci < numchains; ci++)
    {
      for (li = 0; li < nloci; li++)
        {
          G = &(C[0]->G[li]);
          gtree = G->gtree;
          G2 = &(C[ci]->G[li]);
          gtree2 = G2->gtree;
          ngenes = L[li].numgenes;
          for (ei = 0; ei < ngenes; ei++)
            {
              assert (!(gtree[ei].i < 0));
              assert (gtree2[ei].i == -1);
              gtree2[ei].i = gtree[ei].i;
            }
        }
    }
  return;
}
@
These varibles are set:
[[saC.indlist]],
member [[i]],
[[snind]],
[[snind_known]],
[[snind_unknown]], and
[[sind2gi]].
<<updateassignment ind>>=
void
imaIndSet ()
{
  int li;
  int li2;
  int ei;
  int ei2;
  int ii;
  int i;
  int j;
  int k;
  int n;
  int pi;
  int ngenes1;
  int ngenes2;
  char *query;
  int di;
  int *nis;
  int *nii;
  int ngenes;
  struct genealogy *G = NULL;     /* locus li */
  struct edge *gtree = NULL;  /* genealogy of locus li */
  struct edge *gtree2 = NULL; /* genealogy of locus li */
  
  /* set all i's to -1 */
  imaGtreeReseti ();

  /* Known genes are first labelled. 
   * 1. We read a gene with known label. 
   * 2. We search all genes for a gene with known label that has the same name.
   * 3. If we find one with the same name, then we look at the [[i]] if the gene
   *    is already assigned to an individual. If it is, we use the individual
   *    index. 
   * 4. Otherwise, assign the current individual index or [[di]], and increase
   *    [[di]] by one.
   */
  di = 0;
  for (li = 0; li < nloci; li++)
    {
      gtree = C[0]->G[li].gtree;
      ei = 0;
      k = 0;
      for (pi = 0; pi < npops; pi++)
        {
          while (ei < L[li].samppop[pi] + k)
            {
              query = L[li].gNames[ei];

              /* Check if there is another gene with the same name, and an
               * individual index is already assigned. */
              ii = -1;
              for (li2 = 0; li2 < nloci; li2++)
                {
                  ngenes2 = L[li2].numgenesknown;
                  gtree2 = C[0]->G[li2].gtree;
                  for (ei2 = 0; ei2 < ngenes2; ei2++)
                    {
                      if (li == li2 && ei == ei2)
                      {
                        continue;
                      }
                      if (strcmp(query, L[li2].gNames[ei2]) == 0)
                        {
                          /* Check if the gene is already assigned to an
                           * individual. If it is, use the individual index. 
                           */
                          ii = gtree2[ei2].i;
                        }
                      if (ii != -1)
                        {
                          assert (!(ii < 0));
                          break;
                        }
                    }
                  if (ii != -1)
                    {
                      assert (!(ii < 0));
                      break;
                    }
                }
              if (ii < 0)
                {
                  gtree[ei].i = di;
                  di++;
                }
              else
                {
                  gtree[ei].i = ii;
                }
              ei++;
            }
          k += L[li].samppop[pi];
        }
    }
  snind_known = di;

  /* Unknown genes are first labelled. */
  for (li = 0; li < nloci; li++)
    {
      gtree = C[0]->G[li].gtree;
      ei = 0;
      k = 0;
      for (ei = L[li].numgenesknown; ei < L[li].numgenes; ei++)
        {
          query = L[li].gNames[ei];
          /* Check if there is another gene with the same name, and an
           * individual index is already assigned. */
          ii = -1;
          for (li2 = 0; li2 < nloci; li2++)
            {
              gtree2 = C[0]->G[li2].gtree;
              for (ei2 = 0; ei2 < L[li2].numgenesknown; ei2++)
                {
                  if (strcmp(query, L[li2].gNames[ei2]) == 0)
                    {
                      IM_errloc (AT, 
                                 "%d-th unknown gene (%s) at locus %d has the same as %d-th known gene at locus %d",
                                 ei, query, li, ei2, li2);
                    }
                }
              for (ei2 = L[li2].numgenesknown; ei2 < L[li2].numgenes; ei2++)
                {
                  if (li == li2 && ei == ei2)
                  {
                    continue;
                  }
                  if (strcmp(query, L[li2].gNames[ei2]) == 0)
                    {
                      /* Check if the gene is already assigned to an
                       * individual. If it is, use the individual index. 
                       */
                      ii = gtree2[ei2].i;
                    }
                  if (ii != -1)
                    {
                      assert (!(ii < 0));
                      break;
                    }
                }
              if (ii != -1)
                {
                  assert (!(ii < 0));
                  break;
                }
            }
          if (ii < 0)
            {
              gtree[ei].i = di;
              di++;
            }
          else
            {
              gtree[ei].i = ii;
            }
        }
    }
  /* total number of individuals */
  snind = di;
  snind_unknown = snind - snind_known;
  /* copy all i's of a chain to all the rest of chains  */
  imaGtreeCopyi ();

  /* Check if snind is 1. */
  if (assignmentoptions[POPULATIONASSIGNMENTASSIGNED] == 1)
    {
      if (snind != 1)
        {
          IM_errloc (AT, 
                     "A single unknown gene is required: num. of unknown (%d)",
                     snind);
        }
    }


  sinds = malloc (snind_unknown * sizeof (int));

  /* list of genes for an individual */
  saC.indlist = malloc (snind * sizeof(im_node *));
  nis = malloc (snind * sizeof(int));
  nii = malloc (snind * sizeof(int));
  sngenes_ind = malloc (snind * sizeof(int)); 
  for (i = 0; i < snind; i++)
    {
      n = imaIndN (i); 
      nis[i] = n;
      nii[i] = 0;
      /* saC.indlist[i] = malloc (n * sizeof(im_node)); */
      saC.indlist[i] = malloc (nloci * 2 * sizeof(im_node));
    }
  for (li = 0; li < nloci; li++)
    {
      G = &(C[sci]->G[li]);
      gtree = G->gtree;
      ngenes1 = L[li].numgenes;
      for (ei = 0; ei < ngenes1; ei++)
        {
          i = gtree[ei].i;
          j = nii[i];
          saC.indlist[i][j].li = li;
          saC.indlist[i][j].ei = ei;
          nii[i]++;
        }
    }
  for (i = 0; i < snind; i++)
    {
      assert (nis[i] == nii[i]);
      sngenes_ind[i] = nis[i];
    }
  sind2gi = malloc (snind * sizeof (int *));
  for (ii = 0; ii < snind; ii++)
    {
      sind2gi[ii] = malloc (nloci * sizeof (int));
      for (li = 0; li < nloci; li++)
        {
          G = &(C[sci]->G[li]);
          gtree = G->gtree;
          ngenes = L[li].numgenes;
          for (ei = 0; ei < ngenes; ei++)
            {
              if (gtree[ei].i == ii)
                {
                  sind2gi[ii][li] = ei;
                  break;
                }
            }
          if (ei == ngenes)
            {
              sind2gi[ii][li] = -1;
            }
        }
    }
 
  free (nis);
  nis = NULL;
  free (nii);
  nii = NULL;

  /* just print indlist */
  for (i = 0; i < snind; i++)
    {
      printf ("ind [%3d]\t", i);
      for (j = 0; j < sngenes_ind[i]; j++)
        {
          li = saC.indlist[i][j].li;
          ei = saC.indlist[i][j].ei;
          printf ("[%d](%d-%d)\t", j, li, ei);
        }
      printf ("\n");
    }
 
  return;
}

int
imaIndN (int k)
{
  struct genealogy *G = NULL;     /* locus li */
  struct edge *gtree = NULL;  /* genealogy of locus li */
  int li;
  int ei;
  int n;
  int i;
  int ngenes;

  n = 0;
  for (li = 0; li < nloci; li++)
    {
      G = &(C[sci]->G[li]);
      gtree = G->gtree;
      ngenes = L[li].numgenes;
      for (ei = 0; ei < ngenes; ei++)
        {
          i = gtree[ei].i;
          if (i == k)
            {
              n++;
            }
        }
    }
  return n;
}
@
When all [[i]]'s are set, we can use to set [[pairs]] of locus.
\begin{Verbatim}[frame=lines,framesep=5mm]
L[li].pairs[ei] = -1 if ei does not have any counter part of diploid genes
L[li].pairs[ei] = ei2 if ei and ei2 are diploid genes.
\end{Verbatim}
<<updateassignment ind>>=
void
imaIndSetPairs ()
{
  /* can be a function */
  /* set i, pairs */
  int ngenes;
  int li;
  int ei;
  int ei2;
  int ii;
  struct edge *gtree;

  for (li = 0; li < nloci; li++)
    {
      ngenes = L[li].numgenes;
      gtree = C[0]->G[li].gtree;
      for (ei = 0; ei < ngenes; ei++)
        {
          L[li].pairs[ei] = -1;
        }
    }

  for (li = 0; li < nloci; li++)
    {
      ngenes = L[li].numgenes;
      gtree = C[0]->G[li].gtree;
      for (ei = 0; ei < ngenes; ei++)
        {
          ii = gtree[ei].i;
          for (ei2 = 0; ei2 < ngenes; ei2++)
            {
              if (ei == ei2)
                {
                  continue;
                }
              if (gtree[ei2].i == ii)
                {
                  L[li].pairs[ei] = ei2;
                }
            }
        }
    }
  return;
}

@
In addition to the three memory management functions we must call 
[[imaAsnInitAssign]] somewhere around where function 
[[imaAsnSet]] is called. 

[[imaAsnSet]], [[finish_setup_C]]
<<updateassignment header assign>>=
void imaAsnInitAssign (int ci);
<<updateassignment assign>>=
void
imaAsnInitAssign (int ci)
{
  int ii;
  int ij;
  int nei;
  struct genealogy *G; 
  struct edge *gtree; 
  int ei;
  int j;
  int k;
  int li;
  int pi;
  int *m;

  G = NULL;
  gtree = NULL;
  if (assignmentoptions[POPULATIONASSIGNMENT] == 0)
    {
      for (li = 0; li < nloci; li++)
        {
          G = &(C[ci]->G[li]);
          gtree = G->gtree;
          j = 0;
          k = 0;
          for (pi = 0; pi < npops; pi++)
            {
              while (j < L[li].samppop[pi] + k)
                {
                  gtree[j].pop = pi;
                  j++;
                }
              k += L[li].samppop[pi];
            }
        }
    }
  else if (assignmentoptions[POPULATIONASSIGNMENT] == 1)
    {
      m = malloc (snind * sizeof (int));
      for (ii = 0; ii < snind; ii++)
        {
          m[ii] = -2;
        }

      /* We find which individuals are known and which are not. */
      for (li = 0; li < nloci; li++)
        {
          G = &(C[ci]->G[li]);
          gtree = G->gtree;
          j = 0;
          k = 0;
          for (pi = 0; pi < npops; pi++)
            {
              while (j < L[li].samppop[pi] + k)
                {
                  ii = gtree[j].i;
                  if (m[ii] == -2)
                    {
                      m[ii] = pi;
                    }
                  else if (m[ii] == -1)
                    {
                      IM_err (IMERR_INPUTFILEINVALID, 
                              "Some genes of individual (ID: %d) have unknown label",
                              ii); 
                    }
                  else if (m[ii] != pi)
                    {
                      IM_err (IMERR_INPUTFILEINVALID, 
                              "Some genes of individual (ID: %d) are assigned to other label",
                              ii); 
                    }
                  j++;
                }
              k += L[li].samppop[pi];
            }
          while (j < L[li].numgenesunknown + k)
            {
              ii = gtree[j].i;
              if (m[ii] == -2)
                {
                  m[ii] = -1;
                }
              else if (m[ii] != -1)
                {
                  IM_err (IMERR_INPUTFILEINVALID, 
                          "Some genes of individual (ID: %d) have a known label",
                          ii);
                }
              j++;
            }
          if (j != L[li].numgenes)
            {
              IM_err (IMERR_INPUTFILEINVALID, "Invalid initial assignment"); 
            }
        }

      /* Assign individuals of unknown label to a radom population 
       * We want individuals with known labels to appear first, and then
       * individuals with unknown. */
      snind_unknown = 0;
      for (ii = 0; ii < snind; ii++)
        {
          assert (m[ii] > -2);
          if (m[ii] == -1)
            {
              snind_unknown++; 
              m[ii] = randposint (npops);
            }
        }
      snind_known = snind - snind_unknown;
 
      /* Label genes at the tips. */
      for (li = 0; li < nloci; li++)
        {
          G = &(C[ci]->G[li]);
          gtree = G->gtree;
          for (ei = 0; ei < L[li].numgenes; ei++)
            {
              ii = gtree[ei].i;
              assert (!(m[ii] < 0) && m[ii] < npops);
              gtree[ei].pop = m[ii];
            }
        }

      memset (C[ci]->nasn, 0, npops * sizeof (int));

      /* Check if all genes of an individual are assigned to the same label. */
      assert (snind > 0);
      for (ii = 0; ii < snind; ii++)
        {
          nei = sngenes_ind[ii];
          for (ij = 0; ij < nei; ij++)
            {
              li = saC.indlist[ii][ij].li;
              ei = saC.indlist[ii][ij].ei;
              G = &C[ci]->G[li];
              gtree = G->gtree;
              if (gtree[ei].i != ii)
                {
                  IM_err (IMERR_INPUTFILEINVALID, 
                          "Individual ID (%d) and its gene's individual ID (%d) do not match at locus %s %d-th gene",
                          ii, gtree[ei].i, L[li].name, ei + 1); 
                }
              if (gtree[ei].pop != m[ii])
                {
                  IM_err (IMERR_INPUTFILEINVALID, 
                          "The %d-th Gene of Individual (%d) at locus (%s) is assigned to a different population from other genes of the individual",
                          ei + 1, ii, L[li].name); 
                }
            }
          C[ci]->nasn[m[ii]]++;
        }
      free (m);
      m = NULL;
    }

  return;
}

@
\subsubsection{Class Ptree}
[[popnlist]], [[popnlistB]], [[ssizePi]], [[Ps]], and [[popndown]] are set.
\begin{description}
\item [popnlist] a two-dimension array of unsigned integers. The first
dimension is of population nodes, and the second is of periods. Note that
[[popnlist]] and [[genelist]] are of the same type although they are different
in their dimensions (I am not sure if this should be corrected). 
A population emerges at a period and its descendants exist in subsequent
periods. The element of [[popnlist]] is a list of population identifiers that
are descendants of a population (the first dimension) during a period (the
second dimension).
Function [[IMA_popnlist_set]] allocates the memory of variable [[popnlist]] to set
the elements of it, and [[IMA_popnlist_unset]] deallocates it.
\item [popnlistB] a two-dimension array of bit sets. It represents the same
type of elements as those in member variable [[popnlist]].
Function [[IMA_popnlist_set]] allocates the memory of variable [[popnlistB]] to set
the elments of it, and [[IMA_popnlist_unset]] deallocates it.
\item [ssizePi]
\item [Ps] an array of bit sets. Valid populations during a period are in a
bit set. An element of member variable [[popnlistB]] may substitute member
variable [[Ps]].
Function [[IMAscatter_set]] allocates the memory of variable [[Ps]]
to set the elements of it, and [[IMAscatter_unset]] deallocates it.
\item [popndown] a two-dimension array of integers. An element of the matrix
represents the label of the ancestral population during a period (the second
dimension) of a population (the first dimension).
\end{description}

Member [[Ps]] is a powerset of bit sets. We have as many bit sets as
contemporary populations. A bit set of the member [[Ps]] represents a list of 
populations that are possible during a period.
Member [[popndown]] is an integer matrix. A row of the matrix represents one of
populations including ancestral ones. A column of the matrix represents a
period. We want to have population change backward in time when a lineage starts 
at a population during a period and there is no migration along the lineage.
An example of member [[popndown]] is as follows.
\begin{Verbatim}[frame=lines,framesep=5mm]
Integer matrix popndown:
Population
           0 1 2 3 <- period
         0 0 4 4 6
         1 1 4 4 6
         2 2 2 5 6
         3 3 3 5 6
         4 X 4 4 6
         5 X X 5 6
         6 X X X 6

popnlist? Why do we need this? only for popnlistB?
 0     1   2     3   0:(P0:0) 1:(P0:1) 2:(P0:2,P1:2) 3:(P0:3,P1:3) Period 0
 |     |   |     |
 +--4--+   |     |   4:(P2:4,P1:4,P0:0,1)                          Period 1
    |      |     |
    |      +--5--+   5:(P2:5,P1:2,3,P0:2,3)                        Period 2
    |         |
    +----6----+      6:(P3:6,P2:4,5,P1:4,2,3,P0:0,1,2,3)           Period 3
         |
         |
         R

Island model
 0     1   2     3   0:(P0:0) 1:(P0:1) 2:(P0:2) 3:(P0:3)  Period 0
 |     |   |     |
 +-------4-------+   4:(P1:4,P0:0,1,2,3)                  Period 1
         |
         |
         R

\end{Verbatim}
What on earth is [[popnlist]]?
We construct member [[popnlist]] in the following way. All of the elements are
initialized to -1. We start at the second-to-the-last period, which is called a
current period. The previous period is the last period at first.
We have two splited populations at a current period, and one merged population
in the previous period of the current one. 
We maintain a set whose elements are populations that are active. We call it the
active set. The active set is initialized to be a singleton whose element is the
common ancestor of all contemporary populations.
We add splitted populations to the active set, and remove merged populations
from the set. 

We have four steps for the first split
event. First, we set the element of row indexed by
merged population label and column indexed by the previous period to the merged 
population. Second, we set the element of row indexed by the splitted
population label and column indexed by the current period. Third, we copy 
elements of row indexed by the merged population label from column indexed 
by the previous period to those of row indexed by the splited population label. 
Fourth, there are populations in the active set that have not been just added
after removing a merged population. We copy the element of row indexed by a 
population of the populations and column indexed by the previous period to the
element of column indexed by the current period. An example of constructing
member [[popndown]] is as follows.
\begin{Verbatim}[frame=lines,framesep=5mm]
Period 4
Population
           0 1 2 3 <- period
         0 
         1
         2
         3 
         4     
         5    
         6 X X X 6

Period 3
Population
           0 1 2 3 <- period
         0 
         1
         2
         3 
         4     4 6 +
         5     5 6 +
         6 X X X 6 <

Period 2
Population
           0 1 2 3 <- period
         0 
         1 
         2   2 5 6 + 5 6
         3   3 5 6 + 5 6
         4   4 4 6 + copy of 4
         5 X X 5 6 <
         6 X X X 6

Period 1
Population
           0 1 2 3 <- period
         0 0 4 4 6 + 4 4 6
         1 1 4 4 6 + 4 4 6
         2 2 2 5 6 + copy of 2
         3 3 3 5 6 + copy of 3
         4 X 4 4 6 <
         5 X X 5 6
         6 X X X 6
\end{Verbatim}

Function [[imaPtreeSetIsland]] builds a ``tree'' with islands.

[[popnmig]] has the list of populations to which a gene can migrate during a
period. Its dimension is of three: periods, source populations, and sink
populations.


[[popnlist]], [[popnlistB]], [[ssizePi]], [[Ps]], and [[popndown]] are set.
<<updateassignment static ptree>>=
static void imaPtreeSetIsland ();
static void imaPtreeSet ();
static void imaPtreeUnset ();
<<updateassignment ptree>>=
void
imaPtreeSetIsland ()
{
  int ti;
  int ni;
  int pi;
  int i;
  int j;
  int k;
  int npnodes;
  int biti;
  int bitj;
  int n;
  int ip;
  int nperiods;
  int isExist;

  assert (!(npops < 0)); 
  assert (npops < MAXPOPS); 


  npnodes = npops + 1;
  nperiods = 2;


  ssizePi = ((2 * npops - 1) - 1) / 8 + 1;

  assert (lastperiodnumber == 1);

  /* Ps */
  BitPowerSetNew (saC.Ps, ssizePi, nperiods, biti);
  for (ti = 0; ti < lastperiodnumber; ti++)
    {
      for (ni = 0; ni < npops; ni++)
        {
          assert (!(C[sci]->plist[ti][ni] < 0));
          BitTrue (saC.Ps[ti], C[sci]->plist[ti][ni]);
        }
    }
  BitTrue (saC.Ps[1], C[sci]->plist[1][0]);

  /* popndown */
  saC.popndown = malloc ((npops + 1) * sizeof(int *));
  for (pi = 0; pi < npops; pi++)
    {
      saC.popndown[pi] = malloc (nperiods * sizeof(int));
      saC.popndown[pi][0] = pi;
      saC.popndown[pi][1] = npops;
    }
  saC.popndown[npops] = malloc (nperiods * sizeof(int));
  saC.popndown[npops][0] = -1;
  saC.popndown[npops][1] = npops;

  /**********************************************************************/
  /*                           IMA_popnlist_set                         */
  /**********************************************************************/
  assert (!(npops < 0));
  assert (npops < MAXPOPS);

  /* popnlist */
  saC.popnlist = malloc ((npops + 1) * sizeof (int **));
  saC.npopnlist = malloc ((npops + 1) * sizeof (int *));
  assert (nperiods == 2);
  saC.popnlist[npops] = malloc (nperiods * sizeof(int *)); 
  saC.popnlist[npops][1] = malloc (sizeof(int)); 
  saC.popnlist[npops][1][0] = npops;
  saC.popnlist[npops][0] = malloc (npops * sizeof(int)); 

  saC.npopnlist[npops] = malloc (nperiods * sizeof (int));
  saC.npopnlist[npops][1] = 1;
  saC.npopnlist[npops][0] = npops;
  for (i = 0; i < npops; i++)
    {
      saC.popnlist[i] = malloc (nperiods * sizeof(int *)); 
      saC.popnlist[i][1] = NULL;
      saC.popnlist[i][0] = malloc (sizeof(int));
      saC.popnlist[i][0][0] = i;
      saC.popnlist[npops][0][i] = i;

      saC.npopnlist[i] = malloc (nperiods * sizeof (int));
      saC.npopnlist[i][1] = 0;
      saC.npopnlist[i][0] = 1;
    }

/*********************************** DELELE THIS.
  saC.popnlistDELETE = malloc ((npops + 1) * sizeof(gsl_block_uint **));
  saC.popnlistDELETE[npops] = malloc (nperiods * sizeof(gsl_block_uint *)); 
  saC.popnlistDELETE[npops][1] = gsl_block_uint_alloc (1);
  saC.popnlistDELETE[npops][1]->size = 1;
  saC.popnlistDELETE[npops][1]->data[0] = npops;
  saC.popnlistDELETE[npops][0] = gsl_block_uint_alloc (npops);
  saC.popnlistDELETE[npops][0]->size = npops;
  for (i = 0; i < npops; i++)
    {
      saC.popnlistDELETE[i] = malloc (nperiods * sizeof(gsl_block_uint *)); 
      saC.popnlistDELETE[i][1] = NULL;
      saC.popnlistDELETE[i][0] = gsl_block_uint_alloc (1);
      saC.popnlistDELETE[i][0]->size = 1;
      saC.popnlistDELETE[i][0]->data[0] = i;
      saC.popnlistDELETE[npops][0]->data[i] = i;
    }
***********************************/

  /* popnlistB: bit set version of popnlist */
  BitSetPowerSetNew(saC.popnlistB, ssizePi, npnodes, nperiods, biti, bitj);
  for (i = 0; i < npnodes; i++)
    {
      for (j = 0; j < nperiods; j++)
        {
          if (saC.popnlist[i][j] != NULL)
            {
              n = saC.npopnlist[i][j];
              for (k = 0; k < n; k++)
                {
                  ip = saC.popnlist[i][j][k];
                  BitTrue (saC.popnlistB[i][j], ip);
                }
            }
        }
    }

  /**********************************************************************/
  /*                        popnmig nosplit                             */
  /**********************************************************************/
  /* numsplittimes: npops - 1 for tree model, and 0 for island model.   */
  /* We could have a variable for number of periods.                    */
  /* numpopsizeparams: 2*npops - 1 for tree model, and npops for island */
  saC.popnmig = malloc ((numsplittimes + 1) * sizeof (int **));
  for (ti = 0; ti < numsplittimes + 1; ti++)
    {
      saC.popnmig[ti] = malloc (numpopsizeparams * sizeof (int *));
      for (pi = 0; pi < numpopsizeparams; pi++)
        {
          /* #_populations to move for period ti, population pi */
          isExist = 0;
          for (ni = 0; ni < npops - ti; ni++)
            {
              if (C[sci]->plist[ti][ni] == pi)
                {
                  isExist = 1;
                }
            }
          if (isExist == 1)
            {
              n = npops - ti - 1;
            }
          else
            {
              n = 0;
            }

          if (n > 0)
            {
              saC.popnmig[ti][pi] = malloc (n * sizeof (int));
              i = 0;
              for (ni = 0; ni < npops - ti; ni++)
                {
                  if (C[sci]->plist[ti][ni] != pi)
                    {
                      saC.popnmig[ti][pi][i] = C[sci]->plist[ti][ni];
                      i++;
                    }
                }
            }
          else
            {
              saC.popnmig[ti][pi] = NULL;
            }
        }
    }

  return; 
}
@
Much of the setups are not needed. Do we use [[Ps]]? It is the same as
[[periodset]].  We need only one of them, not both.  

[[popndown]] is not a member of struct [[Chain]].
<<updateassignment ptree>>=
void
imaPtreeSet ()
{
  int ti;
  int ni;
  int pi;
  int prevti;
  int i;
  int j;
  int k;
  int isExist;
  int ipExist;
  int sizeExist;
  int npnodes = 2 * npops - 1;
  struct popedge *pnode;
  int biti;
  int bitj;
  int n;
  int ip;

  assert (!(npops < 0)); 
  assert (npops < MAXPOPS); 

  ssizePi = ((2 * npops - 1) - 1) / 8 + 1;

  BitPowerSetNew (saC.Ps, ssizePi, npops, biti);
  for (ti = 0; ti < npops; ti++)
    {
      for (ni = 0; ni < npops - ti; ni++)
        {
          assert (!(C[sci]->plist[ti][ni] < 0));
          BitTrue (saC.Ps[ti], C[sci]->plist[ti][ni]);
        }
    }

  /* WE MAKE A FUNCTION OF THIS POPNDOWN SETUP. */
  saC.popndown = malloc ((2 * npops - 1) * sizeof(int *));
  for (pi = 0; pi < 2 * npops - 1; pi++)
    {
      saC.popndown[pi] = malloc (npops * sizeof(int));
      for (ti = 0; ti < npops; ti++)
        {
          saC.popndown[pi][ti] = -1;
        }
    }
  for (prevti = npops - 1; prevti > 0; prevti--)
    {
      ti = prevti - 1; 
      saC.popndown[C[sci]->addpop[prevti]][prevti] = C[sci]->addpop[prevti];
      saC.popndown[C[sci]->droppops[prevti][0]][ti] = C[sci]->droppops[prevti][0];
      saC.popndown[C[sci]->droppops[prevti][1]][ti] = C[sci]->droppops[prevti][1];
      for (i = prevti; i < npops; i++)
        {
          saC.popndown[C[sci]->droppops[prevti][0]][i] = 
            saC.popndown[C[sci]->addpop[prevti]][i];
          saC.popndown[C[sci]->droppops[prevti][1]][i] = 
            saC.popndown[C[sci]->addpop[prevti]][i];
        }
      for (i = 0; i < 2 * npops - 1; i++)
        {
          if (i == C[sci]->droppops[prevti][0] || i == C[sci]->droppops[prevti][1])
            {
              continue;
            }
          if (BitIsTrue (saC.Ps[ti], i))
            {
              saC.popndown[i][ti] = saC.popndown[i][prevti];
            }
        }
    }

  /**********************************************************************/
  /*                           IMA_popnlist_set                         */
  /**********************************************************************/
  assert (!(npops < 0));
  assert (npops < MAXPOPS);


  saC.popnlist = malloc (npnodes * sizeof (int **));
  saC.npopnlist = malloc (npnodes * sizeof (int *));
  for (i = 0; i < npnodes; i++)
    {
      /* Note: npops == num. of periods */
      saC.popnlist[i] = malloc (npops * sizeof(int *));  
      saC.npopnlist[i] = malloc (npops * sizeof (int));
      for (j = 0; j < npops; j++)
        {
          saC.popnlist[i][j] = NULL;
          saC.npopnlist[i][j] = 0;
        }
    }
  for (i = 0; i < npnodes; i++)
    {
      pnode = &C[sci]->poptree[i]; 
      if (pnode->e == -1)
        {
          k = pnode->b + 1;
        }
      else
        {
          k = pnode->e;
        }
      for (j = pnode->b; j < k; j++)
        {
          saC.popnlist[i][j] = malloc (sizeof (int));
          saC.popnlist[i][j][0] = i;
          saC.npopnlist[i][j] = 1; /* size */
        }
      for (j = pnode->b - 1; !(j < 0); j--)
        {
          isExist = 0; 
          ipExist = -1;
          sizeExist = saC.npopnlist[i][j + 1];
          for (k = 0; k < sizeExist; k++)
            {
              if (saC.popnlist[i][j + 1][k] == C[sci]->addpop[j + 1])
                {
                  isExist = 1;
                  ipExist = k;
                }
            }
          if (isExist == 1)
            {
              saC.popnlist[i][j] = malloc ((sizeExist + 1) * sizeof (int));
              saC.npopnlist[i][j] = sizeExist + 1; /* size */
            }
          else
            {
              saC.popnlist[i][j] = malloc (sizeExist * sizeof (int));
              saC.npopnlist[i][j] = sizeExist; /* size */
            }
          for (k = 0; k < sizeExist; k++)
            {
              saC.popnlist[i][j][k] = saC.popnlist[i][j + 1][k];
            }
          if (isExist == 1)
            {
              saC.popnlist[i][j][sizeExist] = C[sci]->droppops[j + 1][0];
              saC.popnlist[i][j][ipExist] = C[sci]->droppops[j + 1][1];
            }
        }
    }

  /* popnlistB: bit set version of popnlist */
  BitSetPowerSetNew(saC.popnlistB, ssizePi, npnodes, npops, biti, bitj);
  for (i = 0; i < npnodes; i++)
    {
      for (j = 0; j < npops; j++)
        {
          if (saC.popnlist[i][j] != NULL)
            {
              n = saC.npopnlist[i][j];
              for (k = 0; k < n; k++)
                {
                  ip = saC.popnlist[i][j][k];
                  BitTrue (saC.popnlistB[i][j], ip);
                }
            }
        }
    }

  /**********************************************************************/
  /*                       popnmig tree model                           */
  /**********************************************************************/
  /* numsplittimes: npops - 1 for tree model, and 0 for island model.   */
  /* We could have a variable for number of periods.                    */
  /* numpopsizeparams: 2*npops - 1 for tree model, and npops for island */
  saC.popnmig = malloc ((numsplittimes + 1) * sizeof (int **));
  for (ti = 0; ti < lastperiodnumber; ti++)
    {
      saC.popnmig[ti] = malloc (numpopsizeparams * sizeof (int *));
      for (pi = 0; pi < numpopsizeparams; pi++)
        {
          /* #_populations to move for period ti, population pi */
          isExist = 0;
          for (ni = 0; ni < npops - ti; ni++)
            {
              if (C[sci]->plist[ti][ni] == pi)
                {
                  isExist = 1;
                }
            }
          if (isExist == 1)
            {
              n = npops - ti - 1;
            }
          else
            {
              n = 0;
            }

          if (n > 0)
            {
              saC.popnmig[ti][pi] = malloc (n * sizeof (int));
              i = 0;
              for (ni = 0; ni < npops - ti; ni++)
                {
                  if (C[sci]->plist[ti][ni] != pi)
                    {
                      saC.popnmig[ti][pi][i] = C[sci]->plist[ti][ni];
                      i++;
                    }
                }
            }
          else
            {
              saC.popnmig[ti][pi] = NULL;
            }
        }
    }

  return; 
}

void
imaPtreeUnset ()
{
  int pi;
  int i;
  int j;
  int biti;
  int bitj;
  int npnodes; 
  int nperiods;
  int ti;

  if (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 1)
    {
      npnodes = npops + 1;
      nperiods = 2;
    }
  else
    {
      npnodes = 2 * npops - 1;
      nperiods = npops;
    }

  assert (!(npops < 0)); 
  assert (npops < MAXPOPS); 

  BitPowerSetDelete (saC.Ps, nperiods, biti);
  for (pi = 0; pi < npnodes; pi++)
    {
      free (saC.popndown[pi]);
      saC.popndown[pi] = NULL;
    }
  free (saC.popndown);
  saC.popndown = NULL;

  
  /**********************************************************************/
  /*                           IMA_popnlist_set                         */
  /**********************************************************************/
  for (i = 0; i < npnodes; i++)
    {
      for (j = 0; j < nperiods; j++)
        {
          if (saC.popnlist[i][j] != NULL)
            {
              XFREE (saC.popnlist[i][j]);
            }
        }
      XFREE (saC.popnlist[i]);
      XFREE (saC.npopnlist[i]);
    }
  XFREE (saC.popnlist);
  XFREE (saC.npopnlist);
  BitSetPowerSetDelete(saC.popnlistB, npnodes, nperiods, biti, bitj);

  /**********************************************************************/
  /*                               popnmig                              */
  /**********************************************************************/
  for (ti = 0; ti < lastperiodnumber; ti++)
    {
      for (pi = 0; pi < numpopsizeparams; pi++)
        {
          if (saC.popnmig[ti][pi] != NULL)
            {
              free (saC.popnmig[ti][pi]);
              saC.popnmig[ti][pi] = NULL;
            }
        }
      free (saC.popnmig[ti]);
      saC.popnmig[ti] = NULL;
    }
  free (saC.popnmig);
  saC.popnmig = NULL;

  return;
}

@
We use addpop, droppops to set popndown.
\begin{Verbatim}[frame=lines,framesep=5mm]
Phylogeny_setPopndown (&saC.popndown, C[ci]);
\end{Verbatim}
<<updateassignment header ptree>>=
void Phylogeny_setPopndown (int *** popndown, struct chain * t);
void Phylogeny_resetPopndown (int ** popndown, struct chain * t);
<<updateassignment ptree>>=
void
Phylogeny_setPopndown (int *** popndown, struct chain * t)
{
  int pi;
  int ti;
  int i;
  int prevti;

  /* WE MAKE A FUNCTION OF THIS POPNDOWN SETUP. */

  assert (*popndown == NULL);

  *popndown = malloc ((2 * npops - 1) * sizeof(int *));
  for (pi = 0; pi < 2 * npops - 1; pi++)
    {
      (*popndown)[pi] = malloc (npops * sizeof(int));
      for (ti = 0; ti < npops; ti++)
        {
          (*popndown)[pi][ti] = -1;
        }
    }

  Phylogeny_resetPopndown (*popndown, t);
}

void
Phylogeny_resetPopndown (int ** popndown, struct chain * t)
{
  int pi;
  int ti;
  int i;
  int prevti;

  /* WE MAKE A FUNCTION OF THIS POPNDOWN SETUP. */
  assert (popndown != NULL);
  for (pi = 0; pi < 2 * npops - 1; pi++)
    {
      for (ti = 0; ti < npops; ti++)
        {
          (popndown)[pi][ti] = -1;
        }
    }
  for (prevti = npops - 1; prevti > 0; prevti--)
    {
      ti = prevti - 1; 
      (popndown)[t->addpop[prevti]][prevti] = t->addpop[prevti];
      (popndown)[t->droppops[prevti][0]][ti] = t->droppops[prevti][0];
      (popndown)[t->droppops[prevti][1]][ti] = t->droppops[prevti][1];
      for (i = prevti; i < npops; i++)
        {
          (popndown)[t->droppops[prevti][0]][i] = 
            (popndown)[t->addpop[prevti]][i];
          (popndown)[t->droppops[prevti][1]][i] = 
            (popndown)[t->addpop[prevti]][i];
        }
      for (i = 0; i < 2 * npops - 1; i++)
        {
          if (i == t->droppops[prevti][0] || i == t->droppops[prevti][1])
            {
              continue;
            }
          /* if (BitIsTrue (saC.Ps[ti], i)) */
          if (ISELEMENT (i, t->periodset[ti]))
            {
              (popndown)[i][ti] = (popndown)[i][prevti];
            }
        }
    }
}



@
We use [[plist]] to set popnmig.
\begin{Verbatim}[frame=lines,framesep=5mm]
Phylogeny_setPopnmig (&saC.popnmig, C[ci]);
\end{Verbatim}
<<updateassignment header ptree>>=
void Phylogeny_setPopnmig (int **** popnmig, struct chain * t);
<<updateassignment ptree>>=
void
Phylogeny_setPopnmig (int **** popnmig, struct chain * t)
{
  int ti;
  int pi;
  int ni;
  int n;
  int i;
  int isExist;

  /**********************************************************************/
  /*                       popnmig tree model                           */
  /**********************************************************************/
  /* numsplittimes: npops - 1 for tree model, and 0 for island model.   */
  /* We could have a variable for number of periods.                    */
  /* numpopsizeparams: 2*npops - 1 for tree model, and npops for island */

  (*popnmig) = malloc ((numsplittimes + 1) * sizeof (int **));
  for (ti = 0; ti < lastperiodnumber; ti++)
    {
      (*popnmig)[ti] = malloc (numpopsizeparams * sizeof (int *));
      for (pi = 0; pi < numpopsizeparams; pi++)
        {
          /* #_populations to move for period ti, population pi */
          isExist = 0;
          for (ni = 0; ni < npops - ti; ni++)
            {
              if (t->plist[ti][ni] == pi)
                {
                  isExist = 1;
                }
            }
          if (isExist == 1)
            {
              n = npops - ti - 1;
            }
          else
            {
              n = 0;
            }

          if (n > 0)
            {
              (*popnmig)[ti][pi] = malloc (n * sizeof (int));
              i = 0;
              for (ni = 0; ni < npops - ti; ni++)
                {
                  if (t->plist[ti][ni] != pi)
                    {
                      (*popnmig)[ti][pi][i] = t->plist[ti][ni];
                      i++;
                    }
                }
            }
          else
            {
              (*popnmig)[ti][pi] = NULL;
            }
        }
    }
  return;
}

<<updateassignment static ptree>>=
static void imaPnodePrint_node (FILE *fp, struct popedge *ptree, int e);
static void imaPnodePrint (FILE *fp, struct popedge *ptree, int e);
<<updateassignment header ptree>>=
char* imaPtreePrint (int ci);
<<updateassignment ptree>>=
char* 
imaPtreePrint (int ci)
{
  char *ns = NULL;
  FILE *fp;
  struct popedge *ptree = NULL; /* genealogy of locus li */
  
  ptree = C[ci]->poptree;
  fp = fopen ("2.tre", "a");
  imaPnodePrint (fp, ptree, C[ci]->rootpop);
  fclose (fp);
  fp = NULL;
  
  return ns;
}

void 
imaPnodePrint_node (FILE *fp, struct popedge *ptree, int e)
{
  /* fprintf (fp, "%d[%d]", e, ptree[e].pop); */
  fprintf (fp, "%d", e);

  return;
}

void 
imaPnodePrint (FILE *fp, struct popedge *ptree, int e)
{
  int left;
  int right;
  int parent;

  left = ptree[e].up[0];
  right = ptree[e].up[1];
  parent = ptree[e].down;

  assert ((left < 0 && right < 0) || !(left < 0 && right < 0));

  if (left < 0 && right < 0)
    {
      imaPnodePrint_node (fp, ptree, e);
    }
  else
    {
      fprintf (fp, "(");
      imaPnodePrint (fp, ptree, left);
      fprintf (fp, ",");
      imaPnodePrint (fp, ptree, right);
      fprintf (fp, ")");
      imaPnodePrint_node (fp, ptree, e);
    }
  if (parent < 0)
    {
      fprintf (fp, ";\n");
    }
  else
    {
      fprintf (fp, ":%lf", ptree[e].time - ptree[left].time);
    }
  return;
}



@
\subsubsection{Class Saved - Saving and restoring genealogies}
Function [[imaSavedSaveLocusInfo]] saves ``simple'' scalar values not including
complicated ones, and may replace the role of function [[storetreestats]].
Function [[IMA_savelocusgtinfo]] saves member [[gtinfo]], and
it may replace the role of function [[copy_treeinfo]]. Function
[[IMA_savechaingtinfo]] saves member [[allgtinfo]] of a chain, and may replace
the role of function [[copy_treeinfo]]. [[IMA_savechainpcalc]] saves member
[[allpcalc]] of a chain, and may replace the role of function [[copy_probcalc]]. 
Where do we allocate and deallocate memory of [[savedgtinfo]],
[[savedallgtinfo]], and [[savedallpcalc]]?
<<updateassignment static saved>>=
static void imaSavedSaveLocusInfo (int ci, int li);
static void imaSavedRestoreLocusInfo (int ci, int li);
<<updateassignment saved>>=
void
imaSavedSaveLocusInfo (int ci, int li)
{
  int ai;
  struct genealogy *G = NULL;
  G = &(C[ci]->G[li]);
  saT[li].savedroot = G->root;
  saT[li].savedmignum = G->mignum;
  saT[li].savedroottime = G->roottime;
  saT[li].savedlength = G->length;
  saT[li].savedtlength = G->tlength;
  saT[li].savedpdg = G->pdg;        
  for (ai = 0; ai < L[li].nlinked; ai++)
    {
      saT[li].savedpdg_a[ai] = G->pdg_a[ai];
    }
  return;
}

void
imaSavedRestoreLocusInfo (int ci, int li)
{
  int ai;
  struct genealogy *G = NULL;
  G = &(C[ci]->G[li]);
  G->root = saT[li].savedroot;
  G->mignum = saT[li].savedmignum;
  G->roottime = saT[li].savedroottime;
  G->length = saT[li].savedlength;
  G->tlength = saT[li].savedtlength;
  G->pdg = saT[li].savedpdg;
  for (ai = 0; ai < L[li].nlinked; ai++)
    {
      G->pdg_a[ai] = saT[li].savedpdg_a[ai];
    }
  return;
}

@
How do we save a genealogy? How do we restore it? How do we join two edges and
merge two edges? How do we split an edge? We deal with answers to these
questions in this section. As we scramble a genealogy here and there, we have
more edges to save for restore upon rejection of a proposed genealogy. As
an extreme case a proposed genealogy is completely different from its original.
We then would save the original as a whole genealogy. As another extreme case we
may only change the population label of a tip node. We do not deal with those
kinds of extreme cases, rather something in between. 

We have [[im_savedlocus]] type structure with array variable [[scT]]. The members
of the structure used to be in structure [[locus]]. Jody and I discussed
something related to those members, and decided to remove them from structure
[[locus]]. We move those member to those in structure [[im_savedlocus]]. 
We allow member [[saved]]
to grow upon request of more edges to save. We need to know which element of
array [[saved]] corresponds to which of array [[gtree]] for restore of the
element: we have a new member [[ei]] of structure [[edge]]. We keep track of
capacity of array [[saved]] and index of a new element of the array: we
have new members [[savedn]] and [[savedi]]. 

Function [[imaSavedSaveBranch]] adds an edge to array [[saved]]. 
Before adding a given edge we check whether the edge has been added. If the edge
is in array [[saved]], then we does nothing but return. What
members of structure [[edge]] would be saved? Let us list them: connections to 
other edges, time of edge, population of edge, index of edge, and migrations.
Function [[imaSavedFree]] frees memory of members [[saved]] of the
loci of all chains. It deallocates memory of migration events.
Function [[IMA_genealogy_join_edges]] joins edge [[ei1]] and [[ei3]] and
bypasses edge [[ei2]]. Edge [[ei1]] takes all migration events of [[ei2]].
We use function [[joinsisdown]] from [[IMamp]].
We use function [[splitsisdown]] to implement [[IMA_genealogy_split_edges]].
<<updateassignment static saved>>=
static void   imaSavedReset (int li);
static void   imaSavedInit ();
static void   imaSavedFree ();
static int    imaSavedSaveBranch (int ci, int li, int ei);
static void   imaSavedRestore (int ci, int li);
<<updateassignment saved>>=
void 
imaSavedReset (int li)
{
  saT[li].savedi = 0;
  return;
}

@
We allocate [[saT]].
<<updateassignment saved>>=
void 
imaSavedInit ()
{
  int li;
  int ngnodes;
  struct genealogy *G;

  saT = NULL; 

  init_genealogy_weights (&saC.savedallgweight); 
  init_probcalc (&saC.savedallpcalc);
  saT = malloc (nloci * sizeof (im_savedlocus));
  if (saT == NULL)
    {
      IM_err (IMERR_MEM, "saT");
    }
  for (li = 0; li < nloci; li++)
    {
      G = &C[0]->G[li];
      ngnodes = L[li].numlines;
      saT[li].nlinked = L[li].nlinked;
      saT[li].model = L[li].model;
      saT[li].gtree = NULL;
      saT[li].gtree = malloc (ngnodes * sizeof (im_savedlocus));
      if (saT[li].gtree == NULL)
        {
          IM_err (IMERR_MEM, "sat[%d].gtree", li);
        }
      memset (saT[li].gtree, 0, ngnodes * sizeof (im_savedlocus));
      saT[li].saved = NULL;
      saT[li].savedi = 0;
      saT[li].savedn = 0;
      init_genealogy_weights (&saT[li].savedgweight); 
      saT[li].savedpdg_a = NULL;
      saT[li].savedpdg_a = malloc (L[li].nlinked * sizeof (double));
      if (saT[li].savedpdg_a == NULL)
        {
          IM_err (IMERR_MEM, "saT[%d] savedpdg_a", li);
        }
    }

  return;
}

@
We do not deal with all pointers of structure [[edge]].
<<updateassignment saved>>=
void 
imaSavedFree ()
{
  struct edge *saved = NULL; /* genealogy of locus li */
  int savedi;
  int savedn;
  int si;
  int li;
  int ei;
  int ngnodes;
  im_savedlocus *G;

  for (li = 0; li < nloci; li++)
    {
      G = &saT[li];
      saved = G->saved;
      savedi = G->savedi;
      savedn = G->savedn;

      for (si = 0; si < savedn; si++)
        {
          free (saved[si].mig); 
          saved[si].mig = NULL;
          free (saved[si].A);
          saved[si].A = NULL;
          free (saved[si].dlikeA);
          saved[si].dlikeA = NULL;
        }
      free (saved);
      saved = NULL;
      free (G->savedpdg_a);
      G->savedpdg_a = NULL;

      /* member gtree of im_savedlocus */
      ngnodes = L[li].numlines;
      for (ei = 0; ei < ngnodes; ei++)
        {
          if (G->gtree[ei].cmm > 0)
            {
              free (G->gtree[ei].savedmig);
              G->gtree[ei].savedmig = NULL;
              G->gtree[ei].cmm = 0;
            }
        }
      free (G->gtree);
      G->gtree = NULL;
    }
  free (saT);
  saT = NULL;

  return;
}

@
The number of elements in array [[saved]] is equal to [[savedn]]. 
We return the index for the saved edge. If there is already the edge, we return
the index in [[saved]]. If there is no such edge, we add the edge and return the
index for the added edge. Note that we do not return the number of edges saved.
<<updateassignment saved>>=
int
imaSavedSaveBranch (int ci, int li, int ei)
{
  int si;
  int ai;
  int mi;
  int savedi;
  int savedn;
  im_savedlocus *G = NULL;
  struct edge *gtree = NULL;
  struct edge *saved = NULL;

  G = &saT[li];
  gtree = C[ci]->G[li].gtree;
  assert (!(ei < 0));
  assert (ei < L[li].numlines);
  if (!(G->savedi < G->savedn))
    {
      /* allocate more memory of saved */
      G->savedn++;
      G->saved = realloc (G->saved, G->savedn * sizeof(struct edge));
      G->saved[G->savedi].cmm = 0;
      G->saved[G->savedi].mig = NULL;

      G->saved[G->savedi].A = malloc (L[li].nlinked * sizeof (int));
      G->saved[G->savedi].dlikeA = malloc (L[li].nlinked * sizeof (double));

    }
  gtree = C[ci]->G[li].gtree;
  saved = G->saved;
  savedi = G->savedi;
  savedn = G->savedn;

  /* Should we check this loop first?          */
  /* We may use bitset to check the existence. */
  for (si = 0; si < savedi; si++)
    {
      if (saved[si].ei == ei)
        {
          return si;
        }
    }

  saved[savedi].ei = ei;
  saved[savedi].up[0] = gtree[ei].up[0]; 
  saved[savedi].up[1] = gtree[ei].up[1]; 
  saved[savedi].down = gtree[ei].down;
  saved[savedi].time = gtree[ei].time;
  saved[savedi].pop = gtree[ei].pop;

  if (L[li].model == STEPWISE || L[li].model == JOINT_IS_SW)
    {       
      for (ai = (L[li].model == JOINT_IS_SW); 
           ai < L[li].nlinked;
           ai++)
        {
          saved[savedi].A[ai] = gtree[ei].A[ai];
          saved[savedi].dlikeA[ai] = gtree[ei].dlikeA[ai];
        }
    }

  if (modeloptions[NOMIGRATION] == 0)
    {
      if (saved[savedi].cmm < gtree[ei].cmm)
        {
          saved[savedi].cmm = gtree[ei].cmm;
          saved[savedi].mig = realloc (saved[savedi].mig, saved[savedi].cmm *
                                       sizeof (struct migstruct));
        }
      for (mi = 0; mi < gtree[ei].cmm; mi++)
        {
          saved[savedi].mig[mi].mt = gtree[ei].mig[mi].mt;
          saved[savedi].mig[mi].mp = gtree[ei].mig[mi].mp;
          if (gtree[ei].mig[mi].mt < -0.5)
            {
              break;
            }
        }
    }

  G->savedi++;
  return savedi; 
}

void 
imaSavedRestore (int ci, int li)
{
  im_savedlocus *G = NULL;
  struct edge *gtree = NULL; /* genealogy of locus li */
  struct edge *saved = NULL; /* genealogy of locus li */
  int savedi;
  int savedn;
  int mi;
  int si;
  int ei;
  int ai;

  G = &saT[li];
  gtree = C[ci]->G[li].gtree;
  saved = G->saved;
  savedi = G->savedi;
  savedn = G->savedn;

  for (si = 0; si < savedi; si++)
    {
      ei = saved[si].ei;
      assert (!(ei < 0));
      assert (ei < L[li].numlines);
      gtree[ei].up[0] = saved[si].up[0]; 
      gtree[ei].up[1] = saved[si].up[1]; 
      gtree[ei].down = saved[si].down;
      gtree[ei].time = saved[si].time;
      gtree[ei].pop = saved[si].pop;

      if (L[li].model == STEPWISE || L[li].model == JOINT_IS_SW)
        {       
          for (ai = (L[li].model == JOINT_IS_SW); 
               ai < L[li].nlinked;
               ai++)
            {
              gtree[ei].A[ai] = saved[si].A[ai];
              gtree[ei].dlikeA[ai] = saved[si].dlikeA[ai];
            }
        }

      if (modeloptions[NOMIGRATION] == 0)
        {
          for (mi = 0; mi < saved[si].cmm; mi++)
            {
              assert (mi < gtree[ei].cmm);
              gtree[ei].mig[mi].mt = saved[si].mig[mi].mt;
              gtree[ei].mig[mi].mp = saved[si].mig[mi].mp;
              if (gtree[ei].mig[mi].mt < -0.5)
                {
                  break;
                }
            }
        }
    }
  return;
}

@
\subsection{Methods of Asn}
\subsubsection{Construct and Destruct}
There are two functions for initialization and one function for finalization:
[[imaAsnInit]] and [[imaAsnSet]], and
[[imaAsnFree]].
Function [[start_setup_A]] is called function [[setup]]. Depending on assignment
option we set some global variables.
<<updateassignment header asn>>=
void imaAsnInit (void);
void imaAsnFree (void);
<<updateassignment asn>>=
/* initialized before start */
void
imaAsnInit (void)
{
  sbfold.e1 = NULL;
  sbfold.e2 = NULL;
  sbfold.e3 = NULL;
  sbfold.n1 = 0;
  sbfold.n2 = 0;
  sbfold.n3 = 0;
  sbfold.nmax1 = 0;
  sbfold.nmax2 = 0;
  sbfold.nmax3 = 0;
  sbfold.n = NULL;
  sbfold.l = NULL;
  sbfold.seqz1 = NULL;

  sbfnew.e1 = NULL;
  sbfnew.e2 = NULL;
  sbfnew.e3 = NULL;
  sbfnew.n1 = 0;
  sbfnew.n2 = 0;
  sbfnew.n3 = 0;
  sbfnew.nmax1 = 0;
  sbfnew.nmax2 = 0;
  sbfnew.nmax3 = 0;
  sbfnew.n = NULL;
  sbfnew.l = NULL;
  sbfnew.seqz1 = NULL;

  saGiold = NULL;
  saGioldz1 = NULL;
  saGioldz2 = NULL;
  saGinew = NULL;
  saGinewz1 = NULL;
  saGinewz2 = NULL;

  snind = -1;
  snind_known = -1;
  snind_unknown = -1;
  sngenes_ind = NULL;     
  ssizePi = -1;
  sassigned = NULL;
  sind2gi = NULL;        
  sci = -1;
  snnminus1 = NULL;

  snasn = 0;
  return;
}

void
imaAsnFree (void)
{
  int li;
  int i;

  free_genealogy_weights (&saC.savedallgweight);
  free_probcalc (&saC.savedallpcalc);
  for (li = 0; li < nloci; li++)
    {
      free_genealogy_weights (&saT[li].savedgweight);
    }

  imaFreeEdgemiginfo ();
  imaSavedFree ();
  imaIndFree ();

  imaPtreeUnset();

  if (assignmentoptions[POPULATIONASSIGNMENTASSIGNED] == 1)
    {
      assert (nloci == 1);

      for (i = 0; i < L[0].numgenesunknown; i++)
        {
          free (sassigned[i]);
          sassigned[i] = NULL;
        }
      free (sassigned);
      sassigned = NULL;
    }

  imaSbfFree ();
  imaFreeSagi ();
  imaFreeNnminus1 ();


#ifdef COUNT_PRIOR_ASSIGNMENT
  free (saasn);
  saasn = NULL;
#endif /* COUNT_PRIOR_ASSIGNMENT */

  return;
}

@
Initialization after setup of population tree:
There are two main places for memory
initialization and one place for memory finalization. We do some
memory allocation before knowing data especially population tree and gene
trees: function
[[initanymemory]]. We do memory allocation after knowing data: function
[[imaAsnSet]]. Every memory deallocation is done in one
function before exiting program: function [[freeanymemory]].

I may need to separate the initialization function. Let us make one function
with an arbitrary name.

What do we need for handling individuals? We need to know all external branches
whose tip nodes belong to an individual. Member [[indlist]] is used to know all
external edges whose tips belong to an individual. We can know how genes are
related across locu using the following members.
\begin{Verbatim}[frame=lines,framesep=5mm]
snind <- total number of individuals 
indlist[ii][ei] <- individual ii, ei$^{th}$ edge, locus and edge identifiers
sngenes_ind[ii] <- total number of genes or edges whose tips of an individual
sind2gi[ii][li] <- individual ii, li$^{th}$ locus, edge id
L[li].pairs[ei] <- diploid gene edge id of locus li and edge ei
\end{Verbatim}
We have a class named ``Asn,'' which has methods: [[Init]], [[Free]], and
[[Set]]. All of file static variables are considered member variables of the
class. Member variables themselves can be ojects of other class, e.g., [[Ginfo]]
can be a class, which has methods: [[imaGinfoInit]] and [[imaGinfoFree]].
We may change name of the chunk: 
[[updateassignment initfin]] to [[ima asn]] for the tentative class, ``Asn.''
<<updateassignment header asn>>=
void imaAsnSet ();
void imaTreeSet ();
<<updateassignment asn>>=
void
imaAsnSet ()
{
  int i;

  imaInitEdgemiginfo ();
  imaSavedInit ();

  imaIndInit ();
  imaIndSet ();
  imaIndSetPairs ();

  if (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 1)
    {
      imaPtreeSetIsland ();
    }
  else
    {
      imaPtreeSet ();
    }

  if (assignmentoptions[POPULATIONASSIGNMENTASSIGNED] == 1)
    {
      if (nloci != 1)
        {
          IM_errloc (AT, "DNA Barcoding for only a single locus data set");
        }
      sassigned = malloc (L[0].numgenesunknown * sizeof (double *));
      for (i = 0; i < L[0].numgenesunknown; i++)
        {
          sassigned[i] = malloc (npops * sizeof (double));
          memset (sassigned[i], 0, npops * sizeof (double));
        }
    }
  
  imaSbfInit ();
  imaInitSagi ();
  imaInitNnminus1 ();

#ifdef COUNT_PRIOR_ASSIGNMENT
  snasn = IMA_rgf_setSnasn (snind, npops);
  assert (snasn > 0);
  saasn = malloc (snasn * sizeof (int));
  memset (saasn, 0, snasn * sizeof (int));
#endif /* COUNT_PRIOR_ASSIGNMENT */

  /* Check if the given IMa command option and data are compatible. We could
   * have done this check right for some after we read the command line option. 
   * We have * to parse data before we can decide whether the command line 
   * option and data are compatible. WE CHECK THEM HERE NOT IN THE MAIN
   * FUNCTION. 
   * We provide one of two options: assignment or DNA barcoding. This should set
   * proper options. -a1: for assignment, -a2: for DNA barcoding. This should
   * change the assignmentoptions. -a1 sets only POPULATIONASSIGNMENT while -a2
   * sets POPULATIONASSIGNMENT and POPULATIONASSIGNMENTASSIGNED. */
  if (assignmentoptions[POPULATIONASSIGNMENTASSIGNED] == 1 
      && nloci != 1)
    {
      IM_errloc (AT, 
                 "A single locus is allowed for DNA Barcoding: num. of loci (%d)",
                 nloci);
    }
  return;
}

void
imaTreeSet ()
{
  /* imaInitEdgemiginfo (); */
  imaSavedInit ();

  if (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 1)
    {
      imaPtreeSetIsland ();
    }
  else
    {
      imaPtreeSet ();
    }

  return;
}

@
\subsubsection{Record}
The assignment of individuals is recorded in a file with ``.in.p'' suffix.
Function [[init_after_start_IMA]] in [[ima_main.c]] calls function 
[[recordassignment_header]].
We record individual names in ``.tex'' suffix.

<<updateassignment header record>>=
void recordassignment_header (char *fname, int ci, int bIsPerChain);
<<updateassignment record>>=
void 
recordassignment_header (char *fname, int ci, int bIsPerChain)
{
  int li;
  int ii;
  int ei;
  int ki;
  int li2;
  char strName[FNSIZE];
  char *assignfilename;
  int lenname;
  FILE *assignfile = NULL;
  FILE *namefile = NULL;
  FILE *fpassigngenealogy = NULL;

  /* we find individuals for each locus. */
  lenname = 30 + strlen (fname);
  assignfilename = malloc (lenname * sizeof (char));

  if (bIsPerChain == 0)
    {
      strcpy (assignfilename, fname);
      strcat (assignfilename, ".in.p");
      assignfile = fopen (assignfilename, "w");

      strcpy (assignfilename, fname);
      strcat (assignfilename, ".tex");
      namefile = fopen (assignfilename, "w");

      strcpy (assignfilename, fname);
      strcat (assignfilename, ".asn");
    }
  else
    {
      sprintf (assignfilename, "%s.%s.asn", fname, C[ci]->name);
    }
  fpassigngenealogy = fopen (assignfilename, "w");

  if (bIsPerChain == 0)
    {
      if (assignfile == NULL || namefile == NULL)
        {
          IM_err (IMERR_CREATEFILEFAIL, 
                  "Assignment output file cannot be created: %s", 
                  assignfilename);
        }
      fprintf (assignfile, "Gen");
      fprintf (assignfile, "\tlnL");
    }

  fprintf (fpassigngenealogy, "Gen");
  if (bIsPerChain == 1)
    {
      fprintf (fpassigngenealogy, "\tbeta");
      for (ki = 0; ki < numsplittimes; ki++)
        {
          fprintf (fpassigngenealogy, "\tt%d", ki);
        }   
    }
  fprintf (fpassigngenealogy, "\tlnL");

  if (bIsPerChain == 0)
    {
      fprintf (namefile, "\\begin{tabular}{l}\n");
    }
  for (ii = 0; ii < snind; ii++)
    {
      li = 0;
      ei = sind2gi[ii][li];
      if (!(ei < 0))
        {
          removeSpaces (strName, L[li].gNames[ei]);
          if (bIsPerChain == 0)
            {
              fprintf (assignfile, "\tP(%s)", strName);
              fprintf (namefile, "%s\\tabularnewline\n", strName);
            }
          fprintf (fpassigngenealogy, "\tP(%s)", strName);
        }
      else
        {
          /* If the individual does not have genes at first locus, we look for
           * it from the rest of loci. */
          for (li2 = 1; li2 < nloci; li2++)
            {
              ei = sind2gi[ii][li2];
              if (!(ei < 0))
                {
                  removeSpaces (strName, L[li2].gNames[ei]);
                  if (bIsPerChain == 0)
                    {
                      fprintf (assignfile, "\tP(%s)", strName);
                      fprintf (namefile, "%s\\tabularnewline\n", strName);
                    }
                  fprintf (fpassigngenealogy, "\tP(%s)", strName);
                  break;
                }
            }
        }
    }

  if (bIsPerChain == 0)
    {
      fprintf (namefile, "\\end{tabular}\n");
      fprintf (assignfile, "\n");
    }
  fprintf (fpassigngenealogy, "\n");

  if (bIsPerChain == 0)
    {
      fclose (assignfile);
      assignfile = NULL;
      fclose (namefile);
      namefile = NULL;
    }
  fclose (fpassigngenealogy);
  fpassigngenealogy = NULL;
  free (assignfilename);
  assignfilename = NULL;
  return;
}

@
Function [[IMA_ninds]] returns the number of individuals. 
Function [[IMA_nindsunknown]] returns the number of individuals with unknown
origin. These functions are accessors of file static variables. This is more
like ``method'' of a class. We can consider a file a class.
I want to divide [[updateassignment]] module to multiple modules. Each module
can have file static variables that look like member variables of a class.
<<updateassignment header record>>=
int IMA_ninds ();
int IMA_nindsunknown ();
void recordassignment (char *fname, int ci, int gen, int bIsPerChain);
<<updateassignment record>>=
int 
IMA_ninds ()
{
  assert (snind > 0);
  return snind;
}

int 
IMA_nindsunknown ()
{
  assert (!(snind_unknown < 0));
  return snind_unknown;
}

void 
recordassignment (char *fname, int ci, int gen, int bIsPerChain)
{
  int li;
  int ii;
  int ei;
  int ki;
  FILE *assignfile = NULL;
  FILE *fpassigngenealogy = NULL;
  char assignfilename[FNSIZE];
  double pdg;
  int *a = NULL;
  int *pa;

  a = malloc (snind * sizeof (int));

  if (bIsPerChain == 0)
    {
      strcpy (assignfilename, fname);
      strcat (assignfilename, ".in.p");
      assignfile = fopen (assignfilename, "a");
      if (assignfile == NULL)
        { 
          IM_err (IMERR_APPENDFILEFAIL, "Assignment output file cannot be opened: %s", assignfilename);
        }
      fprintf (assignfile, "%d", gen);

      strcpy (assignfilename, fname);
      strcat (assignfilename, ".asn");
    }
  else
    {
      sprintf (assignfilename, "%s.%s.asn", fname, C[ci]->name);
    }

  fpassigngenealogy = fopen (assignfilename, "a");
  if (fpassigngenealogy == NULL)
    { 
      IM_err (IMERR_APPENDFILEFAIL, "Raw assignment output file cannot be opened: %s", assignfilename);
    }
  fprintf (fpassigngenealogy, "%d", gen);
  if (bIsPerChain == 1)
    {
      fprintf (fpassigngenealogy, "\t%lf", beta[ci]);
      for (ki = 0; ki < numsplittimes; ki++)
        {
          fprintf (fpassigngenealogy, "\t%lf", C[ci]->tvals[ki]);
        }   
    }

  pdg = C[ci]->allpcalc.pdg;
  if (bIsPerChain == 0)
    {
      fprintf (assignfile, "\t%lf", pdg);
    }
  fprintf (fpassigngenealogy, "\t%lf", pdg);

  /* how do I know individuals of a locus? */
  pa = a;
  for (ii = 0; ii < snind; ii++)
    {
      li = saC.indlist[ii][0].li;
      ei = saC.indlist[ii][0].ei;
      *pa = C[ci]->G[li].gtree[ei].pop;
      pa++;
    }

  /* A raw assignment is printed out without RGF conversion. */
  pa = a;
  for (ii = 0; ii < snind; ii++)
    {
      fprintf (fpassigngenealogy, "\t%d", *pa);
      pa++;
    }
  fprintf (fpassigngenealogy, "\n");

  /* An assignment is printed out with RGF conversion. */
  if (bIsPerChain == 0)
    {
      IMA_rgs_convert (a, snind);
      pa = a;
      for (ii = 0; ii < snind; ii++)
        {
          fprintf (assignfile, "\t%d", *pa);
          pa++;
        }
      fprintf (assignfile, "\n");
    }

  if (bIsPerChain == 0)
    {
      fclose (assignfile);
      assignfile = NULL;
    }
  fclose (fpassigngenealogy);
  fpassigngenealogy = NULL;
  free (a);
  a = NULL;
 
  return;
}

@
We record assignment when we save genealogies. It would be better to record
steps in both of the recording procedures so that we may be able to associate
a particular genealogy and the corresponding assignment. Function
[[recordassignmentallele]] record a single line for the assignment of all
alleles. Function [[recordassignmentlocus]] records a line per locus. Function
[[recordassignment]] saves the assignment of an individual.

FIXME: Wed Nov  4 21:32:40 EST 2009 - 
We should save the associated genealogy as well.
<<updateassignment header record>>=
void recordassignmentloci (char *fname, int ci);
<<updateassignment record>>=
void 
recordassignmentloci (char *fname, int ci)
{
  static int gen = 0;
#ifdef DEBUG
  int i;
#endif /* DEBUG */

  recordassignment (fname, ci, gen, 0);
#ifdef DEBUG
  if (numchains > 1)
    {
      for (i = 0; i < numchains; i++)
        {
          recordassignment (fname, i, gen, 1);
        }
    }
#endif /* DEBUG */
  gen++;
  return;
}
@
\subsubsection{PrintNumGenesPopn}
We print the number genes that
assigned to populations using function [[imaAsnPrintNumGenesPopn]]. 
<<updateassignment header io>>=
void imaAsnPrintNumGenesPopn (FILE *fp);
void imaAsnPrintNumGenesPopn_stdout ();
<<updateassignment io>>=
void
imaAsnPrintNumGenesPopn_stdout ()
{
  imaAsnPrintNumGenesPopn (stdout);
}

void
imaAsnPrintNumGenesPopn (FILE *fp)
{
  int ii;
  int ei;
  int i;
  int j;
  int li;
  int ngenes[MAXPOPS];
  double sumpops;
  int ci = 0;
  struct edge *gtree = NULL;
  struct genealogy *G = NULL;

  for (i = 0; i < npops; i++)
    {
      ngenes[i] = 0;
    }

  for (ii = 0; ii < snind; ii++)
    {
      li = saC.indlist[ii][0].li;
      ei = saC.indlist[ii][0].ei;
      ngenes[C[0]->G[li].gtree[ei].pop]++;
    } 
     
  fprintf (fp, "Number of genes assigned to populations: ");
  for (i = 0; i < npops; i++)
    {
      fprintf (fp, "[%d] %d\t", i, ngenes[i]);
    }
  fprintf (fp, "\n");
  if (assignmentoptions[POPULATIONASSIGNMENTASSIGNED] == 1)
    {
      assert (nloci == 1);
      li = 0;
      G = &(C[ci]->G[li]);
      gtree = G->gtree;
      fprintf (fp, "Locus [%d]: ", li);
      for (i = L[li].numgenesknown; i < L[li].numgenes; i++)
        {
          fprintf (fp, "gene[%d] -> [%d], ", i, gtree[i].pop);
        }
      fprintf (fp, "\n\n");
      fprintf (fp, "Percentage\n");
      fprintf (fp, "----------\n");

      li = 0;
      for (i = 0; i < L[li].numgenesunknown; i++)
        {
          ei = L[li].numgenesknown + i;
          fprintf (fp, "gene[%d]: ", ei);

          sumpops = 0.0;
          for (j = 0; j < npops; j++)
            {
              sumpops += sassigned[i][j];
            }
          for (j = 0; j < npops; j++)
            {
              fprintf (fp, "[%d] %lf, ", j, sassigned[i][j] / sumpops);
            }
        }
      fprintf (fp, "\n");
    }

  return;
}

@
\subsubsection{Value of assignment}
A value of an assignment:
I thought that I could not any value of an assignment because it is not a value
like sequence alignment. This does not seem be the case. The assignment of
individuals may be numbers, which could be used as an indicator how assignment
parameter sampling behaves. Although there is no meaning in a value of an
assignment, it may be worthwhile to show how assignment parameters sampling from
a posterior distribution behaves.
<<updateassignment header assignment2value>>=
double imaAsnValue (int ci, int li);
<<updateassignment static assignment2value>>=
static double imaAsnValue_mean (int ci, int li);
<<updateassignment assignment2value>>=
double 
imaAsnValue (int ci, int li)
{
  double v;  
  v = imaAsnValue_mean (ci, li);
  return v;
}
double
imaAsnValue_mean (int ci, int li)
{
  double v;
  int ei;
  int ngenes;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;

  v = 0.0;
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  ngenes = L[li].numgenes;
  for (ei = 0; ei < ngenes; ei++)
    {
      v += (double) gtree[ei].pop;
    }
  v /= (double) ngenes; 
  G->asn = v;
  return v; 
}

@
\subsection{Class Gtree}

Find the length of edge [[ei]].
<<updateassignment static gtree>>=
static double imaGtreeBranchLength (int ci, int li, int ei);
<<updateassignment gtree>>=
double
imaGtreeBranchLength (int ci, int li, int ei)
{
  double len;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
    
  assert (ei != G->root);
  len = gtree[ei].time - imaGtreeTime (ci, li, ei);
  return len;
}
@
Function [[imaGtreeSister]] returns sister edge identifier if edge [[ei]]
has its sister. Otherwise, it returns -1.
<<updateassignment static gtree>>=
static int imaGtreeSister (int ci, int li, int ei);
<<updateassignment gtree>>=
int
imaGtreeSister (int ci, int li, int ei)
{
  int v;
  int gparent;

  v = -1;
  gparent = C[ci]->G[li].gtree[ei].down;
  if (!(gparent < 0))
    {
      if (C[ci]->G[li].gtree[gparent].up[0] == ei)
        {
          v = C[ci]->G[li].gtree[gparent].up[1];
        }
      else
        {
          v = C[ci]->G[li].gtree[gparent].up[0];
        }
    }
  return v;
}

@
We return the population label at the top of the lineage.
<<updateassignment static gtree>>=
static int imaGtreePop (int ci, int li, int ei);
<<updateassignment gtree>>=
int
imaGtreePop (int ci, int li, int ei)
{
  return C[ci]->G[li].gtree[ei].pop;
}

@
Function [[imaGtreeTime]] return time at node [[ei]] of the genealogy of
locus [[li]]. Member [[time]] of structure [[edge]] is not the time of node 
that may be assumed. It is the time of parent node. We use one of children of 
a node to find the time at a node.
<<updateassignment static gtree>>=
static double imaGtreeTime (int ci, int li, int ei);
<<updateassignment gtree>>=
double
imaGtreeTime (int ci, int li, int ei)
{
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  int gchild;
  double t;

  G = &(C[ci]->G[li]);
  gtree = G->gtree;

  gchild = gtree[ei].up[0]; /* this may be also up[1]. */
  if (gchild < 0)
    {
      t = 0.0;
    }
  else
    {
      assert (gchild < L[li].numlines);
      t = gtree[gchild].time;
    }
  return t;
}

@
Find the number of migration events below the edge [[ei]].
<<updateassignment static gtree>>=
static int imaGtreeNmig (int ci, int li, int ei);
<<updateassignment gtree>>=
int 
imaGtreeNmig (int ci, int li, int ei)
{
  int n;
  int gparent;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  
  assert (!(ci < 0));
  assert (!(li < 0));
  
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  gparent = gtree[ei].down;

  if (gparent < 0)
    {
      if (gtree[ei].cmm > 0)
        {
          assert (gtree[ei].mig[0].mt < -0.5);
        }
    }

  n = 0;

  if (gtree[ei].cmm > 0)
    {
      while (gtree[ei].mig[n].mt > -0.5)
        {
          n++; 
        }
      assert (!(n < 0));
    }
  
  gtree[ei].nmig = n;
  return n;
}

@
For debug purposes function [[imaGtreePrint]] prints a Newick formated
string of a genealogical tree.
<<updateassignment static gtree>>=
static void imaGnodePrint_node (FILE *fp, struct edge *gtree, int e);
static void imaGnodePrint (FILE *fp, struct edge *gtree, int e);
static void imaGnodePrint_nodeseq (FILE *fp, struct edge *gtree, int e, int si);
void imaGnodePrintseq (FILE *fp, struct edge *gtree, int e, int si);
<<updateassignment gtree>>=
/*
 * Print genealogical trees in Newick formated strings
 */
void 
imaGnodePrint_node (FILE *fp, struct edge *gtree, int e)
{
  int mi;

  fprintf (fp, "%d[%d]", e, gtree[e].pop);

  if (modeloptions[NOMIGRATION] == 0)
    {
      for (mi = 0; mi < gtree[e].cmm; mi++)
        {
          if (gtree[e].mig[mi].mt < -0.5)
            {
              break;
            }
          fprintf (fp, "-[%d@%.1lf]", gtree[e].mig[mi].mp, gtree[e].mig[mi].mt);
        }
    }

  return;
}

void 
imaGnodePrint (FILE *fp, struct edge *gtree, int e)
{
  int left;
  int right;
  int parent;

  left = gtree[e].up[0];
  right = gtree[e].up[1];
  parent = gtree[e].down;

  assert ((left < 0 && right < 0) || !(left < 0 && right < 0));

  if (left < 0 && right < 0)
    {
      imaGnodePrint_node (fp, gtree, e);
    }
  else
    {
      fprintf (fp, "(");
      imaGnodePrint (fp, gtree, left);
      fprintf (fp, ",");
      imaGnodePrint (fp, gtree, right);
      fprintf (fp, ")");
      imaGnodePrint_node (fp, gtree, e);
    }
  if (parent < 0)
    {
      fprintf (fp, ";\n");
    }
  else
    {
      fprintf (fp, ":%lf", gtree[e].time - gtree[left].time);
    }
  return;
}

void 
imaGnodePrint_nodeseq (FILE *fp, struct edge *gtree, int e, int si)
{
  fprintf (fp, "%d[%d]", e, gtree[e].seq[si]);

  return;
}


void 
imaGnodePrintseq (FILE *fp, struct edge *gtree, int e, int si)
{
  int left;
  int right;
  int parent;

  left = gtree[e].up[0];
  right = gtree[e].up[1];
  parent = gtree[e].down;

  assert ((left < 0 && right < 0) || !(left < 0 && right < 0));

  if (left < 0 && right < 0)
    {
      imaGnodePrint_nodeseq (fp, gtree, e, si);
    }
  else
    {
      fprintf (fp, "(");
      imaGnodePrintseq (fp, gtree, left, si);
      fprintf (fp, ",");
      imaGnodePrintseq (fp, gtree, right, si);
      fprintf (fp, ")");
      imaGnodePrint_nodeseq (fp, gtree, e, si);
    }
  if (parent < 0)
    {
      fprintf (fp, ";\n");
    }
  else
    {
      fprintf (fp, ":%lf", gtree[e].time - gtree[left].time);
    }
  return;
}

@
We want to visualize genealogies with migration events and population labels.
Function [[imaGtreePrintall]] prints Newick formatted strings to a file
named [[1.tre]] on the current working directory where we run debugger. 
A program such as [[Figtree]] can visualize genealogies. 
[[funcx]] is only for debug purposes.
<<updateassignment header gtree>>=
char* imaGtreePrint (int ci, int li);
char* imaGtreePrintall (int ci);
char* imaGtreePrintsite (int ci, int li, int si);
char* imaGtreePrintseq (int ci, int li);
void funcx();
<<updateassignment gtree>>=
void 
funcx()
{
  imaGtreePrintall (0);
  return;
}

char* 
imaGtreePrint (int ci, int li)
{
  char *ns = NULL;
  FILE *fp;
  struct genealogy *G = NULL;    /* locus li */
  struct edge *gtree = NULL; /* genealogy of locus li */
  
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  fp = fopen ("1.tre", "a");
  imaGnodePrint (fp, gtree, G->root);
  fclose (fp);
  fp = NULL;
  
  return ns;
}

char* 
imaGtreePrintall (int ci)
{
  char *ns = NULL;
  FILE *fp;
  struct genealogy *G = NULL;    /* locus li */
  struct edge *gtree = NULL; /* genealogy of locus li */
  int li;
  
  fp = fopen ("1.tre", "w");
  for (li = 0; li < nloci; li++)
    {
      G = &(C[ci]->G[li]);
      gtree = G->gtree;
      imaGnodePrint (fp, gtree, G->root);
    }
  fclose (fp);
  fp = NULL;

  return ns;
}

char* 
imaGtreePrintsite (int ci, int li, int si)
{
  char *ns = NULL;
  FILE *fp;
  struct genealogy *G = NULL;    /* locus li */
  struct edge *gtree = NULL; /* genealogy of locus li */
  
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  fp = fopen ("1.tre", "w");
  imaGnodePrintseq (fp, gtree, G->root, si);
  fclose (fp);
  fp = NULL;
  
  return ns;
}

char* 
imaGtreePrintseq (int ci, int li)
{
  int si;
  char *ns = NULL;
  FILE *fp;
  struct genealogy *G = NULL;    /* locus li */
  struct edge *gtree = NULL; /* genealogy of locus li */
  
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  fp = fopen ("1.tre", "w");
  for (si = 0; si < L[li].numsites; si++)
    {
      imaGnodePrintseq (fp, gtree, G->root, si);
    }
  fclose (fp);
  fp = NULL;
  
  return ns;
}

@
\subsection{Miscellaneous functions}
\subsubsection{Comparing events for ordering them in time}

<<updateassignment static>>=
static int im_event_cmp (const void *a, const void *b);
<<updateassignment bf>>=
int 
im_event_cmp (const void *a, const void *b)
{
  const im_event *A = (const im_event *) a;
  const im_event *B = (const im_event *) b;
  if (A->t > B->t)
    return 1;
  else if (A->t < B->t)
    return -1;
  else
    return 0;
}
@
\subsubsection{Utility - String}
<<updateassignment static string>>=
static void removeSpaces (char *s1, const char *s2);
<<updateassignment string>>=
void
removeSpaces (char *s1, const char *s2)
{
  int j;
  int i;
  int len;

  len = strlen (s2);
  j = 0;
  for (i = 0; i < len; i++)
    {
      if (isalnum(s2[i]) 
          || s2[i] == '_' 
          || s2[i] == '-'
          || s2[i] == '@')
        {
          s1[j] = s2[i];
          j++;
        }
    }
  s1[j] = '\0';
  return;
}


@
\subsubsection{Class Chain}
<<updateassignment static chain>>=
static int findperiodoftime (int ci, double ktime);
<<updateassignment chain>>=
int
findperiodoftime (int ci, double ktime)
{
  int ti; 

  ti = 0;
  while (ktime > C[ci]->tvals[ti])
    ti++;

  return ti;

}
 
@
\subsubsection{Debugging functions}
<<updateassignment header debug>>=
void x1 (im_bfupdate *pbf);
int x2 (int old, int li);
int x2print (im_ginfo *gk);
/* void IMA_sbf_print (im_bfupdate *pbf); */
<<updateassignment debug>>=
void
x1 (im_bfupdate *pbf)
/* IMA_sbf_print (im_bfupdate *pbf) */
{
  int i;
  int j;

  printf ("---------\n");
  printf ("Event e1 [%d]:\n", pbf->n1);
  for (i = 0; i < pbf->n1; i++)
    {
      printf ("[%2d] %c - [p:%2d, pi:%2d, pj:%2d] edge [%2d] at %lf\n", 
              i, 
              pbf->e1[i].type,  
              pbf->e1[i].p,
              pbf->e1[i].pi,
              pbf->e1[i].pj,
              pbf->e1[i].ei,
              pbf->e1[i].t);
    }
  printf ("\n"); 

  printf ("---------\n");
  printf ("Event e2 [%d]:\n", pbf->n2);
  for (i = 0; i < pbf->n2; i++)
    {
      printf ("[%2d] %c - [p:%2d, pi:%2d, pj:%2d] edge [%2d] at %lf\n", 
              i, 
              pbf->e2[i].type,  
              pbf->e2[i].p,
              pbf->e2[i].pi,
              pbf->e2[i].pj,
              pbf->e2[i].ei,
              pbf->e2[i].t);
    }
  printf ("\n"); 
 
  printf ("---------\n");
  printf ("Event e3 [%d]:\n", pbf->n3);
  for (i = 0; i < pbf->n3; i++)
    {
      printf ("[%2d] %c - [p:%2d, pi:%2d, pj:%2d] edge [%2d] at %lf\n", 
              i, 
              pbf->e3[i].type,  
              pbf->e3[i].p,
              pbf->e3[i].pi,
              pbf->e3[i].pj,
              pbf->e3[i].ei,
              pbf->e3[i].t);
    }
  printf ("\n"); 

  printf ("---------\n");
  if (pbf->m1 != NULL)
    {
      printf ("z1: edge [%2d], sis [%2d]\n",
              pbf->m1->edgeid, pbf->sis1);
/* 
      printf ("z1: edge [%2d], sis [%2d], down [%2d], downdown [%2d]\n",
              pbf->m1->edgeid, pbf->sis1, pbf->down1, pbf->downdown1);
      printf ("    upt [%lf], sisupt [%lf], sisdnt [%lf]\n",
              pbf->upt1, pbf->sisupt1, pbf->sisdnt1);
*/
      imaEdgemiginfoPrint (pbf->m1);
      printf ("\n");
    }
  else
    {
      printf ("z1:\n");
    }

/* DIPLOID
  printf ("---------\n");
  if (pbf->m2 != NULL)
    {
      printf ("z2: edge [%2d], sis [%2d], down [%2d], downdown [%2d]\n",
              pbf->m2->edgeid, pbf->sis2, pbf->down2, pbf->downdown2);
      printf ("    upt [%lf], sisupt [%lf], sisdnt [%lf]\n",
              pbf->upt2, pbf->sisupt2, pbf->sisdnt2);
      imaEdgemiginfoPrint (pbf->m2);
      printf ("\n");
    }
  else
    {
      printf ("z2:\n");
    }
*/

  printf ("---------\n");
  if (pbf->m3 != NULL)
    {
      printf ("z3:\n");
      imaEdgemiginfoPrint (pbf->m3);
      printf ("\n");
    }
  else
    {
      printf ("z3:\n");
    }

  printf ("---------\n");
  printf ("lz1:\n");
  for (i = 0; i < numpopsizeparams; i++)
    {
      printf ("[%d] %2d: ", i, pbf->nz1[i]);
      for (j = 0; j < pbf->nz1[i]; j++)
        {
          printf (" %2d", pbf->lz1[i][j]);
        }
      printf ("\n");
    }

/* DIPLOID
  printf ("---------\n");
  printf ("lz2:\n");
  for (i = 0; i < numpopsizeparams; i++)
    {
      printf ("[%d] %2d:", i, pbf->nz2[i]);
      for (j = 0; j < pbf->nz2[i]; j++)
        {
          printf (" %2d", pbf->lz2[i][j]);
        }
      printf ("\n");
    }
*/

  printf ("---------\n");
  printf ("l:\n");
  for (i = 0; i < numpopsizeparams; i++)
    {
      printf ("[%d]: %2d\n", i, pbf->n[i]);
    }
   
  return;
}

int
x2 (int old, int li)
{  
  im_ginfo *gk;

  if (old == 0)
    {
      printf ("saGiold\n");
      printf ("-------\n");
      gk = &saGiold[li];
      x2print (gk);
      printf ("saGioldz1\n");
      printf ("-------\n");
      gk = &saGioldz1[li];
      x2print (gk);
    }
  else
    {
      printf ("saGinew\n");
      printf ("-------\n");
      gk = &saGinew[li];
      x2print (gk);
      printf ("saGinewz1\n");
      printf ("-------\n");
      gk = &saGinewz1[li];
      x2print (gk);
    }
  return 0;
}

int
x2print (im_ginfo *gk)
{  
  
  int pi;
  int pj;
  int ti;

  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      printf ("[%d]: cc (%3d) fc (%lf) - theta (%lf)\n", 
              pi, gk->cc[pi], gk->fc[pi], gk->thetas[pi]);
    }

  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      for (pj = 0; pj < numpopsizeparams; pj++)
        {
          if (pi == numpopsizeparams - 1
              || pj == numpopsizeparams - 1)
            {
              continue;
            }
          if (pi == pj)
            {
              continue;
            }
          printf ("[%d -> %d]: cm (%3d) fm (%lf) - mms (%lf)\n", 
                  pi, pj, gk->cm[pi][pj], gk->fm[pi][pj], gk->mms[pi][pj]);
        }
    }

  /* We need number of periods where migrations are allowed. */
  /* npops - 1 for tree model and 1 for tree model.          */
  /* lastperiodnumber is for this                            */
  for (ti = 0; ti < lastperiodnumber; ti++)
    {
      for (pi = 0; pi < numpopsizeparams; pi++)
        {
          if (saC.popnmig[ti][pi] != NULL)
            {
              printf ("[%d, %d], ms (%lf)\n", ti, pi, gk->ms[ti][pi]);
            }
        }
    }
  return 0;
}

@
Function [[BitPrintF]] is used to know the elements of a bit set in a debugger.
<<updateassignment header debug>>=
void  BitPrintF (UByteP A, int size);
<<updateassignment debug>>=
void 
BitPrintF (UByteP A, int size)
{
  int i;
  fprintf (stdout, "Set: ");
  for (i = 0; i < size*8; i++) 
    { 
      if (BitIsTrue (A, i)) 
        { 
          fprintf (stdout, "%d ", i);
        } 
    }
  fprintf (stdout, "\n");
  return;
}

<<updateassignment header debug>>=
void print_popnlist ();
<<updateassignment debug>>=
void
print_popnlist ()
{
  int i;
  int j;
  int k;
  int npnodes = 2 * npops - 1;
  assert (!(npops < 0));
  assert (npops < MAXPOPS);
  for (i = 0; i < npnodes; i++)
    {
      printf ("%d:(", i);
      for (j = 0; j < npops; j++)
        {
          if (saC.popnlist[i][j] != NULL)
            {
              printf ("P%d:", j);
              for (k = 0; k < saC.npopnlist[i][j]; k++)
                {
                  printf ("%d,", saC.popnlist[i][j][k]);
                }
            }
        }
      printf (")\n");
    }
  return;
}

@
\subsection{Assert Genealogies}
There are several things that we want to make sure about genealogies. A
simple usage of function [[assert]] may not suffice. At the outset I wanted
to make sure whether all genealogies population labels are valid with respect
to a population tree. I'd check if a genealogy is a ultrametric
tree. I meant to have ``assertgenealogy'' functions for all update assignment
functions. This is not enough any more because I have different assumptions
for different update assignment functions. We therefore have separate 
subfunctions for ``assertgenealogy'' functions.
Let us see what functions we need.

How do we check whether a genealogy is valid? How do we check whether all
genealogies are valid? What we need is to check whether all of the population 
labels at the events of all genealogies. An edge is checked whether all points
along the edge are ``properly'' labelled. How do we check this? 
All of the tip nodes that belong to the same individual must be labelled the same
population. We may start from a root of a genealogy by traversing a node
recursively. We assume that child node of an edge is properly assigned, and we
check whether all subsequent events backward in time are correctly assigned 
population labels. 
Function [[assertgenealogyedgelabel]] 
checks the validity of a subtree pointed to by the root of the tree calling 
recursively. We assume that the parent node of an edge is assigned to a
population. We go up an edge to check whether next event is
properly assigned to a population considering a give population tree.
We check if a gene tree is ultrametric or heights of a tree are equal:
function [[assertgenealogylocultrametric]].

Function [[assertgenealogyloc]]:
We need the only two functions for external usage: [[assertgenealogy]] and
[[assertgenealogyloc]]. There are three options that we turn on and off:
[[POPASSIGN]], [[NOINDIVIDUAL]], and [[NOMIGRATION]]. 

Function [[assertgenealogy]]:
What should we check? 
We need to check whether all genes of an individual are assigned to the same
population: function [[assertgenealogy_individual]].
We need to check all nodes of genealogies are properly assigned:
[[assertgenealogy_label]]. We may do this for each locus:
[[assertgenealogyloc_label]].

Function [[assertgenealogy_individual]]:
We need to check whether all genes of an individual are assigned to the same
population: function [[assertgenealogy_individual]].
There are [[snind]] many individuals. Each gene is identified by [[li]] and
[[ei]] member of [[indlist]]. The population label [[pop1]] 
of a ``first'' gene is checked whether it is equal to each label [[pop2]] of
all the rest of genes that belong to the same individual.

Function [[assertgenealogylabel]]:
Function [[assertgenealogylabel]] is just for all loci. 
If a node is assigned to a population, its all descendant nodes must be
assigned to the same or descendant populations. This function considers
migration case as well.

The split time update with Nielsen and Wakeley (NW) method implementation is 
not working together with assignment. There is assertion of genealogies with 
NW-assignment update.  
This suite of functions for asserting genealogies should work with and without
the assignment functionality. We should use the assertgenealogy functions with
[[IMamp]] without assignment. 

All assert genealogy functions are removed if [[NDEBUG]] is defined.
<<updateassignment header assertgenealogy>>=
#ifdef NDEBUG
# define assertgenealogy(A)
# define assertgenealogyloc(A,B)
#else
void assertgenealogyloc (int ci, int li);
void assertgenealogy (int ci);
#endif /* NDEBUG */
<<updateassignment static assertgenealogy>>=
/* assertgenealogy */
#ifndef NDEBUG
static void assertgenealogylocdiploid (int ci, int li);
static void assertgenealogyindividual (int ci);
static void assertgenealogyedgelabel (int ci, int li, int ei);
static void assertgenealogylabel (int ci);
static void assertgenealogyloclabel (int ci, int li);
static void assertgenealogyultrametric (int ci);
static void assertgenealogylocultrametric (int ci, int li);
static void assertgenealogylocbranch (int ci, int li);
static void assertgenealogybranch (int ci);
static void IMA_check_popn_up (int kprevperiod, int prevpop, int kperiod, int pop);
static void IMA_check_popn_move (int notpop, int kperiod, int pop);
static void assertgenealogyasn (int ci);
#endif /* NDEBUG */
<<updateassignment assertgenealogy>>=
#ifndef NDEBUG
void
assertgenealogyloc (int ci, int li)
{
  li = 0; /* To avoid compiler complaints. */
  /* FIXME: why there is no use of li? */
  if (modeloptions[NOMIGRATION] == 1)
    {
      /* for not individual? 
       * if (assignmentoptions[POPULATIONASSIGNMENTINDIVIDUAL] == 0) 
          assertgenealogyloclabel (ci, li);
          assertgenealogylocdiploid (ci, li);
       */
      if (assignmentoptions[POPULATIONASSIGNMENTLOCAL] == 0)
        {
          assertgenealogyindividual (ci);
        }
    }
  else
    {
      /* if (assignmentoptions[POPULATIONASSIGNMENTINDIVIDUAL] == 0)
          assertgenealogyloclabel (ci, li);
          assertgenealogylocdiploid (ci, li);
       */ 
      if (assignmentoptions[POPULATIONASSIGNMENTLOCAL] == 0)
        {
          assertgenealogyindividual (ci);
        }
    }
  return;
}

void
assertgenealogy (int ci)
{
  int li;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;

  assertgenealogyultrametric (ci);
  assertgenealogylabel (ci);
  assertgenealogybranch (ci);

  for (li = 0; li < nloci; li++)
    {
      assertgenealogylocdiploid (ci, li);
    }

  if (assignmentoptions[POPULATIONASSIGNMENTLOCAL] == 0)
    {
      assertgenealogyindividual (ci);
    }
  assertgenealogyasn (ci);

  for (li = 0; li < nloci; li++)
    {
      G = &(C[ci]->G[li]);
      gtree = G->gtree;
      if (G->roottime > TIMEMAX / 10)
        {
          assert (0);
        }
    }

  return;
}

void
assertgenealogyasn (int ci)
{
  int i;
  int ii;
  int li;
  int ji;
  int ei;
  int pop1;
  int pop2;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  int ngenes[MAXPOPS];

  for (i = 0; i < npops; i++)
    {
      ngenes[i] = 0;
    }

  for (ii = 0; ii < snind; ii++)
    {
      ji = 0;
      li = saC.indlist[ii][ji].li;
      ei = saC.indlist[ii][ji].ei;
      G = &(C[ci]->G[li]);
      gtree = G->gtree;
      assert (gtree[ei].up[0] < 0 && gtree[ei].up[1] < 0);
      pop1 = gtree[ei].pop;
      for (ji = 1; ji < sngenes_ind[ii]; ji++)
        {
          li = saC.indlist[ii][ji].li;
          ei = saC.indlist[ii][ji].ei;
          G = &(C[ci]->G[li]);
          gtree = G->gtree;
          assert (gtree[ei].up[0] < 0 && gtree[ei].up[1] < 0);
          pop2 = gtree[ei].pop;
          assert (pop1 == pop2);
        }
      ngenes[pop1]++;
    }

  for (i = 0; i < npops; i++)
    {
      assert (ngenes[i] == C[ci]->nasn[i]);
    }

  return;
}

void
assertgenealogyindividual (int ci)
{
  int ii;
  int li;
  int ji;
  int ei;
  int pop1;
  int pop2;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;

  for (ii = 0; ii < snind; ii++)
    {
      ji = 0;
      li = saC.indlist[ii][ji].li;
      ei = saC.indlist[ii][ji].ei;
      G = &(C[ci]->G[li]);
      gtree = G->gtree;
      assert (gtree[ei].up[0] < 0 && gtree[ei].up[1] < 0);
      pop1 = gtree[ei].pop;
      for (ji = 1; ji < sngenes_ind[ii]; ji++)
        {
          li = saC.indlist[ii][ji].li;
          ei = saC.indlist[ii][ji].ei;
          G = &(C[ci]->G[li]);
          gtree = G->gtree;
          assert (gtree[ei].up[0] < 0 && gtree[ei].up[1] < 0);
          pop2 = gtree[ei].pop;
          assert (pop1 == pop2);
        }
    }
  return;
}

void
assertgenealogylocbranch (int ci, int li)
{
  assert (!(ci < 0));  
  assert (!(li < 0));  
  return;
}

void 
assertgenealogybranch (int ci)
{
  int li;
  for (li = 0; li < nloci; li++)
    {
      assertgenealogylocbranch (ci, li);
    }
  return;
}

void
assertgenealogyedgelabel (int ci, int li, int ei)
{
  /* Check all labels of events along a branch! */
  int left;
  int right;
  int gparent;
  int nmigs;
  int mi;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  double ktime;
  double kprevtime;
  int kperiod;
  int kprevperiod;
  int pop;
  int prevpop;
  int ngenes;
  int ngnodes;
 
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  left = gtree[ei].up[0];
  right = gtree[ei].up[1];
  gparent = gtree[ei].down;
  if (modeloptions[NOMIGRATION] == 1)
    {
      nmigs = 0;
    }
  else
    {
      nmigs = imaGtreeNmig (ci, li, ei);
    }
  assert (!(nmigs < 0));

  if (gparent < 0)
    {
      assert (nmigs == 0);
      kprevperiod = -1;
      prevpop = -1;
    }
  else
    {
      ngenes = L[li].numgenes;
      ngnodes = 2 * ngenes - 1;
      assert (gparent < ngnodes);
      assert (!(gtree[gparent].pop < 0));
      kprevtime = gtree[ei].time;
      kprevperiod = findperiodoftime (ci, kprevtime);
      prevpop = gtree[gparent].pop; 
    }
  for (mi = 0; mi < nmigs; mi++)
    {
      ktime = gtree[ei].mig[nmigs - 1 - mi].mt;
      assert (!(ktime < 0.0));
      kperiod = findperiodoftime (ci, ktime);
      assert (!(prevpop < 0));
      pop = gtree[ei].mig[nmigs - 1 - mi].mp;
      IMA_check_popn_up (kprevperiod, prevpop, kperiod, pop);
      prevpop = pop;
      if (mi == nmigs - 1)
        {
          pop = gtree[ei].pop;
        }
      else
        {
          pop = gtree[ei].mig[nmigs - 2 - mi].mp;
        }
      IMA_check_popn_move (prevpop, kperiod, pop);
      assert (!(pop < 0));
      kprevperiod = kperiod;
      prevpop = pop;
    }
  ktime = imaGtreeTime (ci, li, ei);
  kperiod = findperiodoftime (ci, ktime);
  pop = gtree[ei].pop;
  IMA_check_popn_up (kprevperiod, prevpop, kperiod, pop);

  if (left < 0 && right < 0)
    {
      /* No Code */
    }
  else
    {
      assertgenealogyedgelabel (ci, li, left);
      assertgenealogyedgelabel (ci, li, right);
    }
  return;
}

void
assertgenealogylocdiploid (int ci, int li)
{
  int ei;
  int ei2;
  int ngenes;
  struct genealogy *G;
  struct edge *gtree;

  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  ngenes = L[li].numgenes;
  for (ei = 0; ei < ngenes; ei++)
    {
      ei2 = L[li].pairs[ei]; 
      if (ei2 < 0)
        {
          continue;
        }
      else
        {
          assert (gtree[ei].pop == gtree[ei2].pop);
        }
    }
  return;
}

void
assertgenealogylabel (int ci)
{
  int li;

  for (li = 0; li < nloci; li++)
    {
      assertgenealogyloclabel (ci, li);
    }
  return;
}

void
assertgenealogyloclabel (int ci, int li)
{
  struct genealogy *G = NULL;

  G = &(C[ci]->G[li]);
  assertgenealogyedgelabel (ci, li, G->root);

  return;
}

/*
 * New functions
 *
 * assertgenealogy: 
 * We check whether a genealogy is valid. With no migration
 * assumption all internal nodes with the same period are labelled the same
 * population. Tip nodes are labelled the same population as that of their
 * parent nodes if parent nodes are in period 0.
 * Diploid genes must be labelled the same population.
 */

void
assertgenealogyultrametric (int ci)
{
  int li;

  for (li = 0; li < nloci; li++)
    {
      assertgenealogylocultrametric (ci, li);
    }
  return;
}

void
assertgenealogylocultrametric (int ci, int li)
{
  int ngenes;
  int ei;
  int gparent;
  double l;
  double len;
  double lentoroot;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  ngenes = L[li].numgenes;


  for (ei = 0; ei < ngenes; ei++)
    {
      gparent = gtree[ei].down;
      len = imaGtreeBranchLength (ci, li, ei);
      assert (len > 0.00000000000000001);
      while (gparent != G->root)
        {
          l = imaGtreeBranchLength (ci, li, gparent);
          assert (l > 0.00000000000000001);
          len += l;
          gparent = gtree[gparent].down;
        }
      if (ei == 0)
        {
          lentoroot = len;
        }
      assert (fabs(len - lentoroot) < 0.0001);
    }
  return;
}

/* SANGCHUL: I have no other good names for these two functions. */
void
IMA_check_popn_up (int kprevperiod, int prevpop, int kperiod, int pop)
{
  if (!(kprevperiod < 0))
    {
      assert (!(kperiod > kprevperiod));
    }
  assert (!(kperiod < 0));
  assert (kperiod < npops);
  assert (kprevperiod < npops);

  if (kprevperiod < 0) /* a root's population */
    {
      assert (BitIsTrue (saC.Ps[kperiod], pop));
    }
  else /* a non-root's population */
    {
      assert (BitIsTrue (saC.popnlistB[prevpop][kperiod], pop));
    }
  return;
}

void
IMA_check_popn_move (int notpop, int kperiod, int pop)
{
  int ti;
 
  /* [[notpop]] must exist in period [[kperiod]]. */ 
  assert (!(kperiod < 0));
  assert (kperiod < npops);
  assert (BitIsTrue (saC.Ps[kperiod], notpop));
  assert (notpop != pop);

  /* pop does not belong to notpop's descendants. */
  for (ti = kperiod; !(ti < 0); ti--)
    {
      if (BitIsTrue (saC.popnlistB[notpop][ti], pop))
        {
          assert (0);
        }
    }
  
  return;
}
#endif /* NDEBUG */



@
\subsection{Nielsen and Matz 2005}
We describe first the approach of \citet{Nielsen:2006} and that of
our adaptation of \citet{Beerli:1999} to update assignment parameter.
We call the former approach NM05 and the latter BF99. The update of
assignment starts with drawing an individual at random, and ends in
assigning it to a different population. Let us focus on a single genealogy
of a single locus and haploid individuals as an example (Figure 1).
In the exemplary case of a single locus genealogy of haploid individuals,
an individual drawn at random consists of a single gene. The gene
of the individual is then labeled a different population at random.
Figures 1A and 1B are each of the genealogy before and after we label
node 4 from population 2 to 1. As we have two populations in the example,
we label the gene the other population. We could extend this method
to 3 or more populations. Since genes are connected to internal nodes
by branches of a genealogy, population labels at genes are interrelated
to those at internal nodes by branches. Consequently, a new assignment
can render the label at a chosen gene incompatible with the label
at the opposite ending internal node of the external branch, at the
tip of which the chosen gene is placed. Figure 1A shows that the two
labels at nodes C and 4 are both population 2. The incompatibility
occurs where the new label of the gene at node 4 is population 1 and
its parental node C of the external branch is 2 in Figure 1B. As IM
allows migration events along lineages of a genealogy, we can reconcile
the incompatibility by simulating new migration events along the incompatible
external branch. In the example of Figure 1B we add a migration event
along the external branch connecting node 4 and C. 

The assignment update scheme of NM05 described above does not affect
the likelihood because we change neither topology nor branch lengths
of a genealogy. By assuming uniform prior for split time and assignment,
acceptance probability, $\alpha_{\textrm{NM}}(\mathbf{G},\mathbf{t},\mathbf{A}\rightarrow\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*})$
due to \citet{Nielsen:2006} turns into \begin{equation}
\frac{\pi(\mathbf{G}^{*}|\mathbf{t}^{*},\mathbf{A}^{*})}{\pi(\mathbf{G}|\mathbf{t},\mathbf{A})}\frac{q(\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*}\rightarrow\mathbf{G},\mathbf{t},\mathbf{A})}{q(\mathbf{G},\mathbf{t},\mathbf{A}\rightarrow\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*})}.\label{eq:acceptassign}\end{equation}
where the likelihood ratio $f(\mathbf{Y}|\mathbf{G}^{*},\mathbf{A}^{*})/f(\mathbf{Y}|\mathbf{G},\mathbf{A})$
of the acceptance probability does not appear.

Relabel update method could be inefficient for updating multiple genealogies upon
reassigning all gene copies of an individual to other population. We have been 
only interested in assignment that is hard. Instead, we turn to other parameter
such as population tree topology or split time. If we do not have more
information about individualness, or we could pretend to be ignorant of
individualness, then we may allow each gene to be assigned to a particular
population. We may be interested in whether a single population or a
two-population tree model fits data better. 

Although we are aware of infinite variance of harmonic mean estimate for Bayes
factor, it does not mean that we cannot use it.

Yong's population tree update may be useful. At least it would be interesting
for a new split time update. This has something to do with island model that I
had worked on. Jody's method of simulating migration events may be useful to
consider it as a proposal distribution of adding migration events.

We may want to make sure whether we have uniform prior distribution of 
assignment without data. We can check it by counting the number of assignment
with tiny data sets.

Let us simulate two-population and three-population data sets and run each with
different population tree models (e.g., two, three, mayby four, or five). For
each run we record split time and log-likelihood not assignment. The recorded
log-likelihood can be used to compute ``Bayes factor.''


This method is suggested by Jody and it used to be used in DNA Barcoding problem
by Nielsen. The following is a note made by Jody.
\begin{Verbatim}[frame=lines,framesep=5mm]
struct edgemiginfo oldedge1mig;
struct edgemiginfo oldedge2mig;
struct edgemiginfo newedge1mig;
struct edgemiginfo newedge2mig;

Relabel( haploid_or_diploid )  // with migration

Pick individual at random 

Call fillmiginfo
once for oldedge1mig
once for oldedge2mig  //if needed

Pick new population label
set pop for newedge1mig
set pop for newedge2mig // if needed

Call addmigration- return migweight  // Jody will do write this
addmigration_relabel()

With newedge1mig call copynewmig_to_gtree (ci, li);  //need to
change definition of this so it takes a struct edgemiginfo as an
argument
With newedge2mig call copynewmig_to_gtree (ci, li); // if needed 

Reset weights
Recalculate P(G) 

Calculate metropolis hastings and decide if accepted

Write a new function to restore edges using information from
oldedge1mig and oldedge2mi
\end{Verbatim}

Function [[imaSavedRestore]] is used to restore genealogies. 

No migration model cannot be used with ``relabel'' update across loci.
This could be used for DNA barcoding where a single locus data set is prevalent.

Note that we must reset [[allweight]] and [[gweight]].
\begin{Verbatim}[frame=lines,framesep=5mm]
setzero_genealogy_weights (&C[ci]->allgweight);
setzero_genealogy_weights (&C[ci]->G[li].gweight);
treeweight (ci, li);
\end{Verbatim}

We have two functions for the methods of relabeling:
[[updateassignmentrelabel]] and
[[updateassignmentrelabellocus]]. 

We do not consider diploid gene copies. Diploid genes cause lots
of complications without much payoff. 

I do not know if I need 
[[updateassignmentrelabellocus]] since I doubt that allowing each gene its own
assignment is a good way to go. 

Which function is used right now? I have to choose one of them.

\begin{Verbatim}[frame=lines,framesep=5mm]
Island model must be in -j option.
1 Population Assignment, BF99 update, -a7 should be turned on
2 DNA Barcoding, NM05 update, -a4 should be turned on
-j6 is no migration. BF99 can be implemented for no migration case.
NM05 can be implemented for no migration case as well.
-a1 : Assignment, Print structurama output, BF99 or NM05 or both
-a2 : DNA Barcoding, Print info. for DNA Barcoding, BF99 or NM05 or both
-a1 -j6 : Assignment with no-migration
-a2 -j6 : DNA Barcoding with no-migration
-a13 : Assignment with island model
-a23 : DNA Barcoding with island model
\end{Verbatim}

<<updateassignment function header>>=
int updateassignmentrelabel (int ci);
<<updateassignment relabel>>=
int
updateassignmentrelabel (int ci)
{
  int accp;                   /* accept (1) or reject (0)            */
  double logweight;           /* MH ratio                            */
  double logU;                /* log uniform                         */
  double tpw;                 /* log [p(G*)/p(G)]                    */
  double migweight;           /* hastings ratio for migration update */
  struct genealogy *G;        /* locus li                            */
  int mpart;
  int li;
  int nmigaftertreeweight;

  /* declarations must precede any statement for compatibility with Visual C++
   * compiler */
  G = NULL;
  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }

  if (ci == 0)
    {
      for (li = 0; li < nloci; li++)
        {
          L[li].a_rec->upinf[IM_UPDATE_ASSIGNMENT_RELABEL].tries++;
        }
    }
  Cupinf[ci].upinf[IM_UPDATE_ASSIGNMENT_RELABEL].tries++;

  /* save the current state of a chain */
  for (li = 0; li < nloci; li++)
    {
      imaSavedReset (li);
      imaSavedSaveLocusInfo (ci, li);
      copy_treeinfo (&saT[li].savedgweight, &C[ci]->G[li].gweight);
    }
  copy_treeinfo (&saC.savedallgweight, &C[ci]->allgweight);
  copy_probcalc (&saC.savedallpcalc, &C[ci]->allpcalc);

  /* the key proposal function of relabel method */
  migweight = relabel (ci, &mpart);

  if (migweight < REJECTINFINITESITESCONSTANT + 1.0)
    {
      /* Reject it. */
      accp = 0;
    }
  else
    {
      accp = 1;
      /* compute Metropolis-ratio */
      setzero_genealogy_weights (&C[ci]->allgweight);
      for (li = 0; li < nloci; li++)
        {
          setzero_genealogy_weights (&C[ci]->G[li].gweight);
          treeweight (ci, li);
          sum_treeinfo (&C[ci]->allgweight, &C[ci]->G[li].gweight);
        }
      /* check if the number of migration events after the call of treeweight is the
       * same as the number of migration events from update */
      nmigaftertreeweight = 0;
      for (li = 0; li < nloci; li++)
        {
           nmigaftertreeweight += C[ci]->G[li].mignum; 
        }
      assert (nmigaftertreeweight == mpart);
      /* We use allgweight to compute allpcalc */
      initialize_integrate_tree_prob (ci, &C[ci]->allgweight, &C[ci]->allpcalc);

      /* Log[p(G*)] - Log[p(G)] is [[tpw]] */
      tpw = C[ci]->allpcalc.probg - saC.savedallpcalc.probg;

      logU = log(uniform ());
      logweight = beta[ci] * tpw + migweight;
      assert (beta[ci] * tpw + migweight > -1e200
              && beta[ci] * tpw + migweight < 1e200);
    }

  if (accp == 1 && (logweight > 0.0 || logweight > logU))
    {
      /* accept the update */
      accp = 1;
      if (ci == 0)
        {
          for (li = 0; li < nloci; li++)
            {
              L[li].a_rec->upinf[IM_UPDATE_ASSIGNMENT_RELABEL].accp++;
            }
        }
      Cupinf[ci].upinf[IM_UPDATE_ASSIGNMENT_RELABEL].accp++;
      C[ci]->nasn[sbfold.pop]--;
      C[ci]->nasn[sbfnew.pop]++;
    }
  else
    {
      accp = 0;
      for (li = 0; li < nloci; li++)
        {
          /* restore edges changed during update */
          imaSavedRestore (ci, li); 
          imaSavedRestoreLocusInfo (ci, li);
          copy_treeinfo (&C[ci]->G[li].gweight, &saT[li].savedgweight);
        }
      copy_probcalc (&C[ci]->allpcalc, &saC.savedallpcalc);
      copy_treeinfo (&C[ci]->allgweight, &saC.savedallgweight);
    }

  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }
  return accp;
}

@
We only need to move genes that are yet assigned. We do not know which
individuals are not yet assigned.

Function [[relabel]] can be called for assignment as well as DNA barcoding.

FIXME: no migration case check?
FIXME: partial known genes check?


<<updateassignment static>>=
static double relabel (int ci, int *mpart);
<<updateassignment relabel>>=
double
relabel (int ci, int *mpart)
{
  int li;
  int ei;
  double logprob;
  int newpop;
  int oldpop;
  int oldmigcount[MAXLOCI];
  int newmigcount[MAXLOCI];
  struct genealogy *G;
  struct edge *gtree; 
  int ii;
  int ij;
  int nei;
  double t;
  int ki;
  int minki;
  int ni;
  int down;

  /* Pick an individual to relabel. */
  if (modeloptions[NOMIGRATION] == 0)
    {
      ii = snind_known + randposint (snind_unknown);
    }
  else
    {
      ni = 0;
      for (ii = snind_known; ii < snind; ii++)
        {
          nei = sngenes_ind[ii];
          for (ij = 0; ij < nei; ij++)
            {
              li = saC.indlist[ii][ij].li;
              ei = saC.indlist[ii][ij].ei;
              down = C[ci]->G[li].gtree[ei].down;
              if (C[ci]->G[li].gtree[down].pop == C[ci]->G[li].gtree[ei].pop) 
                {
                  break;
                }
            }
          if (ij == nei)
            {
              sinds[ni] = ii;
              ni++;
            }
        }
      if (ni == 0)
        {
          logprob = REJECTINFINITESITESCONSTANT;
          return logprob;
        }
      else
        {
          ii = sinds[randposint (ni)]; 
        }
    }

  /* relabel the selected genes: newpop is chosen with logprob */
  /* we need a list of edge mig info structures */
  li = saC.indlist[ii][0].li;
  ei = saC.indlist[ii][0].ei;
  G = &C[ci]->G[li];
  gtree = G->gtree;
  oldpop = gtree[ei].pop;
  sbfold.pop = oldpop;

  if (modeloptions[NOMIGRATION] == 0)
    {
      logprob = imaRandomPickpopn (&newpop, ci, oldpop, C[ci]->rootpop);
    }
  else
    {
      /* We can only move to descendents of the ancestor. */
      minki = npops;
      nei = sngenes_ind[ii];
      for (ij = 0; ij < nei; ij++)
        {
          li = saC.indlist[ii][ij].li;
          ei = saC.indlist[ii][ij].ei;
          t = C[ci]->G[li].gtree[ei].time;
          ki = findperiodoftime (ci, t);
          if (minki > ki)
            {
              minki = ki;
            }
        }
      /* pop and minki are used to propose a new pop. */
      newpop = oldpop;
      while (newpop == oldpop)
        {
          newpop = randposint (npops);
          if (saC.popndown[newpop][minki] != saC.popndown[oldpop][minki])
            {
              newpop = oldpop;
            }
        }
      logprob = 0.0;
    }
  sbfnew.pop = newpop;

  nei = sngenes_ind[ii];
  for (ij = 0; ij < nei; ij++)
    {
      li = saC.indlist[ii][ij].li;
      ei = saC.indlist[ii][ij].ei;
      imaSavedSaveBranch (ci, li, ei);
    }

  for (ij = 0; ij < nei; ij++)
    {
      li = saC.indlist[ii][ij].li;
      ei = saC.indlist[ii][ij].ei;

      /* This should work with NOMIGRATION. */
      IMA_edge_fillmiginfo (ci, li, ei, &saoems[ij]); 
    }

  for (li = 0; li < nloci; li++)
    {
      oldmigcount[li] = C[ci]->G[li].mignum;
    }

  for (ij = 0; ij < nei; ij++)
    {
      li = saC.indlist[ii][ij].li;
      ei = saC.indlist[ii][ij].ei;
      C[ci]->G[li].gtree[ei].mig[0].mt = -1;
      if (modeloptions[NOMIGRATION] == 0)
        {
          logprob += addmigration_relabel (ci, li, newpop, 
                                           oldmigcount[li],
                                           &newmigcount[li],
                                           &saoems[ij], &sanems[ij]);
        }
      else
        {
          /* We check if edge's old pop and new pop share the same ancestral
           * population.  
           * FIXME: this will lead to high rejection rates. We may figure out
           * which individual can move to other population. We may have to pick
           * individuals that can move.
           */
          oldmigcount[li] = 0;
          newmigcount[li] = 0;
          t = C[ci]->G[li].gtree[ei].time;
          ki = findperiodoftime (ci, t);
          if (saC.popndown[oldpop][ki] != saC.popndown[newpop][ki])
            {
              /* Proposed label cannot move. */
              logprob = REJECTINFINITESITESCONSTANT;
              break;
            }
        }
      oldmigcount[li] = newmigcount[li];
    }
 
  *mpart = 0;
  if (modeloptions[NOMIGRATION] == 0)
    {
      for (li = 0; li < nloci; li++)
        {
          *mpart += oldmigcount[li];
        }

      for (ij = 0; ij < nei; ij++)
        {
          li = saC.indlist[ii][ij].li;
          ei = saC.indlist[ii][ij].ei;
          assert (sanems[ij].edgeid == ei);
          assert (sanems[ij].li == li);

          /* This should work with NOMIGRATION. */
          IMA_edge_copynewmig (ci, li, &sanems[ij]);
        }
    }

  if (logprob > REJECTINFINITESITESCONSTANT)
    {
      for (ij = 0; ij < nei; ij++)
        {
          li = saC.indlist[ii][ij].li;
          ei = saC.indlist[ii][ij].ei;
          gtree = C[ci]->G[li].gtree;
          gtree[ei].pop = newpop;
        }
    }

  return logprob;
}
@
This is one of functions that I do not know what it is at first sight.
<<updateassignment static>>=
static void IMA_edge_fillmiginfo (int ci, int li, int ei, 
                                  struct edgemiginfo *em);
<<updateassignment relabel>>=
void
IMA_edge_fillmiginfo (int ci, int li, int ei, 
                      struct edgemiginfo *em)
{
  int i;
  int j;
  int down;                        /* down edge             */
  struct genealogy *G;             /* locus li              */
  struct edge *gtree;              /* genealogy of locus li */

  G = &(C[ci]->G[li]);
  gtree = G->gtree;
  down = gtree[ei].down;

  /*******************************************************/
  /* oldedgemig                                          */
  /*******************************************************/
  IMA_reset_edgemiginfo (em);
  em->li = li;
  em->sisid = -1; /* do we need sisid? */
  em->edgeid = ei;
  em->upt = imaGtreeTime (ci, li, ei);
  em->dnt = gtree[ei].time;
  em->pop = gtree[ei].pop;
  em->temppop = gtree[ei].pop;
  em->fpop = gtree[down].pop;
  /* b, e, mtimeavail, and mtall are set. */
  fillmiginfoperiods (ci, em);
  /* migration events are copied */
  em->mig[0].mt = -1.0;
  for (j = 0; j <= em->b; j++)
    {
      em->mp[j] = 0;
    }
  em->mpall = 0;

  i = 0;
  j = em->b;
  while (gtree[ei].mig[i].mt > -0.5)
    {
      while (gtree[ei].mig[i].mt > C[ci]->tvals[j])
        {
          j++;
          em->mp[j] = 0;
        }
      em->mp[j]++;
      em->mpall++;
      em->mig[i] = gtree[ei].mig[i];
      i++;
    }
  em->mig[i].mt = -1;

  return;
}
@
This is also a function that I do not know what it is at the sight.
<<updateassignment static>>=
void IMA_edge_copynewmig (int ci, int li, struct edgemiginfo *em);
<<updateassignment relabel>>=
void
IMA_edge_copynewmig (int ci, int li, struct edgemiginfo *em)
{
  int i;
  int ei;
  struct edge *gtree;              /* genealogy of locus li */
  
  ei = em->edgeid;
  gtree = C[ci]->G[li].gtree;

  i = 0;
  while (em->mig[i].mt > 0)
    {
      checkmigt (i, &gtree[ei]);
      copymig (&(gtree[ei].mig[i]), &(em->mig[i]));
      i++;
    }
  gtree[ei].mig[i].mt = -1;
  return;
}


@
Function [[imaRandomPickpopn]] randomly pick a label among populations of the first
period that are descendants of ancestral population [[apop]]. The population
must not be the same as [[pop]]. It returns the log probability to choose a
population and the elected population [[topop]].

We need an array of numbers of individuals assigned to populations.
<<updateassignment static>>=
static double imaRandomPickpopn (int *topop, int ci, int pop, int apop);
<<updateassignment relabel>>=
double
imaRandomPickpopn (int *topop, int ci, int pop, int apop)
{
  double v;
  int n;
  int ip;
  int pi;
  int nzero;

  *topop = pop;
  n = saC.npopnlist[apop][0];
  assert (!(apop < npops));
  while (*topop == pop)
    {
      ip = randposint (n);
      *topop = saC.popnlist[apop][0][ip];
    }
  assert (n > 1);
  /* v = -log ((double) (n - 1)); */

  nzero = 0;
  for (pi = 0; pi < npops; pi++)
    {
      if (C[ci]->nasn[pi] == 0)
        {
          nzero++;
        }
    }
  assert (C[ci]->nasn[pop] > 0);
  v = 0.0;
  if (C[ci]->nasn[pop] == 1 && nzero > 0 && C[ci]->nasn[*topop] > 0)
    {
      v = log ((double) (nzero + 1.0));
    }
  else if (C[ci]->nasn[pop] > 1 && nzero > 1 && C[ci]->nasn[*topop] == 0)
    {
      v = -log ((double) (nzero));
    }

  return v;
}

<<updateassignment static>>=
static double addmigration_relabel (int ci, int li, int newpop, 
                                    int oldmigcount,
                                    int *newmigcount,
                                    struct edgemiginfo *olde, 
                                    struct edgemiginfo *newe);

@
getm and mwork should be reivsed. There were significant changes to getm and
mwork. This is used with relabel methods. I just do not compile lines of getm
and mwork.
<<updateassignment relabel>>=
double
addmigration_relabel (int ci, int li, int newpop, 
                      int oldmigcount,
                      int *newmigcount,
                      struct edgemiginfo *olde, 
                      struct edgemiginfo *newe)
{
  int edge;
  double weight;
  double mproposenum, mproposedenom;
  double mparamf, mparamb;
  struct edge *gtree; 
  int mcount;

  gtree = C[ci]->G[li].gtree;
  assert (C[ci]->G[li].mignum >= 0 );
  /* determine current migration rate to use for update */
  
  /* To reflect Jody's comment: we use overall migration rates of a genealogy.
   * This may help assignment update a little bit. 
   * mparamf = calcmrate (olde->mpall, olde->mtall); */
  mparamf = calcmrate (C[ci]->G[li].mignum, C[ci]->G[li].tlength);

  IMA_reset_edgemiginfo (newe);
  assert(olde->edgeid < L[li].numgenes);
  newe->edgeid = edge = olde->edgeid;
  /* We need li to call checkmig in function simmpath. */
  newe->li = olde->li = li;
  newe->pop = newpop;
  newe->temppop = newpop;
  assert (olde->fpop == gtree[gtree[edge].down].pop);
  newe->fpop = olde->fpop;
  newe->upt = 0.0; /* because we only deal with external branches */
  newe->dnt = gtree[edge].time;
  newe->mig[0].mt = -1;
  fillmiginfoperiods (ci, newe);
  /* newe->mpall = mwork (ci, newe, newe->e, mparamf); TURN ON THIS LATER */
  assert (newe->mtall > 0);    // some of the edge must occur before the last split time

  fprintf (stderr, "relabel should not be called for the moment\n");
  /* mproposedenom = getmprob (ci, mparamf, newe, NULL); TURN ON THIS LATER */
  assert (mproposedenom > -1e200 && mproposedenom < 1e200);

  /* calculate probability of reverse update    */
  mcount = oldmigcount - olde->mpall + newe->mpall;
  
  /* find the migation rate for the backward update */
  /* To reflect Jody's comment: we use overall migration rates of a genealogy.
   * This may help assignment update a little bit. 
   * mparamb = calcmrate (newe->mpall, newe->mtall); */
  mparamb = calcmrate (mcount, C[ci]->G[li].tlength);
  assert (mparamb > 0);

  /* mproposenum = getmprob (ci, mparamb, olde, NULL); TURN ON THIS LATER */
  assert (mproposenum > -1e200 && mproposenum < 1e200);
  weight = mproposenum - mproposedenom;
  *newmigcount = mcount;
  return weight;
}
@
Function [[copy_probcalc]] copies neither [[pdg]] nor [[plg]].
<<updateassignment static>>=
static void copy_probcalc_all (struct probcalc *dest, struct probcalc *srce);
<<updateassignment relabel>>=
void
copy_probcalc_all (struct probcalc *dest, struct probcalc *srce)
{
  memcpy (dest->qintegrate, srce->qintegrate,
          numpopsizeparams * sizeof (double));
  if (nummigrateparams > 0)
    {
      memcpy (dest->mintegrate, srce->mintegrate,
              nummigrateparams * sizeof (double));
    }
  dest->pdg = srce->pdg;
  dest->probg = srce->probg;
  return;
}

@
\subsection{Beerli and Felsenstein 1999}
We adapt an alternative of genealogy updating method developed earlier
by \citet{Beerli:1999}. Their sampling scheme is based on prior distribution
of genealogy given demographic model parameters. We find this updating
scheme slightly better than the one employed by \citet{Nielsen:2006}.
All results are based on the updating scheme due to \citet{Beerli:1999},
which we sketch out here. Readers should refer to their paper for
details.

We start by detaching an external branch from a full genealogy. A
genealogy without a branch is called partial, whereas the original
genealogy with the branch is full. The external branch is called active,
and all the rest of branches in the partial genealogy are called inactive.
We label the gene at the detached active external branch to a different
population, and simulate migration and coalescent events along the
active lineage from the present time toward backward in time by following
\citet{Beerli:1999} as strictly as possible. As a coalescent event
occurs, we choose at random one of inactive lineages of the partial
genealogy that exist at the coalescent time.

As we change genealogical histories in the update of assignment using
\citet{Beerli:1999}, the acceptance probability, $\alpha_{\textrm{BF}}(\mathbf{G},\mathbf{t},\mathbf{A}\rightarrow\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*})$,
involves likelihood ratios that is given by\begin{equation}
\frac{f(\mathbf{Y}|\mathbf{G}^{*},\mathbf{A}^{*})}{f(\mathbf{Y}|\mathbf{G},\mathbf{A})}\frac{\pi(\mathbf{G}^{*}|\mathbf{t}^{*},\mathbf{A}^{*})}{\pi(\mathbf{G}|\mathbf{t},\mathbf{A})}\frac{q(\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*}\rightarrow\mathbf{G},\mathbf{t},\mathbf{A})}{q(\mathbf{G},\mathbf{t},\mathbf{A}\rightarrow\mathbf{G}^{*},\mathbf{t}^{*},\mathbf{A}^{*})}.\label{eq:acceptbf}\end{equation}

A drawback of our adaptation of their algorithm for the assignment
purpose is that proposed genealogies tend to be incompatible with
infinite sites data and result in frequent rejections of proposed
genealogies. It becomes profound as multiple changes to genealogies
due to multilocus data sets are involved for updating assignment,
which renders its usage futile in updating genealogies for the purpose
of assignment. We attempt to remedy it by proposing only a genealogy
that is compatible with infinite sites data. For a coalescent event
of an active lineage we then choose one among the inactive lineages
that lead to genealogies that are compatible with infinite sites data.

I adapt the proposal scheme due to Beerli and Felsenstein (1999) to assignment
problem in the hope of it being useful in the assignment or barcoding problem. 
We give a name to the update function: [[updateassignmentbf]].

In Levine's likelihood, what is a model parameter? Genealogy, itself, is the
parameter of the likelihood.

We choose one of edges to attach an active lineage probabilistically.
<<updateassignment function header>>=
int updateassignmentbf (int ci);
<<updateassignment bf>>=
int
updateassignmentbf (int ci)
{
  int accp;
  double lweight;
  double logU;
  double mweight;
  double hweight;
  struct genealogy *G;
  int li;

  if (snind_unknown == 0)
    {
      return 0;
    }

  G = NULL;
  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }

  /* Count up the number of tries of MCMC cycles. */
  if (ci == 0)
    {
      for (li = 0; li < nloci; li++)
        {
          L[li].a_rec->upinf[IM_UPDATE_ASSIGNMENT_BF].tries++;
        }
    }
  Cupinf[ci].upinf[IM_UPDATE_ASSIGNMENT_BF].tries++;

  /* Save the current state of a chain */
  for (li = 0; li < nloci; li++)
    {
      imaSavedReset (li);
      imaSavedSaveLocusInfo (ci, li);
      copy_treeinfo (&saT[li].savedgweight, &C[ci]->G[li].gweight);
    }
  copy_treeinfo (&saC.savedallgweight, &C[ci]->allgweight);
  copy_probcalc_all (&saC.savedallpcalc, &C[ci]->allpcalc);

  /* Propose a new state of genealogy and assignment. */
  hweight = bfmove (ci);

  /* Find all internal node sequences and mutations of a full genealogy. */
  /* This is for debugging purposes.                                     */
  for (li = 0; li < nloci; li++)
    {
      if (L[li].model == INFINITESITES
          && calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
        {
          accp = IMA_genealogy_findIntSeq (ci, li);
          assert (accp == 1);
        }
    }

  /* Compute Metropolis-ratio. */
  setzero_genealogy_weights (&C[ci]->allgweight);
  for (li = 0; li < nloci; li++)
    {
      setzero_genealogy_weights (&C[ci]->G[li].gweight);
      treeweight (ci, li);
      sum_treeinfo (&C[ci]->allgweight, &C[ci]->G[li].gweight);
    }
  initialize_integrate_tree_prob (ci, &C[ci]->allgweight, &C[ci]->allpcalc);

  /* Compute likelihood. */
  /* This has to be called after treeweight. */
  if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
    {
      bflikelihood (ci);
    }
  else
    {
      C[ci]->allpcalc.pdg = 0.0;
    }

  logU = log (uniform ());
  mweight = (C[ci]->allpcalc.probg - saC.savedallpcalc.probg) 
            + gbeta * (C[ci]->allpcalc.pdg - saC.savedallpcalc.pdg);
  lweight = beta[ci] * mweight + hweight;
  assert (beta[ci] * mweight + hweight > -1e200
          && beta[ci] * mweight + hweight < 1e200);

/* check values of acceptance probability: 
  printf ("pdg: %.3lf - %.3lf (%.3lf), pg: %.3lf - %.3lf (%.3lf), hweight: %.3lf, lweight: %.3lf vs. logU: %.3lf, [%d]\n", 
          C[ci]->allpcalc.pdg, saC.savedallpcalc.pdg, C[ci]->allpcalc.pdg - saC.savedallpcalc.pdg,
          C[ci]->allpcalc.probg, saC.savedallpcalc.probg, C[ci]->allpcalc.probg - saC.savedallpcalc.probg,
          hweight, lweight, logU, lweight > logU);
*/
 
  accp = 0;

  /* Find all internal node sequences and mutations of a full genealogy. */
  /* This is for debugging purposes.                                     */
  for (li = 0; li < nloci; li++)
    {
      if (L[li].model == INFINITESITES
          && calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
        {
          accp = IMA_genealogy_findIntSeq (ci, li);
          assert (accp == 1);
        }
      else if (L[li].model == HKY || L[li].model == STEPWISE)
        {
          /* No code. */
        }
    }

  if (lweight > 0.0 || lweight > logU)
    {
      /* accept the update */
      accp = 1;
      if (ci == 0)
        {
          for (li = 0; li < nloci; li++)
            {
              L[li].a_rec->upinf[IM_UPDATE_ASSIGNMENT_BF].accp++;
            }
        }
      Cupinf[ci].upinf[IM_UPDATE_ASSIGNMENT_BF].accp++;
      C[ci]->nasn[sbfold.pop]--;
      C[ci]->nasn[sbfnew.pop]++;

      /* Always revert to an original. */
      for (li = 0; li < nloci; li++)
        {
          if (L[li].model == HKY)
            {
              copyfraclike (ci, li);
              storescalefactors (ci, li);
            }
        }
    }
  else
    {
      for (li = 0; li < nloci; li++)
        {
          /* restore edges changed during update */
          imaSavedRestore (ci, li); 
          imaSavedRestoreLocusInfo (ci, li);
          copy_treeinfo (&C[ci]->G[li].gweight, &saT[li].savedgweight);
        }
      copy_treeinfo (&C[ci]->allgweight, &saC.savedallgweight);
      copy_probcalc_all (&C[ci]->allpcalc, &saC.savedallpcalc);
    }

  for (li = 0; li < nloci; li++)
    {
      if (L[li].model == HKY)
        {
          restorescalefactors (ci, li);
        }
    }

  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }
  return accp;
}

@
Function [[start_setup_L]] reads data.
Function [[finish_setup_C]] allocates memory of [[gtree]].
Each [[edge]] or node has member [[seq]] to store a sequence. We compare two
sequences at both ends of an edge to check whether there are mutation events on
it. Before that, we traverse a genealogy to check which node is the parent node
of mutating edges. We use ``Fitch'' algorithm to find these node or edge for
each site. There is a unique node or edge whose child edges can have a mutation
for a site. 
For a given partial genealogy, we set [[seq]] member of [[gtree]] and [[mut]]
member of [[genealogy]]. Once we set all [[seq]] member of the edges of a
``partial'' genealogy, then we can decide whether an external branch with a
particular infinite-sites sequence may attach to a sister branch or not.
We reset [[mut]] of a genealogy and [[seq]] of all edges of the genealogy. 

Function [[labelgtree]] does something that I like to know.
Structure [[genealogy]] has member [[mut]] of int array. Structure [[edge]]
has member [[seq]] of int array. Both arrays are of size equal to the number of
segregating sites.
We start with all internal nodes being set to -1. 

We implement [[HKY]] model in Beerli and Felsenstein's algorithm. We use
likelihood to choose one of lineages to attach an active lineage.
<<updateassignment function header>>=
int bflikelihood (int ci);
<<updateassignment bf>>=
int 
bflikelihood (int ci)
{
  int li;
  int ai;
  struct genealogy *G = NULL;

  assert (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0);

  C[ci]->allpcalc.pdg = 0.0;
  for (li = 0; li < nloci; li++)
    {
      G = &(C[ci]->G[li]);
      switch (L[li].model)
        {
        case HKY:
          if (assignmentoptions[JCMODEL] == 1)
            {
              G->pdg = likelihoodJC (ci, li, G->uvals[0]);
            }
          else
            {
              G->pdg = likelihoodHKY (ci, li, G->uvals[0], G->kappaval, -1, -1, -1, -1);
            }
          G->pdg_a[0] = G->pdg;
          break;
        case INFINITESITES:
          /* We need both pdg and pdb_a to be set. */
          G->pdg = likelihoodIS (ci, li, G->uvals[0]);
          G->pdg_a[0] = G->pdg;
          break;
        case STEPWISE:
          G->pdg = 0.0;
          for (ai = 0; ai < L[li].nlinked; ai++)
          {
            G->pdg_a[ai] = likelihoodSW (ci, li, ai, G->uvals[ai], 1.0);
            G->pdg += G->pdg_a[ai];
          }
          break;
        case JOINT_IS_SW:
          assert (0);
          ai = 0;
          G->pdg_a[ai] = likelihoodIS (ci, li, G->uvals[0]);
          for (ai = 1; ai < L[li].nlinked; ai++)
          {
            /* ui = L[li].uii[ai];       */
            /* assert (pdgnew[ui] == 0); */
            G->pdg_a[ai] = likelihoodSW (ci, li, ai, G->uvals[ai], 1.0);
            G->pdg += G->pdg_a[ai];
          }
          break;
        }
      C[ci]->allpcalc.pdg += G->pdg;
    }

  return 0; 
}

@
\texttt{NOTE:} We consider only haploid data type. I do not even
keep the codes for diploid, and will
not consider for the time being maybe forever.

There are one or two external branches that are removed from a genealogy
depending on haploid or diploid data. Detached branches are simulated to be
reattached to the genealogy from which they are detached. Detached branches are
called active lineages along which we simulate migration and coalescent events.
A genealogy before and after we remove external branches is called 
a full genealogy and a partial genealogy, respectively. 
Branches of a partial genealogy are called inactive because they are not
changing in their events along branches.
The moving edges are stored in [[sbfold]] and [[sbfnew]] for computing the 
Hastings ratio.
Note that a partial genealogy can have a rooting branch intact. Migration
events along a rooting branch of a partial genealogy
must ramain without change to it. We use a partial
genealogy to derive coalescent and migration related model parameters that are
used to simulate coalescent and migration events along active lineages.
Note that the partial genealogy from an original full genealogy and
the partial genealogy from a proposed full genealogy may be different given
the same moving branches when root changing is involved. If detaching and 
attaching active lineages does not involve a root, then both partial genealogies
from an original and a proposed ones are equivalent.

There are two ways to treat branches connecting a root. One way is to follow
Beerli and Felsenstein (1999), and the other way is to remove both the branches
that connect with a root that is basically due to Hey and Nielsen (2007). 
There are pros and cons. Two partial genealogies that 
one from an original and one from a proposed are the same under the latter
approach. This is not the case in the former one. Secondly, choosing a branch at
random is symmetric in the former case. That is not symmetric in the latter
case because asymmetric deletion of active lineages between old and new
genealogies. I implement the former one just because this is documented in the
Genetics paper by Beerli and Felsenstein in 1999.

Function [[bfmove]] proposes a genealogy with new population labels. It also
returns Hastings ratio of the proposal. Let us describe function
[[bfmove]].
\paragraph{Two structures: im\_bfupdate and im\_ginfo.} Original and proposed 
genealogies are stored in variables [[sbfold]] and [[sbfnew]]. Structure
[[im_bfupdate]] is somewhat complicated. It contains most of information about
transition between original and proposed genealogies. We keep track of only a
single genealogy of a single chain. Variables [[saGiold]] and [[saGinew]] are
arrays for all loci of a chain, though. (I do not know why we have arrays for
[[saGiold]] and [[saGinew]]. Can we have a single valued variable for each of
the two? Why do we need to keep them for all loci?)
Memory of [[sbfold]] and [[sbfnew]] are
allocated once at the beginning of program and are deallocated at the end since
they are used all the time during MCMC.
Some of pointer members of [[im_bfupdate]] are pointing to memory dynamically
allocated and some are merely pointing to other memory. 

There are three kinds of events along a genealogy: coalescent, migration, and
population split events. We divide all intervals by these events of a partial
genealogy and store those events starting from a first one to the ending tip of
the partial genealogy in [[im_bfupdate]]'s member [[e1]]. 
The capacity of [[e1]] is
member [[nmax1]]. The current number of events in [[e1]] is member [[n1]]. We
reallocate memory of [[e1]] if we need more than current capacity [[nmax1]].
Events [[e2]] includes events along an active lineage until the bottom of a
partial genealogy. Events [[e3]] includes events beyond the bottom of a partial
genealogy. 
{\tt FIXME: It is unclear what e1, e2, e3 are for. }

A simulated active lineage would be attached to a sister branch of a partial
genealogy. Migration events along an active lineage need to be stored. These are
stored to the counter part of [[im_bfupdate]] variable, or variable [[sbfnew]]
is used for an original partial genealogy. This may be confusing, and it is the
way I did unfortunately. Active lineage z1 and migration events along 
the lineage are
stored in [[im_edgemiginfo]] pointed to by member [[m1]] of [[sbfnew]]. The
original branch is stored in [[saoems]] that is pointed by [[m1]] of
[[sbfold]].
{\tt FIXME: We could have been more specific what and where we store information
with a figure. Let me continue to read the following.}

\paragraph{Find all internal node sequences and mutations of a full genealogy.}
Function [[IMA_genealogy_findIntSeq]] finds all ``hidden'' infinite-sites
sequences at the internal nodes of a full genealogy: member [[seq]] of [[edge]]
structure.
It also finds on which 
sites of sequences mutations occur: [[mut]] of [[genealogy]] structure.
Let us look at the function
in detail. We have a member
variable named [[seq]] at structure [[edge]] that stores the sequence
at a node. Member [[numsites]] of structure [[locus]] stores the
number of segregating sites of a locus. We start by setting all characters of
variable [[seq]] to -1. We could have used [[seq]] variable without the reset if
we did update internal sequences in functions [[updategenealogy]] and
[[updategenealogy_covar]]. We would do this later if [[bfmove]] is worth
further development.
Structure [[genealogy]] has member [[mut]] that is of
the same size as [[seq]]. This member [[mut]] does not store sequences 
but edge IDs that have mutation events on them.
We reset [[seq]] and [[mut]] of a full genealogy, and we find mutation
events along edges of a full genealogy as well as sequences at internal
nodes. We can use Fitch's algorithm to find the number of parsimonious mutation
events for a binary tree with infinite-sites data on the leaves of the tree. 
A part of our procedure follows function [[labelgtree]].  
Function [[labelgtree]] 
seems to label all internal node sequences with either 0 or 1 except one node
for each segregating site of a infinite-sites sequence. The node has a
label of 2, which can be 0 or 1. Note that the number 2 represents a union set
of 0 and 1 from the perspective of Fitch's algorithm. If the edge or node with 2
is not a root, we change the number 2 to either 0 or 1 that occurs at its
neighboring edges twice. If it is a root, we replace the number 2 with 0.
\tt{Finding internal sequences is incomplete. We may have to ellaborate on
adding more.}

\paragraph{Pick an individual to relabel.} 
We pick one among [[snind]]
individuals. Individual [[ii]] has [[nei]]-many genes across [[nloci]] 
loci. Since we
change the label of those genes, we save those edges first. Variable
[[saC]]'s [[indlist]] is used to access all the genes that belong to an
individual. All external branches whose genes belong to individual [[ii]] are
saved.

\paragraph{Prepare all migration events storage.} 
We need three storages for migration events for each of old and new 
genealogies: [[saoems]] and [[sanems]] contains two storages. 
Before we use [[saoems]], [[saosms]], [[sanems]], and [[sansms]], 
we reset them using [[IMA_reset_edgemiginfo]]. 
We copy the migration events of external branches whose tips belong to
individual [[ii]] to [[saoems]]. Members of [[edgemiginfo]] structure that are
saved are as follows: 
[[li]], [[edgeid]], [[upt]], [[dnt]],
[[pop]], [[fpop]], [[mpall]], and [[mig]].
Until we are finished with our simulation of active lineages we do not know
whether we need [[saosms[2 * li]]] that store migration events beyond the
ultimate root time of a proposed full genealogy.
For now we save only a single external lineage.

\paragraph{Label all the genes.}
Using one of the genes that belong to
individual [[ii]] we find the label of the individual. We propose a new label
using function [[imaRandomPickpopn]]. I do not like this function, though. We
label all the genes [[newpop]] that belong to individual [[ii]].

\paragraph{Simulate branches for each genealogy.}
If [[saoems]]'s [[edgeid]] is negative, we have no genes that belong to
individual whose assignment is being updated. We move on the next genealogy.

Note that active lineage is named
[[z1]]. [[sbfold]]'s [[m1]] points to an element of [[saoems]]. Local
variable [[m1]] is a pointer to [[sanems]] on which we simulate migration and
coalescent events. 
We simulate one active
lineage starting at the present time, and the migration events for 
the lineages is stored in [[sanems[2 * li]]].
When an active lineage does not coalesce with any inactive lineages of a partial
genealogy, it is said to ``survive'' through the partial genealogy. When 
the active lineage survives through a partial genealogy, we have one more active
lineage [[z3]] sprouting from the bottom end of a partial genealogy.
Note that the bottom end of a partial genealogy can be a rooting node with two
edges connected or a dangling node with one edge. If the active lineage was
attached to the root of an original full genealogy, then the bottom end of a
partial genealogy of the full genealogy would be a dangling node.

We also simulate migration events along lineage [[z3]] when active lineages
survive through a partial genealogy. 
These migration events are stored in
[[sansms[2 * li]]]. Note that we follow the proposal method developed by 
Beerli and Felsenstein (1999), 
where a rooting branch of a partial genealogy can have
migration events, and the tree lengths from top to bottom (i.e., the ultimate
root time) for full and partial
genealogies are the same. We set [[sbfold]]'s
[[is_finiterootbranch]] to `T' when erased
active branches connect with the root of a full genealogy.
Only after we propose a new genealogy can we determine whether we will have
[[saosms[2 * li]]]. If a root is not involved in the update of a genealogy, we
do not need variable [[saosms]]. Only if an active lineage connects with the
root of an original genealogy and simulated new active lineages coalesce with
a partial genealogy before the ultimate root time without concerning the emerge
of lineage [[z3]], we then have [[saosms]]. If a root connecting active lineage
coalesces with one of inactive lineages, then we would have [[saosms]] not
[[sansms]].

Let us consider three cases where erased active
lineages connect with the root of a full genealogy. 
The partial genealogy derived 
from the full genealogy then has a dangling root branch. The bottom end of the
pendent root branch of the partial genealogy is the root node of the current
full genealogy. The node is of degree 1, or there is only one branch connecting
the node. It is like a leave root node. Whereas all internal nodes are usually 
embroidered with coalescent events, the bottom point of a dangling branch is
not. We give the node a name of a fictitous event, ``end'' of a genealogy. The
end event of a partial genealogy is the root of a full genealogy.
If new active lineages pass beyond the ``end'' event, then we have [[sansms]].
If we have [[sansms]], then we must not have [[saosms]], and vice versa.

%\begin{figure}
%\includegraphics[scale=0.60]{imamp36}
%\caption{Beerli and Felsenstein (1999) }
%\end{figure}
%\begin{figure}
%\includegraphics[scale=0.60]{imamp37}
%\caption{Beerli and Felsenstein (1999) }
%\end{figure}

\paragraph{Detach active lineages.}
Function [[IMA_genealogy_detach]] does this job. It detaches [[z1]]. 
from the full genealogy of locus [[li]] of chain [[ci]].
We store the detached edge
information in [[sbfold]]: 
[[down1]], [[sis1]], [[upt1]], [[sisupt1]], [[sisdnt1]], [[downdown1]],
and [[is_finiterootbranch]].
We store sequences at the bottom of active lineages: [[seqz1]].
Elements of [[mut]] with [[down1]] are set down 
to [[sis1]].
Detached edges [[exist]] are set to be `F.' Let us look at the function in
detail.

\tt{See SCAN: 1255018052.}

\paragraph{Get intervals of events of a partial genealogy.}
Prior to simulating a new genealogy we use 
function [[IMA_intervals_collect]] to find all events in between up-time and
down-time. Since we need all intervals of a partial genealogy, up-time is 0, and
down-time is at the root of the partial genealogy. Note that [[roottime]] of
genealogy [[G]] does not change even if we happen to detach a root connecting
edge. [[dnt_genealogy]] is the root time before we detach an active lineage, and
[[G->roottime]] is the root time after we detach an active lineage. These two
values must be the same.
We use file static variables [[sbfold]] and [[sbfnew]] to store all
events along a partial genealogy. 
Coalescent and migration events below [[upt]] are considered, and population
split events from [[upt]] to [[dnt]] are considered. Migration events along a
dangling root must be added. Let us look at the function in detail.

We store all events of a partial genealogy to member [[e1]] of [[sbfold]]. 
Split time events that cross any inactive lineage of the partial genealogy are
added as well. Note that we do not add split time events that happen after the
bottom of the partial genealogy.
Function [[IMA_intervals_collect]] is devoted to [[sbfold]]. 
The total number of events is stored in local variable [[a]]. 
An event is pointed to by [[ek]]. 
First, we
add coalescent events by iterating all the internal edges except the ones that
are not a part of a partial genealogy. We can tell whether an edge is a part of
a partial genealogy by referring to member [[exist]]
of an edge. Type ``c'' is for a coalescent
event. Time [[t]] is the time at the top of an edge. [[p]] and [[pi]] are not
used. 
[[pj]] is storing the population label at the coalescent event of the top of
edge [[ei]]. We increase the number of elements in [[e1]] of [[sbfold]] and move
to a next event after we set the members of an event. We only consider
population split events with type ``s''
that happen between the present time and the ending time
of a partial genealogy. [[p]] stores the period right before the split event.
Note that [[pi]] and [[pj]] are not a population label but a period. [[p]] and
[[pi]] are the same. [[pj]] is the one right after the split event. 
We do not need to specify [[ei]].
The type of migration is denoted by ``m.''
[[p]] is the period at the time of a migration event. [[pi]] and [[pj]] are
population labels before and after a migration event. Note that we take into
account time and period for source population. The source label is not just a
label of the previous event of the edge. The source label is the population from
which a lineage starts. This is different from dealing with migration events in
[[im_migstruct]].

A population label may change as we go backward in time.
We use [[popndown]] to figure out the right
population label at a later period back in time. This is the code that Jody
could use instead of using [[while]] statement and use period [[b]] and [[e]] of
each population.
If a root branch is a
dangling one when [[is_finiterootbranch]] being `T,' we add an ``end'' event. The
procedure looks the same as that for a migration event except that [[pi]] and
[[pj]] are the same because a gene does not migrate but stays put.


\tt{See the paragraph with title being ``Prepare the number of lineages with
which active lineages can ...''}
We should have [[lz1]] of size [[nz1]], and [[lz2]] of size [[nz2]] at the
present time with a partial genealogy. We should have something in [[im_event]]
structure to figure out what we should do when we move to a next event.
Structure [[im_event]] should have an edge ID for coalescent events.
Where should we set [[lz1]] and [[lz2]]? We do this in function 
[[IMA_sbf_lineages]]. 

\paragraph{Derive parameters from a partial genealogy.}
We use events saved in member [[e1]] of [[sbfold]] or [[sbfnew]]
to derive model parameters to
simulate active lineages to attach branches of a partial genealogy.
We use [[sbfold]] or [[sbfnew]] to fill [[saGiold]] or [[saGinew]] that would
contain conunts of migration and coalescent events and derived model parameters.
Structure [[im_ginfo]] is described: 
[[cc]], coalescent counts for populations;
[[fc]], coalescent rates  for populations;
[[cm]], migration counts between populations; 
[[fm]], migration rates between populations; 
[[thetas]], derived theta estimates for populations;
[[mms]], derived migration rates between populations; and
[[ms]], sum of mms for migration rate away for populations. 
Before we start counting any events
function [[imaGinfoReset]] resets all [[ginfo]] structure: [[gk]] and
[[gkz1]] that point to  [[saGiold]] and [[saGioldz1]], respectively. Note that
[[gk]] and [[gkz1]] point to [[saGinew]] and [[saGinewz1]] if we are given ``n''
for argument [[w]]. Typically [[ki]] represents a period index. After counting
events, function [[IMA_ginfo_computetheta]] is invoked to derive migration and
coalescent rate parameters.
We count the number of coalescent events and the number of migration
events in a population. We know the length of lineages that may be
used for coalescent and migration events. These ``rate''
terms are $(n + 1) \times n$ and
$n + 1$ multiplied by the length of an interval length. We add 1 more for both
terms to account an active lineage. 

Comment on Jody's original idea of using a full genealogy to derive model
parameters: A full genealogy could be used to derive model parameters. Even
in this case, we ``should'' use $(n+1) \times n$ not $(n) \times (n-1)$ because
populations with a single lineage would not have positive rate of coalescent
even if there is an inactive lineage.

Use counts of a whole partial genealogy, and total rates from parts of it.
\texttt{IMPORTANT POINTS:} Note that 
there are two [[ginfo]]'s: [[gk]], and [[gkz1]].
Whereas numbers of events, [[cc]] and [[cm]], are the same for the couple of
[[ginfo]]'s. Rates of those, [[fc]], [[fm]], are different for the couple.
All [[cc]], [[fc]], [[cm]], and [[fm]] are indexed by population labels
including ancestral ones, and so are the rates, [[thetas]] and [[mms]]. For
migration events, target populations of a source population
are different for different periods.
Variable [[popnmig]] is used to know what populations are available to migrate
from a population per period.
Migration rate-away per period is stored in variable [[ms]].
We use [[popnmig]] to know the migration rates for target populations from a
source population. 

\texttt{We need to write down a little bit more if we have any problem in this
part.} We may have to tune with different default parameter settings: e.g.,
[[BFMPRIORMIN]]. I am not sure whether I should use [[BFMPRIORMIN]].

\tt{WRITE DOWN MORE}


%\begin{figure}
%\includegraphics[scale=0.60]{imamp39}
%\caption{Events counts and rates}
%\end{figure}

\paragraph{About [[simulation]] goto.}
There is a chance that active lineages cannot coalesce forever because of
the incompatibility of infinite-sites data with the proposed full genealogy. We
need to restart our simulation in that case. This [[simulation]] statement is
the place where we restart our simulation.

\paragraph{Prepare the number of lineages with which active lineages can
coalesce.} 
As we go down a partial genealogy event-by-event, we count how many lineages
are present in a population. As we hit an event downward, we change numbers
of lineages of a population. This could have been all that we needed if we only
considered a tree branching configuration with a population tree. 
We keep track of which lineages are available for being attached by an active
lineage for infinite-sites model: [[nz1]] and [[lz1]]. We do not need [[nz1]] or
[[lz1]] for
finite sites model such as HKY and potentially rate matrix based stepwise
mutation model. The first part
of function [[IMA_sbf_lineages]] counts the number of genes in each
population if an active lineage is present in that population. Let us look at
function [[IMA_sbf_lineages]] in detail. 

There are a couple of members for storing numbers of lineages 
in each populations: [[n]], and [[nz1]]. 
Each of two members has its counter part variable that
contains as many edge IDs as each of the variables: 
[[l]] for [[n]], and [[lz1]] for [[nz1]].
We use [[l]] when we set [[lz1]] in the second part
of function [[IMA_sbf_lineages]]. Member variable [[l]] contains arrays of edge
IDs for each population. 
In infinite-sites mutation model active lineages may or may not attach to an
inactive lineage. For finite-sites model or rate matrix based stepwise mutation
model we can attach active lineages to any inactive lineage. [[lz1]] 
is a subset of [[l]]. 

Let us consider the case of infinite-sites model.
For all the edges of each population in member [[l]], we test whether
an active lineage can attach to them. If the sequence at the bottom of an active
lineage exists along a target edge, then the active lineage is allowed to attach
to the target edge. If there are no mutation events along a target edge, there
exists a single sequence along the edge. Only if the sequence at the bottom
of an active lineage is the same as the single sequence of a target edge, can
the active lineage attach to the target edge. If there is a single mutation
event along a target edge, we have two sequences along the target edge. We 
have $2^n$-many sequences along a target edge with $n$ mutation events. If one
of these $2^n$-many sequences is the same as the sequence at the bottom of an
active lineage, the active lineage can attach to the target edge. 
We do not want and need
to iterate all $2^n$ possible sequences to check whether the sequence at the
bottom of an active linveage exists along the target edge. If all characters
between the sequence at the top of a target edge and the sequence at the bottom
of an active lineage except for the mutation sites of the targe edge are the
same, then the active lineage can coalesce with the target edge. That is why we
skip the [[si]]-the site if [[si]]-th edge of [[mut]] is equal to the target 
edge ID.

\paragraph{Numbers that can be derived from the number of populations}
The
variable [[numpopsizeparams]] stores the total number of populations under a
population model. We consider a few models that are specified by demographic
population histories: population history follows a binary species tree (tree
model), all contemporary populations are considered demes that are separated for
a long time (island model), and all present-time populations a single ancestor.
There are key global variables that affects many parts of [[IMamp]] codes.
For island model, we have no split time, but two periods that are separated
by the imaginary split. We have imaginary population tree where ancestor
population resides in the imaginary last period and descendents in the first
period.

[[numsplittimes]]: This tells us number of popoulation splits. If we consider a
binary population tree, then it is one less than the number of
populations: $K - 1$ where $K$ is the number of present-day populations. 
If we consider Island model, it is 0. What about a single ancestor model? Is it
1? Function [[read_datafile_top_lines]] sets the value.
[[lastperiodnumber]]: This is the same as [[numsplittimes]] if we consider
a binary population tree. We have the imaginary split time for island model.
It is 1 for island model. Note that [[lastperiodnumber]] is 1 and
[[numsplittimes]] is 0 for island model. For single ancestor model, both are 1.
Function [[read_datafile_top_lines]] sets the 
value.
[[numtreepops]]: The number of nodes of a population tree: $2 \times K - 1$. 
For island model, it
is [[npops]] plus one. For a binary population tree, it is twice
the [[npops]] minus one. What about single ancestor model? It should be $K + 1.$
Function [[read_datafile_top_lines]] sets the value
after reading the number of populations from an input file.
[[numpopsizeparams]]: The number of nodes of a population tree. For Island model,
it is [[npops]]. For a binary population tree, it is twice the
[[npops]] minus one, which is equal to [[numtreepops]]. What about single
ancestor model? It must be $K + 1.$

This number of populations are that of population mutation rates.
Note that [[numpopsizeparams]] and [[numtreepops]] are the same for a tree
model. In island model, these are different.
Note that we have two population configurations: tree and
island models. Under tree population model, we have $2 \times n - 1$ many
populations where $n$ is the number of populations at present time. Under island
model, we have $n$ many populations. 

\paragraph{Initialize active lineages.} 
Before we start a simulation of coalescent-migration events along an active
lineage we reset member [[m1]] that hosts migration events: [[dnt]] time at the
down of [[m1]] is reset, [[fpop]] population label at the down of [[m1]],
[[mpall]] number of migrations is set to 0, and [[mig]] are reset. The target
edge is also reset: [[sbfnew]]'s member [[sis1]]. 
Simulated events are stored in[[m1]] that will be set to [[sbfnew]]'s [[m1]].
[[m3]] can store events along a sprouting rooting branch when active lineages
``survives'' through a partial genealogy. Note that [[ki]] is for a period
index, [[pc1]] population label along active lineage [[z1]], and [[ti]] is an
increasing index of events.

\paragraph{Start simulation down towards the genealogy.}
Events are indexed by [[ti]]. Period number is stored in [[ki]]. Simulation
ends with coalescent events of all active lineages. 
For each interval of events we keep sampling next 
waiting time until we exhaust the time duration [[dt]] of interval [[ti]]. 
We can have one or two active lineages: [[z1]] and [[z2]]. When [[z1]] coalesces
with a lineage, variable [[is_coalesced1]] is set to `T.' This is also true for
[[z2]]. The more lineages during a time interval, the more likely an active
lineage is to coalesce: $2\times n/\Theta.$ Migration rates are affected by
migration model parameter: $M.$ Note that this is a migration rate-away from a
population during a particular period, and it is different for populations
and periods. 
Function [[bfmove_ratesI]] determines [[np]] and [[rates]]. Let us look at the
function [[bfmove_ratesI]] in detail. For HKY model (and potentially rate matrix
based stepwise mutation model) we would have 0 coalescent rate when there are 
no lineages in population [[pc1]] where an active lineage is passing. We would
have both [[saGiold]]'s (pointed to by [[gk]]) [[theta]] and [[sbfold]]'s
(pointed to by [[pbf]]) [[n]] being zero. If we are in the last period, 
[[np]] would be 1 and no migration rate is involved. Prior to last period, we
have no-zero migration rate away from population [[pc1]] where an active lineage
is passing through.

When only one active lineage exists, [[np]] can be 1 or 2. We can tell which one
is the existing active lineage by referring [[is_coalesced1]] and
[[is_coalesced2]]. If [[np]] is 1, then the active lineage must coalesce. If
[[np]] is 2, then we choose a coalescent or a migration event: [[re]] means
coalescent event chosen. Let us look at the code of Case (A). We set
[[is_coalesced1]] to `T' to note that [[z1]] lineage completes its simulation by
its coalescent with one of lineage of a partial genealogy. The lineage [[z1]] is
in population [[pc1]]. 
For infinite-sites model we use [[lz1]] to choose one lineage to attach active
lineage [[z1]]. For finite-sites model we use [[l]]. Function
[[bfmove_chooseAnEdge]] is used to draw one lineage as a new sister for an 
active lineage.
We set [[sbfnew]]'s [[sis1]] to the randomly chosen one of [[lz1]] or [[l]] of
[[sbfold]]. The last event of migration container [[m1]] is set: [[mt]],
[[dnt]], and [[fpop]]. We set [[sbfnew]]'s [[m1]] to the migration container.
We could have used [[sbfnew]]'s [[m1]] directly without haveing local variable
[[m1]] if we did not consider diplod data type.
Note that these could be complicated when you consider diploid data type.
For Case (F), function [[IMA_choose_migtopop]] is used to draw another
population at random.

\paragraph{New time is further back in time than the bottom of an event.}
If we exhaust [[dt]], then we change [[n]] for the number of genes for
each population during period [[ki]] depending on the type of event pointed to by
[[ek]]. Function [[bfmove_nextI]] is used to change numbers of genes. The
function is also used to compute Hastings ratio. The event types that are
considered in function [[bfmove_nextI]] are ``a'', ``p'', ``e'', ``c'', ``m'',
and ``s.'' For simulating coalescent and migration events on active lineages we
need only ``e'', ``c'', ``m'', and ``s.'' For computing Hasintgs ratio we also
use ``a'' and ``p'' that we consider later in function [[bfq]].
When the evnet type is ``e,'' we have just reached the ending of a partial
genealogy. We does nothing for an ending event. If we reach ``c'' event type,
then we remove edges that coalesce together and add the edge that appears. Not
only counting edges in populations, but we should also list those edges.
Function [[IMA_sbf_c]] helps this situation.
Similarly, events type ``m'' has function [[IMA_sbf_m]].
Events type ``s'' has no specific functions.

Note that we have included split time in the events. The current label
of active lineages must be updated when we pass population split event using
[[popndown]] variable of [[saC]]. Once we update [[n]], [[pc1]], and [[pc2]],
then we set [[prevt]] to the current event time and move to next event by
increasing [[ti]] and [[ek]]. This has been complicated as we consider
infinite-sites data for our proposal. First, coalescent event is typed ``c.''
[[pj]] of event [[ek]] is the population label of the coalescent event. Two
lineages of that population vanish and the coalesed lineage emerges. This causes
[[n]] for that population to decrease by 1. Note that we do not change member
[[l]] of [[sbfold]]. We use function [[IMA_sbf_c]] to update [[nz1]], [[lz1]],
[[nz2]], and [[lz2]]. Look at the function [[IMA_sbf_c]] in detail. For
migration events, we use [[IMA_sbf_m]].

\paragraph{Simulation beyond the genealogy.}
Let us consider [[nsum]] of 2. 
Consider function [[bfmove_ratesIII]] in detail. The first and second elements
of [[rates]] are migration rates for active lineages [[z1]] and [[z3]],
respectively. The third element is for rate of coalescent of two active
lineages. Three events are possible. Simulation with inactive lineages is done
by considering split time, or split time events are included [[e1]] of
[[sbfold]]. Simulation of two active lineages does not know about any split
time. Next event time [[newct]] can pass split times. If it does, we must stop
at the first hit split time and resimulate (This is why we have [[continue]]
when [[prevki]] and [[ki]] are different). 
 
\paragraph{Determine [[saosms]].}
Even if an active branch is connected with the root of a full genealogy, then we may
or may not have [[saosms]]. If we have simulated beyond the last event of the
partial genealogy of the full genealogy, then we have [[sansms]] not [[saosms]].
If we have simulated the active branch before the last event and the active
branch used to be attached to the root of a full genealogy, then we have
[[saosms]] not [[sansms]].
We copy the latter part of a dangling branch of a partial genealogy to
[[saosms]].
%\begin{figure}
%\includegraphics[scale=0.60]{imamp38}
%\end{figure}

\paragraph{Resimulation for infinite-sites model.}
We need to restart our simulation when active lineages survive through a partial
genealogy and they are not allowed to to coalesce together.

\paragraph{Compute Hastings ratio.}
An original full genealogy is denoted by $G,$ and its partial genealogy by
$G_p.$ We are given a partial genealogy $G_p$ and active lineages with migration
events simulated on them. The simulated results are stored in the following
variables: [[sbfold]], [[sbfnew]], and [[saGiold]].
Function [[IMA_intervals_collectsbfnew]] is used to find [[sbfnew]] from
[[sbfold]] to compute the numerator of Hastings ratio. Then we can find
[[saGinew]] using function [[IMA_genealogy_derivetheta]] as we do for
[[saGiold]].

Let us look at function [[IMA_intervals_collectsbfnew]] in detail.
[[sbfnew]]'s member [[sis1]] is the edge to which active lineage [[z1]] attach.
If this [[sis1]] is equal to [[root]] of a partial genealogy, then we set
[[is_finiterootbranch]] to `T'. The time at a new attaching point can be found
member [[m1]]'s [[dnt]] that is set to [[ct]] or coalescent time. The population
label at the new attaching point is found member [[m1]]'s [[fpop]] that is set
to [[pc]] or current population. Now we know where active lineage [[z1]] attach
in a partial genealogy. We are given [[newm3]] as an argument of function 
[[IMA_intervals_collectsbfnew]]. 
If [[newm3]] exists or is not [[NULL]] (Figure \ref{fig:m3}:A,B), then we do not
need [[m3]] of [[sbfold]]'s member. Even in the case of [[newm3]] is [[NULL]], 
if active lineage [[z1]] is detached from a non-root internal node, then we do
not need, either. When we detach an active lineage from a root node and
[[newm3]] is [[NULL]], then we would have [[m3]] of [[sbfold]]'s (Figure
\ref{fig:m3}:C). Look at the codes after this [[if]] statement:
\begin{Verbatim}[frame=lines,framesep=5mm]
  if (newm3 == NULL && sbfold.is_finiterootbranch == 'T')
\end{Verbatim}
Rooting edge of a partial genealogy must be of a finite length
that is less than a big number. [[roottime]] is time at the top of the root of a
partial genealogy.
[[saosms]] is used to store [[m3]]. Note that we
do not allocate [[m3]], and just point to an element of [[saosms]]. Starting of
[[m3]] depends on where a new coalescent happens. If it happens before
[[roottime]] (type ``A''), [[m3]]'s up time is set to [[roottime]] and its label
is set to root's population label. If it happens after [[roottime]] (type
``B''), then up time is set to the coalescent time [[ct]], and label is set to
current population label [[ct]].
Down time of [[m3]] is set to the bottom of the rooting branch of a partial
genealogy. We find all migration events along [[m3]].

A partial genealogy for an original full genealogy is ``almost'' the same as
that of a proposed full genealogy. We copy all events of [[e1]] of [[sbfold]]'s
to those of [[e1]] of [[sbfnew]]'s. If [[newm3]] is NULL or [[sbfold]]'s 
[[is_finiterootbranch]] is ``F,'' then we need no more than copying [[e1]]. If
[[newm3]] is not [[NULL]] or active lineage [[z1]] suvives all the way to the
end of a partial genealogy, then we append all events in [[newm3]] to [[e1]] of
[[sbfnew]]'s (Case I). 
If [[oldm3]] is not [[NULL]], then we remove those events in
[[oldm3]] from [[e1]] of [[sbfnew]]'s (Case II). 

\texttt{WE STOP HERE!!! CONTINUE TO WORK ON THIS DOCUMENTATION.}
We are in the middle of finding bugs in HKY implementation for assignment.

\paragraph{Prepare [[e2]] and possibly [[e3]].}
Let us describe function [[bfq]]. Look at the function [[bfq]]. 
Variable [[pbf]] of [[im_bfupdate]] points to [[sbfold]] to compute the
denominator of Hastings ratio: $q(\theta\rightarrow\theta^*)$. We fill all events
[[e1]], [[e2]], and potentially [[e3]] of [[pbf]] given simulated active
lineages in [[qbf]].
This structure has three kinds of events. The first events are stored [[e1]],
that includes all the events of a partial genealogy. The capacity of the array
[[e1]] is [[nmax1]]. The number of elements of the array is [[n1]]. There are
two more events storages: [[e2]] and [[e3]]. Member variable [[e2]] includes all
the events of [[e1]] as well as the events along proposed active lineages before
the bottom of a partial genealogy. Note that the last event is included in
[[e2]]. Variable [[e3]] contains the events only after the bottom of a partial
genealogy. We give different [[type]] for the events along active lineages: `a'
for lineage 1 coalescent, `b' for lineage 2 coalescent, `d' for lineages 1 and 2
joint-coalescent, `p' for lineage 1
migration, `q' for lineage 2 migration, and `r' for lineage 3 migration. 
\paragraph{Add probabilities before the bottom of a partial genealogy}
When we have two active lineages, lineage [[z1]] is the one that is longer than
[[z2]] in their original genealogy. Consider a genealogy where we detach two
external branches. One of two can be longer and the other is shorter than the
first one. We name the longer one [[z1]], and the short [[z2]]. We do not know
which will be longer or shorter after their simulation completes. 
Structure [[im_bfupdate]] is used to figure out which edges are [[z1]] and
[[z2]]. Let us consider variable [[sbfold]]. Its member [[e1]] contains events
of a partial genealogy. Detached branches are stored in [[m1]] and [[m2]].
[[m1]] is longer than [[m2]]. Its members [[e2]] contains events of proposed new
active branches as well as events in [[e1]]. We use [[sbfnew]]'s [[m1]] and
[[m2]] to create [[e2]] event array. [[sbfnew]]'s [[m1]] is still longer than
[[m2]]. When we add new simulated active lineage events to [[e2]] of [[sbfold]], 
we use [[sbfnew]]'s [[m1]] and [[m2]]. 

\texttt{We may have to revise the following section due to the previous
paragraph.}

We collect all the events a partial genealogy as well as
those in active lineages before the bottom of a partial genealogy. Next waiting
time is distributed exponentially with mean $1/\lambda$ or 
$\lambda e^{-\lambda t}$. The value of $\lambda$ is the sum of rates of all the
events during a time interval. Let us consider an event with type `b.'
A coalescent event of lineage 2 is chosen with
probability of $\lambda_{c2} / \lambda$ where $\lambda_{c2}$ is the coalescent 
rate of lineage 2. We then choose one of lineages in population [[pc2]]. The
probability that we choose coalescent of lineage 2 is 
\[
\lambda e^{-\lambda t} \times \frac{\lambda_{c2}}{\lambda} \times \frac{1}{n_2}\]
where $\lambda$ is equal to [[totalrate]], $\lambda_{c2}$ is equal to
[[rates[2]]], $n_2$ is equal to [[nz1[pc2]]] for active lineage [[z1]] to
coalesce, and $t$ is the same as [[dt]].
Note that $\lambda$'s are cancelled out. The coalescent event with [[type]]
being 'a' of lineage 1
happens with a similar probability construction except that we replace
$\lambda_{c2}$ by $\lambda_{c1},$ $n_2$ by $n_1.$ The total rate remains the
same. $\lambda_{c1}$ is equal to [[rates[0]]], and $n_1$ is equal to
[[nz1[pc1]]] for active lineage [[z1]] to coalesce. 
The coalescent event between two active lineages with [[type]] being 'd' happens
with probability:
\[
\lambda e^{-\lambda t} \times \frac{\lambda_{c12}}{\lambda},\] where
$\lambda_{c12}$ is equal to [[rates[4]]].

A migration event along lineage 1 happens with probability:
\[
\lambda e^{-\lambda t} \times \frac{\lambda_{m1_k}}{\lambda} \times
\frac{m_{i1 \rightarrow j}}{\lambda_{m1_k}},\]
where $\lambda$ is the total rate, or [[totalrate]], $t$ is [[dt]], 
$\lambda_{m1_k}$ is `total' migration rate away from the current population of
lineage 1 during period $k,$ that is equal to [[gk->ms[ki][pc1]]], and
[[rates[1]]], and $m_{i1 \rightarrow j}$ is the migration rate from population
$i1$ to $j.$ Note that $i1$ is the current population label. 
Note that $m_{i1 \rightarrow j}$ is equal to [[gk->mms[pc1][pj]]].
There are two terms
that are cancelled out: $\lambda$ and $\lambda_{m1_k}.$
A migration event along lineage 2 happens with a similar probability
construction:
\[
\lambda e^{-\lambda t} \times \frac{\lambda_{m2_k}}{\lambda} \times
\frac{m_{i2 \rightarrow j}}{\lambda_{m2_k}},\]
where $m_{i2 \rightarrow j}$ is equal to [[gk->mms[pc2][pj]]].

If there are no events in the active lineages, then we compute the probability
that exponential random variable is larger than the time duration of an
interval that is $\Pr(t \geq t_d),$ which is the same as $1 - \Pr(t < t_d).$ The
probability that we have no event is
\[
e^{-\lambda t}.\]

\paragraph{Add probabilities after the bottom of a partial genealogy}
We consider two cases for computing Hastings term for the simulation beyond the
bottom of a partial genealogy: [[nsum]] is equal to 2 or 3. 
We have a new active genealogy sprouting from the
bottom tip of a partial genealogy by setting [[is_coalesced3]] to 0. The last
event time is set to [[newct]] from which we add time durations from the events
in [[e3]]. Population label at the bottom tip is equal to the last event's
[[pj]]. It must be also equal to [[pop]] of [[edgemiginfo]] [[newm3]].

The computation of probability is similar to the above
: Add probabilities before the bottom of a partial genealogy.

\paragraph{Get [[sbfnew]] and [[saGinew]].}
To compute the numerator of Hastings ratio we prepare two static
variables: [[sbfnew]] and [[saGinew]]. 
[[IMA_intervals_collectsbfnew]] fixes [[sbfnew]] and 
[[IMA_genealogy_derivethetaGinew]] derives [[saGinew]] from [[sbfnew]]. Let us
look at function [[IMA_intervals_collectsbfnew]] in detail. I have mentioned
somewhere else about the condition on which [[sbfold.m3]] exists. 
If active lineages
connect to the root of a full genealogy and they do not survive through the
partial genealogy of the full one, then we have [[sbfold.m3]]. 
This is equivalent to the condition that [[sbfnew.m3]] is NULL and
[[is_finiterootbranch]] is equal to `T.' [[ct]] is the coalescent time of a longer
simulated active lineage if there are two active lineages. 
If [[ct]] is smaller than [[roottime]] of a partial
genealogy, the coalescent time happens earlier than the root time. [[sbfold.m3]]
starts at the root time and starting population label is the same as the label
at the root. If [[ct]] is longer than [[roottime]], [[upt]] is set to the
coalescent time and [[pop]] is set to the label at the coalescent event. [[dnt]]
is set to the time at the bottom of the root of a partial genealogy. We set
[[mig]], [[fpop]], and [[mpall]], properly.

The first part of [[IMA_intervals_collectsbfnew]] fixes [[oldm3]], and the
second part does its original job of fixing [[sbfnew]]. Let us look at the
second part in detail. We start the part by copying [[e1]] of [[sbfold]] to that
of [[sbfnew]]. If [[newm3]] exists, we add the migration events in [[newm3]] to
[[e1]] of [[sbfnew]]. If [[oldm3]] exists (or [[newm3]] does not exist and
[[is_finiterootbranch]] is 1), then we subtract the migration events of
[[oldm3]] from [[e1]] of [[sbfnew]].

Note that we may need to do something about [[seqz1]], [[seqz2]],
[[is_z12first]], etc.

Let us look at the function [[IMA_genealogy_derivethetaGinew]]. We need [[cc]],
[[fc]], [[cm]], and [[fm]] to compute all model parameter values to simulate
events along active lineages. We copy those parts of [[saGiold]] to those of
[[saGinew]] at the outset of the function. 
If we have neither [[newm3]] nor [[oldm3]], we copy all other
model parameter related variables: [[thetas]], [[ms]], and [[mms]].


\paragraph{Reattach the branch or branches.}
              /* Split newsis1 to two branches at time newct1. */
              /* The down branch is newdown1. */
              /* Connect all newedge1, newsis1, and newdown1. */
              /* We should attach 1 first, then 2 because of the case where two
               * edges coalesce with the same sister. */

              /* Split newsis2 to two branches at time newct2. */
              /* The down branch is newdown2. */
              /* Connect all newedge2, newsis2, and newdown2. */

something for assigning infinite-sites sequence at the internal node.
We may keep the internal node sequences at [[down1]] and [[down2]] edges.


\paragraph{Update locus information}
[[mignum]], [[roottime]], and [[root]] are updated. [[length]] and [[tlength]]
are updated in [[treeweight]], and we do not need to deal with them.
\paragraph{Considering infinite-sites data}
We consider data at the tips and the root node of a full genealogy. 
We set all internal nodes to -1.

Starting from a tip node, we stop when we hit the root of a genealogy.

Considering sequence states of infinite-sites data more complicates the
structure of function [[bfmove]]. We should take into account sequence
``labels'' as well as population label.

Why does a genealogy become larger without-data run?
With-data run it falls in a ``infinite'' loop? A run with data generates a large
genealogy. The infinite loop may disappear if I can figure out the problem of
without-data run. 
I decrease theta prior and it is stuck again in a infinite loop.
We use the number of lineages without considering infinite sites data to compute
the total rate of a next event and choose one of possible events: lineage 1
coalescent and migration, lineage 2 coalescent and migration, and lineage 1 and
2 joint coalescent. Once we are finished with our choice of a next event kind,
we consider infinite sites data to choose one of edges available to attach. The
available number of edges can be smaller than the number of lineages in that
population. If there are no available edges to coalesce, we continue to sample
next waiting time. Migration events are not affected by this approach.

We set the the derived coalescent rate parameter value to the maximum if it is
greater than the maximum. The model parameter is determined by [[fc]], [[cc]],
[[fm]], and [[cm]]. When all values are positive, parameter values are well
defined: $fc/cc.$ 
When [[fc]] is positive and [[cc]] is zero, then we ...
use $\Theta_{max}$ or $length_{genealogy}/{n_{genes} - 1}$.
When both [[fc]] and [[cc]] are zero, $\Theta$ is not well defined.
When [[cm]] and [[fm]] are both positive, the migration parameter value is well
defined: $cm/fm.$ If either [[cm]] or [[fm]] is zero, we use ...
$mignum_{genealogy}/tlength_{genealogy}$ or $1/\Theta_{max}.$
HEREHERE

\texttt{NOTE: Diploid data type is not yet considered.}
\paragraph{Diploid Parts: start simulation down towards the genealogy.}
The number [[np]] determines simulation mode. We can tell by variable
[[is_coalesced1]] whether active lineage [[z1]] coalesced. Even if it has not
coalesced, it may not be allowed to coalesce either because $\theta$ for the
population where the active lineage is present is zero (i.e., coalescent rate is
undefined) or because two active lineages must coalesce together. This is true
for variable [[is_coalesced2]]. When two active lineages are in the same
population and they are allowed to coalesce together, they have a positive
coalescent rate. Otherwise, they have zero coalescent rate.
When can [[totalrate]] be zero? Migration rates are always positive. This would
happen in the last period only. There is no lineage in a partial genealogy where
active lineages can coalesce, and two active lieages are not allowed to coalesce
together. This would be zero total rate of a next event. If we have one
active lineage, then it would be the case where there is no lineage in a partial
genealogy to coalesce. This zero total rate is a possible situtation.

We start by setting [[canz12]] of [[sbfold]]. Let us consider two cases: two
active lineage are a sister to each other where down edge has mutation events 
on it, and they are not. If two active lineages share a down edge with mutation
events, then they must coalesce together first before either coalesces with a
lineage of a partial genealogy. This means that [[canz12]] must be true. Edges
[[z1]] and [[z2]] have different sequences at their nodes. Another case is where
two lineages are not a sister to each other or they share a down edge without
mutation on it. In this case they can coalesce together when their sequences at
the bottom of edges are the same.


A thought: we may have different parameters for different active lineages.
We have to consider infinite-sites data when we derive model parameters for
simulations.
We have [[saGioldz1]] and [[saGioldz2]], [[saGinewz1]] and [[saGinewz2]] so that
each active lineage can have its own model parameters for their coalescent
simulation with migrations.


Let us consider the case of two active
lineages. Two lineages exist in populations [[pc1]] and [[pc2]], respectively.
Variable [[saGiold]] has coalescent parameter, [[thetas]], for populations,
and migration rate away [[ms]] for each population per period. If the two 
active lineages are in the last period, we have three choices: lineage [[z1]]
coalesces with one of lineages in population [[pc1]], [[z2]] coalesces with one of
lineages in population [[pc2]], and the active lineages coalesce together. The
populations [[pc1]] and [[pc2]] are the same because the lineages are in the
last period. The variable [[np]] is 3 for this case. 
If there is a single active lineage
during the last period, then [[np]] must be 1. 
In short, active lineages are in the last period 
with [[np]] being 1 or 3.
Similarly, [[np]]
is 2, 4, or 5, when acitve lineages are not in the last period: 2 for a single
active, 4 for two active in different populations, 5 for two active in the same
population. These 5 cases are valid for the case where there are inactive
lineages from a partial genealogy, or before we exhaust all intervals of events
from the partial genealogy. We need to separately consider it when we have only
active lineages beyond the last event of a partial genealogy.

When one of two active coalesces, we set the following variables: 
[[sbfnew.sis2]], [[sbfnew.down2]], [[sbfnew.ct2]], [[sbfnew.m2]], and 
label at [[sbfnew.down2]].
When a single active coalesces, we set 
[[sbfnew.sis1]], [[sbfnew.down1]], [[sbfnew.ct1]], [[sbfnew.m1]], and 
label at [[sbfnew.down1]].
We also end the migration events along the active lineage.
There may be a single active lineage both because there was only one, and
because one active lineage is left after the other active had already coalesced
with a branch. Two active lineages can share a ``sister'' branch for their
coalescents. We attach [[sbfnew.edge1]] branch first, and then [[sbfnew.edge2]] 
because
new sister branches become the upper parts of their original sister branch after
regrafting [[sbfnew.edge1]] to a new sister branch.

Let us see what variables need to be set for a coalescent event for the case of
[[np]] being 1. Lineage [[z1]] or [[z2]] can coalesce. We set [[is_coalesced1]]
to `T' to notice that lineage [[z1]] coalesces. Using time [[newct]] and
population label [[pc1]] of the lineage, we could have find all lineages with
which active lineage [[z1]] is allowed to coalesce.
Member variable [[nz1]] of [[sbfold]] has the number of the allowable lineages.
We choose one of them and access using [[lz1]] of [[sbfold]] at random.
The new edge becomes [[z1]], new sister becomes one of the collected lineages.
The new down edge becomes [[down1]], which is not necessarily connected with
[[z1]]. The migration events along the new edge [[z1]] is pointed to by 
[[sbfnew.m1]],
and its event is terminated by setting [[mt]] to $-1.$ We set population label
at the new internal node to [[pc1]]. The label [[pc1]] might not the one we want
it to be because it is the label for the previous event. Let's say, a previous
event happens in other period, then we need to consider the current period to
find a correct label. Fortunately, we correct this when we meet a split event.
We can safely use [[pc1]] without any change. 
When one of two active lineages coalesces, we set all variables related with
[[sbfnew.edge2]]. When two active coalesce together, we also set variables 
related with [[sbfnew.edge2]] and [[z1]] proceeds to simulate. 

We set all variables for the last coalescent event, which is 1: [[sbfnew.edge1]],
[[sbfnew.sis1]], and [[sbfnew.down1]]. 
If there were two active lineages and
we were finished with the first or not the last coalescent event, then we would
have set all variables with 2: e.g., [[sbfnew.edge2]] and [[sbfnew.sis2]] etc. 
Since
[[is_coalesced1]] was `F' and we set it to `T,' [[sbfnew.edge1]] is [[z1]], and
[[sbfnew.down1]] is [[down1]]. We set [[sbfnew.sis1]] to one of lineages 
in a partial
genealogy: [[lz1]] of [[sbfold]]. 
Because
[[edgemiginfo]] [[m1]] is storing migration events along the edge [[z1]], we set
[[sbfnew.m1]] to [[m1]]. We finalize the migration event by setting 
last migration
event time to -1. This is redundant, but we also set [[dnt]] and [[fpop]] of
[[m1]]. We set the population label of the node, or [[down]] edge to [[pc1]].


When there are two active lineages, [[np]] can be 3, 4, and 5. If [[re]] is 0,
then lineage [[z1]] coalesces with one of lineages in a partial genealogy. This
is Case (C). The code for Case (C) is similar to that of Case (A) except that we
set all variables with 2: [[sbfnew.edge2]], [[sbfnew.sis2]], [[sbfnew.down2]], 
and [[sbfnew.m2]]. If lineage [[z2]] coalesces, then [[re]] is 1 with [[np]] 
being
3, 2 with [[np]] being 4 or 5: Case (D). We set [[is_coalesced2]] to 1 to note
that lineage [[z2]] coalesces. We set [[sbfnew.edge2]] to [[z2]], 
[[sbfnew.down2]] to [[down2]], and [[sbfnew.m2]] to [[m2]]. 
We choose one of
edge from [[lz2]] of [[sbfold]].
We finalize [[edgemiginfo]], and set [[dnt]] and [[fpop]]. The coalescent node
or [[down2]] edge [[pop]] is labelled with [[pc2]].

Case (E). Lineages [[z1]] and [[z2]] coalesce together: 
[[np]] is 3 and [[re]] is 2, or 
[[np]] is 5 and [[re]] is 4.
We can let [[z1]] or [[z2]] continue to simulate their events. If [[sbfold]]'s
[[is_z12first]] is true, then [[seqz1]] must be used for our continued active
lineage and [[z1]] is used. Otherwise, we can choose one of [[z1]] and [[z2]]
for out continued simulating active lineage.

Cases (F) and (G) are for migration events of lineages [[z1]] and [[z2]]. The
migration rates for choosing one event are rate away from a particular
population. Depending on period [[ki]] of time at which a gene migrates there
are $npops - ki - 1$ many populations to which a gene can migrate. [[mms]]
variable of [[gk]] or [[im_ginfo]] has the migration rate for period,
from-pop, and to-pop. We call function [[IMA_choose_migtopop]] to choose one
population. We use [[m1]] for lineage [[z1]], and [[m2]] for [[z2]].
\begin{Verbatim}[frame=lines,framesep=5mm]
Case (A). Only Lineage z1 coalesces:
np == 1, is_coalesced1 == 'F'
np == 2, is_coalesced1 == 'F', re == 0

Case (B). Only Lineage z2 coalesces:
np == 1, is_coalesced2 == 'F'
np == 2, is_coalesced2 == 'F', re == 0

Case (C). Lineage z1 of two coalesces:
np == 3, re == 0 
np == 4, re == 0
np == 5, re == 0

Case (D). Lineage z2 of two coalesces:
np == 3, re == 1 
np == 4, re == 2
np == 5, re == 2

Case (E). Lineages z1 and z2 coalesce together:
np == 3, re == 2 
np == 5, re == 4

Case (F). Lineage z1 migrates:
np == 2, is_coalesced1 == 'F', re == 1
np == 4, re == 1
np == 5, re == 1

Case (G). Lineage z2 migrates:
np == 2, is_coalesced2 == 'F', re == 1
np == 4, re == 3
np == 5, re == 3
\end{Verbatim}

\paragraph{Diploid Parts: Simulation beyond the genealogy.}
If we simulate coalescent and migration events with active lineages, 
active lineages would coalesce with inactive lineages of a partial genealogy. It
is possible that active lineages ``survive'' beyond the bottom of a partial
genealogy. Then a new active lineage from the last event of a partial genealogy
emerges. The last event can be a coalescent or the ``ending'' event depending on
whether active lineages were attached to the oringal root of a full genealogy.
There may be 2 or 3 active lineages, or [[nsum]]. We deal with these two cases,
separately. 

Before we try to simulate active lineages events, we check whether we can ever
propose a new genealogy. What if all active lineages cannot coalesce together?
We then have to restart our simulation. When there are 3 of [[nsum]] active
lineages, we have three possible scenarios of coalescent events. Each scenario
requires at least two coalescent events. For example, [[z1]] and [[z2]] can
coalesce together, and [[z3]] and [[z2]] can coalesce later. If we have only
single coalescent event is possible, then we have to go back [[simulation]]
[[goto]] statement. We reset migration events on active lineages: [[dnt]],
[[fpop]], [[mpall]], and [[mig]] are accessed before we go to [[simulation]]
point.

When [[nsum]] is 3, we have 5 situations, [[si]].
Case 1. All three active lineages are in different populations.
Case 2, 3, and 4. Two are in the same, and the other is in different population.
Case 5. Three are in the same population.
Note that we take split event into account in a little different manner from the
simulation before the bottom of a partial genealogy. 
We simulate next waiting time and if it crosses the imminent population split,
then we set the waiting time to the split time and restart our simulation in the
split time after moving to the next period.
We should find right
period for each cycle of simulation of next event. 
Function [[bfmove_ratesII]] fills [[rates]] using 
variables [[gk]], [[sbfold]], [[ki]], [[pc1]], [[pc2]], and [[pc3]].
The first three are migration
events and the latter three are coalescent events. 
The migration events are similarly handled just like the case above. Coalescent
events deserves more attentions. Since there are 3 active lineages, we set all
variables with 2: e.g., [[sbfnew.edge2]]. 
When lineage [[z1]] and [[z2]] coalesce,
we have [[z2]] coalesce with sister being [[z1]]. At the end, we set [[nsum]] to
2 to simulate 2 active lineages. In a similar fashion,  
when lineage [[z2]] and [[z3]] coalesce, we force [[z2]] coalesce with sister
being [[z3]]. We force [[z1]] coalesce with sister being [[z3]] if lineage
[[z3]] and [[z1]] coalesce. 

Let us consider [[nsum]] of 2. Migration events are handled in the same fashion
as above. When [[z2]] and [[z3]] coalesce together, we set [[is_coalesced2]] and
[[is_coalesced3]] to `T.' We set [[sbfnew.edge1]] to [[z2]], and 
[[sbfnew.sis1]] to
[[z3]]. We set all variables of 1: e.g., [[sbfnew.edge1]] because this is a last
coalescent event. We set [[sbfnew.down1]] to [[sbfold.down2]].
Since we finish our simulation here in the last coalescent event and this is
simulation beyond a partial genealogy, we have two [[edgemiginfo]], [[m2]] and
[[m3]]. We set [[sbfnew.m3]] to [[m3]], and [[sbfnew.m1]] to [[m2]]. 
Label at the coalescent is [[pc2]] that must be the same as [[pc3]].
When [[nsum]] is 2, we have 2 situations, [[si]].
Case 1. lineage 3 and 1 survives.
Case 2. lineage 3 and 2 survives.
Since we do not know whether population labels at current time get acclimated to
current period, we find the current period [[ki]] using current time [[newct]]
and reflect the period on population labels. We pretend to have 6 possible
events although one of them is impossible: 0 for lineage [[z1]]'s migration, 1
for [[z2]]'s migration, 2 for [[z3]]'s migration, 3 for [[z1]] and [[z2]]'s
coalescent that is impossible, 4 for [[z2]] and [[z3]]'s coalescent, and 5 for
[[z3]] and [[z1]]'s coalescent. Depending on whether lineages 3 and 1, or 2 and
3 survives, and whether two are in the same poplation or not, we set the proper
rates.

\paragraph{We missed these points.}
If two active lineages are a sister to each other and they share the same
segregating sites due to mutation events along their parent edge, then two
active lineages must coalesce together before each does with a lineage of a
partial genealogy: [[is_sister]] and [[is_z12first]].

What are the sequences at the bottom of two active lineages that are a sister to
each other?


<<updateassignment static>>=
static double bfmove (int ci);
<<updateassignment bf>>=
double
bfmove (int ci)
{
  /* iterator variables */
  int li;
  int ei;
  int pj;
  int ii;
  int ij;
  int ej;
  int i;
  int mi;
  int si;
  /* numbers of counts */
  int nei;
  int ngenes;
  int nsum;
  int np;
  int ki;
  int prevki;
  int oldpop;
  int newpop;
  struct genealogy *G;
  struct edge *gtree; 
  int z1;
  int z3;
  int pc1;
  int pc3;
  char is_coalesced1;
  char is_coalesced3;
  im_edgemiginfo *m1;
  im_edgemiginfo *m3;
  double totalrate;
  double rates[2 * MAXPOPS];
  double newct;
  int down1;
  int re;
  double dnt_genealogy;
  int ri;
  int nsim;
  int ti;
  double lhweight;
  im_event *ek;
  im_ginfo *gk;
  im_ginfo *gkz1;
  double prevt;
  double dt;
  double u;
  double rt;
  int nr;
  double lqstar;
  double lq;

  lhweight = 0.0;

  /* Find all internal node sequences and mutations of a full genealogy. */
  for (li = 0; li < nloci; li++)
    {
      if (L[li].model == INFINITESITES 
          && calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
        {
          i = IMA_genealogy_findIntSeq (ci, li);
          assert (i == 1);
        }
    }

  /* Pick an individual to relabel. */
  ii = snind_known + randposint (snind_unknown);
  nei = sngenes_ind[ii];
  for (ij = 0; ij < nei; ij++)
    {
      li = saC.indlist[ii][ij].li;
      ei = saC.indlist[ii][ij].ei;
      imaSavedSaveBranch (ci, li, ei);
    }

  /* Prepare all migration events storage. */
  for (li = 0; li < nloci; li++)
    {
      IMA_reset_edgemiginfo (&saoems[2 * li]);
      IMA_reset_edgemiginfo (&saoems[2 * li + 1]);
      IMA_reset_edgemiginfo (&saosms[2 * li]);
      IMA_reset_edgemiginfo (&sanems[2 * li]);
      IMA_reset_edgemiginfo (&sanems[2 * li + 1]);
      IMA_reset_edgemiginfo (&sansms[2 * li]);
    }
  for (ij = 0; ij < nei; ij++)
    {
      li = saC.indlist[ii][ij].li;
      ei = saC.indlist[ii][ij].ei;
      ej = saoems[2 * li].edgeid;
      if (ej < 0)
        {
          IMA_edgemiginfo_copymig (&saoems[2 * li], ci, li, ei);
        }
      else
        {
          assert (0);
        }
    }

  /* Label all the genes. */
  li = saC.indlist[ii][0].li;
  ei = saC.indlist[ii][0].ei;
  oldpop = C[ci]->G[li].gtree[ei].pop;
  lhweight = imaRandomPickpopn (&newpop, ci, oldpop, C[ci]->rootpop);
  sbfold.pop = oldpop;
  sbfnew.pop = newpop;
  for (ij = 0; ij < nei; ij++)
    {
      li = saC.indlist[ii][ij].li;
      ei = saC.indlist[ii][ij].ei;
      C[ci]->G[li].gtree[ei].pop = newpop;
    }

  /* Simulate branches for each genealogy. */
  for (li = 0; li < nloci; li++)
    {
      ngenes = L[li].numgenes;
      G = &C[ci]->G[li];
      gtree = G->gtree;

      /* If no genes in locus [[li]] belong to individual [[ii]]. */
      /* Decide old branches. -> wrong words!     */
      /* We do not have a longer branch any more. */
      if (saoems[2 * li].edgeid < 0)
        {
          /* No long branches any more. */
          /* assert (0); We can delete this line but I do not allow partial
          genes of an individual. */
          continue;
        }

      assert (saoems[2 * li].upt == 0.0);
      sbfold.m1 = &saoems[2 * li];
      z1 = sbfold.m1->edgeid;

      m1 = &sanems[2 * li]; /* sbfnew.m1 could be m1. */
      m1->li = li;
      m1->edgeid = z1;
      m1->upt = 0.0;
      m1->pop = newpop;
      dnt_genealogy = imaGtreeTime (ci, li, G->root);

      /* Detach active lineages. */
      sbfold.is_finiterootbranch = 'F'; /* This is the 1st occurrence.(2 more) */
      IMA_genealogy_detach (ci, li, &sbfold, z1);

      /* Get intervals of events of a partial genealogy. */
      assert (!gsl_fcmp(dnt_genealogy, G->roottime, 1e-7));
      IMA_intervals_collect (ci, li, 0.0, G->roottime);

      /* Derive parameters from a partial genealogy. */
      IMA_genealogy_derivetheta ('o', ci, li, z1);
      gk = &saGiold[li];
      gkz1 = &saGioldz1[li];

      nsim = 0;
simulation:
      nsim++;

#ifdef DEBUG
      if (L[li].model != INFINITESITES)
        {
          assert (L[li].model == HKY || L[li].model == STEPWISE);
          assert (nsim == 1);
        }
#endif /* DEBUG */

      /* Prepare the number of lineages with which active lineages can coalesce. */
      IMA_sbf_lineages (&sbfold, ci, li, z1);

      /* Initialize active lineages. */
      m1->dnt = -1.0;
      m1->fpop = -1;
      m1->mpall = 0;
      m1->mig[0].mt = -1.0;
      m1->mig[0].mp = -1;
      sbfnew.sis1 = -1;
      sbfnew.m1 = NULL; /* sbfnew.m1 is the same as &sanems[2 * li]    */
      sbfnew.m3 = NULL; /* but we do not know this is null or not yet. */
      sbfnew.is_finiterootbranch = 'F';
      sbfnew.canz31 = 'F'; /* both canz31 must be the same? */
      sbfold.canz31 = 'F';
      sbfold.m3 = NULL; /* but we do not know this is null or not yet. */
      is_coalesced1 = 'F';

      ti = 0;
      prevt = 0.0;
      ki = 0;
      pc1 = gtree[z1].pop;
      assert (pc1 == newpop);

      /* Start simulation down towards the genealogy. */
      ek = sbfold.e1; 
      while (is_coalesced1 == 'F')
        {
          dt = ek->t - prevt;
          assert (dt > 0.0);
          while (dt > 0.0 && is_coalesced1 == 'F')
            {
              np = bfmove_ratesI (&rates, gk, gkz1,
                                  &sbfold, ki,
                                  pc1);
              totalrate = 0.0;
              for (pj = 0; pj < np; pj++)
                {
                  assert (!(rates[pj] < 0.0));
                  totalrate += rates[pj];
                }
              if (totalrate > 0.0)
                {
                  u = uniform ();
                  rt = -log (u) / totalrate;
                  dt -= rt; 
                }
              else if (totalrate == 0.0)
                {
                  /* assert (0); */
                  /* assert (0); I do not know when this would happen: Answer -
                   * This can happen when there is no lineage to attach an
                   * active lineage in the last period. I am not sure whether
                   * this could continue to happen once we have zero total rate.
                   * If that is the case, we may let this happen and resimulate
                   * once we get to the beyond of the bottom of a partial
                   * genealogy. */
                  dt = -1.0;
                }
              else
                {
                  assert (0);
                }
              if (dt < 0)
                {
                  /* move to next interval: we hit and exit the current while,
                   * then we increase ti and ek */
                  continue;
                }
              else
                {
                  newct = ek->t - dt;
                }
              re = ran_discretea (np, rates);

              /* Case (A). Only one lineage z1 coalesces. */
              if ((np == 1 && is_coalesced1 == 'F')
                  || (np == 2 && is_coalesced1 == 'F' && re == 0))
                {
                  is_coalesced1 = 'T';
                  /* We need a list of edges: n and l.                     */
                  /* We computes discrete probabilities for all the edges. */
                  i = bfmove_chooseAnEdge (ci, li, &sbfold, newct, pc1);
                  if (L[li].model == INFINITESITES)
                    {
                      sbfnew.sis1 = sbfold.lz1[pc1][i];
                    }
                  else if (L[li].model == HKY || L[li].model == STEPWISE)
                    {
                      sbfnew.sis1 = sbfold.l[pc1][i];
                    }
                  else
                    {
                      assert (0);
                    }
                  /* sbfnew.down1 = sbfold.down1; */
                  sbfnew.m1 = m1;
                  m1->mig[m1->mpall].mt = -1.0;
                  m1->dnt = newct;
                  m1->fpop = pc1;
                }
              /* Case (F). Lineage z1 migrates */
              else if (np == 2 && is_coalesced1 == 'F' && re == 1)
                {
                  IMA_choose_migtopop (&ri, ki, pc1, gk);
                  assert (pc1 != ri);
                  pc1 = ri;
                  mi = m1->mpall;
                  m1->mig[mi].mt = newct;
                  m1->mig[mi].mp = pc1;
                  m1->mpall++;
                }
              else
                {
                  assert (0);
                }
            }
          if (is_coalesced1 == 'T')
            {
              break;
            }

          /* New time is further back in time than the bottom of an event. */
          bfmove_nextI (ci, li, 0.0, ek, np, rates, 
                        NULL, &sbfold, /* &sbfnew, */
                        &ki,
                        z1,
                        &is_coalesced1,
                        &pc1);
          prevt = ek->t;
          ti++;
          if (ti < sbfold.n1)
            {
              ek++;
            }
          else
            {
              break;
            }
        }

      /* Simulation beyond the bottom of a genealogy. */
      sbfnew.m3 = NULL;
      if (is_coalesced1 == 'F') 
        {
          assert (sbfold.n1 == ti);
          /* Should we do two different actions for the last event type? */
          assert (sbfold.e1[ti - 1].type == 'c' 
                  || sbfold.e1[ti - 1].type == 'e');
          assert (sbfold.e1[ti - 1].t == prevt);
          assert (findperiodoftime (ci, prevt) == ki);

          is_coalesced3 = 'F';
          newct = prevt;
          pc3 = sbfold.e1[ti - 1].pj;
          assert (!(pc1 < 0));
          assert (!(pc3 < 0));
          assert (sbfold.e1[ti - 1].ei == G->root);
          z3 = G->root;
          m3 = &sansms[2 * li];
          m3->li = li;
          m3->edgeid = z3;
          m3->upt = prevt;
          m3->pop = pc3;

          sbfold.canz31 = 'T';
          if (L[li].model == INFINITESITES
              && calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
            {
              for (si = 0; si < L[li].numsites; si++)
                {
                  if (G->mut[si] == z3)
                    {
                      continue;
                    }
                  if (gtree[z3].seq[si] != sbfold.seqz1[si])
                    {
                      sbfold.canz31 = 'F';
                      break;
                    }
                }
            }
          else if (L[li].model == HKY || L[li].model == STEPWISE)
            {
              /* No code: we should attach an active lineage. */
            }

          nsum = IMA_sbf_nsum (&sbfold, pc1, pc3);
          assert (nsum == 2); /* Do not consider diploid data type. */
          if (is_coalesced1 == 'F' && sbfold.canz31 == 'F')
            {
              m1->dnt = -1.0;
              m1->fpop = -1;
              m1->mpall = 0;
              m1->mig[0].mt = -1.0;
              goto simulation;
            }
          assert (sbfold.canz31 == 'T');

          /* ki is set before. */
          while (nsum == 2)
            {
              assert (is_coalesced1 == 'F');
              assert (is_coalesced3 == 'F');
              assert (pc1 < 2 * npops - 1);
              assert (!(pc1 < 0));
              assert (pc3 < 2 * npops - 1);
              assert (!(pc3 < 0));
              pc1 = saC.popndown[pc1][ki];
              pc3 = saC.popndown[pc3][ki];

              bfmove_ratesIII (&rates, gk, &sbfold, ki, pc1, pc3);
              nr = 3;
              totalrate = 0.0;
              for (ri = 0; ri < nr; ri++)
                {
                  totalrate += rates[ri];
                }
              assert (totalrate > 0.0);
              u = uniform ();
              rt = -log (u) / totalrate;
              prevki = ki;
              newct = newct + rt;
              ki = findperiodoftime (ci, newct);
              if (prevki == ki)
                {
                  /* No Code */
                }
              else if (prevki < ki)
                {
                  /* ki can be larger than prevki by more than one. */
                  newct = C[ci]->tvals[prevki];
                  ki = prevki + 1;
                  continue;
                }
              else
                {
                  assert (0);
                }
              re = ran_discretea (nr, rates);
              switch (re)
                {
                case 0:
                  IMA_choose_migtopop (&ri, ki, pc1, gk);
                  pc1 = ri;
                  mi = m1->mpall;
                  m1->mig[mi].mt = newct;
                  m1->mig[mi].mp = pc1;
                  m1->mpall++;
                  break;
                case 1:
                  IMA_choose_migtopop (&ri, ki, pc3, gk);
                  pc3 = ri;
                  mi = m3->mpall;
                  m3->mig[mi].mt = newct;
                  m3->mig[mi].mp = pc3;
                  m3->mpall++;
                  break;
                case 2: /* Lineages z1 coalesces with z3. */
                  is_coalesced3 = 'T';
                  is_coalesced1 = 'T';
                  /* What are all these about? */
                  sbfnew.sis1 = z3;
                  /* sbfnew.down1 = sbfold.down1; */
                  sbfnew.m1 = m1;
                  m1->mig[m1->mpall].mt = -1.0;
                  m1->dnt = newct;
                  m1->fpop = pc1;
                  sbfnew.m3 = m3;
                  m3->mig[m3->mpall].mt = -1.0;
                  m3->dnt = newct;
                  m3->fpop = pc3;
                  assert (pc1 == pc3);
                  bfmove_chooseA1 (ci, li, &sbfnew);
                  nsum = 1;
                  break;
                }
            }
        }

      if (sbfold.is_finiterootbranch == 'F')
        {
          assert (sbfold.m3 == NULL);
        }
      /* Get [[sbfnew]] and [[saGinew]]. */
      IMA_intervals_collectsbfnew (ci, li, sbfnew.m3);
      IMA_genealogy_derivetheta ('n', ci, li, z1);
      if (L[li].model == INFINITESITES)
        {
          /* No code. */
        }
      else if (L[li].model == HKY || L[li].model == STEPWISE)
        {
          /* FIXME: What if there is no or single inactive lineage? */
          bfmove_selectAnEdge (ci, li, &sbfnew, &sbfold);
          /* bfmove_selectA1 (ci, li, &sbfold); */
        }

      /* Compute Hasting ratio. */
      /* G     -> Gp     -> Gstar */
      lqstar = bfq (&sbfold, &sbfnew, ci, li, gk, gkz1);
      /* Gstar -> Gstarp -> G     */
      lq = bfq (&sbfnew, &sbfold, ci, li, &saGinew[li], &saGinewz1[li]);
      lhweight += (lq - lqstar);

      /* Reattach the branch or branches. */
      down1 = gtree[sbfnew.m1->edgeid].down;
      if (sbfnew.m3 != NULL)
        {
          assert (sbfnew.sis1 == G->root);
          IMA_genealogy_appendmig (ci, li, 
                                   sbfnew.sis1, sbfnew.m3, 
                                   sbfnew.m1->edgeid, down1);
        }
      else
        {
          IMA_genealogy_bisectsis (ci, li, 
                                   sbfnew.sis1, sbfnew.m1->edgeid, 
                                   down1, 
                                   sbfnew.m1, 
                                   sbfnew.seqz1);
        }
      IMA_genealogy_copymig (ci, li, sbfnew.m1->edgeid, sbfnew.m1);
      gtree[G->root].time = TIMEMAX;
      gtree[G->root].down = -1;
      gtree[G->root].mig[0].mt = -1.0;

      /* Update locus information. */ 
      gtree[z1].exist = 'T';
      down1 = gtree[z1].down;
      gtree[down1].exist = 'T';
      G->roottime = imaGtreeTime (ci, li, G->root); 
      sbfold.n1 = 0;
      sbfold.n2 = 0;
      sbfold.n3 = 0;
      sbfnew.n1 = 0;
      sbfnew.n2 = 0;
      sbfnew.n3 = 0;

      if (L[li].model == INFINITESITES 
          && calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
        {
          i = IMA_genealogy_findIntSeq (ci, li);
          assert (i == 1);
        }
      else if (L[li].model == HKY) 
        {
          /* No code. */
        }
      else if (L[li].model == STEPWISE)
        {
          /* No code. */
          assert (sbfnew.A1 >= L[li].minA[0] && sbfnew.A1 <= L[li].maxA[0]);
          gtree[down1].A[0] = sbfnew.A1;
        }
      /* printf ("[%d] root time - %lf\n", step, G->roottime);  */
    }

  return lhweight;
}

@
We use [[nz1]] and [[lz1]] to choose an edge to attach an active lineage for
infinite-sites model. We use [[n]] and [[z]] to compute likelihood that we would
have if we attach an active lineage to one of lineages that exists during the
interval in population [[pc]]. We need a way to attach and detach an edge very
easily for computing likelihood. We then use the list of likelihoods to choose
one of edges to attach the active lineage.
[[bfmove_chooseA1]] sets the allele at the new coalescent event.
<<updateassignment static>>=
static void bfmove_chooseA1 (int ci, int li, im_bfupdate *pbf);
static double bfmove_selectA1 (int ci, int li, im_bfupdate *pbf, double lq);
static int bfmove_chooseAnEdge (int ci, int li, im_bfupdate *pbf, double ct, int pc);
static int bfmove_selectAnEdge (int ci, int li, im_bfupdate *pbf, im_bfupdate *qbf);
<<updateassignment bf>>=
void
bfmove_chooseA1 (int ci, int li, im_bfupdate *pbf)
{
  double u;
  struct genealogy *G;
  struct edge *gtree; 
  int nA;
  int bi;
  int newA;
  double dlikeA;
  double sisupt;
  int sis;
  int edge;
  double ct;
  int vj;
  double sisnewtlen;
  int d;
  double bessiv;

  if (L[li].model == STEPWISE)
    {
      G = &C[ci]->G[li];
      gtree = G->gtree;

      /**********************************************************/
      /*                  SOMEWHAT COMPLICATED                  */
      /**********************************************************/
      /* All unlinked loci! */
      edge = pbf->m1->edgeid;
      sis = pbf->m3->edgeid;
      sisupt = imaGtreeTime (ci, li, sis);
      sisnewtlen = pbf->m3->dnt - sisupt;
      ct = pbf->m1->dnt;
      
      u = G->uvals[0];
      nA = L[li].maxA[0] - L[li].minA[0] + 1;
      for (bi = 0; bi < nA; bi++)
        {
          newA = L[li].minA[0] + bi;
          dlikeA = 0.0; /* FIXME: */

          d = gtree[sis].A[0] - newA;
          bessiv = bessi (d, sisnewtlen * u);
          assert (bessiv > 0.0);
          dlikeA += (-(sisnewtlen * u) + log (bessiv));

          d = gtree[edge].A[0] - newA;
          bessiv = bessi (d, ct * u);
          assert (bessiv > 0.0);
          dlikeA += (-(ct * u) + log (bessiv));

          /* A rooting edge does not have a likelihood under SW model. */

          pbf->likes11[0][bi] = dlikeA;
        }
      normalizeLoga (nA, pbf->likes11[0]);
      vj = ran_discreteloga (nA, pbf->likes11[0]);
      pbf->likei11 = vj;
      pbf->A1 = L[li].minA[0] + vj;
      pbf->likei1 = 0;
      pbf->likes1[0] = 0.0;
      /**********************************************************/
      /*                  SOMEWHAT COMPLICATED                  */
      /**********************************************************/
    }
  return;
}

double
bfmove_selectA1 (int ci, int li, im_bfupdate *pbf, double lq)
{
  double u;
  struct genealogy *G;
  struct edge *gtree; 
  int nA;
  int bi;
  int newA;
  double dlikeA;
  double sisupt;
  int sis;
  int edge;
  double ct;
  double sisnewtlen;
  int d;
  double bessiv;

  if (L[li].model == STEPWISE)
    {
      assert (pbf->m3 != NULL);

      G = &C[ci]->G[li];
      gtree = G->gtree;

      /**********************************************************/
      /*                  SOMEWHAT COMPLICATED                  */
      /**********************************************************/
      /* All unlinked loci! */
      edge = pbf->m1->edgeid;
      sis = pbf->m3->edgeid;
      sisupt = imaGtreeTime (ci, li, sis);
      sisnewtlen = pbf->m3->dnt - sisupt;
      ct = pbf->m1->dnt;
      
      u = G->uvals[0];
      nA = L[li].maxA[0] - L[li].minA[0] + 1;
      for (bi = 0; bi < nA; bi++)
        {
          newA = L[li].minA[0] + bi;
          dlikeA = 0.0; /* FIXME: */

          d = gtree[sis].A[0] - newA;
          bessiv = bessi (d, sisnewtlen * u);
          assert (bessiv > 0.0);
          dlikeA += (-(sisnewtlen * u) + log (bessiv));

          d = gtree[edge].A[0] - newA;
          bessiv = bessi (d, ct * u);
          assert (bessiv > 0.0);
          dlikeA += (-(ct * u) + log (bessiv));

          /* A rooting edge does not have a likelihood under SW model. */
          pbf->likes11[0][bi] = dlikeA;

          if (pbf->A1 == L[li].minA[0] + bi)
            {
              pbf->likei11 = bi;
            }
        }
      normalizeLoga (nA, pbf->likes11[0]);
      lq += pbf->likes11[0][pbf->likei11];
      assert (pbf->A1 == L[li].minA[0] + pbf->likei11);
      /**********************************************************/
      /*                  SOMEWHAT COMPLICATED                  */
      /**********************************************************/
    }
  return lq;
}

int 
bfmove_chooseAnEdge (int ci, int li, im_bfupdate *pbf, double ct, int pc)
{
  int i;
  int vi;
  int sis;
  struct genealogy *G;
  struct edge *gtree; 
  int edge;
  int down;
  int downdown;
  int up;
  double sisupt;
  double sisdnt;
  double sisoldtl;
  double sisnewtl;
  double downtl;
  double u;
  int nA;
  int bi;
  int newA;
  double dlikeA;
  int d;
  double bessiv;
  int iszero;
  int vj;

  G = &C[ci]->G[li];
  gtree = G->gtree;
  edge = pbf->m1->edgeid;
  down = gtree[edge].down;

  if (L[li].model == INFINITESITES)
    {
      assert (pbf->nz1[pc] > 0);
      vi = randposint (pbf->nz1[pc]);
    }
  else if (L[li].model == HKY || L[li].model == STEPWISE)
    {
      assert (pbf->n[pc] > 0);
#ifdef NOTCONSIDERINGDATA
      vi = randposint (pbf->n[pc]);
      break;
#endif /* NOTCONSIDERINGDATA */
      if (pbf->n[pc] > 0)
        {
          /* Compute all likelihoods for possible full genealogies. */
          
          /* We attach an active lineage to one of lineages. Each of the lineages is
           * a candidate for lineage [[sis]]. We freely attach it, 
           * compute likelihood, and detach it. We keep doing this until we fill all
           * likelihoods for all full possible genealogies. */
          for (i = 0; i < pbf->n[pc]; i++)
            {
              sis = pbf->l[pc][i]; /* FIXME: l is not set yet. */
              /* Attach it. */ 
              /* Attaching may be done using a function. */
              downdown = gtree[sis].down;
              sisupt = imaGtreeTime (ci, li, sis);
              assert (sisupt < ct); 

              sisdnt = gtree[sis].time;
              if (G->root == sis)
                {
                  assert (pbf->n[pc] == 1);
                  /* sisdnt is not ... */
                  /* sisdnt = gtree[sis].time; */
                }
              else
                {
                  assert (ct < sisdnt);
                }

              if (G->root == sis)
                {
                  assert (downdown == -1);
                  G->root = down;
                  G->roottime = ct;
                }
              else
                {
                  if (gtree[downdown].up[IM_EDGE_LEFT] == sis)
                    {
                      gtree[downdown].up[IM_EDGE_LEFT] = down;
                    }
                  else
                    {
                      gtree[downdown].up[IM_EDGE_RIGHT] = down;
                    }
                }
              gtree[down].down = downdown;
              gtree[sis].down = down;
              gtree[edge].down = down;
              gtree[down].up[IM_EDGE_LEFT] = sis;
              gtree[down].up[IM_EDGE_RIGHT] = edge;
              gtree[edge].time = ct;
              gtree[sis].time = ct;
              gtree[down].time = sisdnt;
              sisoldtl = sisdnt - sisupt;
              sisnewtl = ct - sisupt;
              downtl = sisdnt - ct;

              /* Compute likelihood. */
              if (L[li].model == HKY)
                {
                  pbf->likes1[i] = likelihoodHKY (ci, li, 
                                                  G->uvals[0], G->kappaval, 
                                                  -1, -1, -1, -1);
                }
              else if (L[li].model == STEPWISE)
                {
                  /**********************************************************/
                  /*                  SOMEWHAT COMPLICATED                  */
                  /**********************************************************/
                  /* All unlinked loci! */
                  u = G->uvals[0];
                  pbf->likes1[i] = 0.0;
                  nA = L[li].maxA[0] - L[li].minA[0] + 1;
                  for (bi = 0; bi < nA; bi++)
                    {
                      newA = L[li].minA[0] + bi;
                      dlikeA = 0.0; /* FIXME: */
                      if (G->root != down)
                        {
                          dlikeA -= gtree[sis].dlikeA[0];
                        }
                      else
                        {
                          assert (downdown == -1);
                        }

                      d = gtree[sis].A[0] - newA;
                      bessiv = bessi (d, sisnewtl * u);
                      if (!(bessiv > 0.0))
                        {
                          iszero = 1;
                          assert (0);
                          /* Impossible situation: IM_BESSI_MIN; */
                        }
                      else
                        {
                          dlikeA += (-(sisnewtl * u) + log (bessiv));
                        }
                      d = gtree[edge].A[0] - newA;
                      bessiv = bessi (d, ct * u);
                      if (!(bessiv > 0.0))
                        {
                          iszero = 1;
                          assert (0);
                          /* Impossible situation: IM_BESSI_MIN; */
                        }
                      else
                        {
                          dlikeA += (-(ct * u) + log (bessiv));
                        }
 
                      if (!(downdown < 0))
                        {
                          d = newA - gtree[downdown].A[0];
                          bessiv = bessi (d, downtl * u);
                          if (!(bessiv > 0.0))
                            {
                              iszero = 1;
                              assert (0);
                              /* Impossible situation: IM_BESSI_MIN; */
                            }
                          else
                            {
                              dlikeA += (-(downtl * u) + log (bessiv));
                            }
                        }
                      pbf->likes11[i][bi] = dlikeA;
                      if (bi == 0)
                        {
                          pbf->likes1[i] = dlikeA;
                        }
                      else
                        {
                          LogSum2 (pbf->likes1[i], pbf->likes1[i], dlikeA);
                        }
                    }
                  /**********************************************************/
                  /*                  SOMEWHAT COMPLICATED                  */
                  /**********************************************************/
                }

              /* Detach it. */
              up = sis;
              if (G->root == down)
                {
                  assert (downdown == -1);
                  gtree[up].down = -1;
                  G->root = up;
                  gtree[up].time = sisdnt;
                }
              else
                {
                  assert (!(downdown < 0));
                  gtree[up].down = downdown;
                  if (gtree[downdown].up[IM_EDGE_LEFT] == down)
                    {
                      gtree[downdown].up[IM_EDGE_LEFT] = up;
                    }
                  else
                    {
                      gtree[downdown].up[IM_EDGE_RIGHT] = up;
                    }
                  gtree[up].time = gtree[down].time;
                }
            }

          if (pbf->n[pc] > 1)
            {
              normalizeLoga (pbf->n[pc], pbf->likes1);
              vi = ran_discreteloga (pbf->n[pc], pbf->likes1);
              pbf->likei1 = vi;
            }
          else if (pbf->n[pc] == 1)
            {
              vi = 0;
              pbf->likes1[0] = 0.0;
              pbf->likei1 = vi;
            }
          else
            {
              assert (0);
            }

          if (L[li].model == STEPWISE)
            {
              nA = L[li].maxA[0] - L[li].minA[0] + 1;
              normalizeLoga (nA, pbf->likes11[vi]);
              vj = ran_discreteloga (nA, pbf->likes11[vi]);
              pbf->likei11 = vj;
            }
        }
      else if (pbf->n[pc] == 1)
        {
          assert (0); /* Never be called. */
          vi = 0;
          pbf->likes1[0] = 0.0;
          pbf->likei1 = vi;
  
          /* FIXME: likes11[0] is the array that we need to fill. */
          if (L[li].model == STEPWISE)
            {
              nA = L[li].maxA[0] - L[li].minA[0] + 1;
              normalizeLoga (nA, pbf->likes11[vi]);
              vj = ran_discreteloga (nA, pbf->likes11[vi]);
              pbf->likei11 = vj;
            }
        }
      else
        {
          assert (0);
        }
    }
  else
    {
      assert (0);
    }

  return vi;
}

int 
bfmove_selectAnEdge (int ci, int li, im_bfupdate *pbf, im_bfupdate *qbf)
{
  /* pbf: sbfnew, qbf: sbfold */
  int pc;
  double ct;
  int ki;
  int mi;
  int pop;
  int i;
  int n;
  int vi;
  int sis;
  struct genealogy *G;
  struct edge *gtree; 
  int edge;
  int down;
  int downdown;
  int up;
  double sisupt;
  double sisdnt;
  double upt;
  double dnt;
  int ngnodes;
  int ngenes;
  char iscross;
  int ei;
  int bi;
  int nA;
  double dlikeA;
  int d;
  double u;
  int newA;
  double sisoldtl;
  double sisnewtl;
  double downtl;
  double bessiv;
  int iszero;

  G = &C[ci]->G[li];
  gtree = G->gtree;
  edge = pbf->m1->edgeid;
  down = gtree[edge].down;
  ct = qbf->m1->dnt;
  ki = findperiodoftime (ci, ct);
  pc = qbf->m1->fpop;

  ngnodes = L[li].numlines;
  ngenes = L[li].numgenes;

  /* Find all edges that are crossed by time [[ct]]. Exclude edges that are not
   * a part of a partial genealogy. */
  pbf->n[pc] = 0;
  if (qbf->is_finiterootbranch == 'T')
    {
      pbf->n[pc] = 1;
      pbf->l[pc][0] = G->root;
    }
  else
    {
      for (ei = 0; ei < ngnodes; ei++)
        {
          /* Exclude a gene at an active lineage. */
          if (gtree[ei].exist == 'F')
            {
              continue; 
            }
          assert (!(gtree[ei].pop < 0));
          assert (gtree[ei].pop < 2 * MAXPOPS - 1);
          if (ei < ngenes)
            {
              upt = 0.0;
            }
          else
            {
              up = gtree[ei].up[0];
              upt = gtree[up].time;
            }
          dnt = gtree[ei].time;
          iscross = 'F';
          if (upt < ct && ct < dnt)
            {
              pop = gtree[ei].pop;
              if (gtree[ei].mig[0].mt < 0.0)
                {
                  pop = saC.popndown[pop][ki];
                  if (pop == pc)
                    {
                      iscross = 'T';
                    }
                }
              else
                {
                  mi = 0;
                  while (gtree[ei].mig[mi].mt > -0.5)
                    {
                      dnt = gtree[ei].mig[mi].mt;
                      if (upt < ct && ct < dnt)
                        {
                          pop = saC.popndown[pop][ki];
                          if (pop == pc)
                            {
                              iscross = 'T';
                            }
                          break;
                        }
                      upt = dnt;
                      pop = gtree[ei].mig[mi].mp;
                      mi++;
                    }
                  if (iscross == 'F')
                    {
                      dnt = gtree[ei].time;
                      if (upt < ct && ct < dnt)
                        {
                          pop = saC.popndown[pop][ki];
                          if (pop == pc)
                            {
                              iscross = 'T';
                            }
                        }
                    }
                }
            }
          if (iscross == 'T')
            {
              n = pbf->n[pc];
              pbf->l[pc][n] = ei;
              pbf->n[pc]++;
            }
        }
    }

  if (L[li].model == INFINITESITES)
    {
      assert (0);
    }
  else if (L[li].model == HKY || L[li].model == STEPWISE)
    {
      assert (pbf->n[pc] > 0);
#ifdef NOTCONSIDERINGDATA
      vi = randposint (pbf->n[pc]);
      break;
#endif /* NOTCONSIDERINGDATA */
      if (pbf->n[pc] > 0)
        {
          /* Compute all likelihoods for possible full genealogies. */
          
          /* We attach an active lineage to one of lineages. Each of the lineages is
           * a candidate for lineage [[sis]]. We freely attach it, 
           * compute likelihood, and detach it. We keep doing this until we fill all
           * likelihoods for all full possible genealogies. */
          for (i = 0; i < pbf->n[pc]; i++)
            {
              sis = pbf->l[pc][i]; /* FIXME: l is not set yet. */
              /* Attach it. */ 
              /* Attaching may be done using a function. */
              downdown = gtree[sis].down;
              sisupt = imaGtreeTime (ci, li, sis);
              assert (sisupt < ct); 

              sisdnt = gtree[sis].time;
              if (G->root == sis)
                {
                  assert (pbf->n[pc] == 1);
                  /* sisdnt is not ... */
                  /* sisdnt = gtree[sis].time; */
                }
              else
                {
                  assert (ct < sisdnt);
                }

              if (G->root == sis)
                {
                  assert (downdown == -1);
                  G->root = down;
                  G->roottime = ct;
                }
              else
                {
                  if (gtree[downdown].up[IM_EDGE_LEFT] == sis)
                    {
                      gtree[downdown].up[IM_EDGE_LEFT] = down;
                    }
                  else
                    {
                      gtree[downdown].up[IM_EDGE_RIGHT] = down;
                    }
                }
              gtree[down].down = downdown;
              gtree[sis].down = down;
              gtree[edge].down = down;
              gtree[down].up[IM_EDGE_LEFT] = sis;
              gtree[down].up[IM_EDGE_RIGHT] = edge;
              gtree[edge].time = ct;
              gtree[sis].time = ct;
              gtree[down].time = sisdnt;
              sisoldtl = sisdnt - sisupt;
              sisnewtl = ct - sisupt;
              downtl = sisdnt - ct;

              /* Compute likelihood. */
              if (L[li].model == HKY)
                {
                  pbf->likes1[i] = likelihoodHKY (ci, li, 
                                                  G->uvals[0], G->kappaval, 
                                                  -1, -1, -1, -1);
                }
              else if (L[li].model == STEPWISE)
                {
                  /**********************************************************/
                  /*                  SOMEWHAT COMPLICATED                  */
                  /**********************************************************/
                  /* All unlinked loci! */
                  u = G->uvals[0];
                  pbf->likes1[i] = 0.0;
                  nA = L[li].maxA[0] - L[li].minA[0] + 1;
                  for (bi = 0; bi < nA; bi++)
                    {
                      newA = L[li].minA[0] + bi;
                      dlikeA = 0.0; /* FIXME: */
                      if (G->root != down)
                        {
                          dlikeA -= gtree[sis].dlikeA[0];
                        }
                      else
                        {
                          assert (downdown == -1);
                        }

                      d = gtree[sis].A[0] - newA;
                      bessiv = bessi (d, sisnewtl * u);
                      if (!(bessiv > 0.0))
                        {
                          iszero = 1;
                          assert (0);
                          /* Impossible situation: IM_BESSI_MIN; */
                        }
                      else
                        {
                          dlikeA += (-(sisnewtl * u) + log (bessiv));
                        }
                      d = gtree[edge].A[0] - newA;
                      bessiv = bessi (d, ct * u);
                      if (!(bessiv > 0.0))
                        {
                          iszero = 1;
                          assert (0);
                          /* Impossible situation: IM_BESSI_MIN; */
                        }
                      else
                        {
                          dlikeA += (-(ct * u) + log (bessiv));
                        }
 
                      if (!(downdown < 0))
                        {
                          d = newA - gtree[downdown].A[0];
                          bessiv = bessi (d, downtl * u);
                          if (!(bessiv > 0.0))
                            {
                              iszero = 1;
                              assert (0);
                              /* Impossible situation: IM_BESSI_MIN; */
                            }
                          else
                            {
                              dlikeA += (-(downtl * u) + log (bessiv));
                            }
                        }
                      pbf->likes11[i][bi] = dlikeA;
                      if (bi == 0)
                        {
                          pbf->likes1[i] = dlikeA;
                        }
                      else
                        {
                          LogSum2 (pbf->likes1[i], pbf->likes1[i], dlikeA);
                        }
                    }
                  /**********************************************************/
                  /*                  SOMEWHAT COMPLICATED                  */
                  /**********************************************************/
                }

              if (sis == qbf->sis1) /* qbf: sbfold, where is sbfold.sis1 set? */
                {
                  /* IMA_genealogy_detach (ci, li, &sbfold, z1): sets sis1. */
                  pbf->likei1 = i;
                  if (L[li].model == STEPWISE)
                    {
                      pbf->likei11 = gtree[down].A[0] - L[li].minA[0];
                    }
                }

              /* Detach it. */
              up = sis;
              if (G->root == down)
                {
                  assert (downdown == -1);
                  gtree[up].down = -1;
                  G->root = up;
                  gtree[up].time = sisdnt;
                }
              else
                {
                  assert (!(downdown < 0));
                  gtree[up].down = downdown;
                  if (gtree[downdown].up[IM_EDGE_LEFT] == down)
                    {
                      gtree[downdown].up[IM_EDGE_LEFT] = up;
                    }
                  else
                    {
                      gtree[downdown].up[IM_EDGE_RIGHT] = up;
                    }
                  gtree[up].time = gtree[down].time;
                }
            }

          /* We need to set likei11. */
          /* vi = ran_discreteloga (pbf->n[pc], pbf->likes1); */

		  if (pbf->n[pc] > 1)
		    {
			  normalizeLoga (pbf->n[pc], pbf->likes1);
		    }
          else if (pbf->n[pc] == 1)
		    {
              pbf->likes1[0] = 0.0;
              pbf->likei1 = 0;
            }
          else
            {
              assert (0);
            }

          if (L[li].model == STEPWISE)
		    {
              nA = L[li].maxA[0] - L[li].minA[0] + 1;
              assert (!(pbf->likei11 < 0));
              normalizeLoga (nA, pbf->likes11[pbf->likei1]);
            }
        }
      else if (pbf->n[pc] == 1)
        {
          assert (0);
          pbf->likes1[0] = 0.0;
          pbf->likei1 = 0;
        }
    }
  else
    {
      assert (0);
    }

  return vi;
}


@
We need to take [[z1]] and [[z2]] into account.
<<updateassignment static>>=
static double bfmove_nextI (int ci, int li,
                            double lq, im_event *ek, 
                            int np, double rates[], 
                            im_ginfo *gk, 
                            im_bfupdate *pbf,
                            int *ki,
                            int z1,
                            char *is_coalesced1,
                            int *pc1);
<<updateassignment bf>>=
double 
bfmove_nextI (int ci, int li, 
              double lq, im_event *ek, 
              int np, double rates[], 
              im_ginfo *gk, 
              im_bfupdate *pbf,
              int *ki,
              int z1,
              char *is_coalesced1,
              int *pc1)
{
  int pi;
  int pj;
  int pk;
  int pl;
  int edge;
  int n1;
  int n2;
  struct genealogy *G;
  struct edge *gtree; 
  
  G = &C[ci]->G[li];
  gtree = G->gtree;

  switch (ek->type)
    {
    case 'a': /* Active lineage coalesces. */
      assert (np == 1 || np == 2);
      assert (rates[0] > 0.0);
      assert (ek->ei == z1);
      assert (*is_coalesced1 == 'F');
      lq += log (rates[0]);
      if (L[li].model == INFINITESITES)
        {
          assert (pbf->nz1[*pc1] > 0);
          lq -= log ((double) pbf->nz1[*pc1]);
        }
      else if (L[li].model == HKY)
        {
          assert (pbf->n[*pc1] > 0);
          lq += pbf->likes1[pbf->likei1]; /* This has been normalized. */
        }
      else if (L[li].model == STEPWISE)
        {
          assert (pbf->n[*pc1] > 0);
          lq += pbf->likes1[pbf->likei1]; /* This has been normalized. */
          lq += pbf->likes11[pbf->likei1][pbf->likei11]; /* This has been normalized. */
        }
      else
        {
          assert (0);
        }
      *is_coalesced1 = 'T';
      break;
    case 'p': /* Active lineage [[z1]] migrates.  */
      pj = ek->pj;
      assert (ek->ei == z1);
      assert (gk->mms[*pc1][pj] > 0.0);
      lq += log (gk->mms[*pc1][pj]);
      *pc1 = pj;
      break;
    case 'e':
      assert (pbf->is_finiterootbranch == 'T');
      break;
    case 'c':
      pi = ek->pj;
      edge = ek->ei;
      assert (*is_coalesced1 == 'F');
      if (*is_coalesced1 == 'F')
        {
          if (L[li].model == INFINITESITES)
            {
              /* NOTE: We do not update sbfold.l!!!           */
              /* We could have called IMA_sbf_c with n and l. */
              pbf->n[pi]--;
              if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
                {
                  IMA_sbf_c (ci, li, edge, pi, pbf->seqz1,
                             pbf->nz1, pbf->lz1, pbf->a);
                }
              else
                {
                  IMA_sbf_c (ci, li, edge, pi, NULL,
                             pbf->nz1, pbf->lz1, pbf->a);
                }
            }
          else if (L[li].model == HKY || L[li].model == STEPWISE)
            {
              IMA_sbf_c (ci, li, edge, pi, NULL, 
                         pbf->n, pbf->l, pbf->a);
            }
        }
      break;
    case 'm':
      edge = ek->ei;
      pi = ek->pi;
      pj = ek->pj;
      assert (*is_coalesced1 == 'F');
      if (L[li].model == INFINITESITES)
        {
          pbf->n[pi]--;
          pbf->n[pj]++;
          IMA_sbf_m (edge, pi, pj, 
                     pbf->nz1, pbf->lz1, pbf->a);
        }
      else if (L[li].model == HKY || L[li].model == STEPWISE)
        {
          IMA_sbf_m (edge, pi, pj, 
                     pbf->n, pbf->l, pbf->a);
        }
      break;
    case 's':
      assert (ek->p == *ki);
      (*ki)++;
      pj = C[ci]->droppops[*ki][IM_EDGE_LEFT];
      pk = C[ci]->droppops[*ki][IM_EDGE_RIGHT];
      pl = C[ci]->addpop[*ki];
      pbf->n[pl] = pbf->n[pj] + pbf->n[pk];
      n1 = pbf->n[pj];
      n2 = pbf->n[pk];
      if (n1 > 0)
        {
          memcpy (pbf->l[pl], pbf->l[pj], n1 * sizeof (int));
        }
      if (n2 > 0)
        {
          memcpy (&pbf->l[pl][n1], pbf->l[pk], n2 * sizeof (int));
        }
      pbf->n[pj] = 0;
      pbf->n[pk] = 0;
      assert (*is_coalesced1 == 'F');
      *pc1 = saC.popndown[*pc1][*ki];
      assert (L[li].model == INFINITESITES 
              || L[li].model == HKY
              || L[li].model == STEPWISE);
      /* Change the number and sets as well. */
      n1 = pbf->nz1[pj];
      n2 = pbf->nz1[pk];
      pbf->nz1[pl] = n1 + n2;
      if (n1 > 0)
        {
          memcpy (pbf->lz1[pl], pbf->lz1[pj], n1 * sizeof (int));
        }
      if (n2 > 0)
        {
          memcpy (&pbf->lz1[pl][n1], pbf->lz1[pk], n2 * sizeof (int));
        }
      pbf->nz1[pj] = 0;
      pbf->nz1[pk] = 0;
      break;
    }
  return lq;
}
@
There are three different places where we set up rates for a next event. For
each setup we have a function: [[bfmove_ratesI]], [[bfmove_ratesII]], and
[[bfmove_ratesIII]]. The first one is used to set up rates for the case before
active lineages survive through a partial genealogy. The second one is used for
the case where two active lineages survive. The last one is for the case where
one active lineage survives.

Function [[bfmove_ratesI]]: active lineages have their own model parameters
$theta$ and $M$.  
<<updateassignment static>>=
static int bfmove_ratesI (double (*r)[2 * MAXPOPS],
                          im_ginfo *gk,
                          im_ginfo *gkz1,
                          im_bfupdate *pbf,
                          int ki,
                          int pc1);
<<updateassignment bf>>=
int 
bfmove_ratesI (double (*rates)[2 * MAXPOPS], 
               im_ginfo *gk, 
               im_ginfo *gkz1, 
               im_bfupdate *pbf,
               int ki,
               int pc1)
{
  int np;
  int li;

  np = 0;
  li = pbf->m1->li;

  if (L[li].model == INFINITESITES)
    {
      if (gkz1->thetas[pc1] == 0.0)
        {
          assert (pbf->nz1[pc1] == 0);
          (*rates)[np++] = 0.0;
        }
      else
        {
          assert (gkz1->thetas[pc1] > 0.0);
          (*rates)[np++] = 2 * pbf->nz1[pc1] / gkz1->thetas[pc1];
        }
    }
  else if (L[li].model == HKY || L[li].model == STEPWISE)
    {
      if (gk->thetas[pc1] == 0.0)
        {
          assert (pbf->n[pc1] == 0);
          (*rates)[np++] = 0.0;
        }
      else
        {
          assert (gk->thetas[pc1] > 0.0);
          (*rates)[np++] = 2 * pbf->n[pc1] / gk->thetas[pc1];
        }
    }
  else
    {
      assert (0);
    }
  if (ki < lastperiodnumber)
    {
      assert (gk->ms[ki][pc1] > 0.0);
      (*rates)[np++] = gk->ms[ki][pc1];
    }

  return np;
}

@
Why do not we have [[gkz1]] or [[gkz2]]?
There are three possible events: active lineage [[z1]] migrates, [[z3]]
migrates, and [[z1]] and [[z3]] coalesce together.
<<updateassignment static>>=
static void bfmove_ratesIII (double (*rates)[2 * MAXPOPS], im_ginfo *gk, im_bfupdate *pbf,
                             int ki,
                             int pc1, int pc3);
<<updateassignment bf>>=
void
bfmove_ratesIII (double (*rates)[2 * MAXPOPS], im_ginfo *gk, im_bfupdate *pbf,
                 int ki,
                 int pc1, int pc3)
{
  if (ki < lastperiodnumber)
    {
      (*rates)[0] = gk->ms[ki][pc1];
      (*rates)[1] = gk->ms[ki][pc3];
    }
  else
    {
      (*rates)[0] = 0.0;
      (*rates)[1] = 0.0;
    }
  (*rates)[2] = 0.0; 
  assert (pbf->canz31 == 'T');
  if (pc1 == pc3) 
    {
      if (gk->thetas[pc3] == 0.0)
        {
          /* FIXME: is this a rightful max? */
          (*rates)[2] = 2 * (2 - 1) / itheta[pc3].pr.max; 
        }
      else
        {
          (*rates)[2] = 2 * (2 - 1) / gk->thetas[pc3];
        }
    }
  return; 
}
<<updateassignment static>>=
static void IMA_genealogy_detach (int ci, int li, im_bfupdate *pbf,
                                  int z1);
<<updateassignment bf>>=
void 
IMA_genealogy_detach (int ci, int li, im_bfupdate *pbf,
                      int z1)
{
  struct genealogy *G;
  struct edge *gtree; 
  double dnt_genealogy;
  int si;
  int down1;
  int downdown1;
  double sisupt;

  /* For SW model
  double bessiv;
  int d;
  double sislen;
  */

  
  G = &C[ci]->G[li];
  gtree = G->gtree;

  pbf->is_finiterootbranch = 'F'; /* This is the 2nd occurrence. (1 more) */
  dnt_genealogy = imaGtreeTime (ci, li, G->root);
  assert (!gsl_fcmp(dnt_genealogy, G->roottime, 1e-7));
  assert (pbf->m1->edgeid == z1);
  down1 = gtree[z1].down;

  
  if (L[li].model == INFINITESITES) /* FIXME: WHAT ABOUT NO DATA RUN? */
    {
      memcpy (pbf->seqz1, gtree[down1].seq, L[li].numsites * sizeof (int));
    }
  else if (L[li].model == HKY || L[li].model == STEPWISE)
    {
      /* No code. */
    }
  else
    {
      assert (0);
    }

  pbf->sis1 = imaGtreeSister (ci, li, z1);
  assert (!(pbf->sis1 < 0));

  sisupt = imaGtreeTime (ci, li, pbf->sis1);

  downdown1 = gtree[down1].down;
  imaSavedSaveBranch (ci, li, z1);
  imaSavedSaveBranch (ci, li, pbf->sis1);
  imaSavedSaveBranch (ci, li, down1);
  if (!(downdown1 < 0))
    {
      imaSavedSaveBranch (ci, li, downdown1);
    }
  pbf->is_finiterootbranch = 'F'; /* This is the 3rd and last occurrence. */
  if (downdown1 == -1)
    {
      assert (G->root == down1);
      G->root = pbf->sis1;
      gtree[pbf->sis1].down = -1;
      pbf->is_finiterootbranch = 'T';
      /**************************************************/
      /* We keep gtree[sis1].time                       */
      /* We keep migration events along the sister.     */
      /* We keep coalescent event at the original root  */
      /* by naming it ``end.''                          */
      /* We do not change roottime.                     */
      /**************************************************/
    }
  else
    {
      IMA_genealogy_join (gtree, pbf->sis1, down1, downdown1);
    }

  if (L[li].model == INFINITESITES)
    {
      /* Move mutations on down branch to sister. */
      if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
        {
          for (si = 0; si < L[li].numsites; si++)
            {
              if (G->mut[si] == down1)
                {
                  G->mut[si] = pbf->sis1;
                }
            }
        }
    }
  else if (L[li].model == HKY)
    {
      /* No code. */
    }
  else if (L[li].model == STEPWISE)
    {
      pbf->A1 = gtree[down1].A[0];
/* 
      if (downdown1 == -1)
	    {
		}
	  else
	    {
		  d = gtree[pbf->sis1].A[0] - gtree[downdown1].A[0];
		  sislen = gtree[pbf->sis1].time - sisupt;
		  bessiv = bessi (d, sislen * G->uvals[0]);
		  if (!(bessiv > 0.0))
			{
			  assert (0); 
			}
		  else
			{
		      gtree[pbf->sis1].dlikeA[0] = (-(sislen * G->uvals[0]) + log (bessiv));
			}
		}
*/
    }
  else
    {
      assert (0);
    }

  gtree[z1].exist = 'F';
  gtree[down1].exist = 'F';

  return;
}
<<updateassignment function header>>=
int IMA_genealogy_findIntSeq (int ci, int li);
<<updateassignment bf>>=
int
IMA_genealogy_findIntSeq (int ci, int li)
{
  int si;
  int ei;
  int edge;
  int sis;
  int down;
  int ledge;
  int redge;
  int nmut;
  int ngenes;
  int ngnodes;
  char flag;
  struct genealogy *G;
  struct edge *gtree; 
  int accp;

  assert (L[li].model == INFINITESITES);
  G = &C[ci]->G[li];
  gtree = G->gtree;
  ngenes = L[li].numgenes;
  ngnodes = L[li].numlines;
  /* Reset seq and mut of a full genealogy */
  for (si = 0; si < L[li].numsites; si++)
    {
      for (ei = ngenes; ei < ngnodes; ei++)
        {
          gtree[ei].seq[si] = -1; 
        }
      G->mut[si] = -1;
    }
  for (si = 0; si < L[li].numsites; si++)
    {
      for (ei = 0; ei < ngenes; ei++)
        {
          edge = ei;
          flag = 'T';
          while (flag == 'T')
            {
              flag = 'F';
              down = gtree[edge].down;
              if (down == -1)
                {
                  assert (G->root == edge);
                  break;
                }
              if ((sis = gtree[down].up[IM_EDGE_LEFT]) == edge)
                {
                  sis = gtree[down].up[IM_EDGE_RIGHT];
                }
              assert (gtree[edge].seq[si] == 0
                      || gtree[edge].seq[si] == 1
                      || gtree[edge].seq[si] == 2);
              assert (!(gtree[down].seq[si] == -1 && gtree[edge].seq[si] == -1));
              if (gtree[down].seq[si] != gtree[edge].seq[si])
                {
                  if (gtree[edge].seq[si] == 2)
                    {
                      if (gtree[sis].seq[si] != -1)
                        {
                          gtree[down].seq[si] = gtree[sis].seq[si];
                        }
                      else
                        {
                          gtree[down].seq[si] = 2;
                        }
                    }
                  else if ((gtree[sis].seq[si] != -1 && gtree[sis].seq[si] != 2)
                           && (gtree[sis].seq[si] != gtree[edge].seq[si]))
                    {
                      gtree[down].seq[si] = 2;
                      /* assert (G->mut[si] == -1 || G->mut[si] == down); */
                      G->mut[si] = down;
                    }
                  else
                    {
                      gtree[down].seq[si] = gtree[edge].seq[si];
                    }
                  flag = 'T';
                }
              else if (gtree[down].seq[si] == 2)
                {
                  assert (gtree[edge].seq[si] == 2);
                  if (gtree[sis].seq[si] != -1 && gtree[sis].seq[si] != 2)
                    {
                      gtree[down].seq[si] = gtree[sis].seq[si];
                      flag = 'T';
                    }
                }
              edge = down;
            }
        }
    }
  /* Find a single edge with a mutation event at site [[si]]. */
  /* All edges except one must be labelled either 0 or 1. The only
   * edge is labelled 2. The edge is can be found at G->mut[si]. */
  accp = 1;
  for (si = 0; si < L[li].numsites; si++)
    {
      nmut = 0; 
      for (ei = ngenes; ei < ngnodes; ei++)
        {
          assert (gtree[ei].seq[si] == 0
                  || gtree[ei].seq[si] == 1
                  || gtree[ei].seq[si] == 2);
          if (gtree[ei].seq[si] == 2)
            {
              nmut++;
              ledge = gtree[ei].up[IM_EDGE_LEFT];
              redge = gtree[ei].up[IM_EDGE_RIGHT];
              /* assert (gtree[ledge].seq[si] != gtree[redge].seq[si]); */
              if (gtree[ledge].seq[si] == gtree[redge].seq[si])
                {
                  nmut = 999;
                  break;
                }
              if (ei == G->root)
                {
                  gtree[ei].seq[si] = 0;
                  if (gtree[ledge].seq[si] == 0)
                    {
                      G->mut[si] = redge;
                    }
                  else
                    {
                      G->mut[si] = ledge;
                    }
                }
              else
                {
                  down = gtree[ei].down;
                  assert (!(down < 0));
                  assert (down < ngnodes);
                  if (gtree[ledge].seq[si] == gtree[down].seq[si])
                    {
                      G->mut[si] = redge;
                      gtree[ei].seq[si] = gtree[ledge].seq[si];
                    }
                  else
                    {
                      G->mut[si] = ledge;
                      gtree[ei].seq[si] = gtree[redge].seq[si];
                    }
                }
            }
        }
      /* assert (nmut == 1); */
      if (nmut != 1)
        {
          accp = 0;
          break;
        }
    }
  return accp;
}

@
[[n]] has the number of lineages that are present in population [[pi]]. We check
each element of [[l]] for population [[pi]] to see whether there are left or
right child edges of [[edge]]. If there are child edges, we remove them from
[[l]]. The variable [[n]] is update as well. After then, we check whether
[[seqz]] exists on [[edge]]. If so, we add the edge to [[l]] and increase [[n]]
by 1.
We use this for [[n]] and [[l]] members not only for [[nz1]] and [[lz1]]. We
plug NULL for [[seqz]] when we call this function with [[n]] and [[l]]. We do
this when we deal with finite sites mutation model.

If we have no data, then [[seqz]] must be NULL.
<<updateassignment static>>=
static int IMA_sbf_c (int ci, int li, int edge, int pi, 
                      int *seqz,
                      int *n, int **l, int *a);
<<updateassignment bf>>=
int 
IMA_sbf_c (int ci, int li, int edge, int pi, 
           int *seqz,
           int *n, int **l, int *a)
{
  int j;
  int ei;
  char can_coalesce;
  int si;
  int ni;
  int nl;
  struct genealogy *G;
  struct edge *gtree;
  int ledge;
  int redge;

  if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 1)
    {
      assert (seqz == NULL);
    }

  G = &C[ci]->G[li];
  gtree = G->gtree;
  ledge = gtree[edge].up[IM_EDGE_LEFT];
  redge = gtree[edge].up[IM_EDGE_RIGHT];

  /* Remove edges (both left and right) that coalesce together if there is. It
   * is possible that they are absent in [[l]]. */
  nl = n[pi];
  j = 0;
  for (ei = 0; ei < nl; ei++)
    {
      if (l[pi][ei] == ledge || l[pi][ei] == redge)
        {
          /* assert ledge could have coalesced with z. */
        }
      else
        {
          a[j] = l[pi][ei];
          j++;
        }
    }
  assert (j == nl || j == nl - 1 || j == nl - 2);
  if (j < nl)
    {
      if (j > 0)
        {
          memcpy (l[pi], a, j * sizeof (int));
        }
      n[pi] = j;
    }

  /* Add edge if it can coalesce with active lineage z. */
  can_coalesce = 'T';
  if (seqz != NULL)
    {
      for (si = 0; si < L[li].numsites; si++)
        {
          if (G->mut[si] == edge)
            {
              continue;
            }
          if (gtree[edge].seq[si] != seqz[si])
            {
              can_coalesce = 'F';
            }
        }
    }
  if (can_coalesce == 'T') /* edge and z can coalesce together? */
    {
      ni = n[pi];
      l[pi][ni] = edge;
      n[pi]++;
    }
  return 0;
} 

@
We remove [[edge]] from the [[pi]]-th element of list [[l]]. Add it to [[pj]]-th
element of list [[l]]. Change [[n]] accordingly. This may be simplified with a
simple data structure such as linked lists.
<<updateassignment static>>=
static int IMA_sbf_m (int edge, int pi, int pj,
                      int *n, int **l, int *a);
<<updateassignment bf>>=
int 
IMA_sbf_m (int edge, int pi, int pj,
           int *n, int **l, int *a)
{
  int j;
  int ei;
  int ni;
  int nl;

  assert (pi != pj);

  /* Remove an edge if it exists in pi. */
  nl = n[pi];
  j = 0;
  for (ei = 0; ei < nl; ei++)
    {
      if (l[pi][ei] == edge)
        {
          /* assert ledge could have coalesced with z1. */
        }
      else
        {
          a[j] = l[pi][ei];
          j++;
        }
    }
  assert (j == nl || j == nl - 1);
  if (j < nl)
    {
      /* Add the edge to population pj. */
      if (j > 0)
        {
          memcpy (l[pi], a, j * sizeof (int));
        }
      n[pi] = j;
      ni = n[pj];
      for (ei = 0; ei < ni; ei++)
        {
          assert (l[pj][ei] != edge);
        }
      l[pj][ni] = edge;
      n[pj]++;
    }
  else if (j == nl)
    {
      /* No Code! */
    }
  else
    {
      assert (0);
    }
  return 0;
}

<<updateassignment static>>=
static int IMA_sbf_nsum (im_bfupdate *pbf,
                         int pc1, int pc3);
<<updateassignment bf>>=
int
IMA_sbf_nsum (im_bfupdate *pbf,
              int pc1, int pc3)
{
  int nsum;
  int pi;

  /* Make sure that we have one inactive lineage. */
  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      if (pi == pc3)
        {
          assert (pbf->n[pc3] == 1);
        }
      else
        {
          assert (pbf->n[pi] == 0);
        }
    }
  pbf->n[pc1]++;

  nsum = 0;
  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      nsum += pbf->n[pi];
    }
  assert (nsum == 2);

  return nsum;
}

@
We set [[n]], [[l]], [[nz1]], and [[lz1]] of [[sbfold]] or
[[sbfnew]]: 
[[n]], the number of external edges starting at populations; 
[[l]], edges themselves of those starting at populations;
[[nz1]], the number of external edges starting a
populations among [[n]] edges that can coalesce with edge [[z1]]; and
[[lz1]]: edges themselves of [[nz1]]. 
These numbers
are for finding lineages that can be coalesced with active lineages. The numbers
or [[n]], [[nz1]], and [[lz1]] are changing as we go down a
genealogy for our coalescent simulation.
We do not need [[nz1]], and [[lz1]] for HKY model. We instead need to keep
likelihoods for possible coalescent events.
<<updateassignment static>>=
static void IMA_sbf_lineages (im_bfupdate *pbf, int ci, int li, int z1);
<<updateassignment bf>>=
void 
IMA_sbf_lineages (im_bfupdate *pbf, int ci, int li, int z1)
{
  int n;
  int p;
  int np;
  int ni;
  int si;
  int ei;
  int edge;
  struct edge *gtree;
  struct genealogy *G;
  int ngenes;
  char can_coalesce;

  assert (modeloptions[PARAMETERSBYPERIOD] == 0);
  for (p = 0; p < numpopsizeparams; p++)
    {
      pbf->n[p] = 0;
      pbf->nz1[p] = 0; /* Only for infinite-sites model */
    }
  ngenes = L[li].numgenes;
  G = &C[ci]->G[li];
  gtree = G->gtree;
  for (ei = 0; ei < ngenes; ei++)
    {
      /* Exclude a gene at an active lineage. */
      if (ei == z1) 
        {
          continue; 
        }
      assert (!(gtree[ei].pop < 0));
      assert (gtree[ei].pop < 2 * npops - 1);
      p = gtree[ei].pop;
      /* Add gene [[ei]] to population [[p]]. */
      n = pbf->n[p];
      pbf->l[p][n] = ei;
      pbf->n[p]++;
    }

  /* Number of lineages in populations for active lineages to be able to
   * coalesce. */
  if (L[li].model == INFINITESITES)
    {
      for (p = 0; p < numpopsizeparams; p++)
        {
          np = pbf->n[p];
          for (ni = 0; ni < np; ni++)
            {
              edge = pbf->l[p][ni];
              can_coalesce = 'T';
              
              if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
                {
                  for (si = 0; si < L[li].numsites; si++)
                    {
                      if (G->mut[si] == edge)
                        {
                          continue;
                        }
                      if (gtree[edge].seq[si] != pbf->seqz1[si])
                        {
                          can_coalesce = 'F';
                          break;
                        }
                    }
                }

              if (can_coalesce == 'T') /* If edge and z1 can coalesce together? */
                {
                  n = pbf->nz1[p];
                  pbf->lz1[p][n] = edge;
                  pbf->nz1[p]++;
                }
            }
        }
    }
  return;
}
@
[[IMA_intervals_collectsbfnew]] sets [[sbfold]]'s [[m3]] if needed. It also
prepares [[sbfnew]]'s members.

<<updateassignment static>>=
static void IMA_intervals_collectsbfnew (int ci, int li, im_edgemiginfo *newm3);
<<updateassignment bf>>=
void 
IMA_intervals_collectsbfnew (int ci, int li, im_edgemiginfo *newm3)
{
  double ct;
  int pc;

  im_event *ek;
  int mi;
  int mj;
  int ei;
  int si;
  int ki;
  int pi;
  int z3;
  struct edge *gtree;
  struct genealogy *G;
  double t;
  double roottime;
  char m3type;
  int down1;

  G = &C[ci]->G[li];
  gtree = C[ci]->G[li].gtree;
  if (sbfnew.sis1 == G->root)
    {
      sbfnew.is_finiterootbranch = 'T';
    }
  else
    {
      sbfnew.is_finiterootbranch = 'F';
    }
  
  down1 = gtree[sbfnew.m1->edgeid].down;
  if (L[li].model == INFINITESITES)
    {
      if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
        {
          assert (L[li].numsites > 0); /* FIXME: Crash! */
          memcpy (sbfnew.seqz1, gtree[down1].seq, L[li].numsites * sizeof (int)); 
        }
    }
  else if (L[li].model == HKY)
    {
      assert (L[li].numsites > 0); /* FIXME: Crash! */
      /* No code. */
    }
  else if (L[li].model == STEPWISE)
    {
      /* No code. */
    }
  else
    {
      assert (0);
    }

  ct = sbfnew.m1->dnt;
  pc = sbfnew.m1->fpop;

  /***************************************************************************/
  /*                             sbfold.m3                                   */
  /***************************************************************************/
  /* Fill sbfold.m3 when detaching an external root-connecting branch and    */
  /* attaching it to an inactive lineage.                                    */
  if (newm3 == NULL && sbfold.is_finiterootbranch == 'T')
    {
      ei = G->root;
      roottime = imaGtreeTime (ci, li, ei);

      sbfold.m3 = &saosms[2 * li];
      sbfold.m3->li = li;
      sbfold.m3->edgeid = ei;
      if (ct < roottime)
        {
          m3type = 'A';
          sbfold.m3->upt = roottime;
          sbfold.m3->pop = gtree[ei].pop;
        }
      else
        {
          m3type = 'B'; 
          sbfold.m3->upt = ct;
          sbfold.m3->pop = pc;
        }
      assert (ct < gtree[ei].time);
      assert (gtree[ei].time < TIMEMAX - 1.0);
      sbfold.m3->dnt = gtree[ei].time;

      mi = 0;
      mj = 0;
      while (gtree[ei].mig[mi].mt > -0.5)
        {
          if (gtree[ei].mig[mi].mt < ct)
            { 
              mi++;
              continue;
            }
          sbfold.m3->mig[mj] = gtree[ei].mig[mi];
          mi++;
          mj++;
        }
      sbfold.m3->mig[mj].mt = -1.0;
      sbfold.m3->mpall = mj;
      if (mj == 0)
        {
          pi = sbfold.m3->pop;
        }
      else
        {
          pi = sbfold.m3->mig[mj - 1].mp;
        }
      ki = findperiodoftime (ci, sbfold.m3->dnt);
      sbfold.m3->fpop = saC.popndown[pi][ki];
      if (ct < roottime)
        {
          /* No Code! */
        }
      else
        {
          assert (sbfnew.m1->dnt == sbfold.m3->upt);
        }
      assert (sbfnew.m1->dnt < sbfold.m3->dnt);

      /* Why are we doing this here? */
      /* Set sbfnew's canz31? */
      z3 = G->root;
      sbfnew.canz31 = 'T';
      if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
        {
          if (L[li].model == INFINITESITES)
            {
              for (si = 0; si < L[li].numsites; si++)
                {
                  if (G->mut[si] == z3)
                    {
                      continue;
                    }
                  if (gtree[z3].seq[si] != sbfnew.seqz1[si])
                    {
                      sbfnew.canz31 = 'F';
                    }
                }
            }
          else if (L[li].model == HKY || L[li].model == STEPWISE)
            {
              /* No code. */
            }
        }
      assert (sbfnew.canz31 == 'T');
    }
  else
    {
      sbfold.m3 = NULL;
    }

  /***************************************************************************/
  /*                                 sbfnew                                  */
  /***************************************************************************/

  /* Copy e1 from sbfold's to sbfnew's. */
  if (sbfnew.nmax1 < sbfold.n1)
    {
      sbfnew.nmax1 = sbfold.n1;
      sbfnew.e1 = realloc (sbfnew.e1, sbfnew.nmax1 * sizeof (im_event));
    }
  assert (sbfold.n1 > 0);
  memcpy (sbfnew.e1, sbfold.e1, sbfold.n1 * sizeof (im_event));
  sbfnew.n1 = sbfold.n1;

  /* Case I */
  if (newm3 != NULL)
    {
      /* sbfnew is lengthened by newm3. */
      /* if there is end event, we remove it */
      /* we can add ``end'' event. */
      if (sbfnew.e1[sbfnew.n1 - 1].type == 'e')
        {
          sbfnew.n1--;
        }
       
      if (sbfnew.nmax1 < sbfnew.n1 + newm3->mpall + numsplittimes + 1)
        {
          sbfnew.nmax1 = sbfnew.n1 + newm3->mpall + numsplittimes + 1;
          sbfnew.e1 = realloc (sbfnew.e1, sbfnew.nmax1 * sizeof (im_event));
        }
      /* ek = &sbfnew.e1[sbfnew.n1]; */
      ek = sbfnew.e1 + sbfnew.n1;
      mi = 0;
      while (newm3->mig[mi].mt > -0.5)
        {
          t = newm3->mig[mi].mt;
          ek->type = 'm';
          ek->t = t;
          ek->p = findperiodoftime (ci, t);
          if (mi == 0)
            {
              ek->pi = newm3->pop;
            }
          else
            {
              ek->pi = newm3->mig[mi - 1].mp;
            }
          assert (!(ek->pi < 0));
          assert (ek->pi < numpopsizeparams);
          ek->pi = saC.popndown[ek->pi][ek->p];
          ek->pj = newm3->mig[mi].mp;
          assert (!(ek->pi < 0));
          assert (ek->pi < numpopsizeparams);
          assert (!(ek->pj < 0));
          assert (ek->pj < numpopsizeparams);
          ek->ei = newm3->edgeid;
          ek++;
          mi++;
        }
      assert (newm3->mpall == mi); 
      /* end event */
      t = newm3->dnt;
      ek->type = 'e';
      ek->t = t;
      ek->p = findperiodoftime (ci, t);
      if (mi == 0)
        {
          ek->pi = newm3->pop;
        }
      else
        {
          ek->pi = newm3->mig[mi - 1].mp;
        }
      assert (!(ek->pi < 0));
      assert (ek->pi < numpopsizeparams);
      ek->pj = saC.popndown[ek->pi][ek->p];
      assert (!(ek->pj < 0));
      assert (ek->pj < numpopsizeparams);
      ek->ei = newm3->edgeid;
      sbfnew.n1 += newm3->mpall + 1;

      /* We need to sort the events. */
      ek = sbfnew.e1 + sbfnew.n1;
      for (ki = 0; ki < numsplittimes; ki++)
        {
          t = C[ci]->tvals[ki];
          if (newm3->upt < t && t < newm3->dnt)
            {
              ek->type = 's'; 
              ek->t = t;
              ek->p = ki;    /* Split time happens right before the period line. */
              ek->pi = ki;   /* from 0 (pi) to 1 (pj) for the first split time.  */
              ek->pj = ki + 1;
              ek->ei = -1;
              ek++;
              sbfnew.n1++;
            }
        }
      qsort (sbfnew.e1, (size_t) sbfnew.n1, sizeof (im_event), im_event_cmp);
    }
  /* Case II */
  else if (newm3 == NULL && sbfold.is_finiterootbranch == 'T')
    {
      assert (sbfold.m3 != NULL);
      /* sbfnew is shortened by oldm3. */
      /* if there is end event, we remove it */
      /* we may add ``end'' event. */
      if (sbfnew.e1[sbfnew.n1 - 1].type == 'e')
        {
          sbfnew.n1--;
        }
      /* Remove events below oldm3 */
      if (m3type == 'A')
        {
           while (sbfnew.e1[sbfnew.n1 - 1].t > sbfold.m3->upt) 
            {
              if (sbfnew.e1[sbfnew.n1 - 1].type == 'c'
                  && sbfnew.e1[sbfnew.n1 - 1].ei == sbfold.m3->edgeid)
                {
                  break;
                }
              sbfnew.n1--;
            }
        }
      else if (m3type == 'B')
        {
          while (sbfnew.e1[sbfnew.n1 - 1].t > sbfold.m3->upt) 
            {
              assert (!(sbfnew.e1[sbfnew.n1 - 1].type == 'c'
                        && sbfnew.e1[sbfnew.n1 - 1].ei == sbfold.m3->edgeid));
              sbfnew.n1--;
            }
          ek = sbfnew.e1 + sbfnew.n1;
          ek->ei = sbfold.m3->edgeid;
          ek->type = 'e';
          ek->t = sbfold.m3->upt;
          ek->p = findperiodoftime (ci, ek->t);
          mi = 0;
          t = gtree[ek->ei].mig[mi].mt;
          if (t > -0.5 && t < ek->t)
            {
              mi++;
              t = gtree[ek->ei].mig[mi].mt;
            }
          if (mi == 0)
            {
              ek->pi = gtree[ek->ei].pop;
            }
          else
            {
              ek->pi = gtree[ek->ei].mig[mi - 1].mp;
            }
          ek->pj = sbfold.m3->pop;
          sbfnew.n1++;
        }
      else
        {
          assert (0);
        }
      /* No need to sort */
    }
  return;
}

<<updateassignment static>>=
static double bfq (im_bfupdate *pbf, im_bfupdate *qbf, 
                   int ci, int li, 
                   im_ginfo *gk,
                   im_ginfo *gkz1);
<<updateassignment bf>>=
double 
bfq (im_bfupdate *pbf, im_bfupdate *qbf, 
     int ci, int li, 
     im_ginfo *gk,
     im_ginfo *gkz1)
{
  double lq;
  char is_coalesced1;
  char is_coalesced3;
  int pc1;
  double prevt;
  double dt;
  int ki;
  int ti;
  int ti3;
  int pj;
  int np;
  int mi;
  double totalrate;
  im_event *ek;
  double lasteventtime;
  double rates[2 * MAXPOPS];
  int nsum;
  double t;
  struct edge *gtree;
  struct genealogy *G;
  int ngenes;
  double newct;
  int pc3;
  int ri;
  int nr;
  int z1;
  int z3;
  double r;
  char eventAadded;

  G = &C[ci]->G[li];
  gtree = G->gtree;
  ngenes = L[li].numgenes;

  /***************************************************************************/
  /* Prepare [[e2]] and possibly [[e3]].                                     */
  /***************************************************************************/
  /* Type 'a': lineage 1 coalesces. 
   *      'p': lineage 1 migrates.
   *      'r': lineage 3 migrates. */
  lasteventtime = pbf->e1[pbf->n1 - 1].t;

  if (pbf->nmax2 < pbf->n1)
    {
      pbf->nmax2 = pbf->n1;
      pbf->e2 = realloc (pbf->e2, pbf->nmax2 * sizeof (im_event));
    }
  pbf->e2 = memcpy (pbf->e2, pbf->e1, pbf->n1 * sizeof (im_event));
  pbf->n2 = pbf->n1;
  if (pbf->nmax2 < pbf->n2 + qbf->m1->mpall + 1)
    {
      pbf->nmax2 = pbf->n2 + qbf->m1->mpall + 1;
      pbf->e2 = realloc (pbf->e2, pbf->nmax2 * sizeof (im_event));
    }
  ek = pbf->e2 + pbf->n2;
  for (mi = 0; mi < qbf->m1->mpall; mi++)
    {
      t = qbf->m1->mig[mi].mt;
      assert (t > -0.5);
      if (t > lasteventtime)
        {
          break;
        }
      ek->type = 'p';
      ek->t = t;
      ek->p = findperiodoftime (ci, t);
      if (mi == 0)
        {
          ek->pi = qbf->m1->pop;
        }
      else
        {
          ek->pi = qbf->m1->mig[mi - 1].mp;
        }
      ek->pi = saC.popndown[ek->pi][ek->p];
      ek->pj = qbf->m1->mig[mi].mp;
      ek->ei = qbf->m1->edgeid;
      ek++;
      pbf->n2++;
    }
  if (qbf->m1->dnt < lasteventtime)
    {
      /* Active lineage [[z1]] coalesces. */
      ek->type = 'a';
      ek->t = qbf->m1->dnt;
      ek->p = -1;
      ek->pi = -1;
      ek->pj = qbf->m1->fpop;
      ek->ei = qbf->m1->edgeid;
      ek++;
      pbf->n2++;
      eventAadded = 'y';
    }
  else
    {
      eventAadded = 'n';
    }
  qsort (pbf->e2, (size_t) pbf->n2, sizeof (im_event), im_event_cmp);

  /* old3 = two or three active lineages   */
  /* qbf->m1->mpall and a coalescent       */
  /* qbf->m3->mpall and a coalescent       */
  pbf->n3 = 0;
  if (qbf->m3 != NULL)
    {
      if (pbf->nmax3 < qbf->m1->mpall + 1)
        {
          pbf->nmax3 = qbf->m1->mpall + 1;
          pbf->e3 = realloc (pbf->e3, pbf->nmax3 * sizeof (im_event));
        }
      ek = pbf->e3;
      for (mi = 0; mi < qbf->m1->mpall; mi++)
        {
          t = qbf->m1->mig[mi].mt; 
          assert (t > -0.5);
          if (t < lasteventtime)
            {
              continue;
            }
          ek->type = 'p';
          ek->t = t;
          ek->p = findperiodoftime (ci, t);
          if (mi == 0)
            {
              ek->pi = qbf->m1->pop;
            }
          else
            {
              ek->pi = qbf->m1->mig[mi - 1].mp;
            }
          ek->pi = saC.popndown[ek->pi][ek->p];
          ek->pj = qbf->m1->mig[mi].mp;
          ek->ei = qbf->m1->edgeid;
          ek++;
          pbf->n3++;
        }
      assert (qbf->m1->dnt > lasteventtime);
      assert (eventAadded = 'n');
      ek->type = 'a';
      ek->t = qbf->m1->dnt;
      ek->p = -1;
      ek->pi = -1;
      ek->pj = qbf->m1->fpop;
      ek->ei = qbf->m1->edgeid;
      ek++;
      pbf->n3++;

      if (pbf->nmax3 < pbf->n3 + qbf->m3->mpall + 1)
        {
          pbf->nmax3 = pbf->n3 + qbf->m3->mpall + 1;
          pbf->e3 = realloc (pbf->e3, pbf->nmax3 * sizeof (im_event));
        }
      ek = pbf->e3 + pbf->n3;
      for (mi = 0; mi < qbf->m3->mpall; mi++)
        {
          t = qbf->m3->mig[mi].mt;
          assert (t > lasteventtime);
          assert (t > -0.5);
          ek->type = 'r';
          ek->t = t;
          ek->p = findperiodoftime (ci, t);
          if (mi == 0)
            {
              ek->pi = qbf->m3->pop;
            }
          else
            {
              ek->pi = qbf->m3->mig[mi - 1].mp;
            }
          ek->pi = saC.popndown[ek->pi][ek->p];
          ek->pj = qbf->m3->mig[mi].mp;
          ek->ei = qbf->m3->edgeid;
          ek++;
          pbf->n3++;
        }
      if (pbf->nmax3 < pbf->n3 + numsplittimes + 1)
        {
          pbf->nmax3 = pbf->n3 + numsplittimes + 1;
          pbf->e3 = realloc (pbf->e3, pbf->nmax3 * sizeof (im_event));
        }
      ek = pbf->e3 + pbf->n3;
      for (ki = 0; ki < numsplittimes; ki++)
        {
          t = C[ci]->tvals[ki];
          if (qbf->m3->upt < t && t < qbf->m3->dnt)
            {
              ek->type = 's'; 
              ek->t = t;
              ek->p = ki;        /* Split time happens right before the period line. */
              ek->pi = ki;       /* from 0 (pi) to 1 (pj) for the first split time.  */
              ek->pj = ki + 1;
              ek++;
              pbf->n3++;
            }
        }
      qsort (pbf->e3, (size_t) pbf->n3, sizeof (im_event), im_event_cmp);
      assert (pbf->e3[pbf->n3 - 1].type == 'a');
    }
  /***************************************************************************/
  /* Prepare [[e2]] and possibly [[e3]].                                     */
  /***************************************************************************/

  /* Add probabilities before the bottom of a partial genealogy */
  /* pbf:sbfold, and qbf:sbfnew.                                */
  z1 = qbf->m1->edgeid;
  assert (!(z1 < 0));
  is_coalesced1 = 'F';
  pc1 = qbf->m1->pop;
  assert (!(pc1 < 0));
  IMA_sbf_lineages (pbf, ci, li, z1);

  ki = 0;
  ti = 0;
  lq = 0.0; 
  prevt = 0.0;
  ek = pbf->e2;
  while (is_coalesced1 == 'F') 
    {
      dt = ek->t - prevt;
      np = bfmove_ratesI (&rates, gk, gkz1,
                          pbf, ki, 
                          pc1);
      totalrate = 0.0;
      for (pj = 0; pj < np; pj++)
        {
          assert (!(rates[pj] < 0.0));
          totalrate += rates[pj];
        }
      if (totalrate == 0.0)
        {
          /* assert (0); I do not know when this would happen. We have to fix
           * it. */
          assert (ek->type == 'c'
                  || ek->type == 'm'
                  || ek->type == 's'
                  || ek->type == 'e');
        }
      lq -= totalrate * dt;
      lq = bfmove_nextI (ci, li, lq, ek, np, rates, 
                         gk, pbf, /* qbf, */
                         &ki,
                         z1,
                         &is_coalesced1,
                         &pc1);
      prevt = ek->t;
      ti++;
      if (ti < pbf->n2)
        {
          ek++;
        }
      else
        {
          break;
        }
    }

  /* Add probabilities after the bottom of a partial genealogy. */
  if (is_coalesced1 == 'F')
    {
      assert (pbf->m3 == NULL);
      assert (qbf->m3 != NULL);
      assert (pbf->n3 > 0);
      assert (pbf->n2 == ti);
      assert (pbf->e2[ti - 1].type != 's');
      assert (pbf->e2[ti - 1].type == 'e' || pbf->e2[ti - 1].type == 'c');
      assert (pbf->e2[ti - 1].t == prevt);
      assert (findperiodoftime (ci, prevt) == ki);

      is_coalesced3 = 'F';
      newct = prevt;
      pc3 = pbf->e2[ti - 1].pj;
      z3 = pbf->e2[ti - 1].ei;
      assert (z3 == qbf->m3->edgeid);
      assert (!(pc1 < 0));
      assert (!(pc3 < 0));
      assert (qbf->m3->upt == newct);
      assert (qbf->m3->li == li);
      assert (qbf->m3->edgeid == G->root);
      assert (qbf->m3->pop == pc3);

      /* Set canz31? */
      assert (is_coalesced1 == 'F');
      assert (pbf->canz31 == 'T');
      
      nsum = IMA_sbf_nsum (pbf, pc1, pc3);
      assert (nsum == 2);

      ti3 = 0;
      ek = pbf->e3;
      while (nsum == 2)
        {
          dt = ek->t - prevt;

          bfmove_ratesIII (&rates, gk, pbf, ki, pc1, pc3);
          nr = 3;
          totalrate = 0.0;
          for (ri = 0; ri < nr; ri++)
            {
              totalrate += rates[ri];
            }
          assert (totalrate > 0.0);
          assert (dt > 0.0);
          lq -= totalrate * dt;
          switch (ek->type)
            {
            case 's': /* split event. */
              assert (ek->pi == ki);
              ki++;
              assert (ek->pj == ki);
              pc1 = saC.popndown[pc1][ki];
              pc3 = saC.popndown[pc3][ki];
              break;
            case 'p': /* one left active lineage migrates. */
              pj = ek->pj;
              assert (ek->ei == z1);      /* lineage 1 coalesces. */
              assert (rates[0] > 0.0);
              assert (gk->mms[pc1][pj] > 0.0);
              assert (gk->ms[ki][pc1] > 0.0);
              r = gk->mms[pc1][pj];
              lq += log (r);
              pc1 = pj;
              break;
            case 'r': /* Lineage 3 migrates. */
              pj = ek->pj;
              assert (ek->ei == z3);
              assert (rates[1] > 0.0); 
              assert (gk->mms[pc3][pj] > 0.0);
              assert (gk->ms[ki][pc3] > 0.0);
              lq += log (gk->mms[pc3][pj]);
              pc3 = pj;
              break;
            case 'a': /* Two lineages coalesce. */
              is_coalesced3 = 'T';
              assert (ek->ei == z1);
              assert (is_coalesced1 == 'F');
              is_coalesced1 = 'T';
              assert (rates[2] > 0.0); 
              r = rates[2];
              lq += log (r);
              lq = bfmove_selectA1 (ci, li, qbf, lq);
              nsum = 1;
              break;
            default:
              assert (0);
              break;
            }
          prevt = ek->t;
          ti3++;
          ek++;
        }
      assert (ti3 == pbf->n3);
    }

  return lq;
}

@
For period $k_i$, there are $n_p - k_i$ many populations where $n_p$ is the
number of populations at present time. A gene can migrate to one of 
$n_p - k_i - 1$ population during period $k_i.$ These populations are stored at
[[popnmig]] variable. Total rates of migrations from population [[pi]] to [[pj]]
are stored at [[mms]] variable. We find those rates for source population [[pi]]
during period [[ki]]. We choose one sink population among them from the
discrete distribution.
<<updateassignment static>>=
static double IMA_choose_migtopop (int *topop, int ki, int pi, im_ginfo *gk);
<<updateassignment bf>>=
double 
IMA_choose_migtopop (int *topop, int ki, int pi, im_ginfo *gk)
{
  double pr[MAXPOPS];
  int npminus1;
  int ni;
  int pj;
  int i;
  double total;

  total = 0.0;
  npminus1 = npops - ki - 1;
  for (ni = 0; ni < npminus1; ni++)
    {
      pj = saC.popnmig[ki][pi][ni];
      assert (gk->mms[pi][pj] > 0.0);
      pr[ni] = gk->mms[pi][pj];
      total += pr[ni];
    }
  assert (gk->ms[ki][pi] == total); /* FIXME03: failed with -O3 option compilation */

  i = ran_discretea (npminus1, pr);
  *topop = saC.popnmig[ki][pi][i];
  return pr[i] / total;
}

@
Function [[IMA_edgemiginfo_copymig]] copies the migration events of edge [[ei]] of
locus [[li]] to the given [[em]].
We set the following member variables of [[edgemiginfo]] structure: 
[[li]], [[edgeid]], [[upt]], [[dnt]],
[[pop]], [[fpop]], [[mpall]], and [[mig]].
Locus ID and edge ID are stored in [[li]] and [[edgeid]]. Time at the top of
edge [[ei]] is stored at [[upt]], and that for the bottom of the edge [[ei]] at
[[dnt]]. Population labels at the top and the bottom of edge [[ei]] are stored
at [[pop]] and [[fpop]], respectively. Importantly, migration events of edge
[[ei]] are stored at [[mig]]. The number of migration events is [[mpall]]. We
finalize the migration event by setting the last element to -1 of [[mt]] and
[[mpall]] to the number of events.

There are other places where we save these: [[savegenealogy]].
<<updateassignment static>>=
static void IMA_edgemiginfo_copymig (im_edgemiginfo *em, int ci, int li, int ei);
<<updateassignment bf>>=
void
IMA_edgemiginfo_copymig (im_edgemiginfo *em, int ci, int li, int ei)
{
  int mi;
  int down;
  struct edge *gtree;

  gtree = C[ci]->G[li].gtree;
  down = gtree[ei].down;
  assert (!(down < 0));
  em->li = li;
  em->edgeid = ei;
  em->upt = imaGtreeTime (ci, li, ei);
  em->dnt = gtree[ei].time;
  em->pop = gtree[ei].pop;
  em->fpop = gtree[down].pop;
  mi = 0;
  while (gtree[ei].mig[mi].mt > -0.5)
    {
      em->mig[mi] = gtree[ei].mig[mi];
      mi++;
    }
  em->mig[mi].mt = -1;
  em->mpall = mi;

  return;
}


<<updateassignment static>>=
static void IMA_genealogy_copymig (int ci, int li, int ei, im_edgemiginfo *em);
<<updateassignment bf>>=
void
IMA_genealogy_copymig (int ci, int li, int ei, im_edgemiginfo *em)
{
  int mi;
  struct edge *gtree;

  gtree = C[ci]->G[li].gtree;

  assert (em->li == li);
  assert (em->edgeid == ei);
  mi = 0;
  while (em->mig[mi].mt > -0.5)
    {
      checkmigt (mi, &gtree[ei]);
      gtree[ei].mig[mi] = em->mig[mi];
      mi++;
    }
  gtree[ei].mig[mi].mt = -1.0;
  assert (em->mpall == mi);

  return;
}

@
We append simulated migration events [[m3]] or [[em]] to edge [[sis]]. Edge
[[edge]] must be [[sbfnew]]'s [[edge1]], and [[down]] must be [[sbfnew]]'s
[[down1]]. The [[sis]] must be the root of the current partial genealogy. 
<<updateassignment static>>=
static void IMA_genealogy_appendmig (int ci, int li, int sis, im_edgemiginfo *em, 
                                     int edge, int down);
<<updateassignment bf>>=
void
IMA_genealogy_appendmig (int ci, int li, int sis, im_edgemiginfo *em, 
                         int edge, int down)
{
  double sisupt;
  double sisdnt;
  int mj;
  int mi;
  struct genealogy *G;
  struct edge *gtree;

  assert (em->li == li);
  assert (em->edgeid == sis);

  G = &C[ci]->G[li];
  gtree = G->gtree;
  imaSavedSaveBranch (ci, li, sis);
  sisupt = imaGtreeTime (ci, li, sis);
  sisdnt = gtree[sis].time;
  assert (G->root == sis);
  G->root = down;
  assert (G->roottime < em->dnt);
  G->roottime = em->dnt;
  gtree[down].down = -1;
  gtree[sis].down = down;
  gtree[edge].down = down;
  gtree[down].up[IM_EDGE_LEFT] = sis;
  gtree[down].up[IM_EDGE_RIGHT] = edge;
  gtree[edge].time = em->dnt;
  gtree[sis].time = em->dnt;
  gtree[down].time = TIMEMAX; 
  /* A partial genealogy becomes a full genealogy although it may have another
   * active lineage that needs to be attached. */

  mi = 0;
  while (gtree[sis].mig[mi].mt > -0.5 && gtree[sis].mig[mi].mt < em->upt)
    {
      mi++;
    }
  mj = 0;
  while (em->mig[mj].mt > -0.5)
    {
      checkmigt (mi, &gtree[sis]);
      gtree[sis].mig[mi] = em->mig[mj];
      mi++;
      mj++;
    }
  gtree[sis].mig[mi].mt = -1.0;
  assert (em->mpall == mj);
  gtree[down].mig[0].mt = -1.0;
  gtree[down].pop = em->fpop;

  return;
}

<<updateassignment function header>>=
void IMA_genealogy_join (im_edge *gtree, int up, int down, int downdown);
<<updateassignment bf>>=
void 
IMA_genealogy_join (im_edge *gtree, int up, int down, int downdown)
{
  int mi;
  int mj;

  gtree[up].down = downdown;
  if (gtree[downdown].up[IM_EDGE_LEFT] == down)
    {
      gtree[downdown].up[IM_EDGE_LEFT] = up;
    }
  else
    {
      gtree[downdown].up[IM_EDGE_RIGHT] = up;
    }

  mi = 0;
  while (gtree[up].mig[mi].mt > -0.5)
    {
      mi++;
    }
  mj = 0;
  while (gtree[down].mig[mj].mt > -0.5)
    {
      checkmig (mi + 1, &(gtree[up].mig), &(gtree[up].cmm));
      gtree[up].mig[mi] = gtree[down].mig[mj];
      mi++;
      mj++;
    }
  gtree[up].mig[mi].mt = -1;
  gtree[up].time = gtree[down].time;
  return;
}

<<updateassignment function header>>=
void IMA_genealogy_absorbdown (im_edge *gtree, int up, int down);
<<updateassignment bf>>=
void 
IMA_genealogy_absorbdown (im_edge *gtree, int up, int down)
{
  int mi;
  int mj;

  mi = 0;
  while (gtree[up].mig[mi].mt > -0.5)
    {
      mi++;
    }
  mj = 0;
  while (gtree[down].mig[mj].mt > -0.5)
    {
      checkmig (mi + 1, &(gtree[up].mig), &(gtree[up].cmm));
      gtree[up].mig[mi] = gtree[down].mig[mj];
      mi++;
      mj++;
    }
  gtree[up].mig[mi].mt = -1;
  gtree[up].time = gtree[down].time;
  return;
}

<<updateassignment function header>>=
void IMA_genealogy_bisectsis (int ci, int li, 
                              int sis, int edge, int down, 
                              im_edgemiginfo *em, 
                              int *seqz);
<<updateassignment bf>>=
void 
IMA_genealogy_bisectsis (int ci, int li, 
                         int sis, int edge, int down, 
                         im_edgemiginfo *em, 
                         int *seqz)
{
  double sisupt;
  double sisdnt;
  double ct;
  int nowpop;
  int downdown;
  int mj;
  int mi;
  int ki;
  int si;
  struct genealogy *G;
  struct edge *gtree;

  /* I do not like that I have to keep calling these two lines. I wanted to
   * avoid using them. It turned out that I have to change some basic structures
   * */
  G = &C[ci]->G[li];
  gtree = G->gtree;
  downdown = gtree[sis].down;
  imaSavedSaveBranch (ci, li, sis);
  if (!(downdown < 0))
    {
      imaSavedSaveBranch (ci, li, downdown);
    }

  sisupt = imaGtreeTime (ci, li, sis);
  sisdnt = gtree[sis].time;
  ct = em->dnt;
  assert (sisupt < ct && ct < sisdnt);
  if (G->root == sis)
  {
    assert (downdown == -1);
    G->root = down;
    G->roottime = ct;
  }
  else
  {
    if (gtree[downdown].up[IM_EDGE_LEFT] == sis)
      {
        gtree[downdown].up[IM_EDGE_LEFT] = down;
      }
    else
      {
        gtree[downdown].up[IM_EDGE_RIGHT] = down;
      }
  }
  gtree[down].down = downdown;

  gtree[sis].down = down;
  gtree[edge].down = down;
  gtree[down].up[IM_EDGE_LEFT] = sis;
  gtree[down].up[IM_EDGE_RIGHT] = edge;

  /* Population label and migration events */
  gtree[edge].time = ct;
  gtree[sis].time = ct;
  gtree[down].time = sisdnt;
  mi = 0;
  while (gtree[sis].mig[mi].mt > -0.5 
         && gtree[sis].mig[mi].mt < ct)
    {
      mi++;
    }
  if (mi > 0)
    {
      nowpop = gtree[sis].mig[mi - 1].mp;
    }
  else
    {
      nowpop = gtree[sis].pop;
    }

  ki = findperiodoftime (ci, ct);
  nowpop = saC.popndown[nowpop][ki];
  assert (em->fpop == nowpop);
  gtree[down].pop = em->fpop;

  mj = 0;
  while (gtree[sis].mig[mj + mi].mt > -0.5)
    {
      checkmigt (mj, &gtree[down]);
      gtree[down].mig[mj] = gtree[sis].mig[mj + mi];
      assert (nowpop != gtree[down].mig[mj].mp);
      nowpop = gtree[down].mig[mj].mp;
      mj++;
    }
  gtree[sis].mig[mi].mt = -1.0;
  gtree[down].mig[mj].mt = -1.0;

  if (L[li].model == INFINITESITES)
    {
      if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
        {
          /* Allocate proper things at the internal node sequence. */
          for (si = 0; si < L[li].numsites; si++)
            {
              if (G->mut[si] == sis)
                {
                  if (gtree[sis].seq[si] == seqz[si])
                    {
                      G->mut[si] = down;
                    }
                }
            }
        }
    }
  else if (L[li].model == HKY || L[li].model == STEPWISE)
    {
      /* No code. */
    }
  else
    {
      assert (0);
    }
  return;
}

<<updateassignment static>>=
static int IMA_intervals_collect (int ci, int li, double upt, double dnt);
                                  
<<updateassignment bf>>=
int
IMA_intervals_collect (int ci, int li, double upt, double dnt)
{
  struct genealogy *G;
  struct edge *gtree;
  im_event *ek;
  int enmax;
  int ki;
  int mi;
  int ei;
  int a;
  int ngnodes;
  int ngenes;
  double t;

  G = &C[ci]->G[li];
  gtree = G->gtree;
  ngnodes = L[li].numlines;
  ngenes = L[li].numgenes;

  a = 0;
  ek = sbfold.e1;
  enmax = sbfold.nmax1;
  for (ei = ngenes; ei < ngnodes; ei++)
    {
      if (gtree[ei].exist == 'F')
        {
          continue;
        }
      t = imaGtreeTime (ci, li, ei);
      assert (upt < t);
      ek->type = 'c'; 
      ek->t = t;
      ek->p = -1;
      ek->pi = -1;
      ek->pj = gtree[ei].pop;
      ek->ei = ei;
      ek++;
      a++;
    }
  for (ki = 0; ki < numsplittimes; ki++)
    {
      t = C[ci]->tvals[ki];
      if (upt < t && t < dnt)
        {
          ek->type = 's'; 
          ek->t = t;
          ek->p = ki;    /* Split time happens right before the period line. */
          ek->pi = ki;   /* from 0 (pi) to 1 (pj) for the first split time.  */
          ek->pj = ki + 1;
          ek->ei = -1;
          ek++;
          a++;
        }
    }
  for (ei = 0; ei < ngnodes; ei++)
    {
      if (gtree[ei].exist == 'F')
        {
          continue;
        }
      mi = 0;
      assert (gtree[ei].cmm > 0);
      t = gtree[ei].mig[mi].mt;
      while (t > -0.5)
        {
          assert (upt < t);
          if (!(a < enmax - 1))
            {
              enmax += 5;
              sbfold.e1 = realloc (sbfold.e1, enmax * sizeof (im_event));
              sbfold.nmax1 = enmax;

              /* IMPORTANT! The pointer must repoint to a right place. */
              ek = &sbfold.e1[a]; 
            }

          ek->type = 'm';
          ek->t = t;
          ek->p = findperiodoftime (ci, t);
          if (mi == 0)
            {
              ek->pi = gtree[ei].pop;
            }
          else
            {
              ek->pi = gtree[ei].mig[mi - 1].mp;
            }
          ek->pi = saC.popndown[ek->pi][ek->p];
          ek->pj = gtree[ei].mig[mi].mp;
          ek->ei = ei;
          ek++;
          a++;

          mi++;
          t = gtree[ei].mig[mi].mt;
        }
      if (ei == G->root)
        {
          if (sbfold.is_finiterootbranch == 'T')
            {
              t = gtree[ei].time;
              assert (t < TIMEMAX - 1.0);
              if (!(a < enmax - 1))
                {
                  enmax += 5;
                  sbfold.e1 = realloc (sbfold.e1, enmax * sizeof (im_event));
                  sbfold.nmax1 = enmax;

                  /* IMPORTANT! The pointer must repoint to a right place. */
                  ek = &sbfold.e1[a];
                }

              ek->type = 'e';
              ek->t = t;
              ek->p = findperiodoftime (ci, t);
              if (mi == 0)
                {
                  ek->pi = gtree[ei].pop;
                }
              else
                {
                  ek->pi = gtree[ei].mig[mi - 1].mp;
                }
              ek->pi = saC.popndown[ek->pi][ek->p];
              ek->pj = ek->pi;
              ek->ei = ei;
              ek++;
              a++;
            }
        }
    }

  assert (a > 0);
  sbfold.n1 = a;
  qsort (sbfold.e1, (size_t) a, sizeof (im_event), im_event_cmp);
  assert (upt < sbfold.e1[0].t);
  
  return a;
}
@
Proposing a new genealogy from prior distribution of genealogy using
\citet{Beerli:1999} requires values of demographic model parameters.
The genealogy sampling approach under \citet{Hey:2007} unfortunately
integrates demographic model parameters out of prior probability density
of genealogy and demographic model parameters. Values of demographic
model parameters are not involved in the Markov chains. We circumvent
the impediment with the second step of maximizing posterior density
function of demographic parameters given data to find maximum likelihood
estimates of demographic parameters (see Equation 1). We make use
of a single genealogy of a single locus to estimate demographic parameters.
Recall how maximum likelihood estimates are found in Equation (1): 

\begin{equation}
\pi(\Theta|\mathbf{X})\approx\frac{1}{N}\sum_{n=1}^{N}f(\Theta|\mathbf{G}_{n},\mathbf{t}_{n})=\frac{1}{N}\sum_{n=1}^{N}\frac{f(\mathbf{G}_{n}|\mathbf{t}_{n},\Theta)\pi(\Theta)}{f(\mathbf{G}_{n}|\mathbf{t}_{n})}.\label{eq:lmodedetail}\end{equation}


Supposing one sample of $\mathbf{G}_{1}$, and $\mathbf{t}_{1}$,
we estimate the demographic model parameters $\mathbf{\Theta}$ based
on that \begin{equation}
\pi(\mathbf{\Theta}|\mathbf{X})\approx f(\mathbf{\Theta}|\mathbf{G}_{1},\mathbf{t}_{1})=\frac{f(\mathbf{G}_{1}|\mathbf{t}_{1},\mathbf{\Theta})\pi(\mathbf{\Theta})}{f(\mathbf{G}_{1}|\mathbf{t}_{1})}.\label{eq:lmodesingle}\end{equation}


Assuming $f(\mathbf{G}_{1}|\mathbf{t}_{1})$ and $\pi(\mathbf{\Theta})$
are constant, we can have an estimate of $\mathbf{\Theta}$ if we
can find the peak of $f(\mathbf{G}_{1}|\mathbf{t}_{1},\mathbf{\Theta})$.
We use the estimated demographic parameters to simulate coalescent
and migration events along an active lineage. The detail of the implementation
of deriving model parameters from a single genealogy is described
in the following.

Refer to Equations 15 and 16 of the section {}``Multipopulation Models''
in \citet{Hey:2007} for the description of terms in the equations.
The parameter $\theta_{1}$ is derived as follows:\[
\theta_{1}=\begin{cases}
2\times\frac{f_{1}}{c_{1}+1} & c_{1}>0\\
2\times f_{1} & c_{1}=0,\; f_{1}>0\\
0 & c_{1}=0,\; f_{1}=0\end{cases}\]
and the parameter $m_{1}$ is given by:\[
m_{1}=\begin{cases}
\frac{w_{1}+1}{g_{1}} & w_{1}>0\\
\frac{1}{g_{1}} & w_{1}=0,\; g_{1}>0\\
m_{\mathrm{min}} & w_{1}=0,\; g_{1}=0\end{cases}\]


The value we used for $m_{\mathrm{min}}$ is 1.01. Consider the probability
of genealogy given demographic parameters, or Equation (15) in \citet{Hey:2007}.
Taking the derivative of the equation with respect to $\theta_{1}$
and setting it to 0, we find the value that maximize the equation
as $f_{1}/c_{1}$. Similarly, the value for $m_{1}$ is $w_{1}/g_{1}$.
Note that each of the second cases of the equations above where $c_{1}=0$
and $w_{1}=0$ is redundant. We want to emphasize the addition of
1 to $c_{1}$ and $g_{1}$ in order to account an active lineage.

After derivation of demographic parameters, we use Equations (7) and
(3) of \citet{Beerli:1999} to simulate next time of an event. For
infinite sites model, we count the number of lineages that coalesce
with an active lineage so that the resulting full genealogy is compatible
with infinite sites data. While we could have used different derivations
of demographic model parameters, we find ourselves the maximum likelihood
estimates from a single genealogy a good one for the update of assignment.\pagebreak{}



<<updateassignment static>>=
static int IMA_genealogy_derivetheta (char w, int ci, int li, int z1);
<<updateassignment bf>>=
int
IMA_genealogy_derivetheta (char w, int ci, int li, int z1)
{
  im_event *ek;
  double prevt;
  double tau;
  double h2term;
  int pi;
  int pj;
  int ki;
  int ai;
  int pii;
  double fm1;
  double fm1z1;
  int ngenes;
  int npminus1; 
  int ninterval;
  struct edge *gtree;
  int ni;
  int pk;
  int pl;
  im_ginfo *gk;
  im_ginfo *gkz1;
  im_bfupdate *pbf;
  int n1;
  int n2;
  int edge;

  assert (assignmentoptions[POPULATIONASSIGNMENT] == 1);
  gtree = C[ci]->G[li].gtree;

  if (w == 'o')
    {
      pbf = &sbfold;
      gk = &saGiold[li];
      gkz1 = &saGioldz1[li];
    }
  else if (w == 'n')
    {
      pbf = &sbfnew;
      gk = &saGinew[li];
      gkz1 = &saGinewz1[li];
    }
  else
    {
      assert (0);
    }

  ek = pbf->e1;
  ninterval = pbf->n1;
  ngenes = L[li].numgenes;
  IMA_sbf_lineages (pbf, ci, li, z1);
  imaGinfoReset (gk);
  imaGinfoReset (gkz1);

  h2term = 1 / (2 * L[li].hval);
  prevt = 0.0;
  ki = 0;
  npminus1 = npops - ki - 1;
  for (ai = 0; ai < ninterval; ai++)
    {
      tau = ek->t - prevt;
      assert (tau > 0.0);
      /* For all pop'n during period ki */
      for (pii = 0; pii < npops - ki; pii++) 
        {
          pi = C[ci]->plist[ki][pii];

          /* Jody's code does not have plus one or +1. When we have only single
           * lineage, we should have positve coalescent rate. 1 * (1 - 1) is
           * zero, and we would have 0 rate of coalescent for a single lineage.
           * That may be why we add one to the number of lineages. The idea is
           * that we should consider the active lineage. */
          gk->fc[pi] += snnminus1[pbf->n[pi] + 1] * tau * h2term; 
          gkz1->fc[pi] += snnminus1[pbf->nz1[pi] + 1] * tau * h2term; 
          assert (gk->fc[pi] < DBL_MAX);
          assert (gkz1->fc[pi] < DBL_MAX);
          if (modeloptions[NOMIGRATION] == 0 && ki < lastperiodnumber)
            {
              fm1 = (pbf->n[pi] + 1) * tau;
              fm1z1 = (pbf->nz1[pi] + 1) * tau;
              for (ni = 0; ni < npminus1; ni++)
                {
                  pj = saC.popnmig[ki][pi][ni];
                  gk->fm[pi][pj] += fm1;
                  gkz1->fm[pi][pj] += fm1z1;
                }
            }
        }

      switch (ek->type)
        {
        case 'c':
          pi = ek->pj;
          gk->cc[pi]++;
          gkz1->cc[pi]++;
          edge = ek->ei;
          if (L[li].model == INFINITESITES)
            {
              /* NOTE: We do not update sbfold.l!!! */
              pbf->n[pi]--;
              if (calcoptions[DONTCALCLIKELIHOODMUTATION] == 0)
                {
                  IMA_sbf_c (ci, li, edge, pi, pbf->seqz1,
                             pbf->nz1, pbf->lz1, pbf->a);
                }
              else
                {
                  IMA_sbf_c (ci, li, edge, pi, NULL,
                             pbf->nz1, pbf->lz1, pbf->a);
                }
            }
          else if (L[li].model == HKY || L[li].model == STEPWISE)
            {
              /* NOTE: We do not update sbfold.nz1 .lz1 !!! */
              IMA_sbf_c (ci, li, edge, pi, NULL, 
                         pbf->n, pbf->l, pbf->a);
            }
          break;
        case 'm':
          edge = ek->ei;
          pi = ek->pi;
          pj = ek->pj;
          gk->cm[pi][pj]++;
          gkz1->cm[pi][pj]++;
          if (L[li].model == INFINITESITES)
            {
              pbf->n[pi]--;
              pbf->n[pj]++;
              IMA_sbf_m (edge, pi, pj, 
                         pbf->nz1, pbf->lz1, pbf->a);
            }
          else if (L[li].model == HKY || L[li].model == STEPWISE)
            {
              IMA_sbf_m (edge, pi, pj, 
                         pbf->n, pbf->l, pbf->a);
            }
          break;
        case 's':
          assert (ek->p == ki);
          ki++;
          pj = C[ci]->droppops[ki][IM_EDGE_LEFT];
          pk = C[ci]->droppops[ki][IM_EDGE_RIGHT];
          pl = C[ci]->addpop[ki];
          pbf->n[pl] = pbf->n[pj] + pbf->n[pk];
          n1 = pbf->n[pj];
          n2 = pbf->n[pk];
          if (n1 > 0)
            {
              memcpy (pbf->l[pl], pbf->l[pj], n1 * sizeof (int));
            }
          if (n2 > 0)
            {
              memcpy (&pbf->l[pl][n1], pbf->l[pk], n2 * sizeof (int));
            }
          pbf->n[pj] = 0;
          pbf->n[pk] = 0;
          npminus1--;
          assert (!(npminus1 < 0));
          if (!(z1 < 0))
            {
              /* *pc1 = saC.popndown[*pc1][ki]; */
            }
          assert (L[li].model == INFINITESITES 
                  || L[li].model == HKY
                  || L[li].model == STEPWISE);
          if (!(z1 < 0))
            {
              /* FIXME: We do not use gkz1 or nz1, lz1 for HKY.
               * We should replace the above if-statement with 
               * if (L[li].model == INFINITESITES)
               */

              /* Change the number and sets as well. */
              n1 = pbf->nz1[pj];
              n2 = pbf->nz1[pk];
              pbf->nz1[pl] = n1 + n2;
              if (n1 > 0)
                {
                  memcpy (pbf->lz1[pl], pbf->lz1[pj], n1 * sizeof (int));
                }
              if (n2 > 0)
                {
                  memcpy (&pbf->lz1[pl][n1], pbf->lz1[pk], n2 * sizeof (int));
                }
              pbf->nz1[pj] = 0;
              pbf->nz1[pk] = 0;
            }
          break;
        case 'e':
          assert (ai == ninterval - 1);
          break;
        }
      prevt = ek->t;
      ek++;
    }

  IMA_ginfo_computetheta (gk);
  IMA_ginfo_computetheta (gkz1);
  
  return 0;
}

<<updateassignment static>>=
int IMA_ginfo_computetheta (im_ginfo *gk);
<<updateassignment bf>>=
int
IMA_ginfo_computetheta (im_ginfo *gk)
{  
  int pi;
  int pj;
  int ti;
  int ni;
  int npminus1;
  for (pi = 0; pi < numpopsizeparams; pi++)
    {
      if (gk->cc[pi] > 0)         /* Case (A) */
        {
          gk->thetas[pi] = 2 * gk->fc[pi] / (gk->cc[pi] + 1);
        }
      else
        {
          if (gk->fc[pi] > 0.0)   /* Case (B) */
            {
              assert (gk->cc[pi] == 0);
              gk->thetas[pi] = 2 * gk->fc[pi] / (1);
            }
          else                    /* Case (C) */
            {
              gk->thetas[pi] = 0.0;
            }
        }
      for (pj = 0; pj < numpopsizeparams; pj++)
        {
          if (pi == pj)
            {
              continue;
            }
          if (gk->cm[pi][pj] > 0) /* Case (D) */
            {
              assert (gk->fm[pi][pj] > 0.0);
              gk->mms[pi][pj] = (gk->cm[pi][pj] + 1) / gk->fm[pi][pj];
            }
          else                   /* Case (E) and (F) */
            {
              assert (gk->cm[pi][pj] == 0);
              if (gk->fm[pi][pj] > 0.0)
                {
                  gk->mms[pi][pj] = (1) / gk->fm[pi][pj];
                }
              else
                {
                  gk->mms[pi][pj] = BFMPRIORMIN;
                }
            }
        }
    }

  /* We need number of periods where migrations are allowed. */
  /* npops - 1 for tree model and 1 for tree model.          */
  /* lastperiodnumber is for this                            */
  for (ti = 0; ti < lastperiodnumber; ti++)
    {
      for (pi = 0; pi < numpopsizeparams; pi++)
        {
          if (saC.popnmig[ti][pi] != NULL)
            {
              gk->ms[ti][pi] = 0.0;
              npminus1 = npops - ti - 1;
              for (ni = 0; ni < npminus1; ni++)
                {
                  pj = saC.popnmig[ti][pi][ni];
                  gk->ms[ti][pi] += gk->mms[pi][pj];
                }
            }
        }
    }
  return 0;
}



@
We choose one of n (upto 10) elements considering their weight.
We choose one of n elements considering their log weights.

<<updateassignment static>>=
#ifdef DELETETHIS
static int ran_discrete (int n, ...);
#endif /* DELETETHIS */
static int ran_discretea (int n, double pr[]); 
static int ran_discreteloga (int n, double pr[]); 
static int normalizeLoga (int n, double pr[]); 
<<updateassignment bf>>=
#ifdef DELETETHIS
int
ran_discrete (int n, ...)
{
  register int i;
  va_list ap;
  double s;
  double a;
  double l[10];
  double u;
  int v;

  assert (n > 1);
  assert (n <= 10);
  va_start (ap, n);
  a = va_arg (ap, double);
  s = a;
  l[0] = a;
  for (i = 1; i < n; i++)
    {
      a = va_arg (ap, double);
      l[i] = a;
      s += a;
    }
  va_end (ap);

  u = s * uniform ();

  s = 0.0;
  for (i = 0; i < n; i++)
    {
      s += l[i];
      if (u < s)
        {
          v = i;
          break;
        }
    }
  return v;
}
#endif /* DELETETHIS */

int
ran_discretea (int n, double pr[])
{
  register int i;
  int v;
  double s;
  double u;

  s = 0;
  for (i = 0; i < n; i++)
    {
      s += pr[i]; 
    }
  u = s * uniform ();
  s = 0.0;
  for (i = 0; i < n; i++)
    {
      s += pr[i];
      if (u < s)
        {
          v = i;
          break;
        }
    }
  return v;

}

int
ran_discreteloga (int n, double pr[])
{
  register int i;
  int v;
  double s;
  double t;
  double u;

  t = pr[0];
  for (i = 1; i < n; i++)
    {
      LogSum2 (t, t, pr[i]);
    }
  u = log (uniform ()) + t;

  s = pr[0];
  if (u < s)
    {
      v = 0;
    }
  else
    {
      for (i = 1; i < n; i++)
        {
          LogSum2 (s, s, pr[i]);
          if (u < s)
            {
              v = i;
              break;
            }
        }
    }
  return v;
}

int
normalizeLoga (int n, double pr[])
{
  register int i;
  double t;

  t = pr[0];
  for (i = 1; i < n; i++)
    {
      LogSum2 (t, t, pr[i]);
    }
  
  for (i = 0; i < n; i++)
    {
      pr[i] -= t;
    }

  return 0;
}


@
How can I use a finite site model with IMa?

Jukes-Cantor model:\[
\Pr(C|A,u,t)=\frac{1}{4}(1-e^{-\frac{4}{3}ut}).\]
The probability that there is no change is\[
\Pr(C|C,u,t)=\frac{1}{4}(1+3e^{-\frac{4}{3}ut}).\]
Function likelihoodJC computes the likelihood of data under Jukes-Cantor
model. The tree is specified by \textbf{ci} and \textbf{li}. Branch
lengths are scaled by \textbf{u}. We follow the procedure of likelihood
computation at the subsection \textbf{Economizing on the computation}
at pages 253 through 255 of Felsenstein's book. I may copy some of
his text and please look at his book in detail. From now on, {}``he''
is referred to Joe Felsenstein. The return value \textbf{v} is stored
the log likelihood. We compute the log likelihood site-by-site, and
sum them over all sites. The index \textbf{si} runs over the number
of sites of sequence alignment of data. He has the \emph{conditional
likelihood} of a subtree: $L_{k}^{(i)}(s).$ He describes that it
is the probability of everything that is observed from node $k$ on
the tree and up, at site $i,$ conditional on node $k$ having state
$s.$ The value of conditional likelihood at the root of a genealogy
is $L_{root}^{(i)}(s)$ for the site $i$ assuming the root being
occupied by state $s.$ We traverse a genealogy in postorder to compute
$L_{k}^{(i)}(s)$ for all possible states. The probability $L_{k}^{(i)}(s)$
at a tip node is 1 for the observed nucleotide and 0's for the rest
of nucleotides. The four values of $L_{root}^{(i)}(s)$ are weighted
over all four bases by their prior probability under the Jukes-Cantor
model:\[
L^{(i)}=\sum_{x}\pi_{x}L_{root}^{(i)}(x).\]
Since all base frequencies are equal under Jukes-Cantor model, we
can pull $\pi_{x}$ out of the summation over four bases. Function
\texttt{computeLk} calculates $L_{k}^{(i)}(s):$\[
L_{k}^{(i)}(s)=\left(\sum_{x}\Pr(x|s,t_{l})L_{l}^{(i)}(x)\right)\left(\sum_{y}\Pr(y|s,t_{r})L_{r}^{(i)}(y)\right).\]
The values of $L_{tip}^{(i)}$ are\[
\left(L_{tip}^{(i)}(A),L_{tip}^{(i)}(C),L_{tip}^{(i)}(G),L_{tip}^{(i)}(T)\right)=\left(1,0,0,0\right)\]
if the tip base is Adenine. We set 1 for the base that we observe
at the tip node, 0 for the rest of bases. Note that we index A, C,
G, and T from 0, 1, 2 to 3. Variable \texttt{l\_kleft} and \texttt{l\_kright}
stores the left and right parts of $L_{k}^{(i)}(s).$ Note that \texttt{PijJC}
takes arguments just as $\Pr(x|s,t).$ 
<<updateassignment function header>>=
double likelihoodJC (int ci, int li, double u);
int computeLk (double (*l_k)[4], double u, int li, im_edge *t, int k, int si);
double PijJC (int i, int j, double t);
double IMA_edge_length (im_edge *t, int ei);
<<updateassignment bf>>=
double
likelihoodJC (int ci, int li, double u)
{
  double l_k[4];
  double v;
  int si;
  im_edge *gtree; 

  gtree = C[ci]->G[li].gtree;
  v = 0.0;
  for (si = 0; si < L[li].numsites; si++)
    {
      computeLk (&l_k, u, li, gtree, C[ci]->G[li].root, si);
      v += logsum (4, l_k[0], l_k[1], l_k[2], l_k[3]);
      v -= M_LN2 * 2;
    }

  return v;
}

/* Function: computeLk
 * l_k: return value for the conditional likelihood
 * u  : branch length scaler
 * li : locus index
 * t  : tree
 * k  : node index
 * si : site index */
int
computeLk (double (*l_k)[4], double u, int li, im_edge *t, int k, int si)
{
  int s;
  int x;
  int y;
  int left;
  int right;
  int base;
  int basel;
  int baser;
  double l_kl[4] = { 0.0, 0.0, 0.0, 0.0};
  double l_kr[4] = { 0.0, 0.0, 0.0, 0.0};
  double l_kleft;
  double l_kright;
  double A;
  double tl;
  double tr;

  left = t[k].up[0];
  right = t[k].up[1];
  base = -1;
  if (left < 0 && right < 0)
    {
      assert (!(k < 0));
      assert (k < L[li].numgenes);
      base = L[li].seq[k][si];
    }
  else
    {
      assert (!(left < 0 || right < 0));
      basel = computeLk (&l_kl, u, li, t, left, si);
      baser = computeLk (&l_kr, u, li, t, right, si);
      tl = u * IMA_edge_length (t, left);
      tr = u * IMA_edge_length (t, right);

      for (s = 0; s < 4; s++)
        {
          l_kleft = 0.0;
          if (basel == -1)
            {
              for (x = 0; x < 4; x++)
                {
                  A = PijJC (x, s, tl) + l_kl[x];
                  LogSum2 (l_kleft, l_kleft, A);
                }
            }
          else
            {
              assert (basel == 0 || basel == 1 || basel == 2 || basel == 3);
              l_kleft = PijJC (basel, s, tl);
            }

          l_kright = 0.0;
          if (baser == -1)
            {
              for (y = 0; y < 4; y++)
                {
                  A = PijJC (y, s, tr) + l_kr[y];
                  LogSum2 (l_kright, l_kright, A);
                }
            }
          else
            {
              assert (baser == 0 || baser == 1 || baser == 2 || baser == 3);
              l_kright = PijJC (baser, s, tr);
            }
          (*l_k)[s] = l_kleft + l_kright;
        }
    }

  return base; 
}

double
PijJC (int i, int j, double t)
{
  double v;
  double A;

  if (i == j)
    {
      A = -4.0 * t / 3.0;
      LogDiff (v, 0.0, A);
      v -= M_LN2 * 2;
    }
  else
    {
      A = -4.0 * t / 3.0 + log (3.0);
      LogSum2 (v, 0.0, A);
      v -= M_LN2 * 2;
    }
  return v;
}

double
IMA_edge_length (im_edge *t, int ei)
{
  double upt;
  int up0;

  up0 = t[ei].up[0];
  if (up0 < 0)
    {
      upt = 0.0;
    }
  else
    {
      upt = t[up0].time;
    }
  return t[ei].time - upt;
}

@
\subsection{Three point turn update}
We make an inefficient tree update.
This would work only with three-population trees.
Is there a way to extend it to more than three populations? Yes, it seems
possible. We have to change a lot of parts of [[IMa2]]. It will be [[IMa3]]
because we have to change population tree. We apply this method to 3 population
case only. 

Choose one of two ingroup populations. 
<<updateassignment function header>>=
int updateassignmenttpt (int ci);
<<updateassignment tpt>>=
int
updateassignmenttpt (int ci)
{
  int bnocoal;
  int rperiod; 
  int accp;
  double lweight;
  double logU;
  double mweight;
  double hweight;
  struct genealogy *G;
  int li;
  int popx;
  int popa;
  int popb;

  assert (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0);
  if (npops != 3)
    {
      IM_errloc (AT, 
                 "Three point update is implemented only for three populations");
    }

  /* Count up the number of tries of MCMC cycles. */
  if (ci == 0)
    {
      for (li = 0; li < nloci; li++)
        {
          L[li].a_rec->upinf[IM_UPDATE_ASSIGNMENT_RELABEL].tries++;
        }
    }
  Cupinf[ci].upinf[IM_UPDATE_ASSIGNMENT_RELABEL].tries++;

  /* Check if there is any coalescent event in period 1. */
  rperiod = 1; 
  bnocoal = tptExistCoalescentPeriod (ci, rperiod);
  
  /**************************************************************************/
  /* This is not good one but we exit the function when there is a coalescent
   * event in the middle period. */
  /**************************************************************************/
  if (bnocoal == 1)
    {
      return 0;
    }

  G = NULL;
  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }
  /* We can update the population tree of chain ci. */ 
  /* Choose one of two ingroup populations. */
  /* Relabel ... */
  tptChooseAnIngroup (ci, rperiod, &popx, &popa);
  popb = tptOutgroup (ci, rperiod);

  /* Save the current state of a chain */
  for (li = 0; li < nloci; li++)
    {
      imaSavedReset (li);
      imaSavedSaveLocusInfo (ci, li);
      copy_treeinfo (&saT[li].savedgweight, &C[ci]->G[li].gweight);
    }
  copy_treeinfo (&saC.savedallgweight, &C[ci]->allgweight);
  /* We do not call copy_probcalc_all because we do not change likelihood. */
  copy_probcalc (&saC.savedallpcalc, &C[ci]->allpcalc);

  /* Propose a new state of genealogy and assignment. */
  hweight = tptmove (ci, rperiod, popx, popa, popb, 3);

  /* Compute Metropolis-ratio. */
  setzero_genealogy_weights (&C[ci]->allgweight);
  for (li = 0; li < nloci; li++)
    {
      setzero_genealogy_weights (&C[ci]->G[li].gweight);
      treeweight (ci, li);
      sum_treeinfo (&C[ci]->allgweight, &C[ci]->G[li].gweight);
    }
  initialize_integrate_tree_prob (ci, &C[ci]->allgweight, &C[ci]->allpcalc);

  logU = log (uniform ());
  mweight = C[ci]->allpcalc.probg - saC.savedallpcalc.probg;
  lweight = beta[ci] * mweight + hweight;
  assert (beta[ci] * mweight + hweight > -1e200
          && beta[ci] * mweight + hweight < 1e200);

/* check values of acceptance probability: 
  printf ("pdg: %.3lf - %.3lf (%.3lf), pg: %.3lf - %.3lf (%.3lf), hweight: %.3lf, lweight: %.3lf vs. logU: %.3lf, [%d]\n", 
          C[ci]->allpcalc.pdg, saC.savedallpcalc.pdg, C[ci]->allpcalc.pdg - saC.savedallpcalc.pdg,
          C[ci]->allpcalc.probg, saC.savedallpcalc.probg, C[ci]->allpcalc.probg - saC.savedallpcalc.probg,
          hweight, lweight, logU, lweight > logU);
*/
 
  accp = 0;

  if (lweight > 0.0 || lweight > logU)
    {
      /* accept the update */
      accp = 1;
      if (ci == 0)
        {
          for (li = 0; li < nloci; li++)
            {
              L[li].a_rec->upinf[IM_UPDATE_ASSIGNMENT_RELABEL].accp++;
            }
        }
      Cupinf[ci].upinf[IM_UPDATE_ASSIGNMENT_RELABEL].accp++;
      SWAP (C[ci]->nasn[popa], C[ci]->nasn[popb]);

      /* Always revert to an original. */
      for (li = 0; li < nloci; li++)
        {
          if (L[li].model == HKY)
            {
              copyfraclike (ci, li);
              storescalefactors (ci, li);
            }
        }
    }
  else
    {
      for (li = 0; li < nloci; li++)
        {
          /* restore edges changed during update */
          imaSavedRestore (ci, li); 
          imaSavedRestoreLocusInfo (ci, li);
          copy_treeinfo (&C[ci]->G[li].gweight, &saT[li].savedgweight);
        }
      copy_treeinfo (&C[ci]->allgweight, &saC.savedallgweight);
      copy_probcalc (&C[ci]->allpcalc, &saC.savedallpcalc);
    }

  for (li = 0; li < nloci; li++)
    {
      if (L[li].model == HKY)
        {
          restorescalefactors (ci, li);
        }
    }

  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }
  return accp;
}

@
We find two time points of a period. We check all coalescent events whether
there is a coalescent event between the time points. If we have one, we return 0
as FALSE. Otherwise, we return 1 as TRUE;


[[tptExistCoalescentPeriod]] is a part of 
<<updateassignment static>>=
static int tptExistCoalescentPeriod (int ci, int rperiod);
<<updateassignment tpt>>=
int 
tptExistCoalescentPeriod (int ci, int rperiod)
{
  int v;
  double upt;
  double dnt;
  int li;
  int ei;
  double t;
 
  assert (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0);

  if (rperiod == 0)
    {
      upt = 0.0;
    }
  else
    {
      upt = C[ci]->tvals[rperiod - 1];
    }
  dnt = C[ci]->tvals[rperiod]; 
  /* tvals is an array of size npops. */

  v = 0; /* FALSE */ 
  for (li = 0; li < nloci; li++)
    {
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          if (upt < t && t < dnt)
            {
              v = 1;
              li = nloci;
              break;
            }
        }
    }

  return v;
}

@
Two populations merge at the beginning of the period [[rperiod]].  We choose one
of the branches for branch [[x]] and another [[a]]. Two functions are written:  
[[tptChooseAnIngroup]] and [[Phylogeny_tptChooseAnIngroup]].  The former was for
the case of three populations, and the latter is its generalized version.  The
former one will be obsolete if we check the latter works with the
three-population case.

[[Phylogeny_tptChooseAnIngroup]] returns the population tree branch during
[[rperiod]].
<<updateassignment static>>=
static int tptChooseAnIngroup (int ci, int rperiod, int *popx, int *popa);
static int Phylogeny_tptChooseAnIngroup (int ci, int rperiod, int *popx, int *popa);
<<updateassignment tpt>>=
int 
tptChooseAnIngroup (int ci, int rperiod, int *popx, int *popa)
{
  int v;
  struct popedge *ptree;

  assert (rperiod == 1);

  ptree = C[ci]->poptree;
  if (bitran () /*uniform() < 0.5 */ )
    {
      *popx = ptree[3].up[1];
      *popa = ptree[3].up[0];
    }
  else
    {
      *popx = ptree[3].up[0];
      *popa = ptree[3].up[1];
    }
  v = *popa;
  return v;
}

int 
Phylogeny_tptChooseAnIngroup (int ci, int rperiod, int *popx, int *popa)
{
  assert (0 < rperiod && rperiod < npops - 1);
  if (bitran ())
    {
      *popx = C[ci]->droppops[rperiod][0];
      *popa = C[ci]->droppops[rperiod][1];
    }
  else
    {
      *popx = C[ci]->droppops[rperiod][1];
      *popa = C[ci]->droppops[rperiod][0];
    }
  return C[ci]->addpop[rperiod];
}

<<updateassignment static>>=
static int Phylogeny_tptChooseAllPopulations (int ci, int rperiod, 
                                       int *popal, int *popbl, int *popcl,
                                       int *popau, int *popbu, int *popcu);
<<updateassignment population tree update>>=
int 
Phylogeny_tptChooseAllPopulations (int ci, int rperiod, 
                                       int *popal, int *popbl, int *popcl,
                                       int *popau, int *popbu, int *popcu)
{
  *popau = C[ci]->droppops[rperiod][0];
  *popbu = C[ci]->droppops[rperiod][1];
  *popcu = C[ci]->addpop[rperiod];
  *popal = C[ci]->droppops[rperiod + 1][0];
  *popbl = C[ci]->droppops[rperiod + 1][1];
  *popcl = C[ci]->addpop[rperiod + 1];
  return 0;
}


@
We assume a three-population tree. The number 4 is always the index of a rooting
edge. 

[[Phylogeny_sister]] returns the sister population of the branch [[pi]]. 
<<updateassignment static>>=
static int tptOutgroup (int ci, int rperiod);
static int Phylogeny_sister (int ci, int pi);
<<updateassignment tpt>>=
int 
tptOutgroup (int ci, int rperiod)
{
  int v;
  struct popedge *ptree;

  assert (rperiod == 1);

  ptree = C[ci]->poptree;
  if (ptree[4].up[0] < npops)
    {
      v = ptree[4].up[0];
    }
  else
    {
      v = ptree[4].up[1];
    }
  return v;
}

int 
Phylogeny_sister (int ci, int pi)
{
  int v;
  struct popedge *ptree;
  int down;

  ptree = C[ci]->poptree;
  down = ptree[pi].down;
  assert (ptree[pi].numup == 2);
  assert (npops <= down && down < 2 * npops - 1); /* down must be an internal edge. */
  assert (-1 < ptree[down].up[0] && ptree[down].up[0] < 2 * npops - 1);
  assert (-1 < ptree[down].up[1] && ptree[down].up[1] < 2 * npops - 1);

  if (ptree[down].up[0] == pi)
    v = ptree[down].up[1];
  else
    v = ptree[down].up[0];
  return v; 
}
@
[[popa]] is an ingroup, and [[popb]] is an outgroup.
<<updateassignment static>>=
static double tptmove (int ci, int rperiod, int popx, int popa, int popb, int popc);
<<updateassignment tpt>>=
double
tptmove (int ci, int rperiod, int popx, int popa, int popb, int popc)
{
  double lhweight;
  int li;
  int ei;
  int ngnodes;
  double upt;
  double dnt;

  lhweight = 0.0;

  if (rperiod == 0)
    {
      upt = 0.0;
    }
  else
    {
      upt = C[ci]->tvals[rperiod - 1];
    }
  dnt = C[ci]->tvals[rperiod]; 

  /* tvals is an array of size npops. */


  for (li = 0; li < nloci; li++)
    {
      ngnodes = L[li].numlines;
      for (ei = 0; ei < ngnodes; ei++)
        {
          imaSavedSaveBranch (ci, li, ei);
          imaGtreeSwap (ci, li, ei, popx, popa, popb, popc, upt, dnt);
        }
    }
  
  return lhweight;
}
@
We could change labels of population trees. We instead keep them unchanged. We
change labels of genealogies.

We swap population labels. Consider the following population tree with three
populations. We move ingroup population 1 to the outgroup, and the outgroup to
the ingroup. For example, [[popa]] is 1, [[popb]] is 2, and [[popc]] is 3. We
change label at a top of an edge, and those at migration events. We swap 1 and 2
at tops of edges. If migration events occur before [[upt]], then we swap 1 and
2. If they occur between [[upt]] and [[dnt]], then we swap 3 and 2.
\begin{Verbatim}[frame=lines,framesep=5mm]
 0     1    2
 |     |    |
 +--3--+    | <- upt
    |       |
    +---4---+ <- dnt
        |
        |
        R

to 

 0     2    1 
 |     |    |
 +--3--+    | <- upt
    |       |
    +---4---+ <- dnt
        |
        |
        R



 0     1   2     3
 |     |   |     |
 +--4--+   |     |
    |      |     |
    |      +--5--+
    |         |
    +----6----+
         |
         |
         R
\end{Verbatim}


<<updateassignment static>>=
static int imaGtreeSwap (int ci, int li, int ei, 
                         int popx, int popa, int popb, int popc,
                         double upt, double dnt);
<<updateassignment tpt>>=
int
imaGtreeSwap (int ci, int li, int ei, 
              int popx, int popa, int popb, int popc,
              double upt, double dnt)
{
  int n;
  int prevpop;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL;
  
  assert (!(ci < 0));
  assert (!(li < 0));
  
  G = &C[ci]->G[li];
  gtree = &G->gtree[ei];

  /* Change population label at the top of an edge. */
  if (gtree->pop == popa)
    {
      gtree->pop = popb;
    }
  else if (gtree->pop == popb)
    {
      gtree->pop = popa;
    }

  n = 0;
  if (gtree->cmm > 0)
    {
      while (gtree->mig[n].mt > -0.5)
        {
          if (upt < gtree->mig[n].mt && gtree->mig[n].mt < dnt)
            {
              /* Figure out the population label at starting points of disappearing
               * ancestral population. If a lineage passes from popx, then we do
               * nothing about the labelling of migration events of the lineage in
               * the [[rperiod]]. If a lineage passes from popa or popb, then we
               * have to relabel populations of migration events of the lineages. 
               **/

              /* If population label of a just previous event is popx, then we
               * break this while loop. */
              if (n == 0)
                {
                  prevpop = gtree->pop;
                }
              else
                {
                  prevpop = gtree->mig[n-1].mp;
                }
              if (prevpop == popx)
                {
                  break;
                }

              assert (gtree->mig[n].mp != popa);
              if (gtree->mig[n].mp == popc)
                {
                  gtree->mig[n].mp = popb;
                }
              else if (gtree->mig[n].mp == popb)
                {
                  gtree->mig[n].mp = popc;
                }
            }
          else
            {
              assert (gtree->mig[n].mp != popc);
              if (gtree->mig[n].mp == popa)
                {
                  gtree->mig[n].mp = popb;
                }
              else if (gtree->mig[n].mp == popb)
                {
                  gtree->mig[n].mp = popa;
                }
            }
          n++; 
        }
      assert (!(n < 0));
    }
  return n;
}

@
\subsection{Population tree update using the three-point-turn}
We need a prior for divergence time.

Where is the tree set? 

Where is [[popndown]] set for [[Chain]]?

\begin{Verbatim}[frame=lines,framesep=5mm]
See Simulation 5
((t1:0.01221420996,t2:0.01221420996):0.3776580047,((t4:0.06225541553,t3:0.06225541553):0.1938673505,t5:0.256122766):0.1337494486);
\end{Verbatim}


We generalize the three-point-turn update to multiple populations.

\begin{Verbatim}[frame=lines,framesep=5mm]
POPULATIONASSIGNMENTINFINITE: not for island population structures.
tptExistCoalescentPeriod is changed to tptChooseCoalescentPeriod.
\end{Verbatim}

We choose a period using function [[tptChooseCoalescentPeriod]].  A branch
starts at the top of the period and ends in the bottom of it. The function
returns a period during which we relabel populations.  Otherwise, it returns -1,
which means that it could not find any branch to update.

\begin{Verbatim}[frame=lines,framesep=5mm]
mb
exe infile.nex
sumt nruns=1
\end{Verbatim}

There are $(npops - 2)!$ possible labels for the internal nodes for a 
unique given labeled history.
How are [[gsample]] stored? See file [[ginfo.c]].

We use Gernhard (2008) for the prior of divergence time.
$r = \lambda - \mu ~ 1/x$
$x ~ Uniform(0,100)$
$a = \mu / \lambda ~ Uniform(0,1)$
<<updateassignment function header>>=
double priorDivTime (int ci, double r, double x);
<<updateassignment population tree update>>=
double 
priorDivTime (int ci, double r, double x)
{
  double v;
  double loglambda;
  double logr;
  double logmu;
  double s;
  int ti;

  logr = log(r);
  loglambda = log(r/(1.0 - x));
  logmu = log(x) + loglambda;

  LogDiff(v, loglambda, logmu - r * C[ci]->tvals[npops-2]);
  /* npops! is ignored because we do not change number of populations. */
  s = (npops - 1.0) * loglambda + logr - r * C[ci]->tvals[npops-2] - v;
  for (ti = 0; ti < npops - 1; ti++)
    {
      LogDiff(v, loglambda, logmu - r * C[ci]->tvals[ti]);
      s += (2.0 * logr - r * C[ci]->tvals[ti] - v);
    }
  return s;
}

/*
 * Yang and Rannala (1997) Bayesian Phylogenetic Inference Using DNA Sequences:
 * A Markov Chain Monte Carlo Method. Mol. Biol. Evol. 14(7):717--724
 * The code is from treespace.c of PAML 4.4. We adapt the code to IMa2.
 */
int GetIofLHistory (int ci)
{
    /* Get the index of the labelled history (rooted tree with nodes ordered
     according to time).  
     Numbering of nodes: node # increases as the node gets older:
     node d corresponds to time 2*ns-2-d; tree.root=ns*2-2;
     t0=1 > t1 > t2 > ... > t[ns-2]
     */
    struct popedge * ptree;
    int index, i, j, k[MAXPOPS+1], inode, nnode, nodea[MAXPOPS * 2 - 1], s[2];
    int ancestor;
    int daughter;
    
    assert (npops < MAXPOPS); /* We cannot handle big integers. */
    ptree = C[ci]->poptree;

    /* Ordered index of all internal nodes. */
    /* FOR (i,npops) */
    for (i = 0; i < npops; i++)
    {
        nodea[i] = i;
    }

    for (i = 1; i < npops; i++)
    {
        nodea[C[ci]->addpop[i]] = i + npops;
    }

    /* Internal nodes should be ordered in time. */
    for (i = 1, inode = npops, nnode = npops; 
         inode < npops * 2 - 1; 
         i++, inode++, nnode--) 
    {
        ancestor = C[ci]->addpop[i];
        for (j = 0; j < 2; j++)
        {
            daughter = ptree[ancestor].up[j];
            s[j] = nodea[daughter];
        }
        k[nnode] = IMAX(s[0],s[1]); 
        s[0] = IMIN(s[0],s[1]); 
        s[1] = k[nnode];
        k[nnode] = s[1]*(s[1]-1)/2 + s[0];
    }
    index = 0;
    for (nnode=2; nnode <= npops; nnode++)
    {
        index = nnode*(nnode-1)/2*index + k[nnode];
    }
    return (index);
}


/*
 * Yang and Rannala (1997) Bayesian Phylogenetic Inference Using DNA Sequences:
 * A Markov Chain Monte Carlo Method. Mol. Biol. Evol. 14(7):717--724
 * The code is from treespace.c of PAML 4.4. We adapt the code to IMa2.
 */
int GetLHistoryI (int ci, int iLH)
{
    /* Get the ILH_th labelled history.  This function is rather similar to 
     GetTreeI which returns the I_th rooted or unrooted tree topology.
     The labeled history is recorded in the numbering of nodes: 
     node # increases as the node gets older: 
     node d corresponds to time 2*ns-2-d; tree.root=ns*2-2;
     t0=1 > t1 > t2 > ... > t[ns-2]
     k ranges from 0 to i(i-1)/2 and indexes the pair (s1 & s2, with s1<s2),
     out of i lineages, that coalesce.
     */
    int i,k, inode, nodea[MAXPOPS], s1, s2, it;
    struct popedge * ptree;
    int daughter0;
    int daughter1;
    double t;
    int rootnode;
    
    assert (npops < 10);
    assert (C[ci]->poptree == NULL);
    
    C[ci]->rootpop = npops * 2 - 2;
    C[ci]->poptree = malloc ((npops * 2 + 1) * sizeof (struct popedge));
    ptree = C[ci]->poptree;
    for (i = 0; i < npops * 2 - 1; i++)  {
        ptree->numup = 2;
        ptree->up = malloc (2 * sizeof (int));
        ptree->b = 0;
        ptree->up[0] = -1;
        ptree->up[1] = -1;
        ptree++;
    }
 
    t = 0.0;
    for (i = 0; i < npops; i++) nodea[i]=i;
    ptree = C[ci]->poptree;
    it = iLH;
    for (i = npops, inode = npops; i >= 2; i--, inode++)  
    {
        k = it%(i*(i-1)/2);  
        it /= (i*(i-1)/2); 
        s2 = (int)(sqrt(1.+8*k)-1)/2+1;  
        s1 = k-s2*(s2-1)/2; /* s1<s2, k=s2*(s2-1)/2+s1 */
        assert (s1 < s2);
        if (s1 >= s2)
        {
          IM_errloc (AT, "Tree Generation Error using index %d", iLH);
        }
        t += expo (1.0);
        daughter0 = nodea[s1];
        daughter1 = nodea[s2];
        ptree[daughter0].down = inode;
        ptree[daughter0].e = inode - npops + 1;
        ptree[daughter0].time = t; /* e.g., See Gernhard (2009) */
        ptree[daughter1].down = inode;
        ptree[daughter1].e = inode - npops + 1;
        ptree[daughter1].time = t; /* e.g., See Gernhard (2009) */
        ptree[inode].up[0] = daughter0;
        ptree[inode].up[1] = daughter1;
        ptree[inode].b = inode - npops + 1;
        nodea[s1] = inode;
        nodea[s2] = nodea[i-1]; 
    }
    rootnode = inode - 1;
    ptree[rootnode].down = -1;
    ptree[rootnode].e = -1;
    ptree[rootnode].time = TIMEMAX;
    assert (C[ci]->rootpop == inode - 1); 
    return (0);

    /* Set the following members of the chain.
     * periodset <- fillplist
     * addpop
     * droppops
     * plist
     * newickstring <- (not yet)
     * poptreestring <- (not yet)
     * popndown <- Phylogeny_setPopndown
     * popnmig <- Phylogeny_setPopnmig (not used)
     **/
    fillplist (ci);
    assert (C[ci]->popndown == NULL);
    Phylogeny_setPopndown (&C[ci]->popndown, C[ci]);
    //assert (C[ci]->popnmig == NULL);
    //Phylogeny_setPopnmig (&C[ci]->popnmig, C[ci]);

    return 0;
}



<<updateassignment function header>>=
int updateassignmentptree (int ci);
<<updateassignment population tree update>>=
int
updateassignmentptree (int ci)
{
  int rperiod; 
  int accp;
  double lweight;
  double logU;
  double mweight;
  double hweight;
  struct genealogy *G;
  int li;
  int popx;
  int popa;
  int popb;
  int popc;
  int popal;
  int popbl;
  int popcl;
  int popau;
  int popbu;
  int popcu;
  int iTypeMove;

  assert (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0);

  /* Count up the number of tries of MCMC cycles. */
  if (ci == 0)
    {
      L[0].t_rec->upinf[IM_UPDATE_TREE_TPT_TYPE1].tries++;
    }

  G = NULL;
  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }

  iTypeMove = Phylogeny_choose_a_period (ci, &rperiod);
  switch (iTypeMove)
    {
      case 0:
        /* We do not need this? rperiod = tptChooseCoalescentPeriod (ci); */
        return 0;
        break;
      case 1:
        popc = Phylogeny_tptChooseAnIngroup (ci, rperiod, &popx, &popa);
        popb = Phylogeny_sister (ci, popc);
        break;
      case 2:
        Phylogeny_tptChooseAllPopulations (ci, rperiod, 
                                           &popal, &popbl, &popcl,
                                           &popau, &popbu, &popcu);
        break;
      default:
        assert (0);
    }

  /* Save the current state of a chain */
  for (li = 0; li < nloci; li++)
    {
      imaSavedReset (li);
      imaSavedSaveLocusInfo (ci, li);
      copy_treeinfo (&saT[li].savedgweight, &C[ci]->G[li].gweight);
    }
  copy_treeinfo (&saC.savedallgweight, &C[ci]->allgweight);
  /* We do not call copy_probcalc_all because we do not change likelihood. */
  copy_probcalc (&saC.savedallpcalc, &C[ci]->allpcalc);

  /* Propose a new state of genealogy and assignment. */
  switch (iTypeMove)
    {
      case 1:
        /* FIXME: we have not computed hweight correctly? LOG2's have not been
         * subtracted yet. */
        hweight = treemoveI (ci, rperiod, 
                             popx, popa, popb, popc);
        break;
      case 2:
        hweight = treemoveII (ci, rperiod, 
                              popal, popbl, popcl, 
                              popau, popbu, popcu);
        break; 
      default:
        assert (0);
        break;
    }

  /* Compute Metropolis-ratio. */
  setzero_genealogy_weights (&C[ci]->allgweight);
  for (li = 0; li < nloci; li++)
    {
      setzero_genealogy_weights (&C[ci]->G[li].gweight);
      treeweight (ci, li);
      sum_treeinfo (&C[ci]->allgweight, &C[ci]->G[li].gweight);
    }
  initialize_integrate_tree_prob (ci, &C[ci]->allgweight, &C[ci]->allpcalc);

  logU = log (uniform ());
  mweight = C[ci]->allpcalc.probg - saC.savedallpcalc.probg;
  lweight = beta[ci] * mweight + hweight;
  assert (beta[ci] * mweight + hweight > -1e200
          && beta[ci] * mweight + hweight < 1e200);

 
  accp = 0;

  if (lweight > 0.0 || lweight > logU)
    {
      /* accept the update */
      accp = 1;
      if (ci == 0)
        {
          L[0].t_rec->upinf[IM_UPDATE_TREE_TPT_TYPE1].accp++;
        }

#if 0
      /* Always revert to an original. */
      for (li = 0; li < nloci; li++)
        {
          if (L[li].model == HKY)
            {
              copyfraclike (ci, li);
              storescalefactors (ci, li);
            }
        }
#endif
    }
  else
    {
      /* Revert it to the original state state of genealogy and assignment. */
      switch (iTypeMove)
        {
          case 1:
            hweight = treemoveI (ci, rperiod, 
                                 popx, popb, popa, popc);
            break;
          case 2:
            hweight = treemoveII (ci, rperiod, 
                                  popau, popbu, popcu,
                                  popal, popbl, popcl); 
            break; 
          default:
            break;
        }
      for (li = 0; li < nloci; li++)
        {
          /* restore edges changed during update */
          imaSavedRestore (ci, li); 
          imaSavedRestoreLocusInfo (ci, li);
          copy_treeinfo (&C[ci]->G[li].gweight, &saT[li].savedgweight);
        }
      copy_treeinfo (&C[ci]->allgweight, &saC.savedallgweight);
      copy_probcalc (&C[ci]->allpcalc, &saC.savedallpcalc);
    }

#if 0
  for (li = 0; li < nloci; li++)
    {
      if (L[li].model == HKY)
        {
          restorescalefactors (ci, li);
        }
    }
#endif

  if (assignmentoptions[POPULATIONASSIGNMENTCHECKPOINT] == 1)
    {
      assertgenealogy (ci);
    }
  return accp;
}

<<updateassignment extern>>=
extern char popnames[][NAMELENGTH];
<<updateassignment function header>>=
void recordptree_header (char *fname, int ci);
void recordptree (char *fname, int ci);
void recordptree_footer (char *fname, int ci);

<<updateassignment population tree update>>=
void
recordptree_header (char *fname, int ci)
{
  int pi;
  int lenname;
  char *treefilename;
  FILE *treefile = NULL;
  int idummy;

  idummy = ci;

  /* we find individuals for each locus. */
  lenname = 30 + strlen (fname);
  treefilename = malloc (lenname * sizeof (char));

  strcpy (treefilename, fname);
  strcat (treefilename, ".nex.t");
  treefile = fopen (treefilename, "w");

  if (treefile == NULL)
    {
      IM_err (IMERR_CREATEFILEFAIL, 
              "Tree output file cannot be created: %s", 
              treefilename);
    }

  fprintf (treefile, "#NEXUS\n");
  fprintf (treefile, "[ID: 777]\n");
  fprintf (treefile, "begin trees;\n");
  fprintf (treefile, "   translate\n");
  for (pi = 0; pi < npops; pi++)
    {
      fprintf (treefile, "      %3d %s", pi + 1, popnames[pi]);
      if (pi == npops - 1)
        {
          fprintf (treefile, ";\n");
        }
      else
        {
          fprintf (treefile, ",\n");
        }
    }
 
  fclose (treefile);
  treefile = NULL;
  free (treefilename);
  treefilename = NULL;

  return;
}

void 
recordptree (char *fname, int ci)
{
  static int gen = 0;
#ifdef DEBUG
  int i;
#endif /* DEBUG */

  int lenname;
  char *treefilename;
  FILE *treefile = NULL;

  /* we find individuals for each locus. */
  lenname = 30 + strlen (fname);
  treefilename = malloc (lenname * sizeof (char));

  strcpy (treefilename, fname);
  strcat (treefilename, ".nex.t");
  treefile = fopen (treefilename, "a");

  if (treefile == NULL)
    {
      IM_err (IMERR_CREATEFILEFAIL, 
              "Tree output file cannot be created: %s", 
              treefilename);
    }

  /* Note that newickstring and popntreestring are in different format. */
  /* Check it out in build_poptree.c. */
  fprintf (treefile, "   tree rep.%d = %s\n", step, C[ci]->newickstring);

  fclose (treefile);
  treefile = NULL;
  free (treefilename);
  treefilename = NULL;

  gen++;
  return;
}

void
recordptree_footer (char *fname, int ci)
{
  int idummy;
  int lenname;
  char *treefilename;
  FILE *treefile = NULL;

  idummy = ci;

  /* we find individuals for each locus. */
  lenname = 30 + strlen (fname);
  treefilename = malloc (lenname * sizeof (char));

  strcpy (treefilename, fname);
  strcat (treefilename, ".nex.t");
  treefile = fopen (treefilename, "a");

  if (treefile == NULL)
    {
      IM_err (IMERR_CREATEFILEFAIL, 
              "Tree output file cannot be created: %s", 
              treefilename);
    }

  fprintf (treefile, "end;\n");

  fclose (treefile);
  treefile = NULL;
  free (treefilename);
  treefilename = NULL;

  return;
}


@
[[treemove]] is a multiple populatin version of [[tptmove]].

We could change [[mp]] of all migration events within the period.  We check each
lineage which type of population branch it belongs to: A, B, D, or X.  If it
belongs to A, B, D or non-X branch, then we find all of the migration events and
replace C with A, B with C.  If it belongs to X branch, we replace B with A.
We recycle C.  We only change the population tree and save its Newick formatted
tree.
<<updateassignment static>>=
static double treemoveI (int ci, int rperiod, int popx, int popa, int popb, int popc);
<<updateassignment population tree update>>=
double
treemoveI (int ci, int rperiod, int popx, int popa, int popb, int popc)
{
  double lhweight;
  lhweight = 0.0;
  int v;
  int li;
  int ei;
  double t;     /* up time of an gtree edge. */
  double tdown; /* down time of the gtree edge. */

  int mi;
  struct edge *gtree;
  double mt;
  int mp;
  double upt;
  double dnt;
  int pi;
  SET set1;
  int j;
  int k;
  struct popedge * ptree;
  int pope;

  static int statici = 0;
  statici++;

  
  upt = C[ci]->tvals[rperiod - 1];
  dnt = C[ci]->tvals[rperiod]; 

  /********************************************************************/
  /* We change struct Chain and saC.                                  */
  /* static im_popntree saC;                                          */
  /********************************************************************/
  /* Change periodset: Check function fillplist. */
  set1 = C[ci]->periodset[rperiod];
  set1 = SETREMOVE (set1, popb);
  set1 = SETADD (set1, popa);
  C[ci]->periodset[rperiod] = set1;

  /* No change to addpop. */
  /* Change droppops. */
  C[ci]->droppops[rperiod][0] = popx;
  C[ci]->droppops[rperiod][1] = popb;
  C[ci]->droppops[rperiod + 1][0] = popa;
  C[ci]->droppops[rperiod + 1][1] = popc;

  /* Change plist. */
  j = 0; 
  FORALL (k, C[ci]->periodset[rperiod])
    {
      assert (j < npops - rperiod);
      C[ci]->plist[rperiod][j] = k;
      j++;
    }

  /* Change poptree. */
  ptree = C[ci]->poptree;
  pope = ptree[popc].down;
  ptree[popa].down = pope;
  ptree[popa].e = rperiod + 1;
  ptree[popa].time = dnt;
  ptree[popb].down = popc;
  ptree[popb].e = rperiod;
  ptree[popb].time = upt;
  assert (ptree[popc].up[0] == popa || ptree[popc].up[1] == popa); 
  ptree[popc].up[0] = popx;
  ptree[popc].up[1] = popb;
  ptree[pope].up[0] = popa;
  ptree[pope].up[1] = popc;

  /* Change char poptreestring[POPTREESTRINGLENGTHMAX]; ??? */
  /* poptreewrite (ci, C[ci]->poptreestring); */
  C[ci]->newickstring[0] = '\0';
  makenewicktreestring (ci, -1, &C[ci]->newickstring, &C[ci]->nnewickstring);

  /* No change to rootpop */
  /* No change to tvals */

  /* popndown and popnmig were a part of assignment project. We place the same
   * thing under struct Chain. */
  //C[ci]->popndown[popa][rperiod] = popa;
  //C[ci]->popndown[popb][rperiod] = popc;
  Phylogeny_resetPopndown (C[ci]->popndown, C[ci]);

  /* Search this document for "popnmig tree model" as a reference. I am not sure
   * whether we need this one.  Until then, we turn it off.  
   * In "popmig tree model" we use plist to create and set popnmig.  The memory
   * of the variable changes, and therefore make sure free and malloc.
   * int ***popnmig; --- per period, per popn, list of popn's ---
   */
  /* assert (C[ci]->popnmig == NULL); */

  /********************************************************************/
  /* End of Tree update                                               */
  /********************************************************************/

  v = 0;
  for (li = 0; li < nloci; li++)
    {
      gtree = C[ci]->G[li].gtree;
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          tdown = gtree[ei].time;

          if (tdown < upt || dnt < t)
            {
              continue;
            }

          imaSavedSaveBranch (ci, li, ei);

          if (t < upt && upt < tdown)
            {
              mi = Genealogy_skipMig (ci, li, ei, upt);
              pi = Migration_above_startpopn (ci, li, ei, mi, rperiod);
              /* pi = Migration_popnAtTime (ci, li, ei, upt); */
            }
          else
            {
              mi = 0;
            }

          mt = gtree[ei].mig[mi].mt;
          if (pi == popx)
            {
              while (mt > -0.5 && mt < dnt)
                {
                  /* Swap popa and popb. */
                  mp = gtree[ei].mig[mi].mp;
                  if (mp == popa)
                    {
                      gtree[ei].mig[mi].mp = popb;
                    }
                  else if (mp == popb)
                    {
                      gtree[ei].mig[mi].mp = popa;
                    }
                  else
                    {
                      /* No code */
                    }
                  mi++;
                  mt = gtree[ei].mig[mi].mt;
                }
            }
          else
            {
              while (mt > -0.5 && mt < dnt)
                {
                  /* Replace popc with popa, popb with popc. */
                  mp = gtree[ei].mig[mi].mp;
                  if (mp == popc)
                    {
                      gtree[ei].mig[mi].mp = popa;
                    }
                  else if (mp == popb)
                    {
                      gtree[ei].mig[mi].mp = popc;
                    }
                  else 
                    {
                      /* No code */
                    }
                  mi++;
                  mt = gtree[ei].mig[mi].mt;
                }
            }
        }
    }

  return lhweight; /* Everything is deterministic. */
}

<<updateassignment static DELETE>>=
static int Migration_popnAtTime (int ci, int li, int ei, double t);
<<updateassignment population tree update DELETE>>=
int 
Migration_popnAtTime (int ci, int li, int ei, double t)
{
  int mi;
  int pi;

  mi = Genealogy_skipMig (ci, li, ei, t);
  pi = Migration_startpopn (ci, li, ei, mi);
  return pi;
}

@
We do not allow any migration between popal and popbl.  
We do not even allow any indirect connection between popal and popbl (We may
have to allow this one). 

We change population labels of all lineages within the chosen period.  We
replace [[popal]] and [[popbl]] with [[popcl]] because the two populations merge
within the chosen period.  We will change the label of [[popcu]] to one of
[[popau]] or [[popbu]].  

The first part of the code is the same as [[treemoveI]].
<<updateassignment static>>=
static double treemoveII (int ci, int rperiod, 
                          int popal, int popbl, int popcl,
                          int popau, int popbu, int popcu);
<<updateassignment population tree update>>=
double 
treemoveII (int ci, int rperiod, 
            int popal, int popbl, int popcl,
            int popau, int popbu, int popcu)
{
  double lhweight;
  int v;
  int li;
  int ei;
  double t;     /* up time of an gtree edge. */
  double tdown; /* down time of the gtree edge. */

  int mi;
  struct edge * gtree;
  double mt;
  int mp;
  double upt;
  double dnt;
  SET set1;
  int j;
  int k;
  struct popedge * ptree;

  upt = C[ci]->tvals[rperiod - 1];
  dnt = C[ci]->tvals[rperiod]; 

  /********************************************************************/
  /* We change struct Chain and saC.                                  */
  /* static im_popntree saC;                                          */
  /********************************************************************/
  /* Change periodset: Check function fillplist. */

  set1 = C[ci]->periodset[rperiod];
  set1 = SETREMOVE (set1, popal);
  set1 = SETREMOVE (set1, popbl);
  set1 = SETREMOVE (set1, popcu);
  set1 = SETADD (set1, popau);
  set1 = SETADD (set1, popbu);
  set1 = SETADD (set1, popcl);
  C[ci]->periodset[rperiod] = set1;

  /* Change droppops and addpop. */
  C[ci]->droppops[rperiod][0] = popal;
  C[ci]->droppops[rperiod][1] = popbl;
  C[ci]->addpop[rperiod] = popcl;
  C[ci]->droppops[rperiod + 1][0] = popau;
  C[ci]->droppops[rperiod + 1][1] = popbu;
  C[ci]->addpop[rperiod + 1] = popcu;

  /* Change plist. */
  j = 0; 
  FORALL (k, C[ci]->periodset[rperiod])
    {
      C[ci]->plist[rperiod][j] = k;
      j++;
    }

  /* Change poptree. */
  ptree = C[ci]->poptree;
  ptree[popal].e = rperiod;
  ptree[popal].time = upt;
  ptree[popbl].e = rperiod;
  ptree[popbl].time = upt;
  ptree[popcl].b = rperiod;

  ptree[popau].e = rperiod + 1;
  ptree[popau].time = dnt;
  ptree[popbu].e = rperiod + 1;
  ptree[popbu].time = dnt;
  ptree[popcu].b = rperiod + 1;

  /* Change char poptreestring[POPTREESTRINGLENGTHMAX]; ??? */
  /* poptreewrite (ci, C[ci]->poptreestring); */
  C[ci]->newickstring[0] = '\0';
  makenewicktreestring (ci, -1, &C[ci]->newickstring, &C[ci]->nnewickstring);

  /* No change to rootpop */
  /* No change to tvals */

  /* popndown and popnmig were a part of assignment project. We place the same
   * thing under struct Chain. */
  //C[ci]->popndown[popal][rperiod] = popcl;
  //C[ci]->popndown[popbl][rperiod] = popcl;
  //C[ci]->popndown[popcl][rperiod] = popcl;
  //C[ci]->popndown[popau][rperiod] = popau;
  //C[ci]->popndown[popbu][rperiod] = popbu;
  //C[ci]->popndown[popcu][rperiod] = -1;
  Phylogeny_resetPopndown (C[ci]->popndown, C[ci]);

  /* Search this document for "popnmig tree model" as a reference. I am not sure
   * whether we need this one.  Until then, we turn it off.  
   * In "popmig tree model" we use plist to create and set popnmig.  The memory
   * of the variable changes, and therefore make sure free and malloc.
   * int ***popnmig; --- per period, per popn, list of popn's ---
   */
  //assert (C[ci]->popnmig == NULL);

  /********************************************************************/
  /* End of Tree update                                               */
  /********************************************************************/


  v = 0;
  lhweight = 0.0;
  for (li = 0; li < nloci; li++)
    {    
      gtree = C[ci]->G[li].gtree;
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          tdown = gtree[ei].time;

          if (tdown < upt || dnt < t)
            {
              continue;
            }

          imaSavedSaveBranch (ci, li, ei);

          if (t < upt && upt < tdown)
            {
              mi = Genealogy_skipMig (ci, li, ei, upt);
              /* mp = Migration_startpopn (ci, li, ei, mi); */
              /* pi = Migration_popnAtTime (ci, li, ei, upt); */
            }
          else
            {
              mi = 0;
            }
          
          mt = gtree[ei].mig[mi].mt;

          while (mt > -0.5 && mt < dnt)
            {
              /* Merge popal and popbl to popcl. */
              /* Divide popcu to popau and popbu. */
              mp = gtree[ei].mig[mi].mp;
              if (mp == popal || mp == popbl)
                {
                  gtree[ei].mig[mi].mp = popcl;
                  lhweight -= LOG2;
                }
              else if (mp == popcu)
                {
                  if (bitran () /*uniform() < 0.5 */ )
                    {
                      gtree[ei].mig[mi].mp = popau;
                    }
                  else
                    {
                      gtree[ei].mig[mi].mp = popbu;
                    }
                  lhweight += LOG2;
                }
              else
                {
                  /* No code. */
                }
              mi++;
              mt = gtree[ei].mig[mi].mt;
            }
        }
    }

  return lhweight; /* Everything is deterministic. */
}


@
[[Phylogeny_imaGtreeSwap]] is a multiple-population version of [[imaGtreeSwap]]. 
In the function [[imaGtreeSwap]] we instead keep labels of population
trees unchanged, and we change labels of genealogies.
In the phylogeny version, we will change labels of population trees. 

There are a few situations to consider.
\begin{Verbatim}[frame=lines,framesep=5mm]
 0     1    2
 |     |    |
 +--3--+    | <- upt
    |       |
    +---4---+ <- dnt
        |
        |
        R

to 

 0     2    1 
 |     |    |
 +--3--+    | <- upt
    |       |
    +---4---+ <- dnt
        |
        |
        R



 0     1   2     3
 |     |   |     |
 +--4--+   |     |
    |      |     |
    |      +--5--+
    |         |
    +----6----+
         |
         |
         R
\end{Verbatim}

A branch begins at the top of a period, and it ends in the bottom of the
period.  Along the branch and its sister branch segment during the period exist
no coalescent events.  Then, we use the three-point-turn update.  Using function 
[[tptChooseCoalescentPeriod]] we draw such a period at random. We return the
chosen period that must be neither the first nor the last one. A negative value
(i.e., -1) is returned otherwise.

Function [[Phylogeny_isCoalescent]] returns 1 if there are coalescent events
between [[upt]] and [[dnt]] along two branches, 0 otherwise.

Function [[Phylogeny_isCoalescent2]] returns 1 if there are coalescent events
between [[upt]] and [[dnt]] along three branches, 0 otherwise.

Function [[Phylogeny_isMigration]] returns 1 if there are migration events
between two branches, 0 otherwise.

We copied the code tptChooseCoalescentPeriod (int ci) we need to
find a period and decide the type of tree update. It returns 1 or 2 for the type
of updating a tree. We return 0 if there is no available branch to update.

<<updateassignment static>>=
static int Phylogeny_choose_a_period (int ci, int * rperiod);
static int Phylogeny_isCoalescent (int ci, double upt, double dnt, int b1, int b2);
static int Phylogeny_isCoalescent2 (int ci, double upt, double dnt, 
                                    int b1, int b2, int b3);
static int Phylogeny_isMigration (int ci, double upt, double dnt, int b1, int b2);
<<updateassignment population tree update>>=
int 
Phylogeny_choose_a_period (int ci, int * rperiodv)
{
  /* It returns the type of tree update using Three-point-turn updating method. */
  int v;
  double upt;
  double dnt;
  int pi;
  int a1;
  int b1;
  int b2;
  int type;
  int i;
 
  assert (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0);

  *rperiodv = -1;
  type = 0;
  for (i = 0; i < npops; i++)
    {
      pi = randposint (npops);
      if (pi == 0 || pi == npops - 1)
        {
          continue;
        }
      upt = C[ci]->tvals[pi - 1];
      dnt = C[ci]->tvals[pi];
      if (C[ci]->addpop[pi] == C[ci]->droppops[pi + 1][0]
          || C[ci]->addpop[pi] == C[ci]->droppops[pi + 1][1])
        {
          b1 = C[ci]->droppops[pi + 1][0];
          b2 = C[ci]->droppops[pi + 1][1];
          v = Phylogeny_isCoalescent (ci, upt, dnt, b1, b2);
          if (v == 0)
            {
              type = 1;
              *rperiodv = pi;
              break;
            }
        }
      else 
        {
          a1 = C[ci]->addpop[pi]; 
          b1 = C[ci]->droppops[pi + 1][0];
          b2 = C[ci]->droppops[pi + 1][1];
          v = Phylogeny_isMigration (ci, upt, dnt, b1, b2);
          if (v > 0)
            {
              continue;
            }
          v += Phylogeny_isCoalescent2 (ci, upt, dnt, a1, b1, b2);
          if (v == 0)
            {
              type = 2;
              *rperiodv = pi;
              break;
            }
        }
    }

  if (type == 0)
    {
      assert (*rperiodv == -1);
    }
  else if (type == 1 || type == 2)
    {
      assert (0 < *rperiodv && *rperiodv < npops - 1);
    }
  else
    {
      assert (0);
    }
  return type;

}
@

<<updateassignment static>>=
static int tptChooseCoalescentPeriod (int ci);
<<updateassignment population tree update DELETE>>=
int 
tptChooseCoalescentPeriod (int ci)
{
  int v;
  double upt;
  double dnt;
  int rperiod;
  int pi;
  struct popedge *poptree;
  int b1;
  int b2;
  int i;
 
  assert (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0);

  v = 1;
  for (i = 0; i < 2 * npops - 1; i++)
    {
      pi = randposint (2 * npops - 1);
      poptree = &C[ci]->poptree[pi]; /* FIXME: is the precedence okay? */
      if (poptree->e - poptree->b > 1 || poptree->e < 2)
        {
          continue;
        }
      /* A branch begins at the top of a period, and it ends in the bottom of
       * the period. */
      assert (poptree->e - poptree->b == 1);
      rperiod = poptree->b;
      if (rperiod == 0)
        {
          upt = 0.0;
        }
      else
        {
          upt = C[ci]->tvals[rperiod - 1];
        }
      dnt = C[ci]->tvals[rperiod]; 
      /* FALSE: or no coalescent events between upt and dnt. */ 
      b1 = C[ci]->droppops[rperiod + 1][0];
      b2 = C[ci]->droppops[rperiod + 1][1];
      v = Phylogeny_isCoalescent (ci, upt, dnt, b1, b2);
      if (v == 0)
        {
          break;
        }
    }
  if (v == 1)
    {
      rperiod = -1;
    }
  else
    {
      assert (v == 0);
      assert (0 < rperiod && rperiod < npops - 1);
    }
  return rperiod;
}

<<updateassignment population tree update>>=
int 
Phylogeny_isMigration (int ci, double upt, double dnt, int b1, int b2)
{
  int v;
  int li;
  int ei;
  double t;     /* up time of an gtree edge. */
  double tdown; /* down time of the gtree edge. */

  int mi;
  struct edge *gtree;
  double mt;
  int mp;
  int mp0;

  v = 0;
  for (li = 0; li < nloci; li++)
    {
      gtree = C[ci]->G[li].gtree;
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          tdown = gtree[ei].time;

          if (!(tdown < upt) && !(dnt < t))
            {
              if (upt < t && t < dnt) /* Type II and IV */
                {
                  mi = 0;
                }
              else /* Type I and III */
                {
                  assert (t < upt);
                  mi = Genealogy_skipMig (ci, li, ei, upt);
                }
              mt = gtree[ei].mig[mi].mt;

              /* Check migration events between [[upt]] and [[dnt]]. */
              /* For Type II and IV, the second condition can be deleted. */
              while (mt > -0.5 && mt < dnt) 
                {
                  /* Find the starting population. */
                  mp0 = Migration_startpopn (ci, li, ei, mi);

                  /* Find the ending population. */
                  mp = gtree[ei].mig[mi].mp;    

                  /* Check if the migration event is between b1 and b2. */
                  if ((mp0 == b1 && mp == b2) || (mp0 == b2 && mp == b1))
                    {
                      v = 1;
                      return v;
                      ei = L[li].numlines;
                      li = nloci;
                      break;
                    }
                  mi++;
                  mt = gtree[ei].mig[mi].mt;    
                }
            }
        }
    }

  return v;
}

@
If there are migration events before [[t]] (starting from the top of the edge),
we skip those events and return the index of next migration event.  If there is
If there are no such events, we return 0.  We also return 0 if just there are 
no migation event.
<<updateassignment static>>=
static int Genealogy_skipMig (int ci, int li, int ei, double t);
<<updateassignment population tree update>>=
int 
Genealogy_skipMig (int ci, int li, int ei, double t)
{
  int mi;
  struct edge *gtree;
  double mt;

  gtree = C[ci]->G[li].gtree;
  mi = 0;
  /* Skip all migration events before [[t]]. */
  mt = gtree[ei].mig[mi].mt;    
  while (mt > -0.5 && mt < t)
    {
      mi++;
      mt = gtree[ei].mig[mi].mt;
    }
  return mi;
}

@
We find the starting population of the migration [[mi]].
  /* Find the starting population. */
<<updateassignment static>>=
static int Migration_above_startpopn (int ci, int li, int ei, int mi, int ki);
static int Migration_startpopn (int ci, int li, int ei, int mi);
<<updateassignment population tree update>>=
int 
Migration_above_startpopn (int ci, int li, int ei, int mi, int ki)
{
  int mp;
  struct edge *gtree;

  assert (!(mi < 0)); 
  gtree = C[ci]->G[li].gtree;
  if (mi == 0)
    {
      mp = gtree[ei].pop;
    }
  else
    {
      mp = gtree[ei].mig[mi-1].mp;
    }
  mp = C[ci]->popndown[mp][ki-1];

  return mp;
}
 
int 
Migration_startpopn (int ci, int li, int ei, int mi)
{
  int mp0;
  double mt;
  int ki;
  struct edge *gtree;

  assert (!(mi < 0)); 
  gtree = C[ci]->G[li].gtree;
  if (mi == 0)
    {
      mp0 = gtree[ei].pop;
    }
  else
    {
      mp0 = gtree[ei].mig[mi-1].mp;
    }
  mt = gtree[ei].mig[mi].mt;
  ki = findperiodoftime (ci, mt);
  mp0 = C[ci]->popndown[mp0][ki];

  return mp0;
}
 
<<updateassignment population tree update>>=
int 
Phylogeny_isCoalescent (int ci, double upt, double dnt, int b1, int b2)
{
  int v;
  int li;
  int ei;
  double t;
  int b;

  v = 0;
  for (li = 0; li < nloci; li++)
    {
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          b = imaGtreePop (ci, li, ei);
          if (upt < t && t < dnt && (b == b1 || b == b2))
            {
              v = 1;
              li = nloci;
              break;
            }
        }
    }
  return v;
}

int 
Phylogeny_isCoalescent2 (int ci, double upt, double dnt, int b1, int b2, int b3)
{
  int v;
  int li;
  int ei;
  double t;
  int b;

  v = 0;
  for (li = 0; li < nloci; li++)
    {
      for (ei = 0; ei < L[li].numlines; ei++)
        {
          t = imaGtreeTime (ci, li, ei);
          b = imaGtreePop (ci, li, ei);
          if (upt < t && t < dnt && (b == b1 || b == b2 || b == b3))
            {
              v = 1;
              li = nloci;
              break;
            }
        }
    }
  return v;
}




@
\subsection{Assignment summary using STRUCTURAMA}
A point estimate of assignment can be obtained by a combinatorial
search of assignment space \citep{Huelsenbeck:2007} with the definition
of a distance between two assignment \citep{Almudevar:1999,Gusfield:2002}.
\citet{Almudevar:1999} define the distance of two assignments as
the minimal number of individuals that must be removed so that the
two assignments are equal. \citet{Gusfield:2002} shows that the distance
of two assignments can be computed with a polynomial time bounded
above by $O(n^{3}),$, and so do \citet{Konovalov:2005} in a slightly
different manner. We take advantage of the implementation, STRUCTURAMA,
of the combinatorial search for a point estimate of assignment samples
developed by \citet{Huelsenbeck:2007} to summarize posterior samples
of population assignment. It uses the squared distance of an assignment
estimate from each of posterior samples of assignment, and finds one
that minimizes the average squared distance over all posterior samples
of assignment. A point estimated assignment could be a {}``mean''
of posterior samples of assignment.


The problem is how I could do assignment simulation analysis.
Average Gusfield distance of a true assignment from posteior sample of
assignment parameter. The variance of distance can be useful. All we want to
know is how accurate assignment estimates are.

When we run [[IMa2]] on Windows, we can execute [[structurama]]. 
When we run it on a local linux, we still can execute [[structurama]] through
the windows emulator, [[wine]]. When I did not know [[wine]], I implemented a
toy ``server'' that gets data from [[IMa2]] and executes [[structurama]]. 
If a linux version of [[structurama]], or a source code, was available, 
then I would not have implemented any of these. I could implement
[[structurama]]'s finding mean partition. I want to leave it as future
developement if I have any new idea for summarizing posterior samples of
assignment. I wish I could. I do not have one. Until then, I will just use
the windows version of [[structurama]].

The situation in operon cluster is a little more tricky. Jobs of [[IMa2]] are
distributed to slave nodes. Slave nodes cannot communicate with a server because
they are isolated from the Internet. They can get to the Internet only through
their master node. I had to implemented a gateway for the master node.
I hated this situation, but I had no other option. 
I am by no means a network programmer, and I want to find a mean assignment of a
posterior sample of assignment from IMa. Operon cluster manager would
not install Windows emulator, [[wine]], into slave nodes. I do not know why.
[[wine]] is just a linux program that can be installed into any linux machine. I
tried not to bother the administrator because they had been helpful. The gateway
receives a request from a job of [[IMa2]] and sends it to the server located in
Hey lab.

Some issues:
There is something wrong in windows port of Structurama server code. We have to
print out the length of buffer every time we get it. Functions
[[IMA_tcp_send]] and [[IMA_tcp_recv]] are not complete afterall.

Function [[IMA_output_structurama_bat]] creates a batch file that is read into
[[STRUCTURAMA]].

We use one machine
``desktop4'' with the IP address of [[172.17.34.102]] for hosting Structurama
server. Now we have virtually a linux version of Structurama.
We may use machine
``desktop3'' with the IP address of [[172.17.34.101]] for hosting Structurama
server. 

[[IMA_output_structurama_bat]]:  

Windows IMa + Windows Structurama local run
Mac IMa + mac Structurama local run

Linux IMa + wine (Windows) Structurama local run
Cluster IMa + Structram remote run

\subsubsection{Convert IM input to STRUCTURAMA's}
<<updateassignment function header>>=
void IMA_convert_IM2Structurama (char *structrurama);
<<updateassignment structurama>>=
void
IMA_convert_IM2Structurama (char *structurama)
{
  int ii;
  int li;
  int di;
  char *indname;
  int igenotype1;
  int igenotype2;
  FILE *inStructurama;
  inStructurama = NULL;

  inStructurama = fopen (structurama, "w");
  fprintf (inStructurama, "#NEXUS\n\n");
  fprintf (inStructurama, "[ Generated by IMamp ]\n\n");
  fprintf (inStructurama, "begin data;\n");

  fprintf (inStructurama, "\tdimensions nind=%d nloci=%d;\n", snind, nloci);
  fprintf (inStructurama, "\tinfo\n");

  for (ii = 0; ii < snind; ii++)
    {
      indname = IMA_getIndividualName (ii);
      fprintf (inStructurama, "\t%s\t", indname);
      for (li = 0; li < nloci; li++)
        {
          di = IMA_getGenotype (ii, li, &igenotype1, &igenotype2);
          switch (di)
            {
            case 0:
              fprintf (inStructurama, "( ? , ? ) ");
              break;
            case 1: 
              fprintf (inStructurama, "( %d , ? ) ", igenotype1);
              break;
            case 2: 
              fprintf (inStructurama, "( %d , %d ) ", igenotype1, igenotype2);
              break;
            default:
              assert (0);
            }
        }
      fprintf (inStructurama, ",\n");
    }
  fprintf (inStructurama, "\t;\n");
  fprintf (inStructurama, "end;\n\n");

  fclose (inStructurama);
  inStructurama = NULL;

  return;
}

<<updateassignment static>>=
static char*  IMA_getIndividualName (int i);
<<updateassignment structurama>>=
char*
IMA_getIndividualName (int iind)
{
  int ci;
  int li;
  int ei;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL; /* genealogy of locus li */

  ci = 0;
  for (li = 0; li < nloci; li++)
    {
      G = &(C[ci]->G[li]);
      gtree = G->gtree;
      for (ei = 0; ei < L[li].numgenes; ei++)
        {
          if (gtree[ei].i == iind)
            {
              return L[li].gNames[ei];
            }
        }
    }
  return NULL; 
}

<<updateassignment static>>=
static int    IMA_getGenotype (int ii, int li, int *ig1, int *ig2);
<<updateassignment structurama>>=
int 
IMA_getGenotype (int ii, int li, int *ig1, int *ig2)
{
  int v;
  int ei;
  struct genealogy *G = NULL;
  struct edge *gtree = NULL; /* genealogy of locus li */

  G = &(C[sci]->G[li]);
  gtree = G->gtree;
  *ig1 = -1;
  *ig2 = -1;
  for (ei = 0; ei < L[li].numgenes; ei++)
    {
      if (gtree[ei].i == ii)
        {
          if (L[li].model == STEPWISE)
            {
              *ig1 = gtree[ei].A[0];
              if (!(L[li].pairs[ei] < 0))
                {
                  *ig2 = gtree[L[li].pairs[ei]].A[0];
                }
            }
          else
            {
              *ig1 = 0;
              if (!(L[li].pairs[ei] < 0))
                {
                  *ig2 = 1;
                }
            }
          break;
        }
    }
  if (*ig1 == -1 && *ig2 == -1)
    {
      v = 0;
    }
  else if (*ig1 != -1 && *ig2 == -1)
    {
      v = 1;
    }
  else if (*ig1 != -1 && *ig2 != -1)
    {
      v = 2;
    }
  else
    {
      assert (0);
    }
  return v;
}


<<updateassignment function header>>=
#ifdef STRUCTURAMAREMOTERUN
void imaStructuramaRemoterun (char *fname);
<<tcp send recv header function>>
#else
void imaStructuramaLocalrun (char *fname);
#endif
void IMA_output_structurama_bat (char *fname);

@
\subsubsection{TCP/IP module}

<<tcp send recv header function>>=
void * get_in_addr (struct sockaddr *sa);
int IMA_tcp_send (int sd, char *cmd);
int IMA_tcp_recv (int sd, char *cmd);
int sendall(int s, char *buf, int *len);
int recvall(int s, char *buf, int *len);

<<tcp send recv>>=
/* get sockaddr, IPv4 or IPv6: */
void *
get_in_addr (struct sockaddr *sa)
{
  if (sa->sa_family == AF_INET)
    {
      return &(((struct sockaddr_in *) sa)->sin_addr);
    }

  return &(((struct sockaddr_in6 *) sa)->sin6_addr);
}

int
sendall (int s, char *buf, int *len)
{
  int total = 0;                // how many bytes we've sent
  int bytesleft = *len;         // how many we have left to send
  int n;

  while (total < *len)
    {
      n = send (s, buf + total, bytesleft, 0);
      if (n == -1)
        {
          break;
        }
      total += n;
      bytesleft -= n;
    }

  *len = total;                 // return number actually sent here
  return n == -1 ? -1 : 0;      // return -1 on failure, 0 on success
}

int
recvall (int s, char *buf, int *len)
{
  int total = 0;                // how many bytes we've receive
  int bytesleft = *len;         // how many we have left to receive
  int n;

  while (total < *len)
    {
      n = recv (s, buf + total, bytesleft, 0);
      if (n == -1)
        {
          break;
        }
      total += n;
      bytesleft -= n;
    }

  *len = total;                 // return number actually sent here
  return n == -1 ? -1 : 0;      // return -1 on failure, 0 on success
}

int
IMA_tcp_send (int s, char *cmd)
{
  int len;
  /* int bytes_sent; */
  int lenbuf;
  char buf[bufsize];
  FILE *fp;
  int i;

  fp = fopen (cmd, "r");
  lenbuf = bufsize;
  while (lenbuf == bufsize)
    {
      lenbuf = 0;
      for (i = 0; i < bufsize; i++)
        {
          if (feof (fp))
            {
              break;
            }
          buf[i] = fgetc (fp);
          lenbuf++;
        }
      /* Send the length of buffer to send. */
      if (lenbuf != bufsize)
        {
          lenbuf--;
        }
      if (lenbuf > 0)
        {
          /* printf ("Sending: %d\n", lenbuf); */
          len = sizeof (int);
          if (sendall (s, (char *) &lenbuf, &len) == -1)
            {
              perror ("send");
              exit (1);
            }

          if (sendall (s, buf, &lenbuf) == -1)
            {
              perror ("send");
              exit (1);
            }
        }
    }
  len = sizeof (int);
  lenbuf = 999;
  if (sendall (s, (char *) &lenbuf, &len) == -1)
    {
      perror ("send");
      exit (1);
    }

  fclose (fp);
  fp = NULL;
  printf ("Sent: %s\n", cmd);
  return 0;
}


int
IMA_tcp_recv (int s, char *cmd)
{
  int len;
  int lenbuf;
  char buf[bufsize];
  FILE *fp;
  int i;

  fp = fopen (cmd, "w");
  lenbuf = bufsize;
  while (lenbuf == bufsize)
    {
      /* Receive the length of buffer. */
      len = sizeof (int);
      if (recvall (s, (char *) &lenbuf, &len) == -1)
        {
          perror ("recv");
          exit (1);
        }
      if (lenbuf == 999)
        {
          break;
        }
      /* printf ("Received: %d\n", lenbuf); */
      if (recvall (s, buf, &lenbuf) == -1)
        {
          perror ("recv");
          exit (1);
        }
      for (i = 0; i < lenbuf; i++)
        {
          fputc (buf[i], fp);
        }
    }
  if (lenbuf < bufsize)
    {
      len = sizeof (int);
      if (recvall (s, (char *) &lenbuf, &len) == -1)
        {
          perror ("recv");
          exit (1);
        }
      assert (lenbuf == 999);
    }

  fclose (fp);
  fp = NULL;
  printf ("Received: %s\n", cmd);
  return 0;

}
@
A file is created with the following content:
\begin{Verbatim}[frame=lines,framesep=5mm]
execute 1.in
sum
quit
\end{Verbatim}
<<client structurama>>=
void 
IMA_output_structurama_bat (char *fname)
{
  FILE *fp;
  char *batname;
  char *bname;
  int lenbatname;

  fp = NULL;
  batname = NULL;
  lenbatname = strlen (fname) + 4 + 1;
  batname = malloc (lenbatname * sizeof (char));
  sprintf (batname, "%s.bat", fname);

#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
  bname = strrchr (fname, '\\');
#else
  bname = strrchr (fname, '/');
#endif
  if (bname == NULL)
    {
      bname = fname;
    }
  else
    {
      bname++;
    }
 
  fp = fopen (batname, "w");
  fprintf (fp, "execute %s.in\n", bname);
  fprintf (fp, "sum\n");
  fprintf (fp, "quit\n");
  fclose (fp);
  fp = NULL;

  free (batname);
  batname = NULL;
  return;
}
@
\subsubsection{Convert IM input to MrBayes'}
<<updateassignment function header>>=
void IMA_convert_IM2Mrbayes (char *mrbayes);
<<updateassignment mrbayes>>=
void
IMA_convert_IM2Mrbayes (char *mrbayes)
{
  int i;
  FILE *infile;

  infile = fopen (mrbayes, "w");
  
  fprintf (infile, "#NEXUS\n");
  fprintf (infile, "begin data;\n");
  fprintf (infile, "dimensions ntax=%d nchar=1;\n", npops);
  fprintf (infile, "format datatype=dna interleave=no gap=-;\n");
  fprintf (infile, "matrix\n");
  for (i = 0; i < npops; i++)
    {
      fprintf (infile, "%s A\n", popnames[i]);
    }
  fprintf (infile, ";\n");
  fprintf (infile, "end;\n");

  fclose (infile);
  infile = NULL;

  return;
}

<<updateassignment function header>>=
void IMA_output_mrbayes_bat (char *fname);
<<updateassignment mrbayes>>=
void 
IMA_output_mrbayes_bat (char *fname)
{
  FILE *fp;
  char *batname;
  char *bname;
  int lenbatname;

  fp = NULL;
  batname = NULL;
  lenbatname = strlen (fname) + 4 + 1;
  batname = malloc (lenbatname * sizeof (char));
  sprintf (batname, "%s.bat", fname);

#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
  bname = strrchr (fname, '\\');
#else
  bname = strrchr (fname, '/');
#endif
  if (bname == NULL)
    {
      bname = fname;
    }
  else
    {
      bname++;
    }
 
  fp = fopen (batname, "w");
  fprintf (fp, "execute %s.nex\n", bname);
  fprintf (fp, "sumt nruns=1\n");
  fprintf (fp, "quit\n");
  fclose (fp);
  fp = NULL;

  free (batname);
  batname = NULL;
  return;
}

@
Mac IMa + mac Structurama local run
Linux IMa + wine (Windows) Structurama local run
Windows IMa + Windows Structurama local run
Windows-Cygwin IMa + Windows Structurama local run
<<client structurama>>=
#if !defined(STRUCTURAMAREMOTERUN)
void 
imaStructuramaLocalrun (char *fname)
{
  int lencmd;
  char *cmd;
  char *bname;
  char *defaultdir;

  /* Send input files for STRUCTURAMA. */
  /* Make a system command for sending two input files for STRUCTURAMA. */
  lencmd = 2 * strlen (fname) + 100;

  /* Find the default directory based on loadfilebase.
   * /this/directory/a.out -> defaultdir is /this/directory/
   * /a.out                -> /
   * a.out                 -> ./
   * 
   * bname -> a.out
   */
#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
  bname = strrchr (fname, '\\');
#else
  bname = strrchr (fname, '/');
#endif
  if (bname == NULL)
    {
      bname = fname;
    }
  else
    {
      bname++;
    }
  imaDirBase (fname, &defaultdir); 
 
  cmd = malloc (lencmd * sizeof (char));
  /* STRUCTURAMA does not seem to handle files with relative paths. We copy
   * files to the current directory. If we run many different jobs on the same
   * directory, we have to use different base names for output files. Otherwise,
   * we overwrite other files. */

  sprintf (cmd, "%s %s.in %s.in", SYSCMDCOPY, fname, bname);
  printf ("%s\n", cmd);
  system (cmd);
  sprintf (cmd, "%s %s.in.p %s.in.p", SYSCMDCOPY, fname, bname);
  printf ("%s\n", cmd);
  system (cmd);
  sprintf (cmd, "%s %s.bat %s.bat", SYSCMDCOPY, fname, bname);
  printf ("%s\n", cmd);
  system (cmd);

  /* Run STRUCTURAMA. */
  /* Need to define DARWIN, LINUX, and 
   * STRUCTURAMA should be given when configure is call
   * For DARWIN: STRUCTURAMA is given with configure or a user must place
   * structurama_1.0 in a place where one can run with full path
   * For LINUX: STRUCTURAMA must be given and wine must be installed
   * For WIN32 or WIN64: Structurama.exe must be installed and its path must be
   * set by the user.
   */
#if defined(DARWIN)
  sprintf (cmd, "%s/structurama_1.0 < %s.bat >> log.txt", STRUCTURAMA, bname);
#elif defined(LINUX)
  sprintf (cmd, "wine %s/Structurama.exe < %s.bat >> log.txt", 
           STRUCTURAMA, bname);
#elif defined(CYGWIN)
  sprintf (cmd, "%s/Structurama.exe < %s.bat >> log.txt", STRUCTURAMA, bname);
#elif defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
  sprintf (cmd, "%s\\Structurama.exe < %s.bat >> log.txt", STRUCTURAMA, bname);
#endif 
  system (cmd);

  sprintf (cmd, 
           "%s %s.in.sum_assignments %s.in.sum_assignments", 
           SYSCMDRENAME, bname, fname);
  printf ("%s\n", cmd);
  system (cmd);
  sprintf (cmd, 
           "%s %s.in.sum_dist.nex %s.in.sum_dist.nex", 
           SYSCMDRENAME, bname, fname);
  printf ("%s\n", cmd);
  system (cmd);
  sprintf (cmd, 
           "%s %s.in.sum_pairs %s.in.sum_pairs", 
           SYSCMDRENAME, bname, fname);
  printf ("%s\n", cmd);
  system (cmd);

  sprintf (cmd, "%s %s.bat", SYSCMDDELETE, bname);
  printf ("%s\n", cmd);
  system (cmd);
  sprintf (cmd, "%s %s.in", SYSCMDDELETE, bname); 
  printf ("%s\n", cmd);
  system (cmd);
  sprintf (cmd, "%s %s.in.p", SYSCMDDELETE, bname); 
  printf ("%s\n", cmd);
  system (cmd);

  free (cmd);
  cmd = NULL;
  free (defaultdir);
  defaultdir = NULL;
  return;
}
#endif /* STRUCTURAMAREMOTERUN */

/*********************************************************************/
/*                      TCP/IP not for Windows                       */
/*********************************************************************/
/* #ifndef _MSC_VER _WIN32 or _WIN64 */

#ifdef STRUCTURAMAREMOTERUN
<<server include>>
#define PORT "3490"  /* define a port number for the service */
#define HOST "desktop4"
#define bufsize 20
<<tcp send recv>>
<<structurama remote run>>
#undef PORT
#undef HOST 
#undef bufsize
#endif /* STRUCTURAMAREMOTERUN */

@
Local run... windows version ... mac version ... wine version?
<<structurama remote run>>=
void 
imaStructuramaRemoterun (char *fname)
{
  int lencmd;
  char *cmd;
  char *bname;
  int len;
  int lenbname;

  int sockfd;
  struct addrinfo hints, *servinfo, *p;
  int rv;
  char s[INET6_ADDRSTRLEN];

  memset (&hints, 0, sizeof hints);
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;

  /* if ((rv = getaddrinfo ("172.17.34.101", PORT, &hints, &servinfo)) != 0) for
   * Hey Lab desktop3 */
  /* if ((rv = getaddrinfo ("172.17.34.102", PORT, &hints, &servinfo)) != 0) for
   * Hey Lab desktop4 */
  /* if ((rv = getaddrinfo ("10.0.0.1", PORT, &hints, &servinfo)) != 0) for
   * operon Genetics cluster. */

#ifdef GATEWAY
  if ((rv = getaddrinfo (SERVERADDRESS, PORT, &hints, &servinfo)) != 0)
    {
      fprintf (stderr, "getaddrinfo: %s\n", gai_strerror (rv));
      return;
#else
  if ((rv = getaddrinfo (GATEWAYADDRESS, PORT, &hints, &servinfo)) != 0)
    {
      IM_errloc (AT, 
                 "The try of remote connection for structurama has failed: %s.",
                 gai_strerror (rv));
#endif /* GATEWAY */
    }

  /* Loop through all the results and connect to the first we can */
  for (p = servinfo; p != NULL; p = p->ai_next)
    {
      if ((sockfd = socket (p->ai_family, p->ai_socktype, p->ai_protocol)) == -1)
        {
          perror ("client: socket");
          continue;
        }

      if (connect (sockfd, p->ai_addr, p->ai_addrlen) == -1)
        {
          close (sockfd);
          perror ("client: connect");
          continue;
        }
      break;
    }

  if (p == NULL)
    {
#ifdef GATEWAY
      fprintf (stderr, "client: failed to connect\n");
#else
      IM_errloc (AT, "IMa client: failed to connnect");
#endif /* GATEWAY */
    }

  inet_ntop (p->ai_family, 
             get_in_addr ((struct sockaddr *) p->ai_addr),
             s, sizeof s);
#ifdef GATEWAY
  printf ("client: connecting to %s\n", s);
#else
  printf ("IMa: connecting to %s\n", s);
#endif /* GATEWAY */

  freeaddrinfo (servinfo);	/* all done with this structure */

  lencmd = 65 + strlen (fname);
  bname = strrchr (fname, '/');
  if (bname == NULL)
    {
      bname = fname;
    }
  else
    {
      bname = bname + 1;
    }
  lenbname = strlen (bname);
  len = sizeof (int);
  /* 1. Send the length of a string. */
  if (sendall (sockfd, (char *)&lenbname, &len) == -1)
    {
#ifdef GATEWAY
      perror ("send");
#else
      IM_errloc (AT, "send the length of a lenbname: %d", lenbname);
#endif /* GATEWAY */
    }
  /* 2. Send the string. */
  if (sendall (sockfd, bname, &lenbname) == -1)
    {
#ifdef GATEWAY
      perror ("send");
#else
      IM_errloc (AT, "send the file name: %s", bname);
#endif /* GATEWAY */
    }

  cmd = malloc (lencmd * sizeof (char));
  /* 3. Send the input file. */
  sprintf (cmd, "%s.in", fname);
  IMA_tcp_send (sockfd, cmd); 
  /* 4. Send the assignment samples file. */
  sprintf (cmd, "%s.in.p", fname);
  IMA_tcp_send (sockfd, cmd); 
  /* 5. Receive the three output files. */
  sprintf (cmd, "%s.in.sum_assignments", fname);
  IMA_tcp_recv (sockfd, cmd); 
  sprintf (cmd, "%s.in.sum_dist.nex", fname);
  IMA_tcp_recv (sockfd, cmd); 
  sprintf (cmd, "%s.in.sum_pairs", fname);
  IMA_tcp_recv (sockfd, cmd); 

  printf ("Finished!\n");
  free (cmd);
  cmd = NULL;
  close (sockfd);
  return;
}



@
\subsubsection{Server that runs STRUCTURAMA}
A server for STRUCTURAMA can be run under Mac or Windows with Cygwin.
<<server.c>>=
<<server include>>
<<tcp def>>
<<server header>>
<<tcp send recv header function>>
<<tcp send recv>>
<<tcp sigchld handler>>
<<server main>>

#define RUNSTRUCTURAMA
<<server do service>>
#undef RUNSTRUCTURAMA

<<server include>>=
#include "config-common.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>

<<server header>>=
void sigchld_handler (int s);
int DoService (int sd);

<<tcp def>>=
#define PORT "3490" /* the port users will be connecting to */
#define bufsize 20
#define queuesize 5
#define true 1
#define false 0
#define BACKLOG 100 /* how many pending connections queue will hold */

<<tcp sigchld handler>>=
void
sigchld_handler (int s)
{
  while (waitpid (-1, NULL, WNOHANG) > 0);
}

<<server main>>=
int
main (void)
{
  /* listen on sock_fd, new connection on new_fd */
  int sockfd, new_fd;  
  struct addrinfo hints, *servinfo, *p;
  /* connector's address information */
  struct sockaddr_storage their_addr; 
  socklen_t sin_size;
  struct sigaction sa;
  int yes = 1;
  char s[INET6_ADDRSTRLEN];
  int rv;

  memset (&hints, 0, sizeof hints);
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE;  /* use my IP */

  if ((rv = getaddrinfo (NULL, PORT, &hints, &servinfo)) != 0)
    {
      fprintf (stderr, "getaddrinfo: %s\n", gai_strerror (rv));
      return 1;
    }

  /* Loop through all the results and bind to the first we can */
  for (p = servinfo; p != NULL; p = p->ai_next)
    {
      if ((sockfd = socket (p->ai_family, p->ai_socktype,
                            p->ai_protocol)) == -1)
        {
          perror ("server: socket");
          continue;
        }

      if (setsockopt (sockfd, SOL_SOCKET, SO_REUSEADDR, &yes,
                      sizeof (int)) == -1)
        {
          perror ("setsockopt");
          exit (1);
        }

      if (bind (sockfd, p->ai_addr, p->ai_addrlen) == -1)
        {
          close (sockfd);
          perror ("server: bind");
          continue;
        }

      break;
    }

  if (p == NULL)
    {
      fprintf (stderr, "server: failed to bind\n");
      return 2;
    }

  freeaddrinfo (servinfo); /* all done with this structure */

  if (listen (sockfd, BACKLOG) == -1)
    {
      perror ("listen");
      exit (1);
    }

  sa.sa_handler = sigchld_handler; /* reap all dead processes */
  sigemptyset (&sa.sa_mask);
  sa.sa_flags = SA_RESTART;
  if (sigaction (SIGCHLD, &sa, NULL) == -1)
    {
      perror ("sigaction");
      exit (1);
    }

  printf ("server: waiting for connections...\n");

  while (1)
    {
      /* Main accept() loop */
      sin_size = sizeof their_addr;
      new_fd = accept (sockfd, (struct sockaddr *) &their_addr, &sin_size);
      if (new_fd == -1)
        {
          perror ("accept");
          continue;
        }

      inet_ntop (their_addr.ss_family,
                 get_in_addr ((struct sockaddr *) &their_addr), s, sizeof s);
      printf ("server: got connection from %s\n", s);

      if (!fork ())
        {                       /* This is the child process */
          close (sockfd);       /* Child doesn't need the listener */

          DoService (new_fd);

          close (new_fd);
          exit (0);
        }
      close (new_fd);           /* parent doesn't need this */
    }

  return 0;
}

<<server do service>>=
int
DoService (int sd)
{
#ifdef RUNSTRUCTURAMA
  FILE *fp;
#endif /* RUNSTRUCTURAMA */
  char cmd[500];
  int len;
  int lenbname;
  char *bname;

  /* 1. Receive the length of a string. */
  len = sizeof (int);
  if (recvall (sd, (char *) &lenbname, &len) == -1)
    {
      perror ("recv");
      exit (1);
    }
  /* 2. Receive the string. */
  bname = malloc ((lenbname + 1) * sizeof (char));
  /* printf ("Received: %d\n", lenbuf); */
  if (recvall (sd, bname, &lenbname) == -1)
    {
      perror ("recv");
      exit (1);
    }
  bname[lenbname] = '\0';

  /* 3. Receive structurama input. */
  sprintf (cmd, "%s.in", bname);
  IMA_tcp_recv (sd, cmd);
  /* 4. Receive assignment samples files. */
  sprintf (cmd, "%s.in.p", bname);
  IMA_tcp_recv (sd, cmd);

#ifdef RUNSTRUCTURAMA
  /* Prepare a batch file for structurama. */
  sprintf (cmd, "%s.bat", bname);
  fp = fopen (cmd, "w");
  fprintf (fp, "execute %s.in\nsum\nquit\n", bname);
  fclose (fp);
  fp = NULL;

  /* Run STRUCTURAMA. */
# if defined(DARWIN)
  sprintf (cmd, "%s/structurama_1.0 < %s.bat >> log.txt", STRUCTURAMA, bname);
#elif defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64) || defined(CYGWIN)
  sprintf (cmd, "%s/Structurama.exe < %s.bat >> log.txt", STRUCTURAMA, bname);
# endif
  system (cmd);

#else
  /* Connect to server */
  imaStructuramaRemoterun (bname);
#endif /* RUNSTRUCTURAMA */

  /* 5. Send result files back to the client. */
  sprintf (cmd, "%s.in.sum_assignments", bname);
  IMA_tcp_send (sd, cmd);
  sprintf (cmd, "%s.in.sum_dist.nex", bname);
  IMA_tcp_send (sd, cmd);
  sprintf (cmd, "%s.in.sum_pairs", bname);
  IMA_tcp_send (sd, cmd);

  /* 6. Remove all files. */
  sprintf (cmd, "%s.in", bname);
  unlink (cmd);
  sprintf (cmd, "%s.in.p", bname);
  unlink (cmd);
#ifdef RUNSTRUCTURAMA
  sprintf (cmd, "%s.bat", bname);
  unlink (cmd);
#endif /* RUNSTRUCTURAMA */
  sprintf (cmd, "%s.in.sum_assignments", bname);
  unlink (cmd);
  sprintf (cmd, "%s.in.sum_dist.nex", bname);
  unlink (cmd);
  sprintf (cmd, "%s.in.sum_pairs", bname);
  unlink (cmd);

  free (bname);
  bname = NULL;

  /* Wait for a next request. */
  return true;
}

@
\subsubsection{Gateway that pass through STRUCTURAMA - Cluster}
<<gateway.c>>=
#include "config-common.h"
<<server include>>
<<tcp def>>
<<server header>>
void imaStructuramaRemoterun (char *fname);
<<tcp send recv header function>>
<<tcp send recv>>
<<tcp sigchld handler>>
<<server main>>
#undef RUNSTRUCTURAMA
#define GATEWAY
<<server do service>>
<<structurama remote run>>

@
\subsection{Individual Assignment Uncertainty}
uncertainty [file name without .in.p] [nburnin]


Uncertainty of a single individual to a particular group is devised
using distances of assignment. The estimated assignment is used to
quantify the individual uncertainty in assignment of an individual
with respect to its ostensible assignment to a population. We quantify
how often an individual is removed when computing assignment distance
of an estimate from each assignment of posterior samples. For posterior
samples of size N we compute the N-many distances of posterior samples
from a point estimate of assignment. While computing each of N distances,
individuals may or may not be removed. The more often an individual
is removed in the course of computing assignment distance, the less
confident we can be that the individual is assigned to the population
in the estimated assignment. If there is an individual that assigned
to solely a population, then the distance between posterior sample
of assignments and the estimated assignment tends to be less attributed
to the individual. The fraction of removal of the individual would
be near 0. Conversely, an individual that is assigned with low confidence
to a population should contribute more to the distance between posterior
sample of assignments and the estimated assignment. The fraction of
removal of the high uncertainty in assignment would be near 1. We
envision degrees of uncertainty of which individuals are assigned
to its ostensible assignment to a population.

\begin{Verbatim}[frame=lines,framesep=5mm]
@<<"/home/goshng/Documents/Projects/IMamp/run/Hey/output/s2-q1_1.0-q2_1.0-qa_1.0-m1_0.0-m2_0.0-t_1.0.uct"];
x = t /. {1 -> Blue, 2 -> Red};
y = Map[{#[[1]], #[[2]]} &, x];
ArrayPlot[{MapThread[Lighter, Transpose[y]]}, Mesh->True]
Frame->False
FrameTicks -> All
FrameStyle -> Opacity[0], FrameTicksStyle -> Opacity[1]
Mesh -> All
MeshStyle -> Pink

Draw 2 rows of blue and red in grayscale
t = Table[{1, i}, {i, 0, 1, 0.1}];
x = t /. {1 -> Blue, 2 -> Red};
y = Map[{#[[1]], #[[2]]} &, x];
y1 = MapThread[Lighter, Transpose[y]];
t = Table[{2, i}, {i, 0, 1, 0.1}];
x = t /. {1 -> Blue, 2 -> Red};
y = Map[{#[[1]], #[[2]]} &, x];
y2 = MapThread[Lighter, Transpose[y]];
ArrayPlot[{y1, y2}, Mesh -> True]

\begin{tabular}{l}
bobo\tabularnewline
nice\tabularnewline
okay\tabularnewline
a\tabularnewline
b\tabularnewline
xcfasdaadg\tabularnewline
asd\tabularnewline
asd\tabularnewline
\end{tabular}
\end{Verbatim}
<<updateassignment function header>>=
void imaStructuramaUncertainty (char *fname, int nburnin);
<<updateassignment uncertainty>>=
void 
imaStructuramaUncertainty (char *fname, int nburnin)
{
  int d;
  FILE *fp;
  int lenpname;
  char *pname;
  int **m;
  int nrow;
  int ncol;
  int i;
  int *B;
  char **indname;
  int nsample;

  double *au;

  lenpname = 20 + strlen (fname);

  pname = malloc (lenpname * sizeof (char));
  sprintf (pname, "%s.in.p", fname);
  IMA_io_readp (pname, &m, &nrow, &ncol, nburnin);
  nsample = nrow - nburnin;

  /* Must be called after we know ncol, or number of individuals. */
  indname = malloc (ncol * sizeof (char *));
  IMA_io_readp_header (pname, indname, ncol);

  B = malloc (ncol * sizeof (int));
  au = malloc (ncol * sizeof (double));
  memset (au, 0, ncol * sizeof (double));
  sprintf (pname, "%s.in.sum_assignments", fname);
  IMA_io_readsumassignment (pname, ncol, B);
  d = IMA_gusfield_distanceRemoved (B, m, nsample, ncol, NULL, -1, au);

  sprintf (pname, "%s.uct", fname);
  fp = fopen (pname, "w");

  fprintf (fp, "t = {");
  for (i = 0; i < ncol; i++)
    {
      fprintf (fp, "{\"%s\", %d, %lf}", indname[i], B[i], au[i]);
      if (i < ncol - 1)
        {
          fprintf (fp, ", ");
        }
    }
  fprintf (fp, "}\n");
  fclose (fp);
  fp = NULL;
  free (au);
  au = NULL;
  
  for (i = 0; i < ncol; i++)
    {
      free (indname[i]);
      indname[i] = NULL;
    }
  free (indname);
  indname = NULL;

  free (B);
  B = NULL;
  for (i = 0; i < nsample; i++)
    {
      free (m[i]);
      m[i] = NULL;
    }
  free (m);
  m = NULL;
  free (pname);
  pname = NULL;


  return;
}




@
[[ext]] can be either ``.in.p'' or ``.asn''.
<<updateassignment function header>>=
void imaIMTreeUncertainty (char *fname, const char *ext, int nburnin);
<<updateassignment uncertainty>>=
void 
imaIMTreeUncertainty (char *fname, const char *ext, int nburnin)
{
  int d;
  FILE *fp;
  int lenpname;
  char *pname;
  int **m;
  int nrow;
  int ncol;
  int i;
  int *B;
  char **indname;
  int nsample;

  double *au;

  lenpname = 20 + strlen (fname);

  pname = malloc (lenpname * sizeof (char));
  sprintf (pname, "%s%s", fname, ext);
  IMA_io_readp (pname, &m, &nrow, &ncol, nburnin);
  nsample = nrow - nburnin;

  /* Must be called after we know ncol, or number of individuals. */
  indname = malloc (ncol * sizeof (char *));
  IMA_io_readp_header (pname, indname, ncol);

  B = malloc (ncol * sizeof (int));
  au = malloc (ncol * sizeof (double));
  memset (au, 0, ncol * sizeof (double));
  sprintf (pname, "%s.in.sum_assignments", fname);
  IMA_io_readsumassignment (pname, ncol, B);
  d = IMA_gusfield_distanceRemoved (B, m, nsample, ncol, NULL, -1, au);

  sprintf (pname, "%s.uct", fname);
  fp = fopen (pname, "w");

  fprintf (fp, "t = {");
  for (i = 0; i < ncol; i++)
    {
      fprintf (fp, "{\"%s\", %d, %lf}", indname[i], B[i], au[i]);
      if (i < ncol - 1)
        {
          fprintf (fp, ", ");
        }
    }
  fprintf (fp, "}\n");
  fclose (fp);
  fp = NULL;
  free (au);
  au = NULL;
  
  for (i = 0; i < ncol; i++)
    {
      free (indname[i]);
      indname[i] = NULL;
    }
  free (indname);
  indname = NULL;

  free (B);
  B = NULL;
  for (i = 0; i < nsample; i++)
    {
      free (m[i]);
      m[i] = NULL;
    }
  free (m);
  m = NULL;
  free (pname);
  pname = NULL;


  return;
}



@
\subsection{Joint Estimation Using Relabel Approach}
The inference of demographic parameters under IM models is made with
posterior samples of genealogies (Equation 1). Inferring demographic
parameters amounts to summarizing posterior samples of genealogy.
As assignment parameter intertwines with genealogies, just using posterior
samples of genealogies without modification could lead to meaningless
estimates of demographic parameters due to so-called label-switching
problem \citet[e.g., see][]{Stephens:2000}. Let us consider two individuals
A, and B with unknown origins of populations 1, and 2. Two individuals
can be either in the same population, or in different ones. However,
four realizations of assignment are possible: (A,B)1()2, (A)1(B)2,
(B)1(A)2, and ()1(A,B)2 where parentheses represent assignment of
individuals to populations 1 and 2, e.g., (A)1(B)2 means that individual
A is assigned to population 1, and B to 2. Note that the first and
fourth realizations are effectively the same assignment, and so are
the second and third ones. Thus, summarizing genealogies and assignments
warrants dealing with label-switching.

\citet{Stephens:2000} relabels groups so that a loss function induced
by the relabeled groups is minimized. He managed to infer meaningful
parameters pertinent to groups. We apply his idea to estimate demographic
parameters while accounting assignment uncertainty. We follow Algorithm
4.1 of Stephen (2000) to find maximum likelihood estimates of population
mutation rates, and population migration rates (Algorithm 1). The
loss function is one with action being finding maximum likelihood
estimates of model parameters , using posterior density function of
parameters given data, p(Q|X) (see Equation 1). The algorithm leads
to an estimate of the list of permutations as well as an estimate
of model parameters.

One of the difficulties in using Algorithm 1 is that it will be excruciatingly
slow due to the search of maximum likelihood surface. Instead of finding
estimates of the list of permutations and model parameters, we approximate
the estimate of the list of permutation first and then find the estimate
of demographic parameters based on the list of approximate permutations.
We leverage the assignment estimate and the method of computing assignment
distance to approximate n1,?,nN that hopefully best explain genealogies
orientations of population labelings first. We were concerned that
relabeling might distort the posterior distribution of assignment
and genealogies because relabeling populations of a genealogy changes
factors related with populations that leads to change to the genealogies
overlaid on the population tree. We suspect that posterior distribution
of assignment and genealogies are invariant with its population label
changes to genealogies. We describe it with the simplest two populations
IM demographic model in the following. 

Consider a genealogy with two contemporary populations model. Probability
of genealogy and population split time given model parameters depends
on factors related with populations including ancestral one. \begin{eqnarray*}
f(\mathbf{G},\mathbf{t}|\mathbf{\Theta}) & = & \left(\frac{2}{\theta_{1}}\right)^{c_{1}}e^{-f_{1}/\theta_{1}}m_{1}^{w_{1}}e^{-g_{1}m_{1}}\\
 &  & \times\left(\frac{2}{\theta_{2}}\right)^{c_{2}}e^{-f_{2}/\theta_{2}}\times m_{2}^{w_{2}}e^{-g_{2}m_{2}}\\
 &  & \times\left(\frac{2}{\theta_{3}}\right)^{c_{3}}e^{-f_{3}/\theta_{3}}\end{eqnarray*}


where $c_{1}$, $c_{2}$, and $c_{3}$ are the number of coalescent
events within population 1, 2, and 3, respectively. $\theta_{1}$,
$\theta_{2}$, and $\theta_{3}$ are population mutation rates and
$m_{1}$ and $m_{2}$ are population migration rates. $f_{1}=\sum_{i}\tau_{i}n_{1,i}(n_{1,i}-1),$
$f_{2}=\sum_{i}\tau_{i}n_{2,i}(n_{2,i}-1),$ $f_{3}=\sum_{i}\tau_{i}n_{3,i}(n_{3,i}-1),$
$g_{1}=\sum_{i}\tau_{i}n_{1,i},$ and $g_{2}=\sum_{i}\tau_{i}n_{2,i}.$
See Equations 15 and 16 of \citet{Hey:2007} for detailed description
of the equation above.

A genealogy in IM model can be characterized by numbers of coalescent
events ($c$), total coalescent rates ($f$), number of migration
events ($w$), and total migration rates ($g$). We swap two contemporary
populations to have a permuted version of the genealogy. Notation
n is for an operator to permute a list of numbers, and is used to
permute a genealogy. For example, a permutation of ordered pair of
two numbers, (1,2), is (2,1): n(1,2) = (2,1). We abuse n notation
to return a permuted index of an original one: $\nu(1)=2$, and $\nu(2)=1$.
We permute population labels of a genealogy or $\nu(G)$. With two
populations IM model a permutation of genealogy $G$ is to swap two
contemporary population labels 1 and 2:

\begin{eqnarray*}
\nu(G) & = & \nu(c_{1},f_{1},w_{1},g_{1},c_{2},f_{2},w_{2},g_{2},c_{3},f_{3})\\
 & = & (c_{\nu(1)},f_{\nu(1)},w_{\nu(1)},g_{\nu(1)},c_{\nu(2)},f_{\nu(2)},w_{\nu(2)},g_{\nu(2)},c_{3},f_{3})\\
 & = & (c_{2},f_{2},w_{2},g_{2},c_{1},f_{1},w_{1},g_{1},c_{3},f_{3})\end{eqnarray*}


The probability of the permuted version of genealogy $G$ given model
parameters is as follows:\begin{eqnarray*}
f(\nu(G),t|\Theta) & = & \left(\frac{2}{\theta_{1}}\right)^{c_{\nu(1)}}e^{-f_{\nu(1)}/\theta_{1}}m_{1}^{w_{\nu(1)}}e^{-g_{\nu(1)}m_{1}}\\
 &  & \times\left(\frac{2}{\theta_{2}}\right)^{c_{\nu(2)}}e^{-f_{\nu(2)}/\theta_{2}}\times m_{2}^{w_{\nu(2)}}e^{-g_{\nu(2)}m_{2}}\\
 &  & \times\left(\frac{2}{\theta_{3}}\right)^{c_{3}}e^{-f_{3}/\theta_{3}}.\end{eqnarray*}


Whereas the probability of genealogy given model parameters is different
from that of a permuted version of genealogy given model parameters,
the prior of genealogy is equal to the prior of a permuted genealogy:\begin{eqnarray*}
\pi(\nu(G)) & = & \int f(\nu(G)|\Theta)\pi(\Theta)d\Theta\\
 & = & \int f(G|\Theta)\pi(\Theta)d\Theta=\pi(G)\end{eqnarray*}


because model parameters $\Theta=\{\theta_{1},\theta_{2},\theta_{3},m_{1},m_{2}\}$
are integrated out. Accordingly, posterior distribution of genealogy
given data is invariant with respect to permutation of genealogy:\[
\pi(G|X)=\frac{f(X|G)\pi(G)}{f(X)}=\frac{f(X|\nu(G))\pi(\nu(G))}{f(X)}=\pi(\nu(G)|X)\]
where $\pi(\mbox{X}|G)=\pi(\mbox{X}|\nu(G)$.\pagebreak{}


We detail the procedure of
joint estimation of demographic parameters and assignment with an
example in the next.

We relabel populations of each posterior sample of genealogies so
that we minimize discrepancies between the posterior sample of assignment
and the estimated assignment. Figure 2 shows two genealogies that
are sampled from the posterior distribution of assignment and genealogy.
Let us pretend that populations 1 and 2 host individuals A and B,
respectively. Figure 2A shows a genealogy with ?right? assignment
whereas Figure 2B depicts a genealogy with ?wrong? assignment. We
could use the two genealogies to estimate demographic parameters using
Equation 1 without any relabel. Consider population size parameters
for two populations 1 and 2. As population 1 is represented by individual
A in the genealogy of Figure 2A and by individual B in the genealogy
of Figure 2B, a population size estimate of just nominal population
1 by summarizing two genealogies is meaningless. Similarly, the size
of just nominal population 2 has no meaning. What we want to quantify
is something about a population represented by individual A or B,
not population 1, 2, or mixture of them, if we can. To make corrections
of the genealogy in Figure 2B, we could swap labels of populations
1 and 2. Not only labels at those tips A and B are switched, but those
at internal nodes C and D are also changed. The corrected genealogy
of Figure 2B would look like that of Figure 2A. We intend to make
genealogies in Figure 2 so that it shows a pair of label-switched
genealogies that are essentially the same except that population labels
along the genealogies look different.

The case just mentioned is relatively intuitive where there is no
uncertainty in assignment. What if the uncertainty of assignment is
large enough to be hard to decide whether we swap population labels?
We can use the definition of assignment distance to decide whether
we relabel genealogies associated with a posterior sample of assignment.
For example, we have four individuals whose true assignment vector
is (1,1,2,2) or the first two individuals are assigned to population
1, and the other two to population 2. A sampled genealogy is associated
with assignment vector being (1,2,1,1). We have to remove 3 individuals
to make two assignments being equivalent. However, the assignment
distance is not 3 but 1 because (1,2,1,1) is equivalent to (2,1,2,2)
that is different in the first individual from (1,1,2,2). Since labeling
(2,1,2,2) is used to compute the distance between assignment, and
its original labeling is (1,2,1,1), we relabel population 1 to 2 and
2 to 1 in the genealogy associated with the posterior sample of assignment.
If the computation of assignment distance involved the original labeling
(1,2,1,1), then we could have not relabeled populations in genealogies.
In short, we find an actual labeling that is used in computing distances
of assignment associated with a genealogy and the assignment estimate
for each of posterior samples of assignment. We then feed posterior
density function of Equation (1) with the relabeled genealogies to
estimate demographic parameters. There are K! many different assignment
labelings for a given assignment where K is the number of populations.
If more than one relabel result in the same assignment distance, we
could choose one of them at random.

We compare a posterior sample of assignments and assignment estimate to compute
the distance between them. We may or may not swap labels to compute distances
between assignments. If we swap labels, then we also ``swap'' values of the
genealogy associated with the posteior sample of the assignment. This applies to
IMa model based on island demographic models. If a tree based IM model is
applied, then we consider only sister present-day populations to swap labels. We
do not need consider ancestral populations because population trees are a
labeled history and only contemporary populations can be symmetric.
\emph{THIS IS NOT COMMENTED IN THE MANUSCRIPT.}

A list of pairs of sister is needed.

We have [[nsispop]] pairs of sister populations.

We consider tree and island models separaterly. Function
[[imaStructuramaRemoterun]] or [[imaStructuramaLocalrun]] execute [[STRUCTURAMA]] to
estimate a mean assignment by executing the program locally or
remotely. There are two more executables [[server]] and [[gateway]]. These are
out of scope to explain them. Note that we use an output file suffixed ``.in.p''
to summarize posterior samples of assignment parameter, and that we use another
output file suffixed ``.asn'' to ``align'' posterior samples of genealogies.
Assignments in the former output file are RGF converted, and those in the latter
output file are not. Assignment and genealogy must be paired; each genealogy of
the posterior sample must be paired with an assignment in the posterior sample.
Aligning genealogies is accompanied by swapping elements in [[gsampinf]]. We assume
that a summarized assignment in the output file named ``.in.sum\_assignments'' is
a ``true'' assignment although it is not. Function 
[[IMA_io_readsumassignment]] is used to get the point estimate of assignment
parameter. Function [[IMA_io_readp]] is used to have all posterior samples of
assignment parameter.

Once we have a point estimate of assignment parameter and all posterior samples
of the same parameter, then we do two different actions depending on which
demographic model we use. If we use a tree model, we need to more manually 
compare two assignments. We have [[easn]], an integer array of size [[snind]].
We find all pairs of sister present-day populations: [[nsispop]] and [[sispop]].
The number of sister pairs is [[nsispop]]. [[sispop]] is a two dimensional
array.
Function [[imaPtreeNsispop]] computes the number of sister pairs, which is equal
to the number of ancestral populations whose two daughters are present
populations.
We need to check all possible permutations of assignment by swapping sister
populations: there are $2^{nsispop}$ many possible permutations that is equal to
[[ncombsis]]. 
What are [[uc]] and [[cb]]?
Depending on the value of [[uc]] we set [[cb]]. For example,
[[uc]] being 0 corresponds to [[cb]] being 0 (0-th element), 0 (1-st element). [[uc]] being 1 corresponds to
[[cb]] being 1, 0. [[uc]] being 2 to [[cb]] being 0, 1. [[uc]] being 3 to [[cb]]
being 1, 1. 
Using [[cb]] we have [[easn]] ready to use to compute number of individuals to
be removed to make two assignment equal. If we have two pairs of sister present
day populations: for example, populations 0, 1 and populations 2, 3. We have
four possibilities of swapping: no swaps, 0 and 1 swap, 2 and 3 swap,
and last both 0, 1 and 2, 3 swaps. [[sispop]] contains these pairs: 0, 1 at 
first, and 2, 3 secondly. Without using temporary values, we can replace
all labels depending on [[cb]]. Since we have already swapped labels, we need to
count individuals that must be removed using function [[IMA_gdistanceSimple]].
[[d]] is initialized to [[snind]] that is the maximum value of distances between
two assignments of size [[snind]]. If [[d2]] is smaller than [[d]], then we
replace [[d]] with [[d2]] and save the rank [[j]] of permutation [[cb]]. All we
have to do is to swap labels of sister pairs whose [[cb]]'s element is `1.' 

Let us consider island demographic models. This is rather simpler than the case
of tree models. When there are [[npops]], all we need is the permutation that
gives us the distance between two assignments. If there are 5 populations, then
there are 5! numbers of permutations. One of them can be used to compute the
distance between two assignments. We want to find what permutation is the one we
want: 1, 2, 3, 4, 5 or 5, 2, 1, 3, 4. That order is given by [[od]] in 
function [[IMA_gdistanceOrder]]. Once we have [[od]], then we compare values 
of [[od]] and [[od1]]. If they are the same, we do nothing. Otherwise, we swap
the value of [[od1]] and the value of [[od1]] in [[od]]. Note that we do not
change [[od]] but [[od1]].
Once we swap all sister populations, [[od]] and [[od1]] must be the same in
their elements.

A corrected thought: 

We can swap all labels with a pouplation tree with three leaves. We may need
a more sophisticated way to swap all labels with population trees with more than
three tips. We use Gibbs sampling for the former case, and MCMC for the latter
case.
<<updateassignment function header>>=
void IMAgenealogyAlign (char *fname, int n);
void IMA_gsampinf_swap (int gi, int pi, int pj);
<<updateassignment labelswitch>>=
void 
IMAgenealogyAlign (char *fname, int n)
{
  int i;
  int j;
  int k;
  int l;
  int nsispop;
  int **sispop;
  int *od;
  char *pname;
  int len;
  int *tasn;
  int *easn;
  int nrow;
  int ncol;
  int **m;
  int ncombsis;
  char cb[7];
  int d;
  int d2;
  int uc; /* unsigned char */
  int v;

  /***************************************************************************/
  /* FIXME: This does not belong to this function. */
  if (runoptions[SKIPSTRUCTURAMA] == 0)
    {
#if defined(STRUCTURAMAREMOTERUN)
      imaStructuramaRemoterun (fname);
#else
      imaStructuramaLocalrun (fname);
#endif /* STRUCTURAMAREMOTERUN */
    }

  if (trueassignment != NULL)
    {
      imaStructuramaSummary (fname, 0);
    }

  imaStructuramaUncertainty (fname, 0); /* Argument for assignment estimate? */
  /***************************************************************************/

  /***************************************************************************/
  /* Align genealogies by swapping elements in [[gsampinf]].                 */ 
  /***************************************************************************/
  len = strlen (fname);
  pname = (char *) malloc ((len + 30) * sizeof (char)); /* .in.sum_assignments */

  /* Find a point estimate of assignment parameter. */
  tasn = malloc (snind * sizeof (int));
  sprintf (pname, "%s.in.sum_assignments", fname);
  IMA_io_readsumassignment (pname, snind, tasn);
  for (i = 0; i < snind; i++)
    {
      assert (tasn[i] > 0); 
      tasn[i] = tasn[i] - 1;
    }

  /* Read all posterior samples of assignment parameter. */
  sprintf (pname, "%s.asn", fname);
  IMA_io_readp (pname, &m, &nrow, &ncol, 0);
  /* This may be different when there are multiple MCMC ouput files. */
  assert (ncol == snind);
  assert (nrow == n);  

  if (!(npops < 13))
    {
      IM_errloc (AT, 
                 "Island model: number of permutations will be orveflow: %d!",
                 npops);
    }
  if (assignmentoptions[POPULATIONASSIGNMENTINFINITE] == 0)
    {
      if (npops == 2 || npops == 3)
        {
          easn = malloc (snind * sizeof (int));
          nsispop = imaPtreeNsispop (0);
          if (nsispop < 1 || nsispop > 7)
            {
              IM_err (IMERR_ASN, 
                      " number (%d) of present-day sister populations is in between 1 and 7",
                      nsispop);
            }
          sispop = (int **) malloc (nsispop * sizeof (int *));
          for (j = 0; j < nsispop; j++)
            {
              sispop[j] = (int *) malloc (2 * sizeof (int));
            }
          imaPtreeSispop (0, sispop);
          ncombsis = 1 << nsispop;

          /* Compare two assignments: n is the number of pairs of genealogy and
           * assignment. */
          for (i = 0; i < n; i++)
            {
              /* 2^^#sisters many iterations */
              d = snind;
              for (j = 0; j < ncombsis; j++)
                {
                  /* We may not need cb.          */
                  /* It is more readable, though. */
                  uc = j;
                  for (k = 0; k < nsispop; k++)
                    {
                      if (uc & 1<<k)
                        {
                          cb[k] = '1';
                        }
                      else
                        {
                          cb[k] = '0';
                        }
                    }

                  /* Find the number of individuals to be removed. */
                  memcpy (easn, m[i], snind * sizeof (int));
                  for (k = 0; k < nsispop; k++)
                    {
                      if (cb[k] == '1')
                        {
                          for (l = 0; l < snind; l++)
                            {
                              if (easn[l] == sispop[k][0]) 
                                {
                                  easn[l] = sispop[k][1];
                                }
                              else if (easn[l] == sispop[k][1])
                                {
                                  easn[l] = sispop[k][0];
                                }
                            }
                          
                        }
                    }
                  /* Now, easn is a permutation. */

                  d2 = IMA_gdistanceSimple (snind, tasn, easn);

                  if (d2 < d)
                    {
                      d = d2; /* A smaller distance is found.  */
                      v = j;  /* The index of the permutation. */
                    }
                }
              /* Now, we know the permuted asssignment that gives a smallest
               * distance. We now swap genealogies. */

              /* v-th permutation. */
              uc = v;
              for (k = 0; k < nsispop; k++)
                {
                  if (uc & 1<<k)
                    {
                      cb[k] = '1';
                    }
                  else
                    {
                      cb[k] = '0';
                    }
                }
              for (j = 0; j < nsispop; j++)
                {
                  if (cb[j] == '1')
                    {
                      IMA_gsampinf_swap (i, sispop[j][0], sispop[j][1]);
                    }
                }
            }
          XFREE (easn);
          for (i = 0; i < nsispop; i++)
            {
              XFREE (sispop[i]);
            }
          XFREE (sispop);
        }
      else if (3 < npops && npops < 13)
        {
#ifdef COMMENT
          IM_errloc (AT, 
                     "Not yet implemented");
#endif
        }
      else
        {
          IM_errloc (AT, 
                     "Tree model: num. popn. must be less than 13 (npops = %d)",
                     npops);
        }
    }
  else
    {
      for (i = 0; i < snind; i++)
        {
          tasn[i] = tasn[i] + 1;
        }

      od = (int *) malloc (npops * sizeof (int));
      for (i = 0; i < n; i++)
        {
          for (j = 0; j < snind; j++)
            {
              m[i][j] = m[i][j] + 1;
            }
          /* What if m does not have all labels? od 
           */
          IMA_gdistanceOrderNEW (snind, tasn, m[i], npops, od);
          /* od: 1 2 0 3 */
          imaGsampinfRelabel (i, od);
        }
      XFREE (od);
    }

  XFREE (pname);
  XFREE (tasn);
  for (i = 0; i < nrow; i++)
    {
      XFREE (m[i]);
    }
  XFREE (m);

  return; 
}
@
[[imaGsampinfPermutedG]] returns a permuted gi-th genealogy using combination
[[od]]. This works only for 3 poulations.

<<updateassignment function header>>=
void imaGsampinfPermutedG (int gi, float *atree, int *od);

void imaGsampinfRelabel (int gi, int *od);
int imaGsampinfFindmig (int pi, int pj);
extern int gsampinflength;
<<updateassignment labelswitch>>=
void
imaGsampinfPermutedG (int gi, float *atree, int *od)
{
  int i;
  int j;
  int pi;
  int pj;

  /* pi: 0 1 2 3
   * pj: 1 2 0 3
   */
  for (pi = 0; pi < npops; pi++)
    {
      pj = od[pi];
      atree[gsamp_ccp + pi] = gsampinf[gi][gsamp_ccp + pj];
      atree[gsamp_fcp + pi] = gsampinf[gi][gsamp_fcp + pj];
      atree[gsamp_hccp + pi] = gsampinf[gi][gsamp_hccp + pj];
      atree[gsamp_qip + pi] = gsampinf[gi][gsamp_qip + pj];
    }

  for (pi = 0; pi < npops - 1; pi++)
    {
      for (pj = pi + 1; pj < npops; pj++)
        {
          i = imaGsampinfFindmig (pi, pj);
          j = imaGsampinfFindmig (od[pi], od[pj]);
          atree[gsamp_mcp + i] = gsampinf[gi][gsamp_mcp + j];
          atree[gsamp_fmp + i] = gsampinf[gi][gsamp_fmp + j];
          atree[gsamp_mip + i] = gsampinf[gi][gsamp_mip + j];

          i = imaGsampinfFindmig (pj, pi);
          j = imaGsampinfFindmig (od[pj], od[pi]);
          atree[gsamp_mcp + i] = gsampinf[gi][gsamp_mcp + j];
          atree[gsamp_fmp + i] = gsampinf[gi][gsamp_fmp + j];
          atree[gsamp_mip + i] = gsampinf[gi][gsamp_mip + j];
        }
    }

  return;
}


void
imaGsampinfRelabel (int gi, int *od)
{
  int i;
  int j;
  int pi;
  int pj;

  float *atree;

  atree = malloc (gsampinflength * sizeof (float));

  /* NOTE: The order is critical.
   * Replace
   * pj: 1 2 0 3
   * with
   * pi: 0 1 2 3
   */
  for (pi = 0; pi < npops; pi++)
    {
      pj = od[pi];
      atree[gsamp_ccp + pj] = gsampinf[gi][gsamp_ccp + pi];
      atree[gsamp_fcp + pj] = gsampinf[gi][gsamp_fcp + pi];
      atree[gsamp_hccp + pj] = gsampinf[gi][gsamp_hccp + pi];
      atree[gsamp_qip + pj] = gsampinf[gi][gsamp_qip + pi];
    }

  for (pi = 0; pi < npops - 1; pi++)
    {
      for (pj = pi + 1; pj < npops; pj++)
        {
          i = imaGsampinfFindmig (pi, pj);
          j = imaGsampinfFindmig (od[pi], od[pj]);
          atree[gsamp_mcp + j] = gsampinf[gi][gsamp_mcp + i];
          atree[gsamp_fmp + j] = gsampinf[gi][gsamp_fmp + i];
          atree[gsamp_mip + j] = gsampinf[gi][gsamp_mip + i];

          i = imaGsampinfFindmig (pj, pi);
          j = imaGsampinfFindmig (od[pj], od[pi]);
          atree[gsamp_mcp + j] = gsampinf[gi][gsamp_mcp + i];
          atree[gsamp_fmp + j] = gsampinf[gi][gsamp_fmp + i];
          atree[gsamp_mip + j] = gsampinf[gi][gsamp_mip + i];
        }
    }

  memcpy (gsampinf[gi], atree, gsampinflength * sizeof (float));
  XFREE (atree);

  return;
}

int 
imaGsampinfFindmig (int pi, int pj)
{
  int i;
  int mi;
  char migstr[10]; /* m0>1 or q0 */

  i = nummigrateparams;
  sprintf (migstr, "m%d>%d", pi, pj);
  assert (strlen (migstr) == 4);
  for (mi = 0; mi < nummigrateparams; mi++)
    {
      if (strcmp(migstr, imig[mi].str) == 0)
        {
          i = mi;
          break;
        }
    }
  assert (i < nummigrateparams);
  return i;
}

void 
IMA_gsampinf_swap (int gi, int pi, int pj)
{
  int i, j;
  int mi;
  char migstr[10]; /* m0>1 or q0 */

  /* All vlaues in gsampinf associated labels pi and pj are swapped. */
  assert (pi < npops && pj < npops);
  assert (!(pi < 0) && !(pj < 0));

  i = pi;
  j = pj;
  SWAP (gsampinf[gi][gsamp_ccp + i], gsampinf[gi][gsamp_ccp + j]); 
  SWAP (gsampinf[gi][gsamp_fcp + i], gsampinf[gi][gsamp_fcp + j]); 
  SWAP (gsampinf[gi][gsamp_hccp + i], gsampinf[gi][gsamp_hccp + j]); 
  SWAP (gsampinf[gi][gsamp_qip + i], gsampinf[gi][gsamp_qip + j]); 

  i = nummigrateparams;
  sprintf (migstr, "m%d>%d", pi, pj);
  assert (strlen (migstr) == 4);
  for (mi = 0; mi < nummigrateparams; mi++)
    {
      if (strcmp(migstr, imig[mi].str) == 0)
        {
          i = mi;
          break;
        }
    }
  assert (i < nummigrateparams);

  j = nummigrateparams;
  sprintf (migstr, "m%d>%d", pj, pi);
  assert (strlen (migstr) == 4);
  for (mi = 0; mi < nummigrateparams; mi++)
    {
      if (strcmp(migstr, imig[mi].str) == 0)
        {
          j = mi;
          break;
        }
    }
  assert (j < nummigrateparams);
  SWAP (gsampinf[gi][gsamp_mcp + i], gsampinf[gi][gsamp_mcp + j]); 
  SWAP (gsampinf[gi][gsamp_fmp + i], gsampinf[gi][gsamp_fmp + j]); 
  SWAP (gsampinf[gi][gsamp_mip + i], gsampinf[gi][gsamp_mip + j]); 

  return;
}

<<updateassignment static>>=
static int imaPtreeNsispop (int ci);
static int imaPtreeSispop (int ci, int **s);
<<updateassignment labelswitch>>=
int 
imaPtreeNsispop (int ci)
{
  int i;
  int v;
  struct popedge *ptree;

  ptree = C[ci]->poptree;
  v = 0;
  for (i = npops; i < 2 * npops - 1; i++)
    {
      if (ptree[i].up[0] < npops && ptree[i].up[1] < npops) 
        {
          v++;
        }
    }
  return v;
}

int 
imaPtreeSispop (int ci, int **s)
{
  int i;
  int v;
  struct popedge *ptree;

  ptree = C[ci]->poptree;
  v = 0;
  for (i = npops; i < 2 * npops - 1; i++)
    {
      if (ptree[i].up[0] < npops && ptree[i].up[1] < npops) 
        {
          s[v][0] = ptree[i].up[0];
          s[v][1] = ptree[i].up[1];
          v++;
        }
    }
  return v;
}

<<updateassignment macros>>=
#define SWAP(a,b) do {\
  char c[sizeof((a))]; \
  memcpy((void *)&(c), (void *)&(a), sizeof((c))); \
  memcpy((void *)&(a), (void *)&(b), sizeof((a))); \
  memcpy((void *)&(b), (void *)&(c), sizeof((b))); \
} while (0)
 
            


@
\subsection{RG String}
An assignment {\em posterior} sample is a list of vectors where each element is
assigned population label. A population may be characterized by population 
size parameter with sampled gene copies in isolation-with-migration model.
Since we change gene copy population label during inference procedure,
population labels may be ambiguous.
{\tt I need to have a good example of this ambiguity issue.}
In two-population assignment we fix one gene copy to
be assigned to one population. Then we may avoid an issue of ``identifiability''
of which population is which. This issue emerges crucially in 
more-than-two-population cases.

For three-population assignment with 5 gene copies a vector of assignment may be
as follows:
\begin{Verbatim}[frame=lines,framesep=5mm]
1 1 0 2 1
\end{Verbatim}
The first, second, and fifth gene copies are assigned to population 1, the third
to population 0, and the fourth to population 2. This vector can be considered
the same as this:
\begin{Verbatim}[frame=lines,framesep=5mm]
2 2 1 0 2
\end{Verbatim}
In a clustering question two vectors of assignment are the same. Furthermore,
population 1 in the first example and population 2 in the second one may be the
same if they are siblings in terms of population tree.

Once we have a list of vectors of assignment {\em posterior} sample, we need to
find which one is the same configuration. A Restricted Growth string, or RG
string can help determining the same configuration. An algorithm can be used to
convert a vector of assignment to a RG string.
\begin{Verbatim}[frame=lines,framesep=5mm]
c <- 0
map that is empty
for each element in a vector
  if an element is not in the map then
    replace it with c
    add a map of the element to c
    c++
  else
    replace it with the mapped element
  end of if
end of for
\end{Verbatim}
A RG string is a unique representation of a partitions of a number of elements.
{\tt Any reference of RG string and Set Partitions?}
Once we convert a vector of assignment to a RG string, we may determine whether
two assignments are the same just by comparing the RG strings literally. 

A shell script may convert a list of assignment vectors to a list of RG strings
with number of occurrences of those strings. We first convert all vectors in an
assignment {\em posterior} output to RG strings. Then, we may use unix command
[[sort]], and count number of each occurrences. {\tt I do not know what commands
should be used to count occurrences. I think that there should be and this is
not something that I have to develop in a low-level programming language.} 

An example to find out how often lines occur in a file can be done with [[cut]],
[[sort]], and [[uniq]] commands. If columns from 2nd to 41th are for a locus, we
may use the following command with pipes.
\begin{Verbatim}[frame=lines,framesep=5mm]
cut -f 2-41 sim2pop-v042308-assign.out.asn | sort -n | uniq -c | sort -n
\end{Verbatim}

We implement a perl program that summarizes population assignment posterior
sample. A summarization of population assignment includes:
\begin{itemize}
  \item population label proportions of gene copies
  \item a list of highly occurred population assignments
\end{itemize}
The summarization depends on population assignment [[mode]] with which [[imamp]]
have run. Three input files that are necessary are [[imamp]] input data file,
[[imamp]] output file that contains command line options, and population
assigment output file. A command line usage is 
\begin{Verbatim}[frame=lines,framesep=5mm]
perl imamp.pl --imamp-input=inputfile --imamp-output=outputfile --imamp-assignment=assignmentfile --output=summmaryfile
\end{Verbatim}

We have a list of population labels for genes of a locus. We relabel it to
conform the Restricted Growth string.
<<updateassignment function header>>=
int IMA_rgs_convert (int *a, int n);
<<updateassignment rgs>>=
int 
IMA_rgs_convert (int *a, int n)
{
  int max;
  int i;
  int *m;
  int e;

  m = malloc (n * sizeof (int));
  memset (m, -1, n * sizeof (int)); 

  max = 1;
  for (i = 0; i < n; i++)
    {
      e = a[i];
      assert (e < n);
      assert (!(e < 0));
      if (m[e] == -1)
        {
          m[e] = max;
          max++;
        }
      a[i] = m[e];
    }
  free (m);
  m = NULL;

  return max;

}

@
We want to map RGF to and from integers so that we can count the number of
occurences of assignment. These function for handling RGF are directly imported
from a book titled ``Combinatorial Algorithms: Generation, Enumeration and
Search'' authored by Kreher and Stinson published in 1999. The book will be
useful and I will try to skim through it to see if there are more things to
learn. It is a really nice book.

Refer to [[rgf main]] for usages of those function related to RGF. 

The total number of assignments is stored in variable [[snasn]]. We call
[[IMA_rgf_setSnasn]] to set [[snasn]] in
[[imaAsnSet]].

\begin{Verbatim}[frame=lines,framesep=5mm]
> The usual way to run a goodness-of-fit test is to compute 
> pval = Pr(Xsq>t) = gsl_cdf_chisq_Q(t,nu), where t is the test statistic you 
> compute from your data and nu = degrees of freedom of t.
> Then reject the null hypothesis if pval < Pr(type 1 error).
\end{Verbatim}

<<updateassignment file static variables>>=
static int snasn;
static int *saasn;

<<updateassignment static>>=
int IMA_rgf_setSnasn (int nind, int np);
<<updateassignment rgs>>=
int 
IMA_rgf_setSnasn (int nind, int np)
{
  int v;
  int i;

  if (nind < np)
    {
      IM_err (IMERR_ASN, "There are more populations than individuals");
    }
  v = 0;
  for (i = 0 ; i < np; i++)
    {
      v += IMA_stirlings2 (nind, i + 1);
    }
  return v;
}

<<updateassignment function header>>=
void IMA_rgf_tickSaasn (int ci);
void IMA_rgf_saveSaasn ();
<<updateassignment rgs>>=
void 
IMA_rgf_tickSaasn (int ci)
{
  int li;
  int ii;
  int ei;
  int *a = NULL;
  int *pa;
  int r;

  assert (ci == 0);

  a = malloc (snind * sizeof (int));

  /* how do I know individuals of a locus? */
  pa = a;
  for (ii = 0; ii < snind; ii++)
    {
      li = saC.indlist[ii][0].li;
      ei = saC.indlist[ii][0].ei;
      *pa = C[ci]->G[li].gtree[ei].pop;
      pa++;
    }

  IMA_rgs_convert (a, snind);

  /* Add the number of assignments. */
  r = IMA_rankrgf2 (snind, npops, a);
  assert (r < snasn);
  saasn[r]++;

  free (a);
  a = NULL;
 
  return;
}

void 
IMA_rgf_saveSaasn ()
{
  int i;
  FILE *tfile;
  char *fname;
  int len;

  len = strlen (outfilename);
  fname = malloc ((len + 4 + 1) * sizeof (char));
  sprintf (fname, "%s.pri", outfilename);

  tfile = fopen (fname, "w");
  for (i = 0; i < snasn; i++)
    {
      fprintf (tfile, "%d\n", saasn[i]);
    }
  fclose (tfile);
  tfile = NULL;
  XFREE (fname);
  return;
}

<<rgf main>>=
int
main (int argc, const char * argv[]) 
{
  int **d;
  int f[5] = {1, 2, 2, 2, 1};
  int r;
  int i;
  
  printf ("GeneralizedRGF (6)\n");
  d = IMA_generalizedrgf (6);
  IMA_fprintjrgf (stdout, d, 6);
  IMA_freejrgf (&d, 6);
  printf ("\n");  
    
  printf ("List of RGFs with 3\n");
  printf ("-------------------\n");
  IMA_generatergf (3, 3);
  printf ("\n");
  
  IMA_fprintrgf (stdout, f, 3);
  r = IMA_rankrgf (3, f);
  printf ("Rank is %d\n\n", r);

  r = IMA_stirlings2 (3, 1) + IMA_stirlings2 (3, 2) + IMA_stirlings2 (3, 3);
  printf ("StirlingS2 [3, 1 ~ 3] is %d\n\n", r);

  for (i = 0; i < r; i++)
    {
      IMA_unrankrgf (f, i, 3);
      printf ("Unrank [%3d, 3] is ", i);
      IMA_fprintrgf (stdout, f, 3);      
    }
  printf ("\n");
  
  printf ("List of RGFs with 5 upto 2 groups\n");
  printf ("---------------------------------\n");
  IMA_generatergf (5, 2);
  printf ("\n");
  
  d = IMA_generalizedrgf2 (5, 2);
  IMA_fprintjrgf (stdout, d, 5);
  IMA_freejrgf (&d, 5);
  printf ("\n");

  IMA_fprintrgf (stdout, f, 5);
  r = IMA_rankrgf2 (5, 2, f);
  if (!(r < 0))
    {
      printf ("Rank is %d\n", r);      
    }
  printf ("\n");
  
  f[0] = 1;
  f[1] = 2;
  f[2] = 2;
  f[3] = 2;
  f[4] = 1;
  IMA_fprintrgf (stdout, f, 5);
  r = IMA_rankrgf2 (5, 2, f);
  printf ("Rank is %d\n\n", r);
  
  r = IMA_stirlings2(5, 1) + IMA_stirlings2(5, 2);
  printf ("StirlingS2 [5, 1 ~ 2] is %d\n\n", r);
  
  for (i = 0; i < r; i++)
    {
      IMA_unrankrgf2 (f, i, 5, 2);
      printf ("Unrank [%3d, 5] is ", i);
      IMA_fprintrgf (stdout, f, 5);      
    }
  printf ("\n");
  
  r = IMA_stirlings2(13, 5);
  printf ("StirlingS2 [13, 5] is %d\n", r);
  
  return 0;
}

<<updateassignment function header>>=
int IMA_fprintrgf (FILE *fp, int *f, int m);
int IMA_generatergf (int m, int n);
int** IMA_generalizedrgf (int m);
int IMA_freejrgf (int ***d, int m);
int IMA_fprintjrgf (FILE *fp, int **d, int m);
int IMA_rankrgf (int m, int *f);
int IMA_unrankrgf (int *f, int r, int m);
int IMA_stirlings2 (int m, int n);
int IMA_maxrgf (int *f, int m);

int** IMA_generalizedrgf2 (int m, int n);
int IMA_rankrgf2 (int m, int n, int *f);
int IMA_unrankrgf2 (int *f, int r, int m, int n);

<<updateassignment rgs>>=
int
IMA_fprintrgf (FILE *fp, int *f, int m)
{
  int i;
  fprintf (fp, "{");
  for (i = 0; i < m; i++)
    {
      if (i < m - 1)
        {
          fprintf (fp, "%2d ", f[i]);                
        }
      else
        {
          fprintf (fp, "%2d}", f[i]);
        }
    }
  fprintf (fp, "\n");
  return 0;
}

int
IMA_generatergf (int m, int n)
{
  int *f;
  int *fm;
  int i;
  int j;
  char done;
  int maxn;
  int rank;
  
  rank = 0;
  f = malloc (m * sizeof (int));
  fm = malloc (m * sizeof (int));
  for (i = 0; i < m; i++)
    {
      f[i] = 1;
      fm[i] = 2;
    }
  done = 'N';
  while (done == 'N')
    {
      fprintf (stdout, "[%3d] ", rank);
      rank++;
      IMA_fprintrgf (stdout, f, m);          
      j = m;
      do
        {
          j = j - 1;
        } while (f[j] == fm[j]);
      if (j > 0)
        {
          f[j] = f[j] + 1;
          for (i = j + 1; i < m; i++)
            {
              f[i] = 1;
              if (f[j] == fm[j])
                {
                  if (fm[j] < n - 1)
                    {
                      maxn = fm[j];
                    }
                  else
                    {
                      maxn = n - 1;
                    }
                  fm[i] = maxn + 1;
                }
              else
                {
                  fm[i] = fm[j];
                }
            }
        }
      else
        {
          done = 'Y';
        }
    }
  
  free (f);
  free (fm);
  f = NULL;
  fm = NULL;
  return 0;
}

int**
IMA_generalizedrgf (int m)
{
  return IMA_generalizedrgf2 (m, m);
}

int**
IMA_generalizedrgf2 (int m, int n)
{
  int j;
  int i;
  int **d;
  int M;
  int N;
  
  M = m + 1;
  N = n + 1;
  d = malloc (M * sizeof (int *));
  for (i = 0; i < M; i++)
    {
      d[i] = malloc (M * sizeof (int));
      memset (d[i], 0, M * sizeof (int));
    }
  for (j = 0; j < N; j++)
    {
      d[0][j] = 1;
    }
  for (i = 1; i < M; i++)
    {
      for (j = 0; j < M - i; j++)
        {
          d[i][j] = j * d[i-1][j] + d[i-1][j+1];
        }
    }
  return d;
}

int
IMA_freejrgf (int ***d, int m)
{
  int i;
  int M;
  
  M = m + 1;
  for (i = 0; i < M; i++)
    {
      free ((*d)[i]);
      (*d)[i] = NULL;
    }
  free (*d);
  *d = NULL;
  return 0;
}

int
IMA_fprintjrgf (FILE *fp, int **d, int m)
{
  int i;
  int j;
  int M;
  
  M = m + 1;

  fprintf (fp, "  i | ");
  for (j = 0; j < M; j++)
    {
      fprintf (fp, "%4d ", j);
    }
  fprintf (fp, "\n");
  fprintf (fp, "-----");
  for (j = 0; j < M; j++)
    {
      fprintf (fp, "-----");
    }  
  fprintf (fp, "\n");
  
  for (i = 0; i < M; i++)
    {
      fprintf (fp, "%3d | ", i);
      for (j = 0; j < M - i; j++)
        {
          fprintf (fp, "%4d ", d[i][j]);
        }
      fprintf (fp, "\n");
    } 
  return 0;
}

int
IMA_rankrgf (int m, int *f)
{
  return IMA_rankrgf2 (m, m, f);
}

int
IMA_rankrgf2 (int m, int n, int *f)
{
  int r;
  int j;
  int i;
  int **d;
  int M;
  
  for (i = 0; i < m; i++)
    {
      if (f[i] > n)
        {
          printf ("INVALID RGFs - There are elements larger than %d\n", n);
          return -1;
        }
    }
  M = m + 1;
  d = IMA_generalizedrgf2 (m, n);
  r = 0;
  j = 1;
  for (i = 2; i < M; i++)
    {
      r = r + (f[i-1] - 1) * d[m-i][j];
      if (j < f[i-1])
        {
          j = f[i-1];
        }
    }
  IMA_freejrgf (&d, m);  
  return r;
}

int
IMA_unrankrgf (int *f, int r, int m)
{  
  IMA_unrankrgf2 (f, r, m, m);
  return 0;
}

int
IMA_unrankrgf2 (int *f, int r, int m, int n)
{
  int j;
  int i;
  int **d;
  int M;
  
  M = m + 1;
  d = IMA_generalizedrgf2 (m, n);
  j = 1;
  for (i = 2; i < M; i++)
    {
      if (j * d[m-i][j] <= r)
        {
          f[i-1] = j + 1;
          r = r - j * d[m-i][j];
          j = j + 1;
        }
      else
        {
          f[i-1] = r / d[m-i][j] + 1;
          r = r % d[m-i][j];
        }
    }
  IMA_freejrgf (&d, m);
  return 0;
}

int
IMA_stirlings2 (int m, int n)
{
  int i;
  int j;
  int M;
  int N;
  int min;
  int **s;
  int v;
  
  M = m + 1;
  N = n + 1;
  
  s = malloc (M * sizeof (int *));
  for (i = 0; i < M; i++)
    {
      s[i] = malloc ((M + 1) * sizeof (int));
    }
  
  s[0][0] = 1;
  for (i = 1; i < M; i++)
    {
      s[i][0] = 0;
    }
  for (i = 0; i < M; i++)
    {
      s[i][i+1] = 0;
    }
  for (i = 1; i < M; i++)
    {
      if (i < n)
        {
          min = i;
        }
      else
        {
          min = n;
        }
      for (j = 1; j < min + 1; j++)
        {
          s[i][j] = j * s[i-1][j] + s[i-1][j-1];
        }
    }
  v = s[m][n];
  
  for (i = 0; i < M; i++)
    {
      free (s[i]);
      s[i] = NULL;
    }
  free (s);
  s = NULL;
  
  return v;
}

int
IMA_maxrgf (int *f, int m)
{
  int i;
  int maxn;
  maxn = 0;
  for (i = 0; i < m; i++)
    {
      if (maxn < f[i])
        {
          maxn = f[i];
        }
    }
  return maxn;
}

@
\subsection{Gusfield distance}
Function [[IMA_factorial]]: This function gives $n!$ using recursive function.
This may be one function that needs optimization.
Function [[IMA_permFprintf]]: It prints integer array [[p]] of size [[n]] to file
[[fp]]. 
We follow the permutation implementation part of ``Combinatorial Algorithms:
Generation, Enumeration, and Search'' authored by Kreher and Stinson (1999) in
order to implement the enumeration of permutation of size $n$. The initial
integer array should be a monotonic increasing sequence, i.e., 1, 2, 3, 4, 5,
$\cdots, n$ where $n$ is the size of the integer array. We need one more space
for the algorithm to work, and allocate $n + 1$ size of integer array. The first
element is spared for a temporary space. We initialize an integer array of size
3 as [[int]] array of size 4 with 0, 1, 2, and 3. By calling
[[IMA_permLexSuccessor]] successively we can enumerate all $n!$ permutations.
Function [[IMA_gdistance]] uses [[IMA_permLexSuccessor]]. We have used neither
function [[IMA_permLexRank]] nor [[IMA_permLexUnrank]] although the former gives
the rank of a permutation $p$ and the latter gives the $r$-th permutation [[p]].
Function [[IMA_gdistance]] gives the distance between two assignment [[Ai]] and
[[Bi]] of size [[n]]. Note that the elements of an assignment must be a compact
series of positive natural numbers: i.e., {1, 3, 2, 2, 1}. Negative numbers or
zeros are not allowed. Numbers that are smaller than maximum must appear at
least once: i.e., {1, 3, 3, 1} is not acceptable because number 2 does not
appear and it should be written as {1, 2, 2, 1} or {2, 1, 1, 2}.
Function [[IMA_max_intarray]] gives the maximum value of elements of array [[A]]
of size [[n]].
Function [[IMA_io_readp]] reads in assignment output file [[fname]] from
[[IMa]]. The two dimensional array of [[m]] must be NULL. The three arguments
[[m]], [[mr]], and [[mc]] are all return values. We use [[skip_a_line]],
[[read_int]], and [[read_double]] to parse assignment output file [[fname]].
After we read in assignment sample using [[IMA_io_readp]], we call
[[IMA_gusfield_distance]] to compute the total distance of assignment [[A]] from
all assignment samples in [[m]].

We want to measure the distance between two parititons. Partition A has r-many
groups, and B has s-many by following Konovalov (Bioinformatics, 2005).
We assume that r is less than or equal to s. Groups $a_1$ to $a_r$ are
represented by a bit set of size being equal to the number of individuals.
Groups $a_{r+1}$ to $a_s$ are zero bit sets. Groups $b_1$ to $b_s$ are also
represented by bit sets. We take a pairwise intersection between one group
from partition A and another from B. The intersection appears only once. Once a
group is used for intersectioning, we are not allowed to use it any more. We
take the sum of elements of intersection sets and subtract it from the number of
indiviudals to give us Gusfield distance. 
There are $s!$ distances among which we choose the smallest one as a distance
between two partitions.

We are given two integer arrays of the same size. We convert each array to a
vector of bit sets. 
We use a permutation module to generate permutation of size $s$ that is the
largest size of partitions. We use a permutation to shuffle 
groups of partition B, and take intersection between one from partition A and
shuffled one from B. One trick we could use is that we use complement of groups
of B and we can skip intersectioning if the current computing distance gets
already larger than the smallest distance that we have computed.

If two assignments are random, then the distance per individual between them is
near 0.5 if the number of pouplations are the same or 2. What if there are three
populations?
If the number of populations
are different, the distance per individual can be larger than 0.5 and near 1.0.
It cannot be 1. 

Assignment uncertainty:
individual names, id of population assigned to, percentage

\subsubsection{Dawson's uncertainty with forest trees}
<<partition.h>>=
<<hey nielsen copyright>>
#ifndef _PARTITION_H_
#define _PARTITION_H_
<<c decls>>
<<c begin decls>>

void IMA_inp2partitionview (char *fname);

struct im_x_struct {
  int i; /* the number of the observation */
  double logL; /* the log likelihood of the partition */
  int k; /* the number of source populations, k, represented in the sample */
  int *ks; /* the number of individuals assigned to first source population */
  int **is; /* the list of individuals assigned to this population */
};
typedef struct im_x_struct im_x;

struct im_inp_struct {
  int nind;    /* total number of individuals */
  int nmaxpop; /* maximum number of possible source populations */
  int nobs;    /* number of observations */
  int nperiod; /* period */
  double uprior; /* prior parameter u */
  double tprior; /* prior parameter theta */
  im_x *x;   /* observations */
};
typedef struct im_inp_struct im_inp;

<<c end decls>>
#endif /* _PARTITION_H_ */

<<partition.c>>=
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "partition.h"

static void inp_free (im_inp *p, int obs, int maxpop);
static im_inp* inp_alloc (int obs, int maxpop, int maxind);
static int get_obs_p (char *pname, int *obs, int *m, int *ni);
static int parse_in_p (im_inp *p, char *pname);
static int write_partitionview (im_inp *p, char *tname);

<<updateassignment header parser>>
<<updateassignment parser>>

int
main (int argc, char *argv[])
{
  char *outfilename;
  if (argc != 1)
    {
      fprintf (stderr, "Command: %s [file]\n", argv[0]);
      return 0;
    }
  outfilename = argv[1];
  IMA_inp2partitionview (outfilename);
  return 0;
}

void 
IMA_inp2partitionview (char *fname)
{
  char *pname;
  char *tname;
  int len;
  im_inp *pdata;
  int obs;
  int m;
  int ni;

  len = strlen (fname);
  len += 10;
  pname = (char *) malloc (len * sizeof (char));
  tname = (char *) malloc (len * sizeof (char));
  sprintf (pname, "%s.in.p", fname);
  sprintf (tname, "%s.part", fname);

  get_obs_p (pname, &obs, &m, &ni);

  pdata = inp_alloc (obs, m, ni);
  pdata->nobs = obs;
  pdata->nind = ni;
  pdata->nmaxpop = m;
  pdata->nperiod = 10;
  pdata->uprior = 1.0;
  pdata->tprior = 1.0;

  parse_in_p (pdata, pname);
  write_partitionview (pdata, tname);
  inp_free (pdata, obs, m);

  free (pname);
  pname = NULL;
  free (tname);
  tname = NULL;
}

im_inp*
inp_alloc (int obs, int maxpop, int maxind)
{
  im_inp *p;
  int i;
  int j;
  im_x *x;

  assert (obs > 0);
  assert (maxpop > 0);
  p = (im_inp *) malloc (sizeof (im_inp));
  p->x = (im_x *) malloc (obs * sizeof (im_x));
  x = p->x;
  for (i = 0; i < obs; i++)
    {
      x->ks = (int *) malloc (maxpop * sizeof (int));
      x->ks = memset (x->ks, 0, maxpop * sizeof (int));
      x->is = (int **) malloc (maxpop * sizeof (int *));
      /* y = x->is[0]; */
      for (j = 0; j < maxpop; j++)
        {
          x->is[j] = (int *) malloc (maxind * sizeof (int));
          /* y++; */
        }
      x++;
    }


  return p;
}

void
inp_free (im_inp *p, int obs, int maxpop)
{
  int i;
  int j;

  for (i = 0; i < obs; i++)
    {
      free (p->x[i].ks);
      p->x[i].ks = NULL;
      for (j = 0; j < maxpop; j++)
        {
          free (p->x[i].is[j]);
          p->x[i].is[j] = NULL;
        }
      free (p->x[i].is);
      p->x[i].is = NULL;
    }
  free (p->x);
  p->x = NULL;
  free (p);
  p = NULL;

  return;
}

int
get_obs_p (char *pname, int *obs, int *m, int *ni)
{
  FILE *fp;
  char c;
  int ncol;
  int pi;
  fp = fopen (pname, "r");
  assert (fp != NULL);

  *ni = 0;
  c = 'x';
  while (c != '\n')
    {
      c = fgetc (fp);
      if (c == ')')
        {
          (*ni) += 1;
        }
    }

  *obs = 0;
  *m = -1;
  ncol = 0;
  while (!feof (fp))
    {
/*
      if (c == '\n')
        {
          (*obs) += 1;
          ncol = 0;
        }
*/
      if (c == '\t')
        {
          ncol++;
        }
      if (ncol > 1 && ncol < *ni + 2)
        {
          pi = read_int (fp);
          if (pi > *m)
            {
              *m = pi;
            }
        }
      else
        {
          if (!(ncol < *ni + 2))
            {
              ncol = 0;
              /* ungetc ('\n', fp); */
              (*obs) += 1;
            }
          c = fgetc (fp);      
        }
    }

  fclose (fp);
  return 0;
}

int
parse_in_p (im_inp *p, char *pname)
{
  FILE *fp;
  int i;
  int j;
  int iv;
  int ki;
  double dv;
  fp = fopen (pname, "r");

  skip_a_line (fp);

  for (i = 0; i < p->nobs; i++)
    {
      iv = read_int (fp);
      p->x[i].i = iv;
      dv = read_double (fp);
      p->x[i].logL = dv;
      p->x[i].k = 1;
      for (j = 0; j < p->nind; j++)
        {
          iv = read_int (fp);
          if (iv > p->x[i].k)
            {
              p->x[i].k = iv;
            }
          iv--;
          ki = p->x[i].ks[iv];
          p->x[i].is[iv][ki] = j + 1;
          ki++;
          p->x[i].ks[iv] = ki;
        }
     /* NOTE: for structurama only */
     skip_a_line (fp);
    }

  fclose (fp);
  return 0;
}

int
write_partitionview (im_inp *p, char *tname)
{
  int i, j, k;
  FILE *fp;
  fp = fopen (tname, "w");

  fprintf (fp, "%s\n", tname);
  fprintf (fp, "%d\n", p->nind);
  fprintf (fp, "%d\n", p->nmaxpop);
  fprintf (fp, "%d\n", p->nobs);
  fprintf (fp, "%d\n", p->nperiod);
  fprintf (fp, "%lf\n", p->uprior);
  fprintf (fp, "%lf\n", p->tprior);
  for (i = 0; i < p->nobs; i++)
    {
      fprintf (fp, "%d\n", p->x[i].i);
      fprintf (fp, "%lf\n", p->x[i].logL);
      fprintf (fp, "%d\n", p->x[i].k);
      for (j = 0; j < p->x[i].k; j++)
        {
          fprintf (fp, "%d\n", p->x[i].ks[j]);
          for (k = 0; k < p->x[i].ks[j]; k++)
            {
              fprintf (fp, "%d  ", p->x[i].is[j][k]);
            }
          fprintf (fp, "\n");
        }
    }

  fclose (fp);
  return 0;
}

@
\subsubsection{Hierarchical assignment distance}
I do not know whether this is going to work.

We are given two assignments and compute assignment distance, find the permutation
that is used to compute the distance, find the individuals that are removed for
the assignment distance, and (optionally) which assignment of the two is
permuted.
We will use the most intuitive method for the time being.


<<hasn.h>>=
<<hey nielsen copyright>>
#ifndef _HASN_H_
#define _HASN_H_
<<c decls>>
<<c begin decls>>
#include "ncrptree.h"
void imaStructuramaSummary (char *fname, int nburnin);
void IMA_io_readsumassignment (char *fname, int ncol, int *A);
void imaStructuramaUncertainty (char *fname, int nburnin);
void imaIMTreeUncertainty (char *fname, const char *ext, int nburnin);

int IMA_permLexSuccessor (int n, int *p);
int IMA_permLexRank (int n, int *p);
int IMA_permLexUnrank (int *p, int n, int r);
int IMA_permFprintf (FILE *fp, int n, int *p);
int IMA_factorial (int n);

<<structuramak gusfield header>>
<<c end decls>>
#endif /* _HASN_H_ */

<<hasn.c>>=
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "xtrapbits.h"
#include "hasn.h"

<<updateassignment gusfield header>>
int IMA_convertStr2Asn (int ncol, int *A, char *trueassignment);
int IMA_io_readp (char *fname, int ***m, int *mr, int *mc, int nburnin);
int IMA_gusfield_distanceRemoved (int *A, int **m, int nrow, int ncol, 
                                  int *perms, int nperm,
                                  double *r);
int IMA_gusfield_distance (int *A, int **m, int nrow, int ncol); 
int IMA_gusfield_squaredDistance (int *A, int **m, int nrow, int ncol); 
double IMA_gusfield_varianceDistance (int *A, int **m, int nrow, int ncol, double mean); 
static int skip_a_line (FILE *fp);
static int read_int (FILE *fp);
static double read_double (FILE *fp);
/* int IMA_gdistanceRemoved (int n, int *Ai, int *Bi, char *Ci); */
int IMA_gdistanceRemoved (int n, int *Ai, int *Bi, int *perms, int nperm, char *Ci);
int IMA_gdistance (int n, int *Ai, int *Bi);
int IMA_max_intarray (int n, int *A);
int IMA_permLexSuccessor (int n, int *p);
int IMA_permLexRank (int n, int *p);
int IMA_permLexUnrank (int *p, int n, int r);
int IMA_permFprintf (FILE *fp, int n, int *p);
int IMA_factorial (int n);

char *trueassignment;

<<structuramak gusfield>>
<<updateassignment gusfield>>
<<updateassignment uncertainty>>
<<updateassignment parser>>


@
\subsubsection{Individual assignment uncertainty for STRUCTURAMA}
Uncertainty of a single individual to a particular group is devised
using distances of assignment. The estimated assignment is used to
quantify the individual uncertainty in assignment of an individual
with respect to its ostensible assignment to a population. We quantify
how often an individual is removed when computing assignment distance
of an estimate from each assignment of posterior samples. For posterior
samples of size N we compute the N-many distances of posterior samples
from a point estimate of assignment. While computing each of N distances,
individuals may or may not be removed. The more often an individual
is removed in the course of computing assignment distance, the less
confident we can be that the individual is assigned to the population
in the estimated assignment. If there is an individual that assigned
to solely a population, then the distance between posterior sample
of assignments and the estimated assignment tends to be less attributed
to the individual. The fraction of removal of the individual would
be near 0. Conversely, an individual that is assigned with low confidence
to a population should contribute more to the distance between posterior
sample of assignments and the estimated assignment. The fraction of
removal of the high uncertainty in assignment would be near 1. We
envision degrees of uncertainty of which individuals are assigned
to its ostensible assignment to a population.

We need files, [[a.out.in.sum_assignments]], and [[a.out.in.p]]. If IM Tree
model is used, [[a.out.in.p]] is substituted for [[a.out.asn]].
\begin{Verbatim}[frame=lines,framesep=5mm]
uncertainty a.out              <- uncertainty only
uncertainty a.out 0            <- uncertainty only
uncertainty a.out 0 1111122222 <- uncertainty and assignment accuracy
uncertainty a.out 0 x          <- uncertainty of IM Tree model only
\end{Verbatim}

<<uncertainty.h>>=
<<hey nielsen copyright>>
#ifndef _STRUCTURAMA_H_
#define _STRUCTURAMA_H_
<<c decls>>
<<c begin decls>>
void imaStructuramaSummary (char *fname, int nburnin);
void IMA_io_readsumassignment (char *fname, int ncol, int *A);
void imaStructuramaUncertainty (char *fname, int nburnin);
void imaIMTreeUncertainty (char *fname, const char *ext, int nburnin);
<<c end decls>>
#endif /* _STRUCTURAMA_H_ */

<<uncertainty.c>>=
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "xtrapbits.h"
#include "uncertainty.h"

<<updateassignment gusfield header>>
int IMA_convertStr2Asn (int ncol, int *A, char *trueassignment);
int IMA_io_readp (char *fname, int ***m, int *mr, int *mc, int nburnin);
int IMA_gusfield_distanceRemoved (int *A, int **m, int nrow, int ncol, 
                                  int *perms, int nperm,
                                  double *r);
int IMA_gusfield_distance (int *A, int **m, int nrow, int ncol); 
int IMA_gusfield_squaredDistance (int *A, int **m, int nrow, int ncol); 
double IMA_gusfield_varianceDistance (int *A, int **m, int nrow, int ncol, double mean); 
static int skip_a_line (FILE *fp);
static int read_int (FILE *fp);
static double read_double (FILE *fp);
//int IMA_gdistanceRemoved (int n, int *Ai, int *Bi, char *Ci);
int IMA_gdistanceRemoved (int n, int *Ai, int *Bi, int *perms, int nperm, char *Ci);
int IMA_gdistance (int n, int *Ai, int *Bi);
int IMA_max_intarray (int n, int *A);
int IMA_permLexSuccessor (int n, int *p);
int IMA_permLexRank (int n, int *p);
int IMA_permLexUnrank (int *p, int n, int r);
int IMA_permFprintf (FILE *fp, int n, int *p);
int IMA_factorial (int n);

char *trueassignment;

int
main (int argc, char *argv[])
{
  char *outfilename;
  int nburnin;

  outfilename = NULL;
  trueassignment = NULL;
  if (argc == 2)
    {
      outfilename = argv[1];
      nburnin = 0;
    }
  else if (argc == 3)
    {
      outfilename = argv[1];
      nburnin = atoi (argv[2]);
    }
  else if (argc == 4)
    {
      outfilename = argv[1];
      nburnin = atoi (argv[2]);
      trueassignment = argv[3];
    }

  if (outfilename != NULL)
    {
      if (trueassignment != NULL)
        {
          if (*trueassignment == 'x')
            {
              imaIMTreeUncertainty (outfilename, ".asn", nburnin); /* FIXME: .in.p? */
            }
          else
            {
              imaStructuramaSummary (outfilename, nburnin);
            }
        }
      else
        {
          imaStructuramaUncertainty (outfilename, nburnin);
        }
    }

  return 0;
}

<<updateassignment gusfield>>
<<updateassignment uncertainty>>
<<updateassignment parser>>

<<updateassignment header parser>>=
int skip_a_line (FILE *fp);
int read_int (FILE *fp);
double read_double (FILE *fp);

<<updateassignment parser>>=
int
skip_a_line (FILE *fp)
{
  char c;
  c = 'x';
  while (c != '\n')
    {
      c = fgetc(fp);
    }
  return 0;
}

int
read_int (FILE *fp)
{
  int v;
  char c;
  char *buf;
  int len;
  int i;
  
  len = 5;
  buf = malloc (len * sizeof (char));
  
  c = fgetc (fp);
  i = 0;
  while (c != '\t' && c != '\n')
    {
      buf[i++] = c;
      if (i == len)
        {
          len += 5;
          buf = realloc (buf, len * sizeof (char));
        }
      c = fgetc (fp);
    }
  buf[i] = '\0';
  v = atoi (buf);
  
  free (buf);
  buf = NULL;
  return v;
}

double 
read_double (FILE *fp)
{
  double v;
  char c;
  char *buf;
  int len;
  int i;
  
  len = 5;
  buf = malloc (len * sizeof (char));
  
  c = fgetc (fp);
  i = 0;
  while (c != '\t' && c != '\n')
    {
      buf[i++] = c;
      if (i == len)
        {
          len += 5;
          buf = realloc (buf, len * sizeof (char));
        }
      c = fgetc (fp);
    }
  buf[i] = '\0';
  v = atof (buf);
  
  free (buf);
  buf = NULL;
  
  return v;
}

<<updateassignment function header>>=
void imaStructuramaSummary (char *fname, int nburnin);
void IMA_io_readsumassignment (char *fname, int ncol, int *A);
<<updateassignment gusfield>>=
void 
imaStructuramaSummary (char *fname, int nburnin)
{
  FILE *fp;
  int lenpname;
  char *pname;
  int **m;
  int nrow;
  int ncol;
  int nsample;
  int i;
  int *A;
  int *B;
  int total_distance;
  double mean_distance;
  double normalized_distance;
  double variance_distance;
  double squared_distance;
  double meansquared_distance;
  int nind;
  int b_distance; /* distance between true and estimate */

  lenpname = 20 + strlen (fname);

  pname = malloc (lenpname * sizeof (char));
  sprintf (pname, "%s.in.p", fname);

  IMA_io_readp (pname, &m, &nrow, &ncol, nburnin);
  nsample = nrow - nburnin; 
  nind = strlen (trueassignment);
  if (nind == ncol)
    {
      A = malloc (ncol * sizeof (int));
      IMA_convertStr2Asn (ncol, A, trueassignment);

      total_distance = IMA_gusfield_distance (A, m, nsample, ncol); 
      mean_distance = ((double) total_distance) / ((double) nsample);
      normalized_distance = mean_distance / ncol;
      variance_distance = IMA_gusfield_varianceDistance (A, m, nsample, ncol, mean_distance); 
      squared_distance = IMA_gusfield_squaredDistance (A, m, nsample, ncol); 
      meansquared_distance = ((double) squared_distance) / ((double) nsample);
      sprintf (pname, "%s.sum", fname);
      fp = fopen (pname, "w");
      fprintf (fp, "%d\n", total_distance);
      fprintf (fp, "%g\n", mean_distance);
      fprintf (fp, "%g\n", normalized_distance);
      fprintf (fp, "%g\n", variance_distance);
      fprintf (fp, "%g\n", squared_distance);
      fprintf (fp, "%g\n", meansquared_distance);

      B = malloc (ncol * sizeof (int));
      sprintf (pname, "%s.in.sum_assignments", fname);
      IMA_io_readsumassignment (pname, ncol, B);
      b_distance = IMA_gdistance (ncol, A, B);
      fprintf (fp, "%d\n", b_distance);
      free (A);
      A = NULL;
      free (B);
      B = NULL;

      fclose (fp);
      fp = NULL;
    }
  free (A);
  A = NULL;
  for (i = 0; i < nsample; i++)
    {
      free (m[i]);
      m[i] = NULL;
    }
  free (m);
  m = NULL;
  free (pname);
  pname = NULL;
  return;
}

void 
IMA_io_readsumassignment (char *fname, int n, int *A)
{
  FILE *fp;
  char c;
  int i, d;
  
  fp = fopen (fname, "r");
  for (i = 0; i < 10; i++)
    {
      skip_a_line (fp);
    }
  for (i = 0; i < n; i++)
    {
      c = 'x';
      while (c != ')')
        {
          c = fgetc (fp);
        }
      d = read_int (fp);
      A[i] = d;
    }
  fclose (fp);
  fp = NULL;
 
  return;
}

@
It returns 0 if it fails to convert assignemnt to an array. Otherwise, it return
a nonzero value.
This would work for cases where there are less than 10 populations.
<<updateassignment static>>=
int IMA_convertStr2Asn (int ncol, int *a, char *s);
<<updateassignment gusfield>>=
int
IMA_convertStr2Asn (int ncol, int *a, char *s)
{
  int len;
  int i;
  char str[2];

  len = strlen (s);
  assert (len == ncol);

  str[1] = '\0';
  for (i = 0; i < len; i++)
    {
      str[0] = s[i];
      a[i] = atoi (str);
    }
  return 1;
}

@
Read in posterior sample of assignment.
Total distance of an assignment from all posterior sample of assignment.
<<updateassignment static>>=
int IMA_io_readp_header (char *fname, char **name, int mc);
int IMA_io_readp (char *fname, int ***m, int *mr, int *mc, int nburnin);
int IMA_gusfield_distanceRemoved (int *A, int **m, int nrow, int ncol, 
                                  int *perms, int nperm,
                                  double *r);
int IMA_gusfield_distance (int *A, int **m, int nrow, int ncol); 
int IMA_gusfield_squaredDistance (int *A, int **m, int nrow, int ncol); 
double IMA_gusfield_varianceDistance (int *A, int **m, int nrow, int ncol, double mean); 
/*
static int skip_a_line (FILE *fp);
*/

<<updateassignment gusfield>>=
/*
static int
skip_a_line (FILE *fp)
{
  char c;
  c = 'x';
  while (c != '\n')
    {
      c = fgetc(fp);
    }
  return 0;
}
*/

int 
IMA_io_readp_header (char *fname, char **name, int nc)
{
  FILE *fp;
  char c;
  int i;
  int ii;
  char bf[100];
  
  fp = fopen (fname, "r");
  
  /* Count the number of columns. */
  i = 0;
  while (i < 2)
    {
      c = fgetc(fp);
      if (c == '\t')
        {
          i++;
        }
    }
  ii = 0;
  i = 0;
  while (c != '\n' && ii < nc)
    {
      c = fgetc(fp);
      if (c == '\t' || c == '\n')
        {
          bf[i++] = '\0';
          name[ii++] = strdup (bf);
          i = 0;
        }
      else
        {
          bf[i++] = c;
        }
    }
  fclose (fp);
  fp = NULL;
  return 0; 
}

int
IMA_io_readp (char *fname, int ***m, int *mr, int *mc, int nburnin)
{
  FILE *fp;
  char c;
  int ncol, nrow;
  int nsample;
  int i, j;
  double lnL;
  int gi;
  
  fp = fopen (fname, "r");
  
  /* Count the number of columns. */
  c = fgetc(fp);
  ncol = 1;
  while (c != '\n')
    {
      if (c == '\t')
        {
          ncol++;
        }
      c = fgetc(fp);
    }

#ifdef ONLYUNCERTAINTY /* Structurama run */
  ncol -= 3;
  nrow = -1;
#else
  ncol -= 2; /* for IM */
  nrow = -1;
#endif

  while (!feof (fp))
    {
      if (c == '\n')
        {
          nrow++;
        }
      c = fgetc(fp);      
    }
  
  nsample = nrow - nburnin;
  (*m) = malloc (nsample * sizeof (int *));
  for (i = 0; i < nsample; i++)
    {
      (*m)[i] = malloc (ncol * sizeof (int));
    }
  
  /* Reposition pointer to the beginning of the file. */
  fseek (fp, 0L, SEEK_SET);

#ifndef ONLYUNCERTAINTY /* Not for structurama run */
  skip_a_line (fp); /* for IM */
#endif

  for (i = 0; i < nburnin; i++)
    {
      skip_a_line (fp);
    } 

  /* FIXME: Check this out! */

  for (i = 0; i < nsample; i++)
    {
#ifdef ONLYUNCERTAINTY /* Structurama run */
      skip_a_line (fp);
#endif
      gi = read_int (fp);
      lnL = read_double (fp);
      for (j = 0; j < ncol; j++)
        {
          gi = read_int (fp);
          (*m)[i][j] = gi;
        }
    }
  
  fclose (fp);
  fp = NULL;
  
  *mr = nrow;
  *mc = ncol;
  /* fprintf (stdout, "ncol: %5d\nnrow: %5d\n", ncol, nrow); */
  return 0;
}

/* (nrow - nburnin) many samples are used. */
int
IMA_gusfield_distanceRemoved (int *A, int **m, int nrow, int ncol, 
                              int *perms, int nperm,
                              double *r)
{
  int d;
  int i, j;
  char *c;
  
  c = malloc (ncol * sizeof (char));
  d = 0;
  for (i = 0; i < nrow; i++)
    {
      d += IMA_gdistanceRemoved (ncol, A, m[i], perms, nperm, c);
      for (j = 0; j < ncol; j++)
        {
          if (c[j] == 'T')
            {
              r[j] += 1.0;
            }
        }
    }
  for (j = 0; j < ncol; j++)
    {
      r[j] /= ((double) nrow);
    }
  /* printf ("Burnin: %d, Used: %d\n", nburnin, nrow - nburnin);  */

  free (c);
  c = NULL;
  return d;
}

int
IMA_gusfield_distance (int *A, int **m, int nrow, int ncol)
{
  int d;
  int i;
  
  d = 0;
  for (i = 0; i < nrow; i++)
    {
      d += IMA_gdistance (ncol, A, m[i]);
    }
  return d;
}

int
IMA_gusfield_squaredDistance (int *A, int **m, int nrow, int ncol)
{
  int d, d1;
  int i;
  
  d = 0;
  for (i = 0; i < nrow; i++)
    {
      d1 = IMA_gdistance (ncol, A, m[i]);
      d1 *= d1;
      d += d1;
    }
  return d;
}


double
IMA_gusfield_varianceDistance (int *A, int **m, int nrow, int ncol, double mean)
{
  double v;
  double xi;
  int i;
  
  v = 0.0;
  for (i = 0; i < nrow; i++)
    {
      xi = (double) IMA_gdistance (ncol, A, m[i]);
      v += ((xi - mean) * (xi - mean));
    }
  v /= ((double) (nrow - 1.0)); 
  return v;
}

@
Gusfield distance module
<<updateassignment static>>=
<<updateassignment gusfield header>>

@
When and where are these functions used?
[[IMA_gdistanceSimple]] simply counts differences of two assignments [[Ai]] and
[[Bi]].
[[IMA_gdistance]] is the original version of assignment distance. This might
have some bugs that crash the program. Its callers are
[[IMA_gusfield_distance]],
[[IMA_gusfield_squaredDistance]],
[[IMA_gusfield_varianceDistance]], and
[[imaStructuramaSummary]].

[[IMA_gdistanceOrderNEW]] and  
[[IMA_gdistanceOrder]] are used to compute assignment distance as well as find
the permutation that is used to compute the distance. 
[[IMA_gdistanceOrder]] is obsolete.
Callers of [[IMA_gdistanceOrderNEW]] are
[[imaPhylogenySplitTiAsn]], and
[[IMAgenealogyAlign]]. 

[[IMA_gdistanceRemoved]] is for computing individual assignment uncertainty.
Its callers are
[[IMA_gusfield_distanceRemoved]] that is called by
[[imaStructuramaUncertainty]] and 
[[imaIMTreeUncertainty]].

In short, we compute distance, find permutation, and know individuals. We need 
a function that does all of these features.

<<updateassignment gusfield header>>=
int IMA_gdistanceRemoved (int n, int *Ai, int *Bi, int *perms, int nperm, char *Ci);
int IMA_gdistanceOrderNEW (int n, int *Ai, int *Bi, int m, int *od);
int IMA_gdistanceOrder (int n, int *Ai, int *Bi, int m, int *od);
int IMA_gdistance (int n, int *Ai, int *Bi);
int IMA_gdistanceSimple (int n, int *Ai, int *Bi);
int IMA_max_intarray (int n, int *A);

@
We want to compute distance, find permutation, find the removed individuals, and
which assignment is permuted: three functions can be combined,
[[IMA_gdistanceRemoved]], 
[[IMA_gdistanceOrderNEW]], and
[[IMA_gdistance]].
Function [[IMA_gdistanceH]] is now described.
[[n]] is the number of individuals. 
Assignments [[Ai]] and [[Bi]] have positive integers. Unique numbers are
consecutive. The largest value is equal to the number of populations.
Individuals that do not
exist in the assignments are labelled 0.

What is the use of [[perms]]? [[nperm]] must be the size of array [[perms]].

[[wi]] is 0 if [[Bi]] is permuted. If [[Ai]] is permuted, then [[wi]] is 1.

[[pi]] is the returned permutation.

[[Ci]] is the individuals that are removed.

I do not remember ... where and when we used [[perms]]. Hmmm... it is used by
[[c-meanasn]] snippet code. It never seemed to be used in the noweb file.

If [[ndown]] is 0, then there is a single population.

What if two assignments are a single population?
<<structuramak gusfield header>>=
int IMA_gdistanceH (int n, ha_node *ai, ha_node *bi, 
                    int *wi,
                    int **pii, int *nppi,
                    int *perms, int nperm, 
                    char *Ci);
<<structuramak gusfield>>=
int
IMA_gdistanceH (int n, ha_node *ai, ha_node *bi, 
                int *wi,
                int **ppi, int *nppi,
                int *perms, int nperm, 
                char *Ci)
{
  int rk; /* rank for the best permutation */
  int idummy;
  int i, j, k;
  int d, d1, d2;
  int r, s;
  UByteP *ar;
  UByteP *bs;
  UByteP c;
  int sP;
  int *pi;
  int npi; /* number of permutations */

  ha_node *A;
  ha_node *B;

  if (perms == NULL)
    {
      idummy = nperm;
    }

  /* Find r and s. */
  if (ai->ndown == 0)
    {
      r = 1;
    }
  else
    {
      r = ai->ndown;
    }
  if (bi->ndown == 0)
    {
      s = 1;
    }
  else
    {
      s = bi->ndown;
    }
 
  if (r > s) /* Ai is permuted and it has more groups. */
    {
      *wi = 1;
      A = bi;
      B = ai;
      i = s;
      s = r;
      r = i;
    }
  else       /* Bi is permuted and it has more groups. */
    {
      *wi = 0;
      A = ai;
      B = bi;
    }
  assert (!(r > s));
  sP = (n - 1) / 8 + 1;
  BitPowerSetNew (ar, sP, r, i);
  BitPowerSetNew (bs, sP, s, i);
  BitSetNew (c, sP);
  /* pi is initialized to be the first of permutations. */
  pi = malloc ((s + 1) * sizeof (int));
  for (i = 0; i < s + 1; i++)
    {
      pi[i] = i;
    }
  
  /* Set a and b. */
  if (r == 1)
    {
      BitAssign (ar[0], A->a, sP); 
    }
  else
    {
      for (i = 0; i < r; i++)
        {
          BitAssign (ar[i], A->down[i]->a, sP); 
        }
    }
  if (s == 1)
    {
      BitAssign (bs[0], B->a, sP); 
    }
  else
    {
      for (i = 0; i < s; i++)
        {
          BitAssign (bs[i], B->down[i]->a, sP); 
        }
    }
  
  d = n;
  /* We may need gmp library for large number of groups. */
  npi = IMA_factorial(s); 
  i = 0;
  rk = i; /* Rank of the permutation that is used. */
  while (i++ < npi)
    {
      d2 = 0;
      for (j = 1; j < s + 1; j++)
        {
          k = pi[j];
          if (j < r + 1)
            {
              BitDifference (c, ar[j - 1], bs[k - 1], sP, idummy);
              BitNTrues (d1, c, sP, idummy);
              d2 += d1;              
            }
        }
      if (d2 < d)
        {
          rk = i;
          d = d2;
        }
      IMA_permLexSuccessor(s, pi);
    }
  
  assert (rk > 0);
  IMA_permLexUnrank(pi, s, rk - 1);
  /* The permutaion that is used. */
  *ppi = malloc ((s + 1) * sizeof (int));
  memcpy (*ppi, pi, (s + 1) * sizeof (int));
  *nppi = s;

  memset (Ci, 'F', n * sizeof (char));
  for (j = 1; j < s + 1; j++)
    {
      
      k = pi[j];
      if (j < r + 1)
        {
          BitDifference (c, ar[j - 1], bs[k - 1], sP, idummy);
          for (i = 0; i < n; i++)
            {
              if (BitIsTrue (c, i))
                {
                  Ci[i] = 'T';
                }
            }          
        }          
    }  
  
  free (pi);
  pi = NULL;
  BitSetDelete (c);
  BitPowerSetDelete (ar, r, i);
  BitPowerSetDelete (bs, s, i);
  return d;
}
<<updateassignment gusfield>>=
int
IMA_gdistanceRemoved (int n, int *Ai, int *Bi, int *perms, int nperm, char *Ci)
{
  int rk; /* rank for the best permutation */
  int idummy;
  int i, j, k;
  int d, d1, d2;
  int r, s;
  UByteP *ar;
  UByteP *bs;
  UByteP c;
  int sP;
  int g;
  int *pi;
  int npi; /* number of permutations */
  int *A;
  int *B;

  if (perms == NULL)
    {
      idummy = nperm;
    }

  /* Find r and s. */
  r = IMA_max_intarray (n, Ai);
  s = IMA_max_intarray (n, Bi);
  if (r > s)
    {
      A = Bi;
      B = Ai;
      i = s;
      s = r;
      r = i;
    }
  else
    {
      A = Ai;
      B = Bi;
    }
  assert (!(r > s));
  sP = (n - 1) / 8 + 1;
  BitPowerSetNew (ar, sP, r, i);
  BitPowerSetNew (bs, sP, s, i);
  BitSetNew (c, sP);
  /* pi is initialized to be the first of permutations. */
  pi = malloc ((s + 1) * sizeof (int));
  for (i = 0; i < s + 1; i++)
    {
      pi[i] = i;
    }
  
  /* Set a and b. */
  for (i = 0; i < n; i++)
    {
      g = A[i];
      assert (!(g > r));
      BitTrue (ar[g - 1], i);
      g = B[i];
      assert (!(g > s));
      BitTrue (bs[g - 1], i);
    }
  
  d = n;
  npi = IMA_factorial(s);
  i = 0;
  rk = i;
  while (i++ < npi)
    {
      d2 = 0;
      for (j = 1; j < s + 1; j++)
        {
          k = pi[j] - 1;
          if (j < r + 1)
            {
              BitDifference (c, ar[j - 1], bs[k], sP, idummy);
              BitNTrues (d1, c, sP, idummy);
              d2 += d1;              
            }
        }
      if (d2 < d)
        {
          rk = i;
          d = d2;
        }
      IMA_permLexSuccessor(s, pi);
    }
  
  assert (rk > 0);
  IMA_permLexUnrank(pi, s, rk - 1);
  memset (Ci, 'F', n * sizeof (char));
  for (j = 1; j < s + 1; j++)
    {
      k = pi[j] - 1;
      if (j < r + 1)
        {
          BitDifference (c, ar[j - 1], bs[k], sP, idummy);
          for (i = 0; i < n; i++)
            {
              if (BitIsTrue (c, i))
                {
                  Ci[i] = 'T';
                }
            }          
        }          
    }  
  
  free (pi);
  pi = NULL;
  BitSetDelete (c);
  BitPowerSetDelete (ar, r, i);
  BitPowerSetDelete (bs, s, i);
  return d;
}
@
We want to know which relabel is the best. One of [[Ai]] or [[Bi]] 
(maybe [[Ai]]) is an estimated assignment that is a RG string. 
The other (maybe [[Bi]]) is a posterior
sample of assignment where not all populations are assigned with an individual.
For example, [[Bi]] can be $\{1,1,3,3,3\}$ where 5 individuals are assigned to
populations 1 and 3. If the number of populations is 4, then no individuals are
assigned to populations 2 or 4. What we want to do is to decide whether
$\{1,1,3,3,3\}$ or $\{3,3,1,1,1\}$ is near to the estimated assignment. The
estimated assignmend is in RG string format while the two label-switched
assignments are not. If we want to compute a distance between two assignment,
should they be in RG string format?
We need to iterate $m!$ where $m$ is the number of popualtions or maximum value
of labels.
We still need to know the right configuration.
<<updateassignment gusfield>>=

/* Return a swap order not the distance between two assignment. */
int
IMA_gdistanceOrder (int n, int *Ai, int *Bi, int m, int *od)
{
  int idummy;
  int i, j, k;
  int d, d1, d2;
  int r, s;
  UByteP *ar;
  UByteP *bs;
  UByteP c;
  int sP;
  int g;
  int *pi;
  int npi; /* number of permutations */
  int *A;
  int *B;
  int v;
  
  /* Find r and s. */
  r = IMA_max_intarray (n, Ai);
  s = IMA_max_intarray (n, Bi);
  if (r > s)
    {
      A = Bi;
      B = Ai;
      i = s;
      s = r;
      r = i;
    }
  else
    {
      A = Ai;
      B = Bi;
    }
  assert (!(r > s));
  /* r is not greater than s. */
  assert (m == s); /* FIXME: why this should be? */

  sP = (n - 1) / 8 + 1;
  BitPowerSetNew (ar, sP, r, i);
  BitPowerSetNew (bs, sP, s, i);
  BitSetNew (c, sP);
  /* pi is initialized to be the first of permutations. */
  pi = malloc ((s + 1) * sizeof (int));
  for (i = 0; i < s + 1; i++)
    {
      pi[i] = i;
    }
  
  /* Set a and b. */
  for (i = 0; i < n; i++)
    {
      g = A[i];
      assert (!(g > r));
      BitTrue (ar[g - 1], i);
      g = B[i];
      assert (!(g > s));
      BitTrue (bs[g - 1], i);
    }
  
  d = n;
  npi = IMA_factorial(s);
  assert (npi > 0);
  i = 0;
  v = 0;
  while (i++ < npi)
    {
      d2 = 0;
      for (j = 1; j < s + 1; j++)
        {
          k = pi[j] - 1;
          if (j < r + 1)
            {
              BitDifference (c, ar[j - 1], bs[k], sP, idummy);
              BitNTrues (d1, c, sP, idummy);
              d2 += d1;              
            }
        }

      if (d2 < d)
        {
          d = d2;
          v = i;
        }
      IMA_permLexSuccessor(s, pi);
    }

  IMA_permLexUnrank (pi, s, v - 1); /* Unrank is zero-indexed. */
  d2 = 0;
  for (j = 1; j < s + 1; j++)
    {
      k = pi[j] - 1;
      od[j - 1] = k;
      if (j < r + 1)
        {
          BitDifference (c, ar[j - 1], bs[k], sP, idummy);
          BitNTrues (d1, c, sP, idummy);
          d2 += d1;              
        }
    }
  assert (d == d2);
  
  free (pi);
  pi = NULL;
  BitSetDelete (c);
  BitPowerSetDelete (ar, r, i);
  BitPowerSetDelete (bs, s, i);
  return v;
}
@
We assume that there are [[m]] groups in [[n]] individuals. We will generate a
series of permutations of size [[m]], each of which is used to permute [[Bi]] to
compute the distance between [[Ai]] and [[Bi]] by comparing all individuals.
It is intuitive although it is slower than using bit sets. We assume that [[Ai]]
is an estimated assignment, and [[Bi]] is a sample of assignment.

Test it. How? Use the snippet codes, or [[c-gdist]].

<<updateassignment gusfield>>=
/* Return a swap order not the distance between two assignment. */
int
IMA_gdistanceOrderNEW (int n, int *Ai, int *Bi, int m, int *od)
{
  int i, j, k;
  int d, d2;
  int sP;
  int *pi;
  int npi; /* number of permutations */
  int v;
  int *nuBi;
  
  /* FIXME: why this should be? If the sampled assignment does not have all of
   * labels (npops is 4, and assignment only is done for 3 or 2 population),
   * then this will crash the program. We need to consider this case. We could
   * swap or relabel within the assigned populations. */

  nuBi = malloc (n * sizeof (int)); 
  
  sP = (n - 1) / 8 + 1;

  pi = malloc ((m + 1) * sizeof (int));
  for (i = 0; i < m + 1; i++)
    {
      pi[i] = i;
    }
  
  d = n;
  npi = IMA_factorial(m); /* This number should be that of possible permutation. */
  assert (npi > 0);
  i = 0;
  v = 0;
  while (i++ < npi)
    {
      /* Permute Bi using pi. */
      /* pi starts with index 1 not 0. Bi is also based on index 1 not 0. 
       * pi = {0, 1, 2, 3, 4} or {0, 3, 1, 2, 4}.
       * Bi = {1, 1, 3, 3, 3} not {0, 0, 2, 2, 2}
       */
      for (j = 0; j < n; j++)
        {
          nuBi[j] = pi[Bi[j]];
        }

      /* Compare Ai and permuted Bi. */ 
      d2 = IMA_gdistanceSimple (n, Ai, nuBi);

      if (d2 < d)
        {
          d = d2;
          v = i;
        }
      IMA_permLexSuccessor(m, pi);
    }

  IMA_permLexUnrank (pi, m, v - 1); /* Unrank is zero-indexed. */
  d2 = 0;
  for (j = 1; j < m + 1; j++)
    {
      k = pi[j] - 1;
      od[j - 1] = k;
    }
 
  free (nuBi);
  nuBi = NULL;
  free (pi);
  pi = NULL;
  return v;
}

int
IMA_gdistance (int n, int *Ai, int *Bi)
{
  int idummy;
  int i, j, k;
  int d, d1, d2;
  int r, s;
  UByteP *ar;
  UByteP *bs;
  UByteP c;
  int sP;
  int g;
  int *pi;
  int npi; /* number of permutations */
  int *A;
  int *B;
  
  /* Find r and s. */
  r = IMA_max_intarray (n, Ai);
  s = IMA_max_intarray (n, Bi);
  if (r > s)
    {
      A = Bi;
      B = Ai;
      i = s;
      s = r;
      r = i;
    }
  else
    {
      A = Ai;
      B = Bi;
    }
  assert (!(r > s));
  sP = (n - 1) / 8 + 1;
  BitPowerSetNew (ar, sP, r, i);
  BitPowerSetNew (bs, sP, s, i);
  BitSetNew (c, sP);
  /* pi is initialized to be the first of permutations. */
  pi = malloc ((s + 1) * sizeof (int));
  for (i = 0; i < s + 1; i++)
    {
      pi[i] = i;
    }
  
  /* Set a and b. */
  for (i = 0; i < n; i++)
    {
      g = A[i];
      assert (!(g > r));
      BitTrue (ar[g - 1], i);
      g = B[i];
      assert (!(g > s));
      BitTrue (bs[g - 1], i);
    }
  
  d = n;
  npi = IMA_factorial(s);
  assert (npi > 0);
  i = 0;
  while (i++ < npi)
    {
      d2 = 0;
      for (j = 1; j < s + 1; j++)
        {
          k = pi[j] - 1;
          if (j < r + 1)
            {
              BitDifference (c, ar[j - 1], bs[k], sP, idummy);
              BitNTrues (d1, c, sP, idummy);
              d2 += d1;              
            }
        }
      if (d2 < d)
        {
          d = d2;
        }
      IMA_permLexSuccessor(s, pi);
    }
  
  free (pi);
  pi = NULL;
  BitSetDelete (c);
  BitPowerSetDelete (ar, r, i);
  BitPowerSetDelete (bs, s, i);
  return d;
}

int
IMA_gdistanceSimple (int n, int *Ai, int *Bi)
{
  int d;
  int i;

  assert (n > 0);
  d = 0;
  for (i = 0; i < n; i++)
    {
      if (Ai[i] != Bi[i])
        {
          d++;
        }
    }
  return d;
}

int
IMA_max_intarray (int n, int *A)
{
  int i;
  int m;
  m = A[0];
  for (i = 1; i < n; i++)
    {
      if (m < A[i])
        {
          m = A[i];
        }
    }
  return m;
}
@
Permutation module
<<updateassignment static>>=
int IMA_permLexSuccessor (int n, int *p);
int IMA_permLexRank (int n, int *p);
int IMA_permLexUnrank (int *p, int n, int r);
int IMA_permFprintf (FILE *fp, int n, int *p);
int IMA_factorial (int n);
<<updateassignment gusfield>>=
int
IMA_permFprintf (FILE *fp, int n, int *p)
{
  int i;
  
  for (i = 1; i < n + 1; i++)
    {
      if (i == n)
        {
          fprintf (fp, "%2d\n", p[i]);
        }
      else
        {
          fprintf (fp, "%2d ", p[i]);          
        }
    }
  return 0;
}

/* Algorithm 2.14 of Kreher and Stinson */
int
IMA_permLexSuccessor (int n, int *p)
{
  int i, j, t, h;
  int *rho;
  
  rho = malloc ((n + 1) * sizeof (int));
  p[0] = 0;
  i = n - 1;
  while (p[i + 1] < p[i])
    {
      i = i - 1;
    }
  if (i == 0)
    {
      free (rho);
      rho = NULL;
      return 1; /* undefined */
    }
  j = n;
  while (p[j] < p[i])
    {
      j = j - 1;
    }
  t = p[j];
  p[j] = p[i];
  p[i] = t;
  for (h = i + 1; h < n + 1; h++)
    {
      rho[h] = p[h];
    }
  for (h = i + 1; h < n + 1; h++)
    {
      p[h] = rho[n + i + 1 - h];
    }
  free (rho);
  rho = NULL;
  return 0;
}

int
IMA_permLexRank (int n, int *p)
{
  int r, i, j;
  int *rho;
  
  rho = malloc ((n + 1) * sizeof (int));
  r = 0;
  memcpy (rho, p, (n + 1) * sizeof (int));
  for (j = 1; j < n + 1; j++)
    {
      r = r + (rho[j] - 1) * IMA_factorial (n - j);
      for (i = j + 1; i < n + 1; i++)
        {
          if (rho[i] > rho[j])
            {
              rho[i] = rho[i] - 1;
            }
        }
    }
  free (rho);
  rho = NULL;
  return r;
}

int
IMA_permLexUnrank (int *p, int n, int r)
{
  int i, j, d;
  
  p[n] = 1;
  for (j = 1; j < n; j++)
    {
      d = (r % IMA_factorial(j + 1)) / IMA_factorial(j);
      r = r - d * IMA_factorial(j);
      p[n - j] = d + 1;
      for (i = n - j + 1; i < n + 1; i++)
        {
          if (p[i] > d)
            {
              p[i] = p[i] + 1;
            }
        }
    }
  return 0;
}

int
IMA_factorial (int n)
{
  assert (!(n < 0));
  assert (n < 13);
  if (n == 0)
    {
      return 1;
    }
  if (n == 1)
    {
      return 1;
    }
  if (n == 2)
    {
      return 2;
    }
  else
    {
      return n * IMA_factorial (n - 1);
    }
}

@
\subsection{Split ti and asn files}
We read in the assignment estimate or use the argument of [[--true-assignment]].
Read [[bml]] project to determine population tree. 

<<updateassignment header ti>>=
int imaPhylogenySplitTiAsn (const char *fname);
int IMA_fprintf (FILE *fp, int n, int *p);
<<updateassignment ti>>=
int
IMA_fprintf (FILE *fp, int n, int *p)
{
  int i;
  
  for (i = 1; i < n + 1; i++)
    {
      if (i == n)
        {
          fprintf (fp, "%2d\n", p[i]);
        }
      else
        {
          fprintf (fp, "%2d ", p[i]);          
        }
    }
  return 0;
}


int 
imaPhylogenySplitTiAsn (const char *fname)
{
  int i;
  int j;
  int *tasn;
  int nind;
  char *fnamein;
  char *fname_outin;
  char *fname_out;
  char *fname_asn;
  char *fname_ti;
  char *fname_sumassignment;
  char *fname_order;
  FILE *forder;
  int len;
  int nrow;
  int ncol;
  int **m;
  int *od;
  int *odp;
  int r;
  int *nod;
  int npi;
  int d;
  double *fod;
  int nperm;
  int *ranksod;
  int nburnin;

  /* Works with three populations. */
  npops = 3;
  nperm = 6;
  nburnin = 0;

  /* Example: ./iist fischer.out 39 4 */

  len = strlen (fname);
  fname_ti = malloc ((len + 3 + 1) * sizeof (char));
  sprintf (fname_ti, "%s.ti", fname);
  fname_asn = malloc ((len + 4 + 1) * sizeof (char));
  sprintf (fname_asn, "%s.asn", fname);
  IMA_io_readp (fname_asn, &m, &nrow, &ncol, nburnin);
  nind = ncol;
  for (i = 0; i < nrow; i++)
    {
      for (j = 0; j < ncol; j++)
        {
          m[i][j]++;
        }
    }
  
  tasn = malloc (nind * sizeof (int));
  fname_sumassignment = malloc ((len + 20 + 1) * sizeof (char));
  sprintf (fname_sumassignment, "%s.in.sum_assignments", fname);
  IMA_io_readsumassignment (fname_sumassignment, nind, tasn);

  fname_order = malloc ((len + 6 + 1) * sizeof (char));
  sprintf (fname_order, "%s.order", fname);
  forder = fopen (fname_order, "w");


  od = (int *) malloc (npops * sizeof (int));
  odp = (int *) malloc ((npops + 1)* sizeof (int));
  nod = (int *) malloc (nperm * sizeof (int));
  fod = (double *) malloc (nperm * sizeof (double));
  memset (fod, 0, nperm * sizeof (double));
  memset (nod, 0, nperm * sizeof (int));
  ranksod = (int *) malloc (nrow * sizeof (int));

  for (i = 0; i < nrow; i++)
    {
      /*******************************************************/
      /* CHECK: see the detail of tasn and m[i] to check od. */
      /*******************************************************/
      d = IMA_gdistanceOrderNEW (nind, tasn, m[i], npops, od); /* FIXME: npops is fixed to 2 */
      odp[0] = 0;
      for (j = 0; j < npops; j++)
        {
          odp[j + 1] = od[j] + 1; 
        }
      r = IMA_permLexRank (npops, odp);
      ranksod[i] = r;
      fprintf (forder, "%d\n", r);
      nod[r]++;
      if (nod[r] == 1)
        {
          fod[r] = d;
        }
      else
        {
          fod[r] += d;
          fod[r] /= 2.0; /* FIXME: the same bug in Thermodynamic Integration */
        }

#ifdef Debug
      printf ("[%4d]: ", i);
      for (j = 0; j < ncol; j++)
        {
          printf ("%d ", m[i][j]);
        }
      printf ("\n");
      fprintf (stdout, "[%4d]: ", i);
      IMA_fprintf (stdout, npops, odp);
#endif

      /* The rank of od? */
      /* Count it. */
      /* od: 1 2 0 3 */
      /* bmlAlign (i, od, p, nk, npops);  */
      /* # of npops can be smaller than estimate. */
      /* imaGsampinfRelabel (i, od); */
    }

  /* Ranks */
  for (i = 0; i < npops + 1; i++)
    {
      odp[i] = i;
    }
  npi = IMA_factorial(npops);
  fname_out = (char *) malloc ((len + 7 + 1) * sizeof (char));
  fnamein = (char *) malloc ((len + 3 + 1) * sizeof (char));
  fname_outin = (char *) malloc ((len + 10 + 1) * sizeof (char));
  sprintf (fnamein, "%s.in", fname);
  for (i = 0; i < npi; i++)
    {
      IMA_fprintf (stdout, npops, odp);
      r = IMA_permLexRank (npops, odp);
      assert (r == i);
      fprintf (stdout, "\trank: %d - (c) %d - %lf\n", r, nod[i], fod[i]);
      IMA_permLexSuccessor (npops, odp);
      sprintf (fname_out, "%s.%02d.out", fname, i);
      imaFileAsnOpen (fname_out, fname);
      imaFileTiOpen (fname_out);
      imaFileBatCreate (fname_out);
      sprintf (fname_outin, "%s.%02d.out.in", fname, i);
      imaFileCopy (fname_outin, fnamein);
    }

  for (i = 0; i < nrow; i++)
    {
      for (j = 0; j < ncol; j++)
        {
          m[i][j]--;
        }
    }
 
  /* Ranks divides ti and asn files to multiple ones. */
  for (i = 0; i < nrow; i++)
    {
      sprintf (fname_out, "%s.%02d.out", fname, ranksod[i]);
      imaFileAsnAppend (fname_out, i, m[i], nind);
      imaFileTiAppend (fname_out, i); 
      /* atree[gsamp_ccp + pj] = gsampinf[gi][gsamp_ccp + pi]; */
/*
      r = IMA_permLexRank (npops, ranksod[i]);
      IMA_permLexUnrank(p, 3, r);
      IMA_fprintf (stdout, 3, p);
*/
    }
  
  /* Free all local variables. */
  free (ranksod);
  free (od);
  free (odp);
  free (nod);
  free (tasn);
  free (fnamein); 
  free (fname_outin); 
  free (fname_out); 
  free (fname_ti); 
  free (fname_asn); 
  free (fname_sumassignment); 
  for (i = 0; i < nrow; i++)
    {
      free (m[i]);
    }
  free (m);

  free (fname_order); 
  fclose (forder);

  return 0;
}

@
A file with ``asn'' extension is split into [[asni]] many files. 
[[imaFileAsnOpen]] deletes all current [[asni]] many files.
[[imaFileAsnAppend]] appends [[gi]]-th posterior sample of assignment to a file
named ``outfile.00.out.asn'' with [[m]] that is an integer array.
[[imaFileTiOpen]] deletes all current [[tii]] many files. 
[[imaFileTiAppend]] appends [[gi]]-th posterior sample of genealogy to a file
named ``outfile.00.out.ti.'' We alread have [[gsampinf]] ready.
<<updateassignment header ti>>=
int imaFileAsnOpen (const char *fnameasn, const char *fnameorg);
int imaFileAsnAppend (const char *fnameasn, int gi, int *m, int n);
int imaFileTiOpen (const char *fnameti);
int imaFileTiAppend (const char *fnameti, int gi);
int imaFileBatCreate (const char *fname);
int imaFileCopy (const char *fname1, const char *fname2);
<<updateassignment ti>>=
int 
imaFileCopy (const char *fname1, const char *fname2)
{
  char *cmd;
  int len;

  len = strlen (fname1) + strlen (fname2) + 10;
  cmd = (char *) malloc (len * sizeof (char));
  sprintf (cmd, "%s %s %s", SYSCMDCOPY, fname2, fname1);
  system (cmd);
  free (cmd);
  cmd = NULL;
  return 0;
}

int 
imaFileBatCreate (const char *fname)
{
  FILE * fp;
  char * fnamebat;
  int len;
  const char * basename;

  len = strlen (fname);
  fnamebat = (char *) malloc ((len + 4 + 1) * sizeof (char));
  sprintf (fnamebat, "%s.bat", fname);

#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
  basename = strrchr (fname, '\\');
#else
  basename = strrchr (fname, '/');
#endif
  if (basename == NULL)
    {
      basename = fname;
    }
  else
    {
      basename++;
    }

  fp = fopen (fnamebat, "w");
  fprintf (fp, "execute %s.in\nsum\nquit\n", basename);
  fclose (fp);
  fp = NULL;
  free (fnamebat);

  return 0;
}

int 
imaFileAsnOpen (const char *fname, const char *fnameorg)
{
  FILE *fp;
  FILE *fporg;
  char *fnameasn;
  char *fnameinp;
  char *fnameorgasn;
  int len;
  int lenorg;
  int c;

  len = strlen (fname);
  lenorg = strlen (fnameorg);
  fnameasn = (char *) malloc ((len + 4 + 1) * sizeof (char));
  sprintf (fnameasn, "%s.asn", fname);
  fnameinp = (char *) malloc ((len + 5 + 1) * sizeof (char));
  sprintf (fnameinp, "%s.in.p", fname);
  fnameorgasn = (char *) malloc ((lenorg + 4 + 1) * sizeof (char));
  sprintf (fnameorgasn, "%s.asn", fnameorg);

  /* Copy the first line. */
  fporg = fopen (fnameorgasn, "r");
  fp = fopen (fnameasn, "w");
  c = fgetc (fporg);
  while (c != '\n')
    {
      fputc (c, fp);
      c = fgetc (fporg);
    }
  fputc (c, fp);
  fclose (fp);

  rewind (fporg);
  fp = fopen (fnameinp, "w");
  c = fgetc (fporg);
  while (c != '\n')
    {
      fputc (c, fp);
      c = fgetc (fporg);
    }
  fputc (c, fp);
  fclose (fp);
  fp = NULL;

  fclose (fporg);
  fporg = NULL;

  free (fnameasn);
  free (fnameinp);
  free (fnameorgasn);
  return 0;
}

int 
imaFileAsnAppend (const char *fname, int gi, int *m, int n)
{
  FILE *fp;
  FILE *fpinp;
  char *fnameasn;
  char *fnameinp;
  int len;
  int i;
  int *a;

  len = strlen (fname);
  fnameasn = (char *) malloc ((len + 4 + 1) * sizeof (char));
  sprintf (fnameasn, "%s.asn", fname);
  fnameinp = (char *) malloc ((len + 5 + 1) * sizeof (char));
  sprintf (fnameinp, "%s.in.p", fname);

  a = (int *) malloc (n * sizeof (int));
  memcpy (a, m, n * sizeof (int));
  IMA_rgs_convert (a, n);

  fp = fopen (fnameasn, "a");
  fpinp = fopen (fnameinp, "a");
  fprintf (fp, "%d\t0\t%d", gi, m[0]);
  fprintf (fpinp, "%d\t0\t%d", gi, a[0]);
  for (i = 1; i < n; i++)
    {
      fprintf (fp, "\t%d", m[i]);
      fprintf (fpinp, "\t%d", a[i]);
    }
  fprintf (fp, "\n");
  fprintf (fpinp, "\n");
  fclose (fp);
  fp = NULL;
  fclose (fpinp);
  fpinp = NULL;

  free (fnameasn);
  free (fnameinp);
  return 0; 
}

int 
imaFileTiOpen (const char *fname)
{
  FILE *fp;
  char *fnameti;
  int len;

  len = strlen (fname);
  fnameti = (char *) malloc ((len + 3 + 1) * sizeof (char));
  sprintf (fnameti, "%s.ti", fname);

  fp = fopen (fnameti, "w");
  fprintf (fp, "VALUESSTART\n");
  fclose (fp);
  fp = NULL;

  free (fnameti);
  return 0;
}

int 
imaFileTiAppend (const char *fname, int gi)
{
  FILE *fp;
  char *fnameti;
  int len;
  int i;

  len = strlen (fname);
  fnameti = (char *) malloc ((len + 3 + 1) * sizeof (char));
  sprintf (fnameti, "%s.ti", fname);

  fp = fopen (fnameti, "a");
  fprintf (fp, "%f", gsampinf[gi][0]);
  for (i = 1; i < gsampinflength; i++)
    {
      fprintf (fp, "\t%f", gsampinf[gi][i]);
    }
  fprintf (fp, "\n");
  fclose (fp);
  fp = NULL;

  free (fnameti);
  return 0; 

}

@
\pagebreak{}

\addcontentsline{toc}{section}{References}
\bibliographystyle{imr}
\bibliography{imr}

\end{document}

Some sites
http://ooc-lang.org
github 
http://www.parrot.org
http://rakudo.org

